[{"relative_path": "src/test/java/org/apache/commons/cli/Options_addRequiredOptionTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Options_addRequiredOptionTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testAddRequiredOptionSuccess() {\n        options.addRequiredOption(\"r\", \"required\", true, \"required option with argument\");\n        assertTrue(options.hasOption(\"r\"));\n        assertTrue(options.hasOption(\"required\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }\n\n    @Test\n    public void testAddRequiredOptionNoArgument() {\n        options.addRequiredOption(\"n\", \"noarg\", false, \"required option without argument\");\n        assertTrue(options.hasOption(\"n\"));\n        assertTrue(options.hasOption(\"noarg\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }\n\n    @Test\n    public void testAddRequiredOptionDuplicate() {\n        options.addRequiredOption(\"d\", \"duplicate\", true, \"first required option\");\n        options.addRequiredOption(\"d\", \"duplicate\", true, \"second required option\");\n        assertTrue(options.hasOption(\"d\"));\n        assertTrue(options.hasOption(\"duplicate\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }\n}\n", "file_hash": "61e10df23c3681d5b4b5e7d9c01c734e6b3c3f6d4d11cd142d2d50a89ee786d4", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class Options_addRequiredOptionTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testAddRequiredOptionSuccess() {\n        options.addRequiredOption(\"r\", \"required\", true, \"required option with argument\");\n        assertTrue(options.hasOption(\"r\"));\n        assertTrue(options.hasOption(\"required\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }\n\n    @Test\n    public void testAddRequiredOptionNoArgument() {\n        options.addRequiredOption(\"n\", \"noarg\", false, \"required option without argument\");\n        assertTrue(options.hasOption(\"n\"));\n        assertTrue(options.hasOption(\"noarg\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }\n\n    @Test\n    public void testAddRequiredOptionDuplicate() {\n        options.addRequiredOption(\"d\", \"duplicate\", true, \"first required option\");\n        options.addRequiredOption(\"d\", \"duplicate\", true, \"second required option\");\n        assertTrue(options.hasOption(\"d\"));\n        assertTrue(options.hasOption(\"duplicate\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }\n}", "definition": "public class Options_addRequiredOptionTest", "class_docstring": "", "name": "Options_addRequiredOptionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        options = new Options();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddRequiredOptionSuccess() {\n        options.addRequiredOption(\"r\", \"required\", true, \"required option with argument\");\n        assertTrue(options.hasOption(\"r\"));\n        assertTrue(options.hasOption(\"required\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddRequiredOptionSuccess", "params": [], "body": "                                               {\n        options.addRequiredOption(\"r\", \"required\", true, \"required option with argument\");\n        assertTrue(options.hasOption(\"r\"));\n        assertTrue(options.hasOption(\"required\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }", "signature": "@Test\n    public void testAddRequiredOptionSuccess()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddRequiredOptionNoArgument() {\n        options.addRequiredOption(\"n\", \"noarg\", false, \"required option without argument\");\n        assertTrue(options.hasOption(\"n\"));\n        assertTrue(options.hasOption(\"noarg\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddRequiredOptionNoArgument", "params": [], "body": "                                                  {\n        options.addRequiredOption(\"n\", \"noarg\", false, \"required option without argument\");\n        assertTrue(options.hasOption(\"n\"));\n        assertTrue(options.hasOption(\"noarg\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }", "signature": "@Test\n    public void testAddRequiredOptionNoArgument()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddRequiredOptionDuplicate() {\n        options.addRequiredOption(\"d\", \"duplicate\", true, \"first required option\");\n        options.addRequiredOption(\"d\", \"duplicate\", true, \"second required option\");\n        assertTrue(options.hasOption(\"d\"));\n        assertTrue(options.hasOption(\"duplicate\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddRequiredOptionDuplicate", "params": [], "body": "                                                 {\n        options.addRequiredOption(\"d\", \"duplicate\", true, \"first required option\");\n        options.addRequiredOption(\"d\", \"duplicate\", true, \"second required option\");\n        assertTrue(options.hasOption(\"d\"));\n        assertTrue(options.hasOption(\"duplicate\"));\n        assertEquals(1, options.getRequiredOptions().size());\n    }", "signature": "@Test\n    public void testAddRequiredOptionDuplicate()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/ParseException_wrapTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport java.io.IOException;\n\npublic class ParseException_wrapTest {\n\n    @Test\n    public void testWrapWithUnsupportedOperationException() {\n        UnsupportedOperationException unsupportedOperationException = new UnsupportedOperationException(\"Unsupported operation\");\n        assertThrows(UnsupportedOperationException.class, () -> ParseException.wrap(unsupportedOperationException));\n    }\n\n    @Test\n    public void testWrapWithParseException() {\n        ParseException parseException = new ParseException(\"Parse error\");\n        assertEquals(parseException, ParseException.wrap(parseException));\n    }\n\n    @Test\n    public void testWrapWithOtherException() {\n        IOException ioException = new IOException(\"IO error\");\n        ParseException wrappedException = ParseException.wrap(ioException);\n        assertEquals(ioException, wrappedException.getCause());\n    }\n}\n", "file_hash": "d4983c8bf53b317ed58fc2629d5c05e88e62271916758e0a195c4a1322a34072", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.*;", "import org.junit.jupiter.api.Test;", "import java.io.IOException;"], "methods": [], "classes": [{"original_string": "public class ParseException_wrapTest {\n\n    @Test\n    public void testWrapWithUnsupportedOperationException() {\n        UnsupportedOperationException unsupportedOperationException = new UnsupportedOperationException(\"Unsupported operation\");\n        assertThrows(UnsupportedOperationException.class, () -> ParseException.wrap(unsupportedOperationException));\n    }\n\n    @Test\n    public void testWrapWithParseException() {\n        ParseException parseException = new ParseException(\"Parse error\");\n        assertEquals(parseException, ParseException.wrap(parseException));\n    }\n\n    @Test\n    public void testWrapWithOtherException() {\n        IOException ioException = new IOException(\"IO error\");\n        ParseException wrappedException = ParseException.wrap(ioException);\n        assertEquals(ioException, wrappedException.getCause());\n    }\n}", "definition": "public class ParseException_wrapTest", "class_docstring": "", "name": "ParseException_wrapTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testWrapWithUnsupportedOperationException() {\n        UnsupportedOperationException unsupportedOperationException = new UnsupportedOperationException(\"Unsupported operation\");\n        assertThrows(UnsupportedOperationException.class, () -> ParseException.wrap(unsupportedOperationException));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWrapWithUnsupportedOperationException", "params": [], "body": "                                                            {\n        UnsupportedOperationException unsupportedOperationException = new UnsupportedOperationException(\"Unsupported operation\");\n        assertThrows(UnsupportedOperationException.class, () -> ParseException.wrap(unsupportedOperationException));\n    }", "signature": "@Test\n    public void testWrapWithUnsupportedOperationException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testWrapWithParseException() {\n        ParseException parseException = new ParseException(\"Parse error\");\n        assertEquals(parseException, ParseException.wrap(parseException));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWrapWithParseException", "params": [], "body": "                                             {\n        ParseException parseException = new ParseException(\"Parse error\");\n        assertEquals(parseException, ParseException.wrap(parseException));\n    }", "signature": "@Test\n    public void testWrapWithParseException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testWrapWithOtherException() {\n        IOException ioException = new IOException(\"IO error\");\n        ParseException wrappedException = ParseException.wrap(ioException);\n        assertEquals(ioException, wrappedException.getCause());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWrapWithOtherException", "params": [], "body": "                                             {\n        IOException ioException = new IOException(\"IO error\");\n        ParseException wrappedException = ParseException.wrap(ioException);\n        assertEquals(ioException, wrappedException.getCause());\n    }", "signature": "@Test\n    public void testWrapWithOtherException()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/ApplicationTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * This is a collection of tests that test real world applications command lines.\n *\n * <p>\n * The following applications are tested:\n * <ul>\n * <li>ls</li>\n * <li>Ant</li>\n * <li>Groovy</li>\n * <li>man</li>\n * </ul>\n * </p>\n */\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ApplicationTest {\n    /**\n     * Ant test\n     */\n    @Test\n    public void testAnt() throws Exception {\n        // use the GNU parser\n        final CommandLineParser parser = new GnuParser();\n        final Options options = new Options();\n        options.addOption(\"help\", false, \"print this message\");\n        options.addOption(\"projecthelp\", false, \"print project help information\");\n        options.addOption(\"version\", false, \"print the version information and exit\");\n        options.addOption(\"quiet\", false, \"be extra quiet\");\n        options.addOption(\"verbose\", false, \"be extra verbose\");\n        options.addOption(\"debug\", false, \"print debug information\");\n        options.addOption(\"logfile\", true, \"use given file for log\");\n        options.addOption(\"logger\", true, \"the class which is to perform the logging\");\n        options.addOption(\"listener\", true, \"add an instance of a class as a project listener\");\n        options.addOption(\"buildfile\", true, \"use given buildfile\");\n        //@formatter:off\n        options.addOption(OptionBuilder.withDescription(\"use value for given property\")\n                                        .hasArgs()\n                                        .withValueSeparator()\n                                        .create('D'));\n                           //, null, true, , false, true);\n        //@formatter:on\n        options.addOption(\"find\", true, \"search for buildfile towards the root of the filesystem and use it\");\n\n        final String[] args = {\"-buildfile\", \"mybuild.xml\", \"-Dproperty=value\", \"-Dproperty1=value1\", \"-projecthelp\"};\n\n        final CommandLine line = parser.parse(options, args);\n\n        // check multiple values\n        final String[] opts = line.getOptionValues(\"D\");\n        assertEquals(\"property\", opts[0]);\n        assertEquals(\"value\", opts[1]);\n        assertEquals(\"property1\", opts[2]);\n        assertEquals(\"value1\", opts[3]);\n\n        // check single value\n        assertEquals(line.getOptionValue(\"buildfile\"), \"mybuild.xml\");\n\n        // check option\n        assertTrue(line.hasOption(\"projecthelp\"));\n    }\n\n    @Test\n    public void testGroovy() throws Exception {\n        final Options options = new Options();\n\n        //@formatter:off\n        options.addOption(\n            OptionBuilder.withLongOpt(\"define\").\n                withDescription(\"define a system property\").\n                hasArg(true).\n                withArgName(\"name=value\").\n                create('D'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"usage information\")\n                .withLongOpt(\"help\")\n                .create('h'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"debug mode will print out full stack traces\")\n                .withLongOpt(\"debug\")\n                .create('d'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"display the Groovy and JVM versions\")\n                .withLongOpt(\"version\")\n                .create('v'));\n        options.addOption(\n            OptionBuilder.withArgName(\"charset\")\n                .hasArg()\n                .withDescription(\"specify the encoding of the files\")\n                .withLongOpt(\"encoding\")\n                .create('c'));\n        options.addOption(\n            OptionBuilder.withArgName(\"script\")\n                .hasArg()\n                .withDescription(\"specify a command line script\")\n                .create('e'));\n        options.addOption(\n            OptionBuilder.withArgName(\"extension\")\n                .hasOptionalArg()\n                .withDescription(\"modify files in place; create backup if extension is given (e.g. \\'.bak\\')\")\n                .create('i'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"process files line by line using implicit 'line' variable\")\n                .create('n'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"process files line by line and print result (see also -n)\")\n                .create('p'));\n        options.addOption(\n            OptionBuilder.withArgName(\"port\")\n                .hasOptionalArg()\n                .withDescription(\"listen on a port and process inbound lines\")\n                .create('l'));\n        options.addOption(\n            OptionBuilder.withArgName(\"splitPattern\")\n                .hasOptionalArg()\n                .withDescription(\"split lines using splitPattern (default '\\\\s') using implicit 'split' variable\")\n                .withLongOpt(\"autosplit\")\n                .create('a'));\n        //@formatter:on\n\n        final Parser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-e\", \"println 'hello'\"}, true);\n\n        assertTrue(line.hasOption('e'));\n        assertEquals(\"println 'hello'\", line.getOptionValue('e'));\n    }\n\n    @Test\n    public void testLs() throws Exception {\n        // create the command line parser\n        final CommandLineParser parser = new PosixParser();\n        final Options options = new Options();\n        options.addOption(\"a\", \"all\", false, \"do not hide entries starting with .\");\n        options.addOption(\"A\", \"almost-all\", false, \"do not list implied . and ..\");\n        options.addOption(\"b\", \"escape\", false, \"print octal escapes for nongraphic characters\");\n        //@formatter:off\n        options.addOption(OptionBuilder.withLongOpt(\"block-size\")\n                                        .withDescription(\"use SIZE-byte blocks\")\n                                        .hasArg()\n                                        .withArgName(\"SIZE\")\n                                        .create());\n        //@formatter:on\n        options.addOption(\"B\", \"ignore-backups\", false, \"do not list implied entried ending with ~\");\n        options.addOption(\"c\", false, \"with -lt: sort by, and show, ctime (time of last modification of file status information) with \"\n            + \"-l:show ctime and sort by name otherwise: sort by ctime\");\n        options.addOption(\"C\", false, \"list entries by columns\");\n\n        final String[] args = {\"--block-size=10\"};\n\n        final CommandLine line = parser.parse(options, args);\n        assertTrue(line.hasOption(\"block-size\"));\n        assertEquals(line.getOptionValue(\"block-size\"), \"10\");\n    }\n\n    /**\n     * author Slawek Zachcial\n     */\n    @Test\n    public void testMan() {\n        final String cmdLine = \"man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath] [-Ppager] [-Slist] [-msystem] [-pstring] [-Llocale] [-eextension] [section]\"\n            + \" page ...\";\n        //@formatter:off\n        final Options options = new Options().\n                addOption(\"a\", \"all\", false, \"find all matching manual pages.\").\n                addOption(\"d\", \"debug\", false, \"emit debugging messages.\").\n                addOption(\"e\", \"extension\", false, \"limit search to extension type 'extension'.\").\n                addOption(\"f\", \"whatis\", false, \"equivalent to whatis.\").\n                addOption(\"k\", \"apropos\", false, \"equivalent to apropos.\").\n                addOption(\"w\", \"location\", false, \"print physical location of man page(s).\").\n                addOption(\"l\", \"local-file\", false, \"interpret 'page' argument(s) as local file name(s)\").\n                addOption(\"u\", \"update\", false, \"force a cache consistency check.\").\n                //FIXME - should generate -r,--prompt string\n                addOption(\"r\", \"prompt\", true, \"provide 'less' pager with prompt.\").\n                addOption(\"c\", \"catman\", false, \"used by catman to reformat out of date cat pages.\").\n                addOption(\"7\", \"ascii\", false, \"display ASCII translation or certain latin1 chars.\").\n                addOption(\"t\", \"troff\", false, \"use troff format pages.\").\n                //FIXME - should generate -T,--troff-device device\n                addOption(\"T\", \"troff-device\", true, \"use groff with selected device.\").\n                addOption(\"Z\", \"ditroff\", false, \"use groff with selected device.\").\n                addOption(\"D\", \"default\", false, \"reset all options to their default values.\").\n                //FIXME - should generate -M,--manpath path\n                addOption(\"M\", \"manpath\", true, \"set search path for manual pages to 'path'.\").\n                //FIXME - should generate -P,--pager pager\n                addOption(\"P\", \"pager\", true, \"use program 'pager' to display output.\").\n                //FIXME - should generate -S,--sections list\n                addOption(\"S\", \"sections\", true, \"use colon separated section list.\").\n                //FIXME - should generate -m,--systems system\n                addOption(\"m\", \"systems\", true, \"search for man pages from other UNIX system(s).\").\n                //FIXME - should generate -L,--locale locale\n                addOption(\"L\", \"locale\", true, \"define the locale for this particular man search.\").\n                //FIXME - should generate -p,--preprocessor string\n                addOption(\"p\", \"preprocessor\", true, \"string indicates which preprocessor to run.\\n\" +\n                         \" e - [n]eqn  p - pic     t - tbl\\n\" +\n                         \" g - grap    r - refer   v - vgrind\").\n                addOption(\"V\", \"version\", false, \"show version.\").\n                addOption(\"h\", \"help\", false, \"show this usage message.\");\n        //@formatter:on\n\n        final HelpFormatter hf = new HelpFormatter();\n        final String eol = System.lineSeparator();\n        final StringWriter out = new StringWriter();\n        hf.printHelp(new PrintWriter(out), 60, cmdLine, null, options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null, false);\n        //@formatter:off\n        assertEquals(\"usage: man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath]\" + eol +\n                        \"           [-Ppager] [-Slist] [-msystem] [-pstring]\" + eol +\n                        \"           [-Llocale] [-eextension] [section] page ...\" + eol +\n                        \" -7,--ascii                display ASCII translation or\" + eol +\n                        \"                           certain latin1 chars.\" + eol +\n                        \" -a,--all                  find all matching manual pages.\" + eol +\n                        \" -c,--catman               used by catman to reformat out of\" + eol +\n                        \"                           date cat pages.\" + eol +\n                        \" -d,--debug                emit debugging messages.\" + eol +\n                        \" -D,--default              reset all options to their\" + eol +\n                        \"                           default values.\" + eol +\n                        \" -e,--extension            limit search to extension type\" + eol +\n                        \"                           'extension'.\" + eol +\n                        \" -f,--whatis               equivalent to whatis.\" + eol +\n                        \" -h,--help                 show this usage message.\" + eol +\n                        \" -k,--apropos              equivalent to apropos.\" + eol +\n                        \" -l,--local-file           interpret 'page' argument(s) as\" + eol +\n                        \"                           local file name(s)\" + eol +\n                        \" -L,--locale <arg>         define the locale for this\" + eol +\n                        \"                           particular man search.\" + eol +\n                        \" -M,--manpath <arg>        set search path for manual pages\" + eol +\n                        \"                           to 'path'.\" + eol +\n                        \" -m,--systems <arg>        search for man pages from other\" + eol +\n                        \"                           UNIX system(s).\" + eol +\n                        \" -P,--pager <arg>          use program 'pager' to display\" + eol +\n                        \"                           output.\" + eol +\n                        \" -p,--preprocessor <arg>   string indicates which\" + eol +\n                        \"                           preprocessor to run.\" + eol +\n                        \"                           e - [n]eqn  p - pic     t - tbl\" + eol +\n                        \"                           g - grap    r - refer   v -\" + eol +\n                        \"                           vgrind\" + eol +\n                        \" -r,--prompt <arg>         provide 'less' pager with prompt.\" + eol +\n                        \" -S,--sections <arg>       use colon separated section list.\" + eol +\n                        \" -t,--troff                use troff format pages.\" + eol +\n                        \" -T,--troff-device <arg>   use groff with selected device.\" + eol +\n                        \" -u,--update               force a cache consistency check.\" + eol +\n                        \" -V,--version              show version.\" + eol +\n                        \" -w,--location             print physical location of man\" + eol +\n                        \"                           page(s).\" + eol +\n                        \" -Z,--ditroff              use groff with selected device.\" + eol,\n                out.toString());\n        //@formatter:on\n    }\n\n    /**\n     * Real world test with long and short options.\n     */\n    @Test\n    public void testNLT() throws Exception {\n        final Option help = new Option(\"h\", \"help\", false, \"print this message\");\n        final Option version = new Option(\"v\", \"version\", false, \"print version information\");\n        final Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n        final Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n\n        //@formatter:off\n        final Option timeLimit = OptionBuilder.withLongOpt(\"limit\").hasArg()\n                                        .withValueSeparator()\n                                        .withDescription(\"Set time limit for execution, in minutes\")\n                                        .create(\"l\");\n\n        final Option age = OptionBuilder.withLongOpt(\"age\").hasArg()\n                                  .withValueSeparator()\n                                  .withDescription(\"Age (in days) of cache item before being recomputed\")\n                                  .create(\"a\");\n\n        final Option server = OptionBuilder.withLongOpt(\"server\").hasArg()\n                                     .withValueSeparator()\n                                     .withDescription(\"The NLT server address\")\n                                     .create(\"s\");\n\n        final Option numResults = OptionBuilder.withLongOpt(\"results\").hasArg()\n                                         .withValueSeparator()\n                                         .withDescription(\"Number of results per item\")\n                                         .create(\"r\");\n\n        final Option configFile = OptionBuilder.withLongOpt(\"file\").hasArg()\n                                         .withValueSeparator()\n                                         .withDescription(\"Use the specified configuration file\")\n                                         .create();\n        //@formatter:on\n\n        final Options options = new Options();\n        options.addOption(help);\n        options.addOption(version);\n        options.addOption(newRun);\n        options.addOption(trackerRun);\n        options.addOption(timeLimit);\n        options.addOption(age);\n        options.addOption(server);\n        options.addOption(numResults);\n        options.addOption(configFile);\n\n        // create the command line parser\n        final CommandLineParser parser = new PosixParser();\n\n        final String[] args = {\"-v\", \"-l\", \"10\", \"-age\", \"5\", \"-file\", \"filename\"};\n\n        final CommandLine line = parser.parse(options, args);\n        assertTrue(line.hasOption(\"v\"));\n        assertEquals(line.getOptionValue(\"l\"), \"10\");\n        assertEquals(line.getOptionValue(\"limit\"), \"10\");\n        assertEquals(line.getOptionValue(\"a\"), \"5\");\n        assertEquals(line.getOptionValue(\"age\"), \"5\");\n        assertEquals(line.getOptionValue(\"file\"), \"filename\");\n    }\n}\n", "file_hash": "b15d5b73bfe0192b2ee4758946fbb8bba1dfdcd78d1c984c3e042ac1958b9d31", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import java.io.PrintWriter;", "import java.io.StringWriter;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ApplicationTest {\n    /**\n     * Ant test\n     */\n    @Test\n    public void testAnt() throws Exception {\n        // use the GNU parser\n        final CommandLineParser parser = new GnuParser();\n        final Options options = new Options();\n        options.addOption(\"help\", false, \"print this message\");\n        options.addOption(\"projecthelp\", false, \"print project help information\");\n        options.addOption(\"version\", false, \"print the version information and exit\");\n        options.addOption(\"quiet\", false, \"be extra quiet\");\n        options.addOption(\"verbose\", false, \"be extra verbose\");\n        options.addOption(\"debug\", false, \"print debug information\");\n        options.addOption(\"logfile\", true, \"use given file for log\");\n        options.addOption(\"logger\", true, \"the class which is to perform the logging\");\n        options.addOption(\"listener\", true, \"add an instance of a class as a project listener\");\n        options.addOption(\"buildfile\", true, \"use given buildfile\");\n        //@formatter:off\n        options.addOption(OptionBuilder.withDescription(\"use value for given property\")\n                                        .hasArgs()\n                                        .withValueSeparator()\n                                        .create('D'));\n                           //, null, true, , false, true);\n        //@formatter:on\n        options.addOption(\"find\", true, \"search for buildfile towards the root of the filesystem and use it\");\n\n        final String[] args = {\"-buildfile\", \"mybuild.xml\", \"-Dproperty=value\", \"-Dproperty1=value1\", \"-projecthelp\"};\n\n        final CommandLine line = parser.parse(options, args);\n\n        // check multiple values\n        final String[] opts = line.getOptionValues(\"D\");\n        assertEquals(\"property\", opts[0]);\n        assertEquals(\"value\", opts[1]);\n        assertEquals(\"property1\", opts[2]);\n        assertEquals(\"value1\", opts[3]);\n\n        // check single value\n        assertEquals(line.getOptionValue(\"buildfile\"), \"mybuild.xml\");\n\n        // check option\n        assertTrue(line.hasOption(\"projecthelp\"));\n    }\n\n    @Test\n    public void testGroovy() throws Exception {\n        final Options options = new Options();\n\n        //@formatter:off\n        options.addOption(\n            OptionBuilder.withLongOpt(\"define\").\n                withDescription(\"define a system property\").\n                hasArg(true).\n                withArgName(\"name=value\").\n                create('D'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"usage information\")\n                .withLongOpt(\"help\")\n                .create('h'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"debug mode will print out full stack traces\")\n                .withLongOpt(\"debug\")\n                .create('d'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"display the Groovy and JVM versions\")\n                .withLongOpt(\"version\")\n                .create('v'));\n        options.addOption(\n            OptionBuilder.withArgName(\"charset\")\n                .hasArg()\n                .withDescription(\"specify the encoding of the files\")\n                .withLongOpt(\"encoding\")\n                .create('c'));\n        options.addOption(\n            OptionBuilder.withArgName(\"script\")\n                .hasArg()\n                .withDescription(\"specify a command line script\")\n                .create('e'));\n        options.addOption(\n            OptionBuilder.withArgName(\"extension\")\n                .hasOptionalArg()\n                .withDescription(\"modify files in place; create backup if extension is given (e.g. \\'.bak\\')\")\n                .create('i'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"process files line by line using implicit 'line' variable\")\n                .create('n'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"process files line by line and print result (see also -n)\")\n                .create('p'));\n        options.addOption(\n            OptionBuilder.withArgName(\"port\")\n                .hasOptionalArg()\n                .withDescription(\"listen on a port and process inbound lines\")\n                .create('l'));\n        options.addOption(\n            OptionBuilder.withArgName(\"splitPattern\")\n                .hasOptionalArg()\n                .withDescription(\"split lines using splitPattern (default '\\\\s') using implicit 'split' variable\")\n                .withLongOpt(\"autosplit\")\n                .create('a'));\n        //@formatter:on\n\n        final Parser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-e\", \"println 'hello'\"}, true);\n\n        assertTrue(line.hasOption('e'));\n        assertEquals(\"println 'hello'\", line.getOptionValue('e'));\n    }\n\n    @Test\n    public void testLs() throws Exception {\n        // create the command line parser\n        final CommandLineParser parser = new PosixParser();\n        final Options options = new Options();\n        options.addOption(\"a\", \"all\", false, \"do not hide entries starting with .\");\n        options.addOption(\"A\", \"almost-all\", false, \"do not list implied . and ..\");\n        options.addOption(\"b\", \"escape\", false, \"print octal escapes for nongraphic characters\");\n        //@formatter:off\n        options.addOption(OptionBuilder.withLongOpt(\"block-size\")\n                                        .withDescription(\"use SIZE-byte blocks\")\n                                        .hasArg()\n                                        .withArgName(\"SIZE\")\n                                        .create());\n        //@formatter:on\n        options.addOption(\"B\", \"ignore-backups\", false, \"do not list implied entried ending with ~\");\n        options.addOption(\"c\", false, \"with -lt: sort by, and show, ctime (time of last modification of file status information) with \"\n            + \"-l:show ctime and sort by name otherwise: sort by ctime\");\n        options.addOption(\"C\", false, \"list entries by columns\");\n\n        final String[] args = {\"--block-size=10\"};\n\n        final CommandLine line = parser.parse(options, args);\n        assertTrue(line.hasOption(\"block-size\"));\n        assertEquals(line.getOptionValue(\"block-size\"), \"10\");\n    }\n\n    /**\n     * author Slawek Zachcial\n     */\n    @Test\n    public void testMan() {\n        final String cmdLine = \"man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath] [-Ppager] [-Slist] [-msystem] [-pstring] [-Llocale] [-eextension] [section]\"\n            + \" page ...\";\n        //@formatter:off\n        final Options options = new Options().\n                addOption(\"a\", \"all\", false, \"find all matching manual pages.\").\n                addOption(\"d\", \"debug\", false, \"emit debugging messages.\").\n                addOption(\"e\", \"extension\", false, \"limit search to extension type 'extension'.\").\n                addOption(\"f\", \"whatis\", false, \"equivalent to whatis.\").\n                addOption(\"k\", \"apropos\", false, \"equivalent to apropos.\").\n                addOption(\"w\", \"location\", false, \"print physical location of man page(s).\").\n                addOption(\"l\", \"local-file\", false, \"interpret 'page' argument(s) as local file name(s)\").\n                addOption(\"u\", \"update\", false, \"force a cache consistency check.\").\n                //FIXME - should generate -r,--prompt string\n                addOption(\"r\", \"prompt\", true, \"provide 'less' pager with prompt.\").\n                addOption(\"c\", \"catman\", false, \"used by catman to reformat out of date cat pages.\").\n                addOption(\"7\", \"ascii\", false, \"display ASCII translation or certain latin1 chars.\").\n                addOption(\"t\", \"troff\", false, \"use troff format pages.\").\n                //FIXME - should generate -T,--troff-device device\n                addOption(\"T\", \"troff-device\", true, \"use groff with selected device.\").\n                addOption(\"Z\", \"ditroff\", false, \"use groff with selected device.\").\n                addOption(\"D\", \"default\", false, \"reset all options to their default values.\").\n                //FIXME - should generate -M,--manpath path\n                addOption(\"M\", \"manpath\", true, \"set search path for manual pages to 'path'.\").\n                //FIXME - should generate -P,--pager pager\n                addOption(\"P\", \"pager\", true, \"use program 'pager' to display output.\").\n                //FIXME - should generate -S,--sections list\n                addOption(\"S\", \"sections\", true, \"use colon separated section list.\").\n                //FIXME - should generate -m,--systems system\n                addOption(\"m\", \"systems\", true, \"search for man pages from other UNIX system(s).\").\n                //FIXME - should generate -L,--locale locale\n                addOption(\"L\", \"locale\", true, \"define the locale for this particular man search.\").\n                //FIXME - should generate -p,--preprocessor string\n                addOption(\"p\", \"preprocessor\", true, \"string indicates which preprocessor to run.\\n\" +\n                         \" e - [n]eqn  p - pic     t - tbl\\n\" +\n                         \" g - grap    r - refer   v - vgrind\").\n                addOption(\"V\", \"version\", false, \"show version.\").\n                addOption(\"h\", \"help\", false, \"show this usage message.\");\n        //@formatter:on\n\n        final HelpFormatter hf = new HelpFormatter();\n        final String eol = System.lineSeparator();\n        final StringWriter out = new StringWriter();\n        hf.printHelp(new PrintWriter(out), 60, cmdLine, null, options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null, false);\n        //@formatter:off\n        assertEquals(\"usage: man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath]\" + eol +\n                        \"           [-Ppager] [-Slist] [-msystem] [-pstring]\" + eol +\n                        \"           [-Llocale] [-eextension] [section] page ...\" + eol +\n                        \" -7,--ascii                display ASCII translation or\" + eol +\n                        \"                           certain latin1 chars.\" + eol +\n                        \" -a,--all                  find all matching manual pages.\" + eol +\n                        \" -c,--catman               used by catman to reformat out of\" + eol +\n                        \"                           date cat pages.\" + eol +\n                        \" -d,--debug                emit debugging messages.\" + eol +\n                        \" -D,--default              reset all options to their\" + eol +\n                        \"                           default values.\" + eol +\n                        \" -e,--extension            limit search to extension type\" + eol +\n                        \"                           'extension'.\" + eol +\n                        \" -f,--whatis               equivalent to whatis.\" + eol +\n                        \" -h,--help                 show this usage message.\" + eol +\n                        \" -k,--apropos              equivalent to apropos.\" + eol +\n                        \" -l,--local-file           interpret 'page' argument(s) as\" + eol +\n                        \"                           local file name(s)\" + eol +\n                        \" -L,--locale <arg>         define the locale for this\" + eol +\n                        \"                           particular man search.\" + eol +\n                        \" -M,--manpath <arg>        set search path for manual pages\" + eol +\n                        \"                           to 'path'.\" + eol +\n                        \" -m,--systems <arg>        search for man pages from other\" + eol +\n                        \"                           UNIX system(s).\" + eol +\n                        \" -P,--pager <arg>          use program 'pager' to display\" + eol +\n                        \"                           output.\" + eol +\n                        \" -p,--preprocessor <arg>   string indicates which\" + eol +\n                        \"                           preprocessor to run.\" + eol +\n                        \"                           e - [n]eqn  p - pic     t - tbl\" + eol +\n                        \"                           g - grap    r - refer   v -\" + eol +\n                        \"                           vgrind\" + eol +\n                        \" -r,--prompt <arg>         provide 'less' pager with prompt.\" + eol +\n                        \" -S,--sections <arg>       use colon separated section list.\" + eol +\n                        \" -t,--troff                use troff format pages.\" + eol +\n                        \" -T,--troff-device <arg>   use groff with selected device.\" + eol +\n                        \" -u,--update               force a cache consistency check.\" + eol +\n                        \" -V,--version              show version.\" + eol +\n                        \" -w,--location             print physical location of man\" + eol +\n                        \"                           page(s).\" + eol +\n                        \" -Z,--ditroff              use groff with selected device.\" + eol,\n                out.toString());\n        //@formatter:on\n    }\n\n    /**\n     * Real world test with long and short options.\n     */\n    @Test\n    public void testNLT() throws Exception {\n        final Option help = new Option(\"h\", \"help\", false, \"print this message\");\n        final Option version = new Option(\"v\", \"version\", false, \"print version information\");\n        final Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n        final Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n\n        //@formatter:off\n        final Option timeLimit = OptionBuilder.withLongOpt(\"limit\").hasArg()\n                                        .withValueSeparator()\n                                        .withDescription(\"Set time limit for execution, in minutes\")\n                                        .create(\"l\");\n\n        final Option age = OptionBuilder.withLongOpt(\"age\").hasArg()\n                                  .withValueSeparator()\n                                  .withDescription(\"Age (in days) of cache item before being recomputed\")\n                                  .create(\"a\");\n\n        final Option server = OptionBuilder.withLongOpt(\"server\").hasArg()\n                                     .withValueSeparator()\n                                     .withDescription(\"The NLT server address\")\n                                     .create(\"s\");\n\n        final Option numResults = OptionBuilder.withLongOpt(\"results\").hasArg()\n                                         .withValueSeparator()\n                                         .withDescription(\"Number of results per item\")\n                                         .create(\"r\");\n\n        final Option configFile = OptionBuilder.withLongOpt(\"file\").hasArg()\n                                         .withValueSeparator()\n                                         .withDescription(\"Use the specified configuration file\")\n                                         .create();\n        //@formatter:on\n\n        final Options options = new Options();\n        options.addOption(help);\n        options.addOption(version);\n        options.addOption(newRun);\n        options.addOption(trackerRun);\n        options.addOption(timeLimit);\n        options.addOption(age);\n        options.addOption(server);\n        options.addOption(numResults);\n        options.addOption(configFile);\n\n        // create the command line parser\n        final CommandLineParser parser = new PosixParser();\n\n        final String[] args = {\"-v\", \"-l\", \"10\", \"-age\", \"5\", \"-file\", \"filename\"};\n\n        final CommandLine line = parser.parse(options, args);\n        assertTrue(line.hasOption(\"v\"));\n        assertEquals(line.getOptionValue(\"l\"), \"10\");\n        assertEquals(line.getOptionValue(\"limit\"), \"10\");\n        assertEquals(line.getOptionValue(\"a\"), \"5\");\n        assertEquals(line.getOptionValue(\"age\"), \"5\");\n        assertEquals(line.getOptionValue(\"file\"), \"filename\");\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ApplicationTest", "class_docstring": "\nThis is a collection of tests that test real world applications command lines.\n\n<p>\nThe following applications are tested:\n<ul>\n<li>ls</li>\n<li>Ant</li>\n<li>Groovy</li>\n<li>man</li>\n</ul>\n</p>\n", "name": "ApplicationTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testAnt() throws Exception {\n        // use the GNU parser\n        final CommandLineParser parser = new GnuParser();\n        final Options options = new Options();\n        options.addOption(\"help\", false, \"print this message\");\n        options.addOption(\"projecthelp\", false, \"print project help information\");\n        options.addOption(\"version\", false, \"print the version information and exit\");\n        options.addOption(\"quiet\", false, \"be extra quiet\");\n        options.addOption(\"verbose\", false, \"be extra verbose\");\n        options.addOption(\"debug\", false, \"print debug information\");\n        options.addOption(\"logfile\", true, \"use given file for log\");\n        options.addOption(\"logger\", true, \"the class which is to perform the logging\");\n        options.addOption(\"listener\", true, \"add an instance of a class as a project listener\");\n        options.addOption(\"buildfile\", true, \"use given buildfile\");\n        //@formatter:off\n        options.addOption(OptionBuilder.withDescription(\"use value for given property\")\n                                        .hasArgs()\n                                        .withValueSeparator()\n                                        .create('D'));\n                           //, null, true, , false, true);\n        //@formatter:on\n        options.addOption(\"find\", true, \"search for buildfile towards the root of the filesystem and use it\");\n\n        final String[] args = {\"-buildfile\", \"mybuild.xml\", \"-Dproperty=value\", \"-Dproperty1=value1\", \"-projecthelp\"};\n\n        final CommandLine line = parser.parse(options, args);\n\n        // check multiple values\n        final String[] opts = line.getOptionValues(\"D\");\n        assertEquals(\"property\", opts[0]);\n        assertEquals(\"value\", opts[1]);\n        assertEquals(\"property1\", opts[2]);\n        assertEquals(\"value1\", opts[3]);\n\n        // check single value\n        assertEquals(line.getOptionValue(\"buildfile\"), \"mybuild.xml\");\n\n        // check option\n        assertTrue(line.hasOption(\"projecthelp\"));\n    }", "docstring": "\nAnt test\n", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAnt", "params": [], "body": "                                           {\n        // use the GNU parser\n        final CommandLineParser parser = new GnuParser();\n        final Options options = new Options();\n        options.addOption(\"help\", false, \"print this message\");\n        options.addOption(\"projecthelp\", false, \"print project help information\");\n        options.addOption(\"version\", false, \"print the version information and exit\");\n        options.addOption(\"quiet\", false, \"be extra quiet\");\n        options.addOption(\"verbose\", false, \"be extra verbose\");\n        options.addOption(\"debug\", false, \"print debug information\");\n        options.addOption(\"logfile\", true, \"use given file for log\");\n        options.addOption(\"logger\", true, \"the class which is to perform the logging\");\n        options.addOption(\"listener\", true, \"add an instance of a class as a project listener\");\n        options.addOption(\"buildfile\", true, \"use given buildfile\");\n        //@formatter:off\n        options.addOption(OptionBuilder.withDescription(\"use value for given property\")\n                                        .hasArgs()\n                                        .withValueSeparator()\n                                        .create('D'));\n                           //, null, true, , false, true);\n        //@formatter:on\n        options.addOption(\"find\", true, \"search for buildfile towards the root of the filesystem and use it\");\n\n        final String[] args = {\"-buildfile\", \"mybuild.xml\", \"-Dproperty=value\", \"-Dproperty1=value1\", \"-projecthelp\"};\n\n        final CommandLine line = parser.parse(options, args);\n\n        // check multiple values\n        final String[] opts = line.getOptionValues(\"D\");\n        assertEquals(\"property\", opts[0]);\n        assertEquals(\"value\", opts[1]);\n        assertEquals(\"property1\", opts[2]);\n        assertEquals(\"value1\", opts[3]);\n\n        // check single value\n        assertEquals(line.getOptionValue(\"buildfile\"), \"mybuild.xml\");\n\n        // check option\n        assertTrue(line.hasOption(\"projecthelp\"));\n    }", "signature": "@Test\n    public void testAnt()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGroovy() throws Exception {\n        final Options options = new Options();\n\n        //@formatter:off\n        options.addOption(\n            OptionBuilder.withLongOpt(\"define\").\n                withDescription(\"define a system property\").\n                hasArg(true).\n                withArgName(\"name=value\").\n                create('D'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"usage information\")\n                .withLongOpt(\"help\")\n                .create('h'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"debug mode will print out full stack traces\")\n                .withLongOpt(\"debug\")\n                .create('d'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"display the Groovy and JVM versions\")\n                .withLongOpt(\"version\")\n                .create('v'));\n        options.addOption(\n            OptionBuilder.withArgName(\"charset\")\n                .hasArg()\n                .withDescription(\"specify the encoding of the files\")\n                .withLongOpt(\"encoding\")\n                .create('c'));\n        options.addOption(\n            OptionBuilder.withArgName(\"script\")\n                .hasArg()\n                .withDescription(\"specify a command line script\")\n                .create('e'));\n        options.addOption(\n            OptionBuilder.withArgName(\"extension\")\n                .hasOptionalArg()\n                .withDescription(\"modify files in place; create backup if extension is given (e.g. \\'.bak\\')\")\n                .create('i'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"process files line by line using implicit 'line' variable\")\n                .create('n'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"process files line by line and print result (see also -n)\")\n                .create('p'));\n        options.addOption(\n            OptionBuilder.withArgName(\"port\")\n                .hasOptionalArg()\n                .withDescription(\"listen on a port and process inbound lines\")\n                .create('l'));\n        options.addOption(\n            OptionBuilder.withArgName(\"splitPattern\")\n                .hasOptionalArg()\n                .withDescription(\"split lines using splitPattern (default '\\\\s') using implicit 'split' variable\")\n                .withLongOpt(\"autosplit\")\n                .create('a'));\n        //@formatter:on\n\n        final Parser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-e\", \"println 'hello'\"}, true);\n\n        assertTrue(line.hasOption('e'));\n        assertEquals(\"println 'hello'\", line.getOptionValue('e'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGroovy", "params": [], "body": "                                              {\n        final Options options = new Options();\n\n        //@formatter:off\n        options.addOption(\n            OptionBuilder.withLongOpt(\"define\").\n                withDescription(\"define a system property\").\n                hasArg(true).\n                withArgName(\"name=value\").\n                create('D'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"usage information\")\n                .withLongOpt(\"help\")\n                .create('h'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"debug mode will print out full stack traces\")\n                .withLongOpt(\"debug\")\n                .create('d'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"display the Groovy and JVM versions\")\n                .withLongOpt(\"version\")\n                .create('v'));\n        options.addOption(\n            OptionBuilder.withArgName(\"charset\")\n                .hasArg()\n                .withDescription(\"specify the encoding of the files\")\n                .withLongOpt(\"encoding\")\n                .create('c'));\n        options.addOption(\n            OptionBuilder.withArgName(\"script\")\n                .hasArg()\n                .withDescription(\"specify a command line script\")\n                .create('e'));\n        options.addOption(\n            OptionBuilder.withArgName(\"extension\")\n                .hasOptionalArg()\n                .withDescription(\"modify files in place; create backup if extension is given (e.g. \\'.bak\\')\")\n                .create('i'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"process files line by line using implicit 'line' variable\")\n                .create('n'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"process files line by line and print result (see also -n)\")\n                .create('p'));\n        options.addOption(\n            OptionBuilder.withArgName(\"port\")\n                .hasOptionalArg()\n                .withDescription(\"listen on a port and process inbound lines\")\n                .create('l'));\n        options.addOption(\n            OptionBuilder.withArgName(\"splitPattern\")\n                .hasOptionalArg()\n                .withDescription(\"split lines using splitPattern (default '\\\\s') using implicit 'split' variable\")\n                .withLongOpt(\"autosplit\")\n                .create('a'));\n        //@formatter:on\n\n        final Parser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-e\", \"println 'hello'\"}, true);\n\n        assertTrue(line.hasOption('e'));\n        assertEquals(\"println 'hello'\", line.getOptionValue('e'));\n    }", "signature": "@Test\n    public void testGroovy()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLs() throws Exception {\n        // create the command line parser\n        final CommandLineParser parser = new PosixParser();\n        final Options options = new Options();\n        options.addOption(\"a\", \"all\", false, \"do not hide entries starting with .\");\n        options.addOption(\"A\", \"almost-all\", false, \"do not list implied . and ..\");\n        options.addOption(\"b\", \"escape\", false, \"print octal escapes for nongraphic characters\");\n        //@formatter:off\n        options.addOption(OptionBuilder.withLongOpt(\"block-size\")\n                                        .withDescription(\"use SIZE-byte blocks\")\n                                        .hasArg()\n                                        .withArgName(\"SIZE\")\n                                        .create());\n        //@formatter:on\n        options.addOption(\"B\", \"ignore-backups\", false, \"do not list implied entried ending with ~\");\n        options.addOption(\"c\", false, \"with -lt: sort by, and show, ctime (time of last modification of file status information) with \"\n            + \"-l:show ctime and sort by name otherwise: sort by ctime\");\n        options.addOption(\"C\", false, \"list entries by columns\");\n\n        final String[] args = {\"--block-size=10\"};\n\n        final CommandLine line = parser.parse(options, args);\n        assertTrue(line.hasOption(\"block-size\"));\n        assertEquals(line.getOptionValue(\"block-size\"), \"10\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLs", "params": [], "body": "                                          {\n        // create the command line parser\n        final CommandLineParser parser = new PosixParser();\n        final Options options = new Options();\n        options.addOption(\"a\", \"all\", false, \"do not hide entries starting with .\");\n        options.addOption(\"A\", \"almost-all\", false, \"do not list implied . and ..\");\n        options.addOption(\"b\", \"escape\", false, \"print octal escapes for nongraphic characters\");\n        //@formatter:off\n        options.addOption(OptionBuilder.withLongOpt(\"block-size\")\n                                        .withDescription(\"use SIZE-byte blocks\")\n                                        .hasArg()\n                                        .withArgName(\"SIZE\")\n                                        .create());\n        //@formatter:on\n        options.addOption(\"B\", \"ignore-backups\", false, \"do not list implied entried ending with ~\");\n        options.addOption(\"c\", false, \"with -lt: sort by, and show, ctime (time of last modification of file status information) with \"\n            + \"-l:show ctime and sort by name otherwise: sort by ctime\");\n        options.addOption(\"C\", false, \"list entries by columns\");\n\n        final String[] args = {\"--block-size=10\"};\n\n        final CommandLine line = parser.parse(options, args);\n        assertTrue(line.hasOption(\"block-size\"));\n        assertEquals(line.getOptionValue(\"block-size\"), \"10\");\n    }", "signature": "@Test\n    public void testLs()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMan() {\n        final String cmdLine = \"man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath] [-Ppager] [-Slist] [-msystem] [-pstring] [-Llocale] [-eextension] [section]\"\n            + \" page ...\";\n        //@formatter:off\n        final Options options = new Options().\n                addOption(\"a\", \"all\", false, \"find all matching manual pages.\").\n                addOption(\"d\", \"debug\", false, \"emit debugging messages.\").\n                addOption(\"e\", \"extension\", false, \"limit search to extension type 'extension'.\").\n                addOption(\"f\", \"whatis\", false, \"equivalent to whatis.\").\n                addOption(\"k\", \"apropos\", false, \"equivalent to apropos.\").\n                addOption(\"w\", \"location\", false, \"print physical location of man page(s).\").\n                addOption(\"l\", \"local-file\", false, \"interpret 'page' argument(s) as local file name(s)\").\n                addOption(\"u\", \"update\", false, \"force a cache consistency check.\").\n                //FIXME - should generate -r,--prompt string\n                addOption(\"r\", \"prompt\", true, \"provide 'less' pager with prompt.\").\n                addOption(\"c\", \"catman\", false, \"used by catman to reformat out of date cat pages.\").\n                addOption(\"7\", \"ascii\", false, \"display ASCII translation or certain latin1 chars.\").\n                addOption(\"t\", \"troff\", false, \"use troff format pages.\").\n                //FIXME - should generate -T,--troff-device device\n                addOption(\"T\", \"troff-device\", true, \"use groff with selected device.\").\n                addOption(\"Z\", \"ditroff\", false, \"use groff with selected device.\").\n                addOption(\"D\", \"default\", false, \"reset all options to their default values.\").\n                //FIXME - should generate -M,--manpath path\n                addOption(\"M\", \"manpath\", true, \"set search path for manual pages to 'path'.\").\n                //FIXME - should generate -P,--pager pager\n                addOption(\"P\", \"pager\", true, \"use program 'pager' to display output.\").\n                //FIXME - should generate -S,--sections list\n                addOption(\"S\", \"sections\", true, \"use colon separated section list.\").\n                //FIXME - should generate -m,--systems system\n                addOption(\"m\", \"systems\", true, \"search for man pages from other UNIX system(s).\").\n                //FIXME - should generate -L,--locale locale\n                addOption(\"L\", \"locale\", true, \"define the locale for this particular man search.\").\n                //FIXME - should generate -p,--preprocessor string\n                addOption(\"p\", \"preprocessor\", true, \"string indicates which preprocessor to run.\\n\" +\n                         \" e - [n]eqn  p - pic     t - tbl\\n\" +\n                         \" g - grap    r - refer   v - vgrind\").\n                addOption(\"V\", \"version\", false, \"show version.\").\n                addOption(\"h\", \"help\", false, \"show this usage message.\");\n        //@formatter:on\n\n        final HelpFormatter hf = new HelpFormatter();\n        final String eol = System.lineSeparator();\n        final StringWriter out = new StringWriter();\n        hf.printHelp(new PrintWriter(out), 60, cmdLine, null, options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null, false);\n        //@formatter:off\n        assertEquals(\"usage: man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath]\" + eol +\n                        \"           [-Ppager] [-Slist] [-msystem] [-pstring]\" + eol +\n                        \"           [-Llocale] [-eextension] [section] page ...\" + eol +\n                        \" -7,--ascii                display ASCII translation or\" + eol +\n                        \"                           certain latin1 chars.\" + eol +\n                        \" -a,--all                  find all matching manual pages.\" + eol +\n                        \" -c,--catman               used by catman to reformat out of\" + eol +\n                        \"                           date cat pages.\" + eol +\n                        \" -d,--debug                emit debugging messages.\" + eol +\n                        \" -D,--default              reset all options to their\" + eol +\n                        \"                           default values.\" + eol +\n                        \" -e,--extension            limit search to extension type\" + eol +\n                        \"                           'extension'.\" + eol +\n                        \" -f,--whatis               equivalent to whatis.\" + eol +\n                        \" -h,--help                 show this usage message.\" + eol +\n                        \" -k,--apropos              equivalent to apropos.\" + eol +\n                        \" -l,--local-file           interpret 'page' argument(s) as\" + eol +\n                        \"                           local file name(s)\" + eol +\n                        \" -L,--locale <arg>         define the locale for this\" + eol +\n                        \"                           particular man search.\" + eol +\n                        \" -M,--manpath <arg>        set search path for manual pages\" + eol +\n                        \"                           to 'path'.\" + eol +\n                        \" -m,--systems <arg>        search for man pages from other\" + eol +\n                        \"                           UNIX system(s).\" + eol +\n                        \" -P,--pager <arg>          use program 'pager' to display\" + eol +\n                        \"                           output.\" + eol +\n                        \" -p,--preprocessor <arg>   string indicates which\" + eol +\n                        \"                           preprocessor to run.\" + eol +\n                        \"                           e - [n]eqn  p - pic     t - tbl\" + eol +\n                        \"                           g - grap    r - refer   v -\" + eol +\n                        \"                           vgrind\" + eol +\n                        \" -r,--prompt <arg>         provide 'less' pager with prompt.\" + eol +\n                        \" -S,--sections <arg>       use colon separated section list.\" + eol +\n                        \" -t,--troff                use troff format pages.\" + eol +\n                        \" -T,--troff-device <arg>   use groff with selected device.\" + eol +\n                        \" -u,--update               force a cache consistency check.\" + eol +\n                        \" -V,--version              show version.\" + eol +\n                        \" -w,--location             print physical location of man\" + eol +\n                        \"                           page(s).\" + eol +\n                        \" -Z,--ditroff              use groff with selected device.\" + eol,\n                out.toString());\n        //@formatter:on\n    }", "docstring": "\nauthor Slawek Zachcial\n", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMan", "params": [], "body": "                          {\n        final String cmdLine = \"man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath] [-Ppager] [-Slist] [-msystem] [-pstring] [-Llocale] [-eextension] [section]\"\n            + \" page ...\";\n        //@formatter:off\n        final Options options = new Options().\n                addOption(\"a\", \"all\", false, \"find all matching manual pages.\").\n                addOption(\"d\", \"debug\", false, \"emit debugging messages.\").\n                addOption(\"e\", \"extension\", false, \"limit search to extension type 'extension'.\").\n                addOption(\"f\", \"whatis\", false, \"equivalent to whatis.\").\n                addOption(\"k\", \"apropos\", false, \"equivalent to apropos.\").\n                addOption(\"w\", \"location\", false, \"print physical location of man page(s).\").\n                addOption(\"l\", \"local-file\", false, \"interpret 'page' argument(s) as local file name(s)\").\n                addOption(\"u\", \"update\", false, \"force a cache consistency check.\").\n                //FIXME - should generate -r,--prompt string\n                addOption(\"r\", \"prompt\", true, \"provide 'less' pager with prompt.\").\n                addOption(\"c\", \"catman\", false, \"used by catman to reformat out of date cat pages.\").\n                addOption(\"7\", \"ascii\", false, \"display ASCII translation or certain latin1 chars.\").\n                addOption(\"t\", \"troff\", false, \"use troff format pages.\").\n                //FIXME - should generate -T,--troff-device device\n                addOption(\"T\", \"troff-device\", true, \"use groff with selected device.\").\n                addOption(\"Z\", \"ditroff\", false, \"use groff with selected device.\").\n                addOption(\"D\", \"default\", false, \"reset all options to their default values.\").\n                //FIXME - should generate -M,--manpath path\n                addOption(\"M\", \"manpath\", true, \"set search path for manual pages to 'path'.\").\n                //FIXME - should generate -P,--pager pager\n                addOption(\"P\", \"pager\", true, \"use program 'pager' to display output.\").\n                //FIXME - should generate -S,--sections list\n                addOption(\"S\", \"sections\", true, \"use colon separated section list.\").\n                //FIXME - should generate -m,--systems system\n                addOption(\"m\", \"systems\", true, \"search for man pages from other UNIX system(s).\").\n                //FIXME - should generate -L,--locale locale\n                addOption(\"L\", \"locale\", true, \"define the locale for this particular man search.\").\n                //FIXME - should generate -p,--preprocessor string\n                addOption(\"p\", \"preprocessor\", true, \"string indicates which preprocessor to run.\\n\" +\n                         \" e - [n]eqn  p - pic     t - tbl\\n\" +\n                         \" g - grap    r - refer   v - vgrind\").\n                addOption(\"V\", \"version\", false, \"show version.\").\n                addOption(\"h\", \"help\", false, \"show this usage message.\");\n        //@formatter:on\n\n        final HelpFormatter hf = new HelpFormatter();\n        final String eol = System.lineSeparator();\n        final StringWriter out = new StringWriter();\n        hf.printHelp(new PrintWriter(out), 60, cmdLine, null, options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null, false);\n        //@formatter:off\n        assertEquals(\"usage: man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath]\" + eol +\n                        \"           [-Ppager] [-Slist] [-msystem] [-pstring]\" + eol +\n                        \"           [-Llocale] [-eextension] [section] page ...\" + eol +\n                        \" -7,--ascii                display ASCII translation or\" + eol +\n                        \"                           certain latin1 chars.\" + eol +\n                        \" -a,--all                  find all matching manual pages.\" + eol +\n                        \" -c,--catman               used by catman to reformat out of\" + eol +\n                        \"                           date cat pages.\" + eol +\n                        \" -d,--debug                emit debugging messages.\" + eol +\n                        \" -D,--default              reset all options to their\" + eol +\n                        \"                           default values.\" + eol +\n                        \" -e,--extension            limit search to extension type\" + eol +\n                        \"                           'extension'.\" + eol +\n                        \" -f,--whatis               equivalent to whatis.\" + eol +\n                        \" -h,--help                 show this usage message.\" + eol +\n                        \" -k,--apropos              equivalent to apropos.\" + eol +\n                        \" -l,--local-file           interpret 'page' argument(s) as\" + eol +\n                        \"                           local file name(s)\" + eol +\n                        \" -L,--locale <arg>         define the locale for this\" + eol +\n                        \"                           particular man search.\" + eol +\n                        \" -M,--manpath <arg>        set search path for manual pages\" + eol +\n                        \"                           to 'path'.\" + eol +\n                        \" -m,--systems <arg>        search for man pages from other\" + eol +\n                        \"                           UNIX system(s).\" + eol +\n                        \" -P,--pager <arg>          use program 'pager' to display\" + eol +\n                        \"                           output.\" + eol +\n                        \" -p,--preprocessor <arg>   string indicates which\" + eol +\n                        \"                           preprocessor to run.\" + eol +\n                        \"                           e - [n]eqn  p - pic     t - tbl\" + eol +\n                        \"                           g - grap    r - refer   v -\" + eol +\n                        \"                           vgrind\" + eol +\n                        \" -r,--prompt <arg>         provide 'less' pager with prompt.\" + eol +\n                        \" -S,--sections <arg>       use colon separated section list.\" + eol +\n                        \" -t,--troff                use troff format pages.\" + eol +\n                        \" -T,--troff-device <arg>   use groff with selected device.\" + eol +\n                        \" -u,--update               force a cache consistency check.\" + eol +\n                        \" -V,--version              show version.\" + eol +\n                        \" -w,--location             print physical location of man\" + eol +\n                        \"                           page(s).\" + eol +\n                        \" -Z,--ditroff              use groff with selected device.\" + eol,\n                out.toString());\n        //@formatter:on\n    }", "signature": "@Test\n    public void testMan()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNLT() throws Exception {\n        final Option help = new Option(\"h\", \"help\", false, \"print this message\");\n        final Option version = new Option(\"v\", \"version\", false, \"print version information\");\n        final Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n        final Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n\n        //@formatter:off\n        final Option timeLimit = OptionBuilder.withLongOpt(\"limit\").hasArg()\n                                        .withValueSeparator()\n                                        .withDescription(\"Set time limit for execution, in minutes\")\n                                        .create(\"l\");\n\n        final Option age = OptionBuilder.withLongOpt(\"age\").hasArg()\n                                  .withValueSeparator()\n                                  .withDescription(\"Age (in days) of cache item before being recomputed\")\n                                  .create(\"a\");\n\n        final Option server = OptionBuilder.withLongOpt(\"server\").hasArg()\n                                     .withValueSeparator()\n                                     .withDescription(\"The NLT server address\")\n                                     .create(\"s\");\n\n        final Option numResults = OptionBuilder.withLongOpt(\"results\").hasArg()\n                                         .withValueSeparator()\n                                         .withDescription(\"Number of results per item\")\n                                         .create(\"r\");\n\n        final Option configFile = OptionBuilder.withLongOpt(\"file\").hasArg()\n                                         .withValueSeparator()\n                                         .withDescription(\"Use the specified configuration file\")\n                                         .create();\n        //@formatter:on\n\n        final Options options = new Options();\n        options.addOption(help);\n        options.addOption(version);\n        options.addOption(newRun);\n        options.addOption(trackerRun);\n        options.addOption(timeLimit);\n        options.addOption(age);\n        options.addOption(server);\n        options.addOption(numResults);\n        options.addOption(configFile);\n\n        // create the command line parser\n        final CommandLineParser parser = new PosixParser();\n\n        final String[] args = {\"-v\", \"-l\", \"10\", \"-age\", \"5\", \"-file\", \"filename\"};\n\n        final CommandLine line = parser.parse(options, args);\n        assertTrue(line.hasOption(\"v\"));\n        assertEquals(line.getOptionValue(\"l\"), \"10\");\n        assertEquals(line.getOptionValue(\"limit\"), \"10\");\n        assertEquals(line.getOptionValue(\"a\"), \"5\");\n        assertEquals(line.getOptionValue(\"age\"), \"5\");\n        assertEquals(line.getOptionValue(\"file\"), \"filename\");\n    }", "docstring": "\nReal world test with long and short options.\n", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNLT", "params": [], "body": "                                           {\n        final Option help = new Option(\"h\", \"help\", false, \"print this message\");\n        final Option version = new Option(\"v\", \"version\", false, \"print version information\");\n        final Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n        final Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n\n        //@formatter:off\n        final Option timeLimit = OptionBuilder.withLongOpt(\"limit\").hasArg()\n                                        .withValueSeparator()\n                                        .withDescription(\"Set time limit for execution, in minutes\")\n                                        .create(\"l\");\n\n        final Option age = OptionBuilder.withLongOpt(\"age\").hasArg()\n                                  .withValueSeparator()\n                                  .withDescription(\"Age (in days) of cache item before being recomputed\")\n                                  .create(\"a\");\n\n        final Option server = OptionBuilder.withLongOpt(\"server\").hasArg()\n                                     .withValueSeparator()\n                                     .withDescription(\"The NLT server address\")\n                                     .create(\"s\");\n\n        final Option numResults = OptionBuilder.withLongOpt(\"results\").hasArg()\n                                         .withValueSeparator()\n                                         .withDescription(\"Number of results per item\")\n                                         .create(\"r\");\n\n        final Option configFile = OptionBuilder.withLongOpt(\"file\").hasArg()\n                                         .withValueSeparator()\n                                         .withDescription(\"Use the specified configuration file\")\n                                         .create();\n        //@formatter:on\n\n        final Options options = new Options();\n        options.addOption(help);\n        options.addOption(version);\n        options.addOption(newRun);\n        options.addOption(trackerRun);\n        options.addOption(timeLimit);\n        options.addOption(age);\n        options.addOption(server);\n        options.addOption(numResults);\n        options.addOption(configFile);\n\n        // create the command line parser\n        final CommandLineParser parser = new PosixParser();\n\n        final String[] args = {\"-v\", \"-l\", \"10\", \"-age\", \"5\", \"-file\", \"filename\"};\n\n        final CommandLine line = parser.parse(options, args);\n        assertTrue(line.hasOption(\"v\"));\n        assertEquals(line.getOptionValue(\"l\"), \"10\");\n        assertEquals(line.getOptionValue(\"limit\"), \"10\");\n        assertEquals(line.getOptionValue(\"a\"), \"5\");\n        assertEquals(line.getOptionValue(\"age\"), \"5\");\n        assertEquals(line.getOptionValue(\"file\"), \"filename\");\n    }", "signature": "@Test\n    public void testNLT()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/Options_getMatchingOptionsTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport java.util.List;\n\npublic class Options_getMatchingOptionsTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testGetMatchingOptionsExactMatch() {\n        options.addOption(\"a\", \"apple\", false, \"apple option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"apple\");\n        assertEquals(1, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"apple\"));\n    }\n\n    @Test\n    public void testGetMatchingOptionsPartialMatch() {\n        options.addOption(\"b\", \"banana\", false, \"banana option\");\n        options.addOption(\"c\", \"cherry\", false, \"cherry option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"ban\");\n        assertEquals(1, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"banana\"));\n    }\n\n    @Test\n    public void testGetMatchingOptionsNoMatch() {\n        options.addOption(\"d\", \"date\", false, \"date option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"fig\");\n        assertTrue(matchingOptions.isEmpty());\n    }\n\n    @Test\n    public void testGetMatchingOptionsMultipleMatches() {\n        options.addOption(\"e\", \"elephant\", false, \"elephant option\");\n        options.addOption(\"f\", \"elephantine\", false, \"elephantine option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"ele\");\n        assertEquals(2, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"elephant\"));\n        assertTrue(matchingOptions.contains(\"elephantine\"));\n    }\n}\n", "file_hash": "08e1a1c7e8bcc8a03f3ee20e3a1d7b53b5904d0c0094bf3324d8043587a7c76f", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import java.util.List;"], "methods": [], "classes": [{"original_string": "public class Options_getMatchingOptionsTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testGetMatchingOptionsExactMatch() {\n        options.addOption(\"a\", \"apple\", false, \"apple option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"apple\");\n        assertEquals(1, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"apple\"));\n    }\n\n    @Test\n    public void testGetMatchingOptionsPartialMatch() {\n        options.addOption(\"b\", \"banana\", false, \"banana option\");\n        options.addOption(\"c\", \"cherry\", false, \"cherry option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"ban\");\n        assertEquals(1, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"banana\"));\n    }\n\n    @Test\n    public void testGetMatchingOptionsNoMatch() {\n        options.addOption(\"d\", \"date\", false, \"date option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"fig\");\n        assertTrue(matchingOptions.isEmpty());\n    }\n\n    @Test\n    public void testGetMatchingOptionsMultipleMatches() {\n        options.addOption(\"e\", \"elephant\", false, \"elephant option\");\n        options.addOption(\"f\", \"elephantine\", false, \"elephantine option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"ele\");\n        assertEquals(2, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"elephant\"));\n        assertTrue(matchingOptions.contains(\"elephantine\"));\n    }\n}", "definition": "public class Options_getMatchingOptionsTest", "class_docstring": "", "name": "Options_getMatchingOptionsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        options = new Options();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetMatchingOptionsExactMatch() {\n        options.addOption(\"a\", \"apple\", false, \"apple option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"apple\");\n        assertEquals(1, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"apple\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetMatchingOptionsExactMatch", "params": [], "body": "                                                   {\n        options.addOption(\"a\", \"apple\", false, \"apple option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"apple\");\n        assertEquals(1, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"apple\"));\n    }", "signature": "@Test\n    public void testGetMatchingOptionsExactMatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetMatchingOptionsPartialMatch() {\n        options.addOption(\"b\", \"banana\", false, \"banana option\");\n        options.addOption(\"c\", \"cherry\", false, \"cherry option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"ban\");\n        assertEquals(1, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"banana\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetMatchingOptionsPartialMatch", "params": [], "body": "                                                     {\n        options.addOption(\"b\", \"banana\", false, \"banana option\");\n        options.addOption(\"c\", \"cherry\", false, \"cherry option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"ban\");\n        assertEquals(1, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"banana\"));\n    }", "signature": "@Test\n    public void testGetMatchingOptionsPartialMatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetMatchingOptionsNoMatch() {\n        options.addOption(\"d\", \"date\", false, \"date option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"fig\");\n        assertTrue(matchingOptions.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetMatchingOptionsNoMatch", "params": [], "body": "                                                {\n        options.addOption(\"d\", \"date\", false, \"date option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"fig\");\n        assertTrue(matchingOptions.isEmpty());\n    }", "signature": "@Test\n    public void testGetMatchingOptionsNoMatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetMatchingOptionsMultipleMatches() {\n        options.addOption(\"e\", \"elephant\", false, \"elephant option\");\n        options.addOption(\"f\", \"elephantine\", false, \"elephantine option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"ele\");\n        assertEquals(2, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"elephant\"));\n        assertTrue(matchingOptions.contains(\"elephantine\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetMatchingOptionsMultipleMatches", "params": [], "body": "                                                        {\n        options.addOption(\"e\", \"elephant\", false, \"elephant option\");\n        options.addOption(\"f\", \"elephantine\", false, \"elephantine option\");\n        List<String> matchingOptions = options.getMatchingOptions(\"ele\");\n        assertEquals(2, matchingOptions.size());\n        assertTrue(matchingOptions.contains(\"elephant\"));\n        assertTrue(matchingOptions.contains(\"elephantine\"));\n    }", "signature": "@Test\n    public void testGetMatchingOptionsMultipleMatches()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/DefaultParserTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * TODO Needs a rework using JUnit parameterized tests.\n */\npublic class DefaultParserTest extends AbstractParserTestCase {\n\n    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new DefaultParser();\n    }\n\n    @Test\n    public void testBuilder() {\n        // @formatter:off\n        parser = DefaultParser.builder()\n                .setStripLeadingAndTrailingQuotes(false)\n                .setAllowPartialMatching(false)\n                .setDeprecatedHandler(null)\n                .build();\n        // @formatter:on\n        assertEquals(DefaultParser.class, parser.getClass());\n    }\n\n    @Test\n    public void testDeprecated() throws ParseException {\n        final Set<Option> handler = new HashSet<>();\n        parser = DefaultParser.builder().setDeprecatedHandler(handler::add).build();\n        final Option opt1 = Option.builder().option(\"d1\").deprecated().build();\n        // @formatter:off\n        final Option opt2 = Option.builder().option(\"d2\").deprecated(DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .setSince(\"1.0\")\n                .setDescription(\"Do this instead.\").get()).build();\n        // @formatter:on\n        final Option opt3 = Option.builder().option(\"a\").build();\n        // @formatter:off\n        final CommandLine cl = parser.parse(new Options()\n                .addOption(opt1)\n                .addOption(opt2)\n                .addOption(opt3),\n                new String[] {\"-d1\", \"-d2\", \"-a\"});\n        // @formatter:on\n        // Trigger handler:\n        assertTrue(cl.hasOption(opt1.getOpt()));\n        assertTrue(cl.hasOption(opt2.getOpt()));\n        assertTrue(cl.hasOption(opt3.getOpt()));\n        // Assert handler was triggered\n        assertTrue(handler.contains(opt1));\n        assertTrue(handler.contains(opt2));\n        assertFalse(handler.contains(opt3));\n    }\n\n    @Test\n    public void testLongOptionQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"--bfile\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testLongOptionQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"--bfile\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" strips quotes\");\n    }\n\n    @Override\n    @Test\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testLongOptionWithEqualsQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testLongOptionWithEqualsQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }\n\n    @Override\n    @Test\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n        final String[] args = {\"-b\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        //This is behavior is not consistent with the other parsers, but is required for backwards compatibility\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm -b\\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testShortOptionQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"-b\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testShortOptionQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"-b\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" strips quotes\");\n    }\n}\n", "file_hash": "c25ef2fb9f7f2e59072df85c2ca91ef39028bbada85d48ce2a77f3beef0d19fe", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import java.util.HashSet;", "import java.util.Set;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class DefaultParserTest extends AbstractParserTestCase {\n\n    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new DefaultParser();\n    }\n\n    @Test\n    public void testBuilder() {\n        // @formatter:off\n        parser = DefaultParser.builder()\n                .setStripLeadingAndTrailingQuotes(false)\n                .setAllowPartialMatching(false)\n                .setDeprecatedHandler(null)\n                .build();\n        // @formatter:on\n        assertEquals(DefaultParser.class, parser.getClass());\n    }\n\n    @Test\n    public void testDeprecated() throws ParseException {\n        final Set<Option> handler = new HashSet<>();\n        parser = DefaultParser.builder().setDeprecatedHandler(handler::add).build();\n        final Option opt1 = Option.builder().option(\"d1\").deprecated().build();\n        // @formatter:off\n        final Option opt2 = Option.builder().option(\"d2\").deprecated(DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .setSince(\"1.0\")\n                .setDescription(\"Do this instead.\").get()).build();\n        // @formatter:on\n        final Option opt3 = Option.builder().option(\"a\").build();\n        // @formatter:off\n        final CommandLine cl = parser.parse(new Options()\n                .addOption(opt1)\n                .addOption(opt2)\n                .addOption(opt3),\n                new String[] {\"-d1\", \"-d2\", \"-a\"});\n        // @formatter:on\n        // Trigger handler:\n        assertTrue(cl.hasOption(opt1.getOpt()));\n        assertTrue(cl.hasOption(opt2.getOpt()));\n        assertTrue(cl.hasOption(opt3.getOpt()));\n        // Assert handler was triggered\n        assertTrue(handler.contains(opt1));\n        assertTrue(handler.contains(opt2));\n        assertFalse(handler.contains(opt3));\n    }\n\n    @Test\n    public void testLongOptionQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"--bfile\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testLongOptionQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"--bfile\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" strips quotes\");\n    }\n\n    @Override\n    @Test\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testLongOptionWithEqualsQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testLongOptionWithEqualsQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }\n\n    @Override\n    @Test\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n        final String[] args = {\"-b\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        //This is behavior is not consistent with the other parsers, but is required for backwards compatibility\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm -b\\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testShortOptionQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"-b\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testShortOptionQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"-b\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" strips quotes\");\n    }\n}", "definition": "public class DefaultParserTest extends AbstractParserTestCase", "class_docstring": "\nTODO Needs a rework using JUnit parameterized tests.\n", "name": "DefaultParserTest", "super_interfaces": [], "superclasses": "AbstractParserTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new DefaultParser();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @BeforeEach\n    public", "marker_annotations": ["@Override", "@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        super.setUp();\n        parser = new DefaultParser();\n    }", "signature": "@Override\n    @BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilder() {\n        // @formatter:off\n        parser = DefaultParser.builder()\n                .setStripLeadingAndTrailingQuotes(false)\n                .setAllowPartialMatching(false)\n                .setDeprecatedHandler(null)\n                .build();\n        // @formatter:on\n        assertEquals(DefaultParser.class, parser.getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilder", "params": [], "body": "                              {\n        // @formatter:off\n        parser = DefaultParser.builder()\n                .setStripLeadingAndTrailingQuotes(false)\n                .setAllowPartialMatching(false)\n                .setDeprecatedHandler(null)\n                .build();\n        // @formatter:on\n        assertEquals(DefaultParser.class, parser.getClass());\n    }", "signature": "@Test\n    public void testBuilder()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeprecated() throws ParseException {\n        final Set<Option> handler = new HashSet<>();\n        parser = DefaultParser.builder().setDeprecatedHandler(handler::add).build();\n        final Option opt1 = Option.builder().option(\"d1\").deprecated().build();\n        // @formatter:off\n        final Option opt2 = Option.builder().option(\"d2\").deprecated(DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .setSince(\"1.0\")\n                .setDescription(\"Do this instead.\").get()).build();\n        // @formatter:on\n        final Option opt3 = Option.builder().option(\"a\").build();\n        // @formatter:off\n        final CommandLine cl = parser.parse(new Options()\n                .addOption(opt1)\n                .addOption(opt2)\n                .addOption(opt3),\n                new String[] {\"-d1\", \"-d2\", \"-a\"});\n        // @formatter:on\n        // Trigger handler:\n        assertTrue(cl.hasOption(opt1.getOpt()));\n        assertTrue(cl.hasOption(opt2.getOpt()));\n        assertTrue(cl.hasOption(opt3.getOpt()));\n        // Assert handler was triggered\n        assertTrue(handler.contains(opt1));\n        assertTrue(handler.contains(opt2));\n        assertFalse(handler.contains(opt3));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeprecated", "params": [], "body": "                                                       {\n        final Set<Option> handler = new HashSet<>();\n        parser = DefaultParser.builder().setDeprecatedHandler(handler::add).build();\n        final Option opt1 = Option.builder().option(\"d1\").deprecated().build();\n        // @formatter:off\n        final Option opt2 = Option.builder().option(\"d2\").deprecated(DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .setSince(\"1.0\")\n                .setDescription(\"Do this instead.\").get()).build();\n        // @formatter:on\n        final Option opt3 = Option.builder().option(\"a\").build();\n        // @formatter:off\n        final CommandLine cl = parser.parse(new Options()\n                .addOption(opt1)\n                .addOption(opt2)\n                .addOption(opt3),\n                new String[] {\"-d1\", \"-d2\", \"-a\"});\n        // @formatter:on\n        // Trigger handler:\n        assertTrue(cl.hasOption(opt1.getOpt()));\n        assertTrue(cl.hasOption(opt2.getOpt()));\n        assertTrue(cl.hasOption(opt3.getOpt()));\n        // Assert handler was triggered\n        assertTrue(handler.contains(opt1));\n        assertTrue(handler.contains(opt2));\n        assertFalse(handler.contains(opt3));\n    }", "signature": "@Test\n    public void testDeprecated()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongOptionQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"--bfile\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" keeps quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionQuoteHandlingWithoutStrip", "params": [], "body": "                                                                           {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"--bfile\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" keeps quotes\");\n    }", "signature": "@Test\n    public void testLongOptionQuoteHandlingWithoutStrip()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongOptionQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"--bfile\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" strips quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionQuoteHandlingWithStrip", "params": [], "body": "                                                                        {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"--bfile\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" strips quotes\");\n    }", "signature": "@Test\n    public void testLongOptionQuoteHandlingWithStrip()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionWithEqualsQuoteHandling", "params": [], "body": "                                                                         {\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }", "signature": "@Override\n    @Test\n    public void testLongOptionWithEqualsQuoteHandling()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongOptionWithEqualsQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" keeps quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionWithEqualsQuoteHandlingWithoutStrip", "params": [], "body": "                                                                                     {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" keeps quotes\");\n    }", "signature": "@Test\n    public void testLongOptionWithEqualsQuoteHandlingWithoutStrip()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongOptionWithEqualsQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionWithEqualsQuoteHandlingWithStrip", "params": [], "body": "                                                                                  {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }", "signature": "@Test\n    public void testLongOptionWithEqualsQuoteHandlingWithStrip()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n        final String[] args = {\"-b\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        //This is behavior is not consistent with the other parsers, but is required for backwards compatibility\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm -b\\\"arg\\\" keeps quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionConcatenatedQuoteHandling", "params": [], "body": "                                                                            {\n        final String[] args = {\"-b\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        //This is behavior is not consistent with the other parsers, but is required for backwards compatibility\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm -b\\\"arg\\\" keeps quotes\");\n    }", "signature": "@Override\n    @Test\n    public void testShortOptionConcatenatedQuoteHandling()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortOptionQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"-b\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" keeps quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionQuoteHandlingWithoutStrip", "params": [], "body": "                                                                            {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"-b\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" keeps quotes\");\n    }", "signature": "@Test\n    public void testShortOptionQuoteHandlingWithoutStrip()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortOptionQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"-b\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" strips quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionQuoteHandlingWithStrip", "params": [], "body": "                                                                         {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"-b\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" strips quotes\");\n    }", "signature": "@Test\n    public void testShortOptionQuoteHandlingWithStrip()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/TypeHandlerTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.InvalidPathException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class TypeHandlerTest {\n\n    /** Used for Class and Object creation tests. */\n    public static class Instantiable {\n\n        @Override\n        public boolean equals(final Object arg0) {\n            return arg0 instanceof Instantiable;\n        }\n\n        @Override\n        public int hashCode() {\n            return 1;\n        }\n    }\n\n    /** Used for Class and Object negative creation tests */\n    public static final class NotInstantiable {\n        private NotInstantiable() {\n        }\n\n    }\n\n    /** Always returns the same Path. */\n    private static final Converter<Path, InvalidPathException> PATH_CONVERTER = s -> Paths.get(\"foo\");\n\n    private static Stream<Date> createDateFixtures() {\n        return Stream.of(Date.from(Instant.EPOCH), Date.from(Instant.ofEpochSecond(0)), Date.from(Instant.ofEpochSecond(40_000)));\n\n    }\n\n    private static Stream<Arguments> createValueTestParameters() throws MalformedURLException {\n        // force the PatternOptionBuilder to load / modify the TypeHandler table.\n        @SuppressWarnings(\"unused\")\n        final Class<?> loadStatic = PatternOptionBuilder.FILES_VALUE;\n        // reset the type handler table.\n        // TypeHandler.resetConverters();\n        final List<Arguments> list = new ArrayList<>();\n\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the machine on which the test is running. To avoid this\n         * problem, convert the time into a string and then unparse that using the converter. This produces strings that always match the correct time zone.\n         */\n        final Date date = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n\n        list.add(Arguments.of(Instantiable.class.getName(), PatternOptionBuilder.CLASS_VALUE, Instantiable.class));\n        list.add(Arguments.of(\"what ever\", PatternOptionBuilder.CLASS_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"what ever\", PatternOptionBuilder.DATE_VALUE, ParseException.class));\n        list.add(Arguments.of(dateFormat.format(date), PatternOptionBuilder.DATE_VALUE, date));\n        list.add(Arguments.of(\"Jun 06 17:48:57 EDT 2002\", PatternOptionBuilder.DATE_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"non-existing.file\", PatternOptionBuilder.EXISTING_FILE_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"some-file.txt\", PatternOptionBuilder.FILE_VALUE, new File(\"some-file.txt\")));\n\n        list.add(Arguments.of(\"some-path.txt\", Path.class, new File(\"some-path.txt\").toPath()));\n\n        // the PatternOptionBuilder.FILES_VALUE is not registered so it should just return the string\n        list.add(Arguments.of(\"some.files\", PatternOptionBuilder.FILES_VALUE, \"some.files\"));\n\n        list.add(Arguments.of(\"just-a-string\", Integer.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Integer.class, 5));\n        list.add(Arguments.of(\"5.5\", Integer.class, ParseException.class));\n        list.add(Arguments.of(Long.toString(Long.MAX_VALUE), Integer.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Long.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Long.class, 5L));\n        list.add(Arguments.of(\"5.5\", Long.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Short.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Short.class, (short) 5));\n        list.add(Arguments.of(\"5.5\", Short.class, ParseException.class));\n        list.add(Arguments.of(Integer.toString(Integer.MAX_VALUE), Short.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Byte.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Byte.class, (byte) 5));\n        list.add(Arguments.of(\"5.5\", Byte.class, ParseException.class));\n        list.add(Arguments.of(Short.toString(Short.MAX_VALUE), Byte.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Character.class, 'j'));\n        list.add(Arguments.of(\"5\", Character.class, '5'));\n        list.add(Arguments.of(\"5.5\", Character.class, '5'));\n        list.add(Arguments.of(\"\\\\u0124\", Character.class, Character.toChars(0x0124)[0]));\n\n        list.add(Arguments.of(\"just-a-string\", Double.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Double.class, 5d));\n        list.add(Arguments.of(\"5.5\", Double.class, 5.5));\n\n        list.add(Arguments.of(\"just-a-string\", Float.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Float.class, 5f));\n        list.add(Arguments.of(\"5.5\", Float.class, 5.5f));\n        list.add(Arguments.of(Double.toString(Double.MAX_VALUE), Float.class, Float.POSITIVE_INFINITY));\n\n        list.add(Arguments.of(\"just-a-string\", BigInteger.class, ParseException.class));\n        list.add(Arguments.of(\"5\", BigInteger.class, new BigInteger(\"5\")));\n        list.add(Arguments.of(\"5.5\", BigInteger.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", BigDecimal.class, ParseException.class));\n        list.add(Arguments.of(\"5\", BigDecimal.class, new BigDecimal(\"5\")));\n        list.add(Arguments.of(\"5.5\", BigDecimal.class, new BigDecimal(5.5)));\n\n        list.add(Arguments.of(\"1.5\", PatternOptionBuilder.NUMBER_VALUE, Double.valueOf(1.5)));\n        list.add(Arguments.of(\"15\", PatternOptionBuilder.NUMBER_VALUE, Long.valueOf(15)));\n        list.add(Arguments.of(\"not a number\", PatternOptionBuilder.NUMBER_VALUE, ParseException.class));\n\n        list.add(Arguments.of(Instantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE, new Instantiable()));\n        list.add(Arguments.of(NotInstantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE, ParseException.class));\n        list.add(Arguments.of(\"unknown\", PatternOptionBuilder.OBJECT_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"String\", PatternOptionBuilder.STRING_VALUE, \"String\"));\n\n        final String urlString = \"https://commons.apache.org\";\n        list.add(Arguments.of(urlString, PatternOptionBuilder.URL_VALUE, new URL(urlString)));\n        list.add(Arguments.of(\"Malformed-url\", PatternOptionBuilder.URL_VALUE, ParseException.class));\n\n        return list.stream();\n\n    }\n\n    @Test\n    public void testCreateClass() throws ParseException {\n        final Class<?> cls = getClass();\n        assertEquals(cls, TypeHandler.createClass(cls.getName()));\n    }\n\n    // @ParameterizedTest\n    // @MethodSource(\"createDateFixtures\")\n    // public void testCreateDate(final Date date) {\n    //     assertEquals(date, TypeHandler.createDate(date.toString()));\n    // }\n\n    @Test\n    public void testCreateFile() {\n        final File file = new File(\"\").getAbsoluteFile();\n        assertEquals(file, TypeHandler.createFile(file.toString()));\n    }\n\n    @Test\n    public void testCreateFiles() {\n        assertThrows(UnsupportedOperationException.class, () -> TypeHandler.createFiles(null));\n    }\n\n    @Test\n    public void testCreateNumber() throws ParseException {\n        assertEquals(0L, TypeHandler.createNumber(\"0\"));\n        assertEquals(0d, TypeHandler.createNumber(\"0.0\"));\n    }\n\n    @Test\n    public void testCreateObject() throws ParseException {\n        assertTrue(TypeHandler.createObject(Date.class.getName()) instanceof Date);\n    }\n\n    @Test\n    public void testCreateURL() throws ParseException, MalformedURLException {\n        final URL file = Paths.get(\"\").toAbsolutePath().toUri().toURL();\n        assertEquals(file, TypeHandler.createURL(file.toString()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @ParameterizedTest(name = \"{0} as {1}\")\n    @MethodSource(\"createValueTestParameters\")\n    public void testCreateValue(final String str, final Class<?> type, final Object expected) throws Exception {\n        @SuppressWarnings(\"cast\")\n        final Object objectApiTest = type; // KEEP this cast\n        if (expected instanceof Class<?> && Throwable.class.isAssignableFrom((Class<?>) expected)) {\n            assertThrows((Class<Throwable>) expected, () -> TypeHandler.createValue(str, type));\n            assertThrows((Class<Throwable>) expected, () -> TypeHandler.createValue(str, objectApiTest));\n        } else {\n            assertEquals(expected, TypeHandler.createValue(str, type));\n            assertEquals(expected, TypeHandler.createValue(str, objectApiTest));\n        }\n    }\n\n    @Test\n    public void testCreateValueExistingFile() throws Exception {\n        try (FileInputStream result = TypeHandler.createValue(\"src/test/resources/org/apache/commons/cli/existing-readable.file\",\n                PatternOptionBuilder.EXISTING_FILE_VALUE)) {\n            assertNotNull(result);\n        }\n    }\n\n    /* proof of equality for later tests */\n    @Test\n    public void testnstantiableEquals() {\n        assertEquals(new Instantiable(), new Instantiable());\n    }\n\n    @Test\n    public void testOpenFile() throws ParseException, IOException {\n        try (FileInputStream fis = TypeHandler.openFile(\"src/test/resources/org/apache/commons/cli/existing-readable.file\")) {\n            IOUtils.consume(fis);\n        }\n    }\n\n    @Test\n    public void testRegister() {\n        final Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();\n        final TypeHandler typeHandler = new TypeHandler(map);\n        assertEquals(Converter.PATH, typeHandler.getConverter(Path.class));\n        try {\n            map.put(Path.class, PATH_CONVERTER);\n            assertEquals(PATH_CONVERTER, typeHandler.getConverter(Path.class));\n        } finally {\n            map.remove(Path.class);\n            assertEquals(Converter.DEFAULT, typeHandler.getConverter(Path.class));\n        }\n    }\n\n}\n", "file_hash": "c3142d4a7f99d520572ec3a0b80ffe0df5ce15dec93e49aca8e523298b571977", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import java.io.File;", "import java.io.FileInputStream;", "import java.io.IOException;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import java.net.MalformedURLException;", "import java.net.URL;", "import java.nio.file.InvalidPathException;", "import java.nio.file.Path;", "import java.nio.file.Paths;", "import java.text.DateFormat;", "import java.text.SimpleDateFormat;", "import java.time.Instant;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.List;", "import java.util.Map;", "import java.util.stream.Stream;", "import org.apache.commons.io.IOUtils;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.provider.Arguments;", "import org.junit.jupiter.params.provider.MethodSource;"], "methods": [], "classes": [{"original_string": "public class TypeHandlerTest {\n\n    /** Used for Class and Object creation tests. */\n    public static class Instantiable {\n\n        @Override\n        public boolean equals(final Object arg0) {\n            return arg0 instanceof Instantiable;\n        }\n\n        @Override\n        public int hashCode() {\n            return 1;\n        }\n    }\n\n    /** Used for Class and Object negative creation tests */\n    public static final class NotInstantiable {\n        private NotInstantiable() {\n        }\n\n    }\n\n    /** Always returns the same Path. */\n    private static final Converter<Path, InvalidPathException> PATH_CONVERTER = s -> Paths.get(\"foo\");\n\n    private static Stream<Date> createDateFixtures() {\n        return Stream.of(Date.from(Instant.EPOCH), Date.from(Instant.ofEpochSecond(0)), Date.from(Instant.ofEpochSecond(40_000)));\n\n    }\n\n    private static Stream<Arguments> createValueTestParameters() throws MalformedURLException {\n        // force the PatternOptionBuilder to load / modify the TypeHandler table.\n        @SuppressWarnings(\"unused\")\n        final Class<?> loadStatic = PatternOptionBuilder.FILES_VALUE;\n        // reset the type handler table.\n        // TypeHandler.resetConverters();\n        final List<Arguments> list = new ArrayList<>();\n\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the machine on which the test is running. To avoid this\n         * problem, convert the time into a string and then unparse that using the converter. This produces strings that always match the correct time zone.\n         */\n        final Date date = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n\n        list.add(Arguments.of(Instantiable.class.getName(), PatternOptionBuilder.CLASS_VALUE, Instantiable.class));\n        list.add(Arguments.of(\"what ever\", PatternOptionBuilder.CLASS_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"what ever\", PatternOptionBuilder.DATE_VALUE, ParseException.class));\n        list.add(Arguments.of(dateFormat.format(date), PatternOptionBuilder.DATE_VALUE, date));\n        list.add(Arguments.of(\"Jun 06 17:48:57 EDT 2002\", PatternOptionBuilder.DATE_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"non-existing.file\", PatternOptionBuilder.EXISTING_FILE_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"some-file.txt\", PatternOptionBuilder.FILE_VALUE, new File(\"some-file.txt\")));\n\n        list.add(Arguments.of(\"some-path.txt\", Path.class, new File(\"some-path.txt\").toPath()));\n\n        // the PatternOptionBuilder.FILES_VALUE is not registered so it should just return the string\n        list.add(Arguments.of(\"some.files\", PatternOptionBuilder.FILES_VALUE, \"some.files\"));\n\n        list.add(Arguments.of(\"just-a-string\", Integer.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Integer.class, 5));\n        list.add(Arguments.of(\"5.5\", Integer.class, ParseException.class));\n        list.add(Arguments.of(Long.toString(Long.MAX_VALUE), Integer.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Long.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Long.class, 5L));\n        list.add(Arguments.of(\"5.5\", Long.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Short.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Short.class, (short) 5));\n        list.add(Arguments.of(\"5.5\", Short.class, ParseException.class));\n        list.add(Arguments.of(Integer.toString(Integer.MAX_VALUE), Short.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Byte.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Byte.class, (byte) 5));\n        list.add(Arguments.of(\"5.5\", Byte.class, ParseException.class));\n        list.add(Arguments.of(Short.toString(Short.MAX_VALUE), Byte.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Character.class, 'j'));\n        list.add(Arguments.of(\"5\", Character.class, '5'));\n        list.add(Arguments.of(\"5.5\", Character.class, '5'));\n        list.add(Arguments.of(\"\\\\u0124\", Character.class, Character.toChars(0x0124)[0]));\n\n        list.add(Arguments.of(\"just-a-string\", Double.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Double.class, 5d));\n        list.add(Arguments.of(\"5.5\", Double.class, 5.5));\n\n        list.add(Arguments.of(\"just-a-string\", Float.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Float.class, 5f));\n        list.add(Arguments.of(\"5.5\", Float.class, 5.5f));\n        list.add(Arguments.of(Double.toString(Double.MAX_VALUE), Float.class, Float.POSITIVE_INFINITY));\n\n        list.add(Arguments.of(\"just-a-string\", BigInteger.class, ParseException.class));\n        list.add(Arguments.of(\"5\", BigInteger.class, new BigInteger(\"5\")));\n        list.add(Arguments.of(\"5.5\", BigInteger.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", BigDecimal.class, ParseException.class));\n        list.add(Arguments.of(\"5\", BigDecimal.class, new BigDecimal(\"5\")));\n        list.add(Arguments.of(\"5.5\", BigDecimal.class, new BigDecimal(5.5)));\n\n        list.add(Arguments.of(\"1.5\", PatternOptionBuilder.NUMBER_VALUE, Double.valueOf(1.5)));\n        list.add(Arguments.of(\"15\", PatternOptionBuilder.NUMBER_VALUE, Long.valueOf(15)));\n        list.add(Arguments.of(\"not a number\", PatternOptionBuilder.NUMBER_VALUE, ParseException.class));\n\n        list.add(Arguments.of(Instantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE, new Instantiable()));\n        list.add(Arguments.of(NotInstantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE, ParseException.class));\n        list.add(Arguments.of(\"unknown\", PatternOptionBuilder.OBJECT_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"String\", PatternOptionBuilder.STRING_VALUE, \"String\"));\n\n        final String urlString = \"https://commons.apache.org\";\n        list.add(Arguments.of(urlString, PatternOptionBuilder.URL_VALUE, new URL(urlString)));\n        list.add(Arguments.of(\"Malformed-url\", PatternOptionBuilder.URL_VALUE, ParseException.class));\n\n        return list.stream();\n\n    }\n\n    @Test\n    public void testCreateClass() throws ParseException {\n        final Class<?> cls = getClass();\n        assertEquals(cls, TypeHandler.createClass(cls.getName()));\n    }\n\n    // @ParameterizedTest\n    // @MethodSource(\"createDateFixtures\")\n    // public void testCreateDate(final Date date) {\n    //     assertEquals(date, TypeHandler.createDate(date.toString()));\n    // }\n\n    @Test\n    public void testCreateFile() {\n        final File file = new File(\"\").getAbsoluteFile();\n        assertEquals(file, TypeHandler.createFile(file.toString()));\n    }\n\n    @Test\n    public void testCreateFiles() {\n        assertThrows(UnsupportedOperationException.class, () -> TypeHandler.createFiles(null));\n    }\n\n    @Test\n    public void testCreateNumber() throws ParseException {\n        assertEquals(0L, TypeHandler.createNumber(\"0\"));\n        assertEquals(0d, TypeHandler.createNumber(\"0.0\"));\n    }\n\n    @Test\n    public void testCreateObject() throws ParseException {\n        assertTrue(TypeHandler.createObject(Date.class.getName()) instanceof Date);\n    }\n\n    @Test\n    public void testCreateURL() throws ParseException, MalformedURLException {\n        final URL file = Paths.get(\"\").toAbsolutePath().toUri().toURL();\n        assertEquals(file, TypeHandler.createURL(file.toString()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @ParameterizedTest(name = \"{0} as {1}\")\n    @MethodSource(\"createValueTestParameters\")\n    public void testCreateValue(final String str, final Class<?> type, final Object expected) throws Exception {\n        @SuppressWarnings(\"cast\")\n        final Object objectApiTest = type; // KEEP this cast\n        if (expected instanceof Class<?> && Throwable.class.isAssignableFrom((Class<?>) expected)) {\n            assertThrows((Class<Throwable>) expected, () -> TypeHandler.createValue(str, type));\n            assertThrows((Class<Throwable>) expected, () -> TypeHandler.createValue(str, objectApiTest));\n        } else {\n            assertEquals(expected, TypeHandler.createValue(str, type));\n            assertEquals(expected, TypeHandler.createValue(str, objectApiTest));\n        }\n    }\n\n    @Test\n    public void testCreateValueExistingFile() throws Exception {\n        try (FileInputStream result = TypeHandler.createValue(\"src/test/resources/org/apache/commons/cli/existing-readable.file\",\n                PatternOptionBuilder.EXISTING_FILE_VALUE)) {\n            assertNotNull(result);\n        }\n    }\n\n    /* proof of equality for later tests */\n    @Test\n    public void testnstantiableEquals() {\n        assertEquals(new Instantiable(), new Instantiable());\n    }\n\n    @Test\n    public void testOpenFile() throws ParseException, IOException {\n        try (FileInputStream fis = TypeHandler.openFile(\"src/test/resources/org/apache/commons/cli/existing-readable.file\")) {\n            IOUtils.consume(fis);\n        }\n    }\n\n    @Test\n    public void testRegister() {\n        final Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();\n        final TypeHandler typeHandler = new TypeHandler(map);\n        assertEquals(Converter.PATH, typeHandler.getConverter(Path.class));\n        try {\n            map.put(Path.class, PATH_CONVERTER);\n            assertEquals(PATH_CONVERTER, typeHandler.getConverter(Path.class));\n        } finally {\n            map.remove(Path.class);\n            assertEquals(Converter.DEFAULT, typeHandler.getConverter(Path.class));\n        }\n    }\n\n}", "definition": "public class TypeHandlerTest", "class_docstring": "", "name": "TypeHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final Converter<Path, InvalidPathException> PATH_CONVERTER = s -> Paths.get(\"foo\");", "docstring": " Always returns the same Path.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Converter<Path, InvalidPathException>", "name": "PATH_CONVERTER = s -> Paths.get(\"foo\")", "syntax_pass": true}], "classes": [{"original_string": "    public static class Instantiable {\n\n        @Override\n        public boolean equals(final Object arg0) {\n            return arg0 instanceof Instantiable;\n        }\n\n        @Override\n        public int hashCode() {\n            return 1;\n        }\n    }", "definition": "    public static class Instantiable", "class_docstring": " Used for Class and Object creation tests.", "name": "Instantiable", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object arg0) {\n            return arg0 instanceof Instantiable;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "arg0", "type": "Object"}], "body": "                                                 {\n            return arg0 instanceof Instantiable;\n        }", "signature": "@Override\n        public boolean equals(final Object arg0)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return 1;\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    public static final class NotInstantiable {\n        private NotInstantiable() {\n        }\n\n    }", "definition": "    public static final class NotInstantiable", "class_docstring": " Used for Class and Object negative creation tests", "name": "NotInstantiable", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private NotInstantiable() {\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "NotInstantiable", "params": [], "body": "                                  {\n        }", "signature": "private NotInstantiable()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static Stream<Date> createDateFixtures() {\n        return Stream.of(Date.from(Instant.EPOCH), Date.from(Instant.ofEpochSecond(0)), Date.from(Instant.ofEpochSecond(40_000)));\n\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Stream<Date>", "classes": []}, "name": "createDateFixtures", "params": [], "body": "                                                     {\n        return Stream.of(Date.from(Instant.EPOCH), Date.from(Instant.ofEpochSecond(0)), Date.from(Instant.ofEpochSecond(40_000)));\n\n    }", "signature": "private static Stream<Date> createDateFixtures()"}, {"syntax_pass": true, "original_string": "    private static Stream<Arguments> createValueTestParameters() throws MalformedURLException {\n        // force the PatternOptionBuilder to load / modify the TypeHandler table.\n        @SuppressWarnings(\"unused\")\n        final Class<?> loadStatic = PatternOptionBuilder.FILES_VALUE;\n        // reset the type handler table.\n        // TypeHandler.resetConverters();\n        final List<Arguments> list = new ArrayList<>();\n\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the machine on which the test is running. To avoid this\n         * problem, convert the time into a string and then unparse that using the converter. This produces strings that always match the correct time zone.\n         */\n        final Date date = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n\n        list.add(Arguments.of(Instantiable.class.getName(), PatternOptionBuilder.CLASS_VALUE, Instantiable.class));\n        list.add(Arguments.of(\"what ever\", PatternOptionBuilder.CLASS_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"what ever\", PatternOptionBuilder.DATE_VALUE, ParseException.class));\n        list.add(Arguments.of(dateFormat.format(date), PatternOptionBuilder.DATE_VALUE, date));\n        list.add(Arguments.of(\"Jun 06 17:48:57 EDT 2002\", PatternOptionBuilder.DATE_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"non-existing.file\", PatternOptionBuilder.EXISTING_FILE_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"some-file.txt\", PatternOptionBuilder.FILE_VALUE, new File(\"some-file.txt\")));\n\n        list.add(Arguments.of(\"some-path.txt\", Path.class, new File(\"some-path.txt\").toPath()));\n\n        // the PatternOptionBuilder.FILES_VALUE is not registered so it should just return the string\n        list.add(Arguments.of(\"some.files\", PatternOptionBuilder.FILES_VALUE, \"some.files\"));\n\n        list.add(Arguments.of(\"just-a-string\", Integer.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Integer.class, 5));\n        list.add(Arguments.of(\"5.5\", Integer.class, ParseException.class));\n        list.add(Arguments.of(Long.toString(Long.MAX_VALUE), Integer.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Long.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Long.class, 5L));\n        list.add(Arguments.of(\"5.5\", Long.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Short.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Short.class, (short) 5));\n        list.add(Arguments.of(\"5.5\", Short.class, ParseException.class));\n        list.add(Arguments.of(Integer.toString(Integer.MAX_VALUE), Short.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Byte.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Byte.class, (byte) 5));\n        list.add(Arguments.of(\"5.5\", Byte.class, ParseException.class));\n        list.add(Arguments.of(Short.toString(Short.MAX_VALUE), Byte.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Character.class, 'j'));\n        list.add(Arguments.of(\"5\", Character.class, '5'));\n        list.add(Arguments.of(\"5.5\", Character.class, '5'));\n        list.add(Arguments.of(\"\\\\u0124\", Character.class, Character.toChars(0x0124)[0]));\n\n        list.add(Arguments.of(\"just-a-string\", Double.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Double.class, 5d));\n        list.add(Arguments.of(\"5.5\", Double.class, 5.5));\n\n        list.add(Arguments.of(\"just-a-string\", Float.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Float.class, 5f));\n        list.add(Arguments.of(\"5.5\", Float.class, 5.5f));\n        list.add(Arguments.of(Double.toString(Double.MAX_VALUE), Float.class, Float.POSITIVE_INFINITY));\n\n        list.add(Arguments.of(\"just-a-string\", BigInteger.class, ParseException.class));\n        list.add(Arguments.of(\"5\", BigInteger.class, new BigInteger(\"5\")));\n        list.add(Arguments.of(\"5.5\", BigInteger.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", BigDecimal.class, ParseException.class));\n        list.add(Arguments.of(\"5\", BigDecimal.class, new BigDecimal(\"5\")));\n        list.add(Arguments.of(\"5.5\", BigDecimal.class, new BigDecimal(5.5)));\n\n        list.add(Arguments.of(\"1.5\", PatternOptionBuilder.NUMBER_VALUE, Double.valueOf(1.5)));\n        list.add(Arguments.of(\"15\", PatternOptionBuilder.NUMBER_VALUE, Long.valueOf(15)));\n        list.add(Arguments.of(\"not a number\", PatternOptionBuilder.NUMBER_VALUE, ParseException.class));\n\n        list.add(Arguments.of(Instantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE, new Instantiable()));\n        list.add(Arguments.of(NotInstantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE, ParseException.class));\n        list.add(Arguments.of(\"unknown\", PatternOptionBuilder.OBJECT_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"String\", PatternOptionBuilder.STRING_VALUE, \"String\"));\n\n        final String urlString = \"https://commons.apache.org\";\n        list.add(Arguments.of(urlString, PatternOptionBuilder.URL_VALUE, new URL(urlString)));\n        list.add(Arguments.of(\"Malformed-url\", PatternOptionBuilder.URL_VALUE, ParseException.class));\n\n        return list.stream();\n\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Stream<Arguments>", "classes": []}, "name": "createValueTestParameters", "params": [], "body": "                                                                                              {\n        // force the PatternOptionBuilder to load / modify the TypeHandler table.\n        @SuppressWarnings(\"unused\")\n        final Class<?> loadStatic = PatternOptionBuilder.FILES_VALUE;\n        // reset the type handler table.\n        // TypeHandler.resetConverters();\n        final List<Arguments> list = new ArrayList<>();\n\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the machine on which the test is running. To avoid this\n         * problem, convert the time into a string and then unparse that using the converter. This produces strings that always match the correct time zone.\n         */\n        final Date date = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n\n        list.add(Arguments.of(Instantiable.class.getName(), PatternOptionBuilder.CLASS_VALUE, Instantiable.class));\n        list.add(Arguments.of(\"what ever\", PatternOptionBuilder.CLASS_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"what ever\", PatternOptionBuilder.DATE_VALUE, ParseException.class));\n        list.add(Arguments.of(dateFormat.format(date), PatternOptionBuilder.DATE_VALUE, date));\n        list.add(Arguments.of(\"Jun 06 17:48:57 EDT 2002\", PatternOptionBuilder.DATE_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"non-existing.file\", PatternOptionBuilder.EXISTING_FILE_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"some-file.txt\", PatternOptionBuilder.FILE_VALUE, new File(\"some-file.txt\")));\n\n        list.add(Arguments.of(\"some-path.txt\", Path.class, new File(\"some-path.txt\").toPath()));\n\n        // the PatternOptionBuilder.FILES_VALUE is not registered so it should just return the string\n        list.add(Arguments.of(\"some.files\", PatternOptionBuilder.FILES_VALUE, \"some.files\"));\n\n        list.add(Arguments.of(\"just-a-string\", Integer.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Integer.class, 5));\n        list.add(Arguments.of(\"5.5\", Integer.class, ParseException.class));\n        list.add(Arguments.of(Long.toString(Long.MAX_VALUE), Integer.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Long.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Long.class, 5L));\n        list.add(Arguments.of(\"5.5\", Long.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Short.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Short.class, (short) 5));\n        list.add(Arguments.of(\"5.5\", Short.class, ParseException.class));\n        list.add(Arguments.of(Integer.toString(Integer.MAX_VALUE), Short.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Byte.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Byte.class, (byte) 5));\n        list.add(Arguments.of(\"5.5\", Byte.class, ParseException.class));\n        list.add(Arguments.of(Short.toString(Short.MAX_VALUE), Byte.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Character.class, 'j'));\n        list.add(Arguments.of(\"5\", Character.class, '5'));\n        list.add(Arguments.of(\"5.5\", Character.class, '5'));\n        list.add(Arguments.of(\"\\\\u0124\", Character.class, Character.toChars(0x0124)[0]));\n\n        list.add(Arguments.of(\"just-a-string\", Double.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Double.class, 5d));\n        list.add(Arguments.of(\"5.5\", Double.class, 5.5));\n\n        list.add(Arguments.of(\"just-a-string\", Float.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Float.class, 5f));\n        list.add(Arguments.of(\"5.5\", Float.class, 5.5f));\n        list.add(Arguments.of(Double.toString(Double.MAX_VALUE), Float.class, Float.POSITIVE_INFINITY));\n\n        list.add(Arguments.of(\"just-a-string\", BigInteger.class, ParseException.class));\n        list.add(Arguments.of(\"5\", BigInteger.class, new BigInteger(\"5\")));\n        list.add(Arguments.of(\"5.5\", BigInteger.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", BigDecimal.class, ParseException.class));\n        list.add(Arguments.of(\"5\", BigDecimal.class, new BigDecimal(\"5\")));\n        list.add(Arguments.of(\"5.5\", BigDecimal.class, new BigDecimal(5.5)));\n\n        list.add(Arguments.of(\"1.5\", PatternOptionBuilder.NUMBER_VALUE, Double.valueOf(1.5)));\n        list.add(Arguments.of(\"15\", PatternOptionBuilder.NUMBER_VALUE, Long.valueOf(15)));\n        list.add(Arguments.of(\"not a number\", PatternOptionBuilder.NUMBER_VALUE, ParseException.class));\n\n        list.add(Arguments.of(Instantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE, new Instantiable()));\n        list.add(Arguments.of(NotInstantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE, ParseException.class));\n        list.add(Arguments.of(\"unknown\", PatternOptionBuilder.OBJECT_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"String\", PatternOptionBuilder.STRING_VALUE, \"String\"));\n\n        final String urlString = \"https://commons.apache.org\";\n        list.add(Arguments.of(urlString, PatternOptionBuilder.URL_VALUE, new URL(urlString)));\n        list.add(Arguments.of(\"Malformed-url\", PatternOptionBuilder.URL_VALUE, ParseException.class));\n\n        return list.stream();\n\n    }", "signature": "private static Stream<Arguments> createValueTestParameters()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCreateClass() throws ParseException {\n        final Class<?> cls = getClass();\n        assertEquals(cls, TypeHandler.createClass(cls.getName()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateClass", "params": [], "body": "                                                        {\n        final Class<?> cls = getClass();\n        assertEquals(cls, TypeHandler.createClass(cls.getName()));\n    }", "signature": "@Test\n    public void testCreateClass()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCreateFile() {\n        final File file = new File(\"\").getAbsoluteFile();\n        assertEquals(file, TypeHandler.createFile(file.toString()));\n    }", "docstring": " }", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateFile", "params": [], "body": "                                 {\n        final File file = new File(\"\").getAbsoluteFile();\n        assertEquals(file, TypeHandler.createFile(file.toString()));\n    }", "signature": "@Test\n    public void testCreateFile()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCreateFiles() {\n        assertThrows(UnsupportedOperationException.class, () -> TypeHandler.createFiles(null));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateFiles", "params": [], "body": "                                  {\n        assertThrows(UnsupportedOperationException.class, () -> TypeHandler.createFiles(null));\n    }", "signature": "@Test\n    public void testCreateFiles()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCreateNumber() throws ParseException {\n        assertEquals(0L, TypeHandler.createNumber(\"0\"));\n        assertEquals(0d, TypeHandler.createNumber(\"0.0\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateNumber", "params": [], "body": "                                                         {\n        assertEquals(0L, TypeHandler.createNumber(\"0\"));\n        assertEquals(0d, TypeHandler.createNumber(\"0.0\"));\n    }", "signature": "@Test\n    public void testCreateNumber()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCreateObject() throws ParseException {\n        assertTrue(TypeHandler.createObject(Date.class.getName()) instanceof Date);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateObject", "params": [], "body": "                                                         {\n        assertTrue(TypeHandler.createObject(Date.class.getName()) instanceof Date);\n    }", "signature": "@Test\n    public void testCreateObject()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCreateURL() throws ParseException, MalformedURLException {\n        final URL file = Paths.get(\"\").toAbsolutePath().toUri().toURL();\n        assertEquals(file, TypeHandler.createURL(file.toString()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateURL", "params": [], "body": "                                                                             {\n        final URL file = Paths.get(\"\").toAbsolutePath().toUri().toURL();\n        assertEquals(file, TypeHandler.createURL(file.toString()));\n    }", "signature": "@Test\n    public void testCreateURL()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @ParameterizedTest(name = \"{0} as {1}\")\n    @MethodSource(\"createValueTestParameters\")\n    public void testCreateValue(final String str, final Class<?> type, final Object expected) throws Exception {\n        @SuppressWarnings(\"cast\")\n        final Object objectApiTest = type; // KEEP this cast\n        if (expected instanceof Class<?> && Throwable.class.isAssignableFrom((Class<?>) expected)) {\n            assertThrows((Class<Throwable>) expected, () -> TypeHandler.createValue(str, type));\n            assertThrows((Class<Throwable>) expected, () -> TypeHandler.createValue(str, objectApiTest));\n        } else {\n            assertEquals(expected, TypeHandler.createValue(str, type));\n            assertEquals(expected, TypeHandler.createValue(str, objectApiTest));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @ParameterizedTest(name = \"{0} as {1}\")\n    @MethodSource(\"createValueTestParameters\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "@ParameterizedTest(name = \"{0} as {1}\")", "@MethodSource(\"createValueTestParameters\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateValue", "params": [{"name": "str", "type": "String"}, {"name": "type", "type": "Class<?>"}, {"name": "expected", "type": "Object"}], "body": "                                                                                                               {\n        @SuppressWarnings(\"cast\")\n        final Object objectApiTest = type; // KEEP this cast\n        if (expected instanceof Class<?> && Throwable.class.isAssignableFrom((Class<?>) expected)) {\n            assertThrows((Class<Throwable>) expected, () -> TypeHandler.createValue(str, type));\n            assertThrows((Class<Throwable>) expected, () -> TypeHandler.createValue(str, objectApiTest));\n        } else {\n            assertEquals(expected, TypeHandler.createValue(str, type));\n            assertEquals(expected, TypeHandler.createValue(str, objectApiTest));\n        }\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @ParameterizedTest(name = \"{0} as {1}\")\n    @MethodSource(\"createValueTestParameters\")\n    public void testCreateValue(final String str, final Class<?> type, final Object expected)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCreateValueExistingFile() throws Exception {\n        try (FileInputStream result = TypeHandler.createValue(\"src/test/resources/org/apache/commons/cli/existing-readable.file\",\n                PatternOptionBuilder.EXISTING_FILE_VALUE)) {\n            assertNotNull(result);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateValueExistingFile", "params": [], "body": "                                                               {\n        try (FileInputStream result = TypeHandler.createValue(\"src/test/resources/org/apache/commons/cli/existing-readable.file\",\n                PatternOptionBuilder.EXISTING_FILE_VALUE)) {\n            assertNotNull(result);\n        }\n    }", "signature": "@Test\n    public void testCreateValueExistingFile()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testnstantiableEquals() {\n        assertEquals(new Instantiable(), new Instantiable());\n    }", "docstring": " proof of equality for later tests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testnstantiableEquals", "params": [], "body": "                                        {\n        assertEquals(new Instantiable(), new Instantiable());\n    }", "signature": "@Test\n    public void testnstantiableEquals()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOpenFile() throws ParseException, IOException {\n        try (FileInputStream fis = TypeHandler.openFile(\"src/test/resources/org/apache/commons/cli/existing-readable.file\")) {\n            IOUtils.consume(fis);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOpenFile", "params": [], "body": "                                                                  {\n        try (FileInputStream fis = TypeHandler.openFile(\"src/test/resources/org/apache/commons/cli/existing-readable.file\")) {\n            IOUtils.consume(fis);\n        }\n    }", "signature": "@Test\n    public void testOpenFile()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRegister() {\n        final Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();\n        final TypeHandler typeHandler = new TypeHandler(map);\n        assertEquals(Converter.PATH, typeHandler.getConverter(Path.class));\n        try {\n            map.put(Path.class, PATH_CONVERTER);\n            assertEquals(PATH_CONVERTER, typeHandler.getConverter(Path.class));\n        } finally {\n            map.remove(Path.class);\n            assertEquals(Converter.DEFAULT, typeHandler.getConverter(Path.class));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRegister", "params": [], "body": "                               {\n        final Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();\n        final TypeHandler typeHandler = new TypeHandler(map);\n        assertEquals(Converter.PATH, typeHandler.getConverter(Path.class));\n        try {\n            map.put(Path.class, PATH_CONVERTER);\n            assertEquals(PATH_CONVERTER, typeHandler.getConverter(Path.class));\n        } finally {\n            map.remove(Path.class);\n            assertEquals(Converter.DEFAULT, typeHandler.getConverter(Path.class));\n        }\n    }", "signature": "@Test\n    public void testRegister()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/Option_equalsTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Option_equalsTest {\n\n    private Option option1;\n    private Option option2;\n\n    @BeforeEach\n    public void setUp() {\n        option1 = Option.builder(\"opt1\").longOpt(\"longOpt1\").build();\n        option2 = Option.builder(\"opt2\").longOpt(\"longOpt2\").build();\n    }\n\n    @Test\n    public void testEqualsSameObject() {\n        assertTrue(option1.equals(option1));\n    }\n\n    @Test\n    public void testEqualsDifferentType() {\n        assertFalse(option1.equals(\"not an Option\"));\n    }\n\n    @Test\n    public void testEqualsDifferentShortOption() {\n        Option option3 = Option.builder(\"opt3\").longOpt(\"longOpt1\").build();\n        assertFalse(option1.equals(option3));\n    }\n\n    @Test\n    public void testEqualsDifferentLongOption() {\n        Option option3 = Option.builder(\"opt1\").longOpt(\"longOpt3\").build();\n        assertFalse(option1.equals(option3));\n    }\n\n    @Test\n    public void testEqualsSameOptions() {\n        Option option3 = Option.builder(\"opt1\").longOpt(\"longOpt1\").build();\n        assertTrue(option1.equals(option3));\n    }\n}\n", "file_hash": "70b288c1c62887cefdbb3bcac119901edc225926a8c75f0d9f25401dc1d64c09", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class Option_equalsTest {\n\n    private Option option1;\n    private Option option2;\n\n    @BeforeEach\n    public void setUp() {\n        option1 = Option.builder(\"opt1\").longOpt(\"longOpt1\").build();\n        option2 = Option.builder(\"opt2\").longOpt(\"longOpt2\").build();\n    }\n\n    @Test\n    public void testEqualsSameObject() {\n        assertTrue(option1.equals(option1));\n    }\n\n    @Test\n    public void testEqualsDifferentType() {\n        assertFalse(option1.equals(\"not an Option\"));\n    }\n\n    @Test\n    public void testEqualsDifferentShortOption() {\n        Option option3 = Option.builder(\"opt3\").longOpt(\"longOpt1\").build();\n        assertFalse(option1.equals(option3));\n    }\n\n    @Test\n    public void testEqualsDifferentLongOption() {\n        Option option3 = Option.builder(\"opt1\").longOpt(\"longOpt3\").build();\n        assertFalse(option1.equals(option3));\n    }\n\n    @Test\n    public void testEqualsSameOptions() {\n        Option option3 = Option.builder(\"opt1\").longOpt(\"longOpt1\").build();\n        assertTrue(option1.equals(option3));\n    }\n}", "definition": "public class Option_equalsTest", "class_docstring": "", "name": "Option_equalsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Option option1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "option1", "syntax_pass": true}, {"attribute_expression": "private Option option2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "option2", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        option1 = Option.builder(\"opt1\").longOpt(\"longOpt1\").build();\n        option2 = Option.builder(\"opt2\").longOpt(\"longOpt2\").build();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        option1 = Option.builder(\"opt1\").longOpt(\"longOpt1\").build();\n        option2 = Option.builder(\"opt2\").longOpt(\"longOpt2\").build();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEqualsSameObject() {\n        assertTrue(option1.equals(option1));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEqualsSameObject", "params": [], "body": "                                       {\n        assertTrue(option1.equals(option1));\n    }", "signature": "@Test\n    public void testEqualsSameObject()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEqualsDifferentType() {\n        assertFalse(option1.equals(\"not an Option\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEqualsDifferentType", "params": [], "body": "                                          {\n        assertFalse(option1.equals(\"not an Option\"));\n    }", "signature": "@Test\n    public void testEqualsDifferentType()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEqualsDifferentShortOption() {\n        Option option3 = Option.builder(\"opt3\").longOpt(\"longOpt1\").build();\n        assertFalse(option1.equals(option3));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEqualsDifferentShortOption", "params": [], "body": "                                                 {\n        Option option3 = Option.builder(\"opt3\").longOpt(\"longOpt1\").build();\n        assertFalse(option1.equals(option3));\n    }", "signature": "@Test\n    public void testEqualsDifferentShortOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEqualsDifferentLongOption() {\n        Option option3 = Option.builder(\"opt1\").longOpt(\"longOpt3\").build();\n        assertFalse(option1.equals(option3));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEqualsDifferentLongOption", "params": [], "body": "                                                {\n        Option option3 = Option.builder(\"opt1\").longOpt(\"longOpt3\").build();\n        assertFalse(option1.equals(option3));\n    }", "signature": "@Test\n    public void testEqualsDifferentLongOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEqualsSameOptions() {\n        Option option3 = Option.builder(\"opt1\").longOpt(\"longOpt1\").build();\n        assertTrue(option1.equals(option3));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEqualsSameOptions", "params": [], "body": "                                        {\n        Option option3 = Option.builder(\"opt1\").longOpt(\"longOpt1\").build();\n        assertTrue(option1.equals(option3));\n    }", "signature": "@Test\n    public void testEqualsSameOptions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/ArgumentIsOptionTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ArgumentIsOptionTest {\n\n    private Options options;\n    private CommandLineParser parser;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options().addOption(\"p\", false, \"Option p\").addOption(\"attr\", true, \"Option accepts argument\");\n        parser = new PosixParser();\n    }\n\n    @Test\n    public void testOption() throws Exception {\n        final String[] args = {\"-p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertTrue(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertFalse(cl.hasOption(\"attr\"), \"Confirm -attr is not set\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }\n\n    @Test\n    public void testOptionAndOptionWithArgument() throws Exception {\n        final String[] args = {\"-p\", \"-attr\", \"p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertTrue(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertTrue(cl.hasOption(\"attr\"), \"Confirm -attr is set\");\n        assertEquals(\"p\", cl.getOptionValue(\"attr\"), \"Confirm arg of -attr\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }\n\n    @Test\n    public void testOptionWithArgument() throws Exception {\n        final String[] args = {\"-attr\", \"p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertTrue(cl.hasOption(\"attr\"), \"Confirm -attr is set\");\n        assertEquals(\"p\", cl.getOptionValue(\"attr\"), \"Confirm arg of -attr\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }\n}\n", "file_hash": "18d7293c73cd36698ca890b4f44b899d9b10c76777ed5bda24ecf744d6f1f5e2", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ArgumentIsOptionTest {\n\n    private Options options;\n    private CommandLineParser parser;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options().addOption(\"p\", false, \"Option p\").addOption(\"attr\", true, \"Option accepts argument\");\n        parser = new PosixParser();\n    }\n\n    @Test\n    public void testOption() throws Exception {\n        final String[] args = {\"-p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertTrue(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertFalse(cl.hasOption(\"attr\"), \"Confirm -attr is not set\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }\n\n    @Test\n    public void testOptionAndOptionWithArgument() throws Exception {\n        final String[] args = {\"-p\", \"-attr\", \"p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertTrue(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertTrue(cl.hasOption(\"attr\"), \"Confirm -attr is set\");\n        assertEquals(\"p\", cl.getOptionValue(\"attr\"), \"Confirm arg of -attr\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }\n\n    @Test\n    public void testOptionWithArgument() throws Exception {\n        final String[] args = {\"-attr\", \"p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertTrue(cl.hasOption(\"attr\"), \"Confirm -attr is set\");\n        assertEquals(\"p\", cl.getOptionValue(\"attr\"), \"Confirm arg of -attr\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ArgumentIsOptionTest", "class_docstring": "", "name": "ArgumentIsOptionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}, {"attribute_expression": "private CommandLineParser parser;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CommandLineParser", "name": "parser", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        options = new Options().addOption(\"p\", false, \"Option p\").addOption(\"attr\", true, \"Option accepts argument\");\n        parser = new PosixParser();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        options = new Options().addOption(\"p\", false, \"Option p\").addOption(\"attr\", true, \"Option accepts argument\");\n        parser = new PosixParser();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOption() throws Exception {\n        final String[] args = {\"-p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertTrue(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertFalse(cl.hasOption(\"attr\"), \"Confirm -attr is not set\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOption", "params": [], "body": "                                              {\n        final String[] args = {\"-p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertTrue(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertFalse(cl.hasOption(\"attr\"), \"Confirm -attr is not set\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }", "signature": "@Test\n    public void testOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionAndOptionWithArgument() throws Exception {\n        final String[] args = {\"-p\", \"-attr\", \"p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertTrue(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertTrue(cl.hasOption(\"attr\"), \"Confirm -attr is set\");\n        assertEquals(\"p\", cl.getOptionValue(\"attr\"), \"Confirm arg of -attr\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionAndOptionWithArgument", "params": [], "body": "                                                                   {\n        final String[] args = {\"-p\", \"-attr\", \"p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertTrue(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertTrue(cl.hasOption(\"attr\"), \"Confirm -attr is set\");\n        assertEquals(\"p\", cl.getOptionValue(\"attr\"), \"Confirm arg of -attr\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }", "signature": "@Test\n    public void testOptionAndOptionWithArgument()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionWithArgument() throws Exception {\n        final String[] args = {\"-attr\", \"p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertTrue(cl.hasOption(\"attr\"), \"Confirm -attr is set\");\n        assertEquals(\"p\", cl.getOptionValue(\"attr\"), \"Confirm arg of -attr\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionWithArgument", "params": [], "body": "                                                          {\n        final String[] args = {\"-attr\", \"p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertTrue(cl.hasOption(\"attr\"), \"Confirm -attr is set\");\n        assertEquals(\"p\", cl.getOptionValue(\"attr\"), \"Confirm arg of -attr\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }", "signature": "@Test\n    public void testOptionWithArgument()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/SolrCliTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport java.util.Locale;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test fixtures used in SOLR tests.\n */\nclass SolrCliTest {\n\n    public static final String ZK_HOST = \"localhost:9983\";\n\n    public static final String DEFAULT_CONFIG_SET = \"_default\";\n\n    public static final Option OPTION_ZKHOST_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"zkHost\")\n            .longOpt(\"zkHost\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --zk-host instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_ZKHOST =\n    // @formatter:off\n        Option.builder(\"z\")\n            .longOpt(\"zk-host\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_SOLRURL_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"solrUrl\")\n            .longOpt(\"solrUrl\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --solr-url instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_SOLRURL =\n    // @formatter:off\n        Option.builder(\"url\")\n            .longOpt(\"solr-url\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_VERBOSE =\n    // @formatter:off\n        Option.builder(\"v\")\n            .longOpt(\"verbose\")\n            .argName(\"verbose\")\n            .required(false)\n            .desc(\"Enable more verbose command output.\")\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_HELP =\n    // @formatter:off\n        Option.builder(\"h\")\n            .longOpt(\"help\")\n            .required(false)\n            .desc(\"Print this message.\")\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_RECURSE =\n    // @formatter:off\n        Option.builder(\"r\")\n            .longOpt(\"recurse\")\n            .argName(\"recurse\")\n            .hasArg()\n            .required(false)\n            .desc(\"Recurse (true|false), default is false.\")\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_CREDENTIALS =\n    // @formatter:off\n        Option.builder(\"u\")\n            .longOpt(\"credentials\")\n            .argName(\"credentials\")\n            .hasArg()\n            .required(false)\n            .desc(\"Credentials in the format username:password. Example: --credentials solr:SolrRocks\")\n            .build();\n    // @formatter:on\n\n    public static String getDefaultSolrUrl() {\n        final String scheme = \"http\";\n        final String host = \"localhost\";\n        final String port = \"8983\";\n        return String.format(Locale.ROOT, \"%s://%s:%s\", scheme.toLowerCase(Locale.ROOT), host, port);\n    }\n\n    @Test\n    public void testOptions() {\n        // sanity checks\n        assertNotNull(DEFAULT_CONFIG_SET);\n        assertNotNull(OPTION_CREDENTIALS);\n        assertNotNull(OPTION_HELP);\n        assertNotNull(OPTION_RECURSE);\n        assertNotNull(OPTION_SOLRURL);\n        assertNotNull(OPTION_SOLRURL_DEPRECATED);\n        assertNotNull(OPTION_VERBOSE);\n        assertNotNull(OPTION_ZKHOST);\n        assertNotNull(OPTION_ZKHOST_DEPRECATED);\n        assertNotNull(ZK_HOST);\n        assertNotNull(getDefaultSolrUrl());\n    }\n}\n", "file_hash": "2ff1db0edd7c7d25e9c579cb424e2dd3bf8c3c1e03f1ff0f557ba2f94026328e", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import java.util.Locale;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "class SolrCliTest {\n\n    public static final String ZK_HOST = \"localhost:9983\";\n\n    public static final String DEFAULT_CONFIG_SET = \"_default\";\n\n    public static final Option OPTION_ZKHOST_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"zkHost\")\n            .longOpt(\"zkHost\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --zk-host instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_ZKHOST =\n    // @formatter:off\n        Option.builder(\"z\")\n            .longOpt(\"zk-host\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_SOLRURL_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"solrUrl\")\n            .longOpt(\"solrUrl\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --solr-url instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_SOLRURL =\n    // @formatter:off\n        Option.builder(\"url\")\n            .longOpt(\"solr-url\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_VERBOSE =\n    // @formatter:off\n        Option.builder(\"v\")\n            .longOpt(\"verbose\")\n            .argName(\"verbose\")\n            .required(false)\n            .desc(\"Enable more verbose command output.\")\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_HELP =\n    // @formatter:off\n        Option.builder(\"h\")\n            .longOpt(\"help\")\n            .required(false)\n            .desc(\"Print this message.\")\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_RECURSE =\n    // @formatter:off\n        Option.builder(\"r\")\n            .longOpt(\"recurse\")\n            .argName(\"recurse\")\n            .hasArg()\n            .required(false)\n            .desc(\"Recurse (true|false), default is false.\")\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_CREDENTIALS =\n    // @formatter:off\n        Option.builder(\"u\")\n            .longOpt(\"credentials\")\n            .argName(\"credentials\")\n            .hasArg()\n            .required(false)\n            .desc(\"Credentials in the format username:password. Example: --credentials solr:SolrRocks\")\n            .build();\n    // @formatter:on\n\n    public static String getDefaultSolrUrl() {\n        final String scheme = \"http\";\n        final String host = \"localhost\";\n        final String port = \"8983\";\n        return String.format(Locale.ROOT, \"%s://%s:%s\", scheme.toLowerCase(Locale.ROOT), host, port);\n    }\n\n    @Test\n    public void testOptions() {\n        // sanity checks\n        assertNotNull(DEFAULT_CONFIG_SET);\n        assertNotNull(OPTION_CREDENTIALS);\n        assertNotNull(OPTION_HELP);\n        assertNotNull(OPTION_RECURSE);\n        assertNotNull(OPTION_SOLRURL);\n        assertNotNull(OPTION_SOLRURL_DEPRECATED);\n        assertNotNull(OPTION_VERBOSE);\n        assertNotNull(OPTION_ZKHOST);\n        assertNotNull(OPTION_ZKHOST_DEPRECATED);\n        assertNotNull(ZK_HOST);\n        assertNotNull(getDefaultSolrUrl());\n    }\n}", "definition": "class SolrCliTest", "class_docstring": "\nTest fixtures used in SOLR tests.\n", "name": "SolrCliTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "public static final String ZK_HOST = \"localhost:9983\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ZK_HOST = \"localhost:9983\"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_CONFIG_SET = \"_default\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_CONFIG_SET = \"_default\"", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_ZKHOST_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"zkHost\")\n            .longOpt(\"zkHost\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --zk-host instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build();", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_ZKHOST_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"zkHost\")\n            .longOpt(\"zkHost\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --zk-host instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_ZKHOST =\n    // @formatter:off\n        Option.builder(\"z\")\n            .longOpt(\"zk-host\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_ZKHOST =\n    // @formatter:off\n        Option.builder(\"z\")\n            .longOpt(\"zk-host\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_SOLRURL_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"solrUrl\")\n            .longOpt(\"solrUrl\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --solr-url instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_SOLRURL_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"solrUrl\")\n            .longOpt(\"solrUrl\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --solr-url instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_SOLRURL =\n    // @formatter:off\n        Option.builder(\"url\")\n            .longOpt(\"solr-url\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_SOLRURL =\n    // @formatter:off\n        Option.builder(\"url\")\n            .longOpt(\"solr-url\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_VERBOSE =\n    // @formatter:off\n        Option.builder(\"v\")\n            .longOpt(\"verbose\")\n            .argName(\"verbose\")\n            .required(false)\n            .desc(\"Enable more verbose command output.\")\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_VERBOSE =\n    // @formatter:off\n        Option.builder(\"v\")\n            .longOpt(\"verbose\")\n            .argName(\"verbose\")\n            .required(false)\n            .desc(\"Enable more verbose command output.\")\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_HELP =\n    // @formatter:off\n        Option.builder(\"h\")\n            .longOpt(\"help\")\n            .required(false)\n            .desc(\"Print this message.\")\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_HELP =\n    // @formatter:off\n        Option.builder(\"h\")\n            .longOpt(\"help\")\n            .required(false)\n            .desc(\"Print this message.\")\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_RECURSE =\n    // @formatter:off\n        Option.builder(\"r\")\n            .longOpt(\"recurse\")\n            .argName(\"recurse\")\n            .hasArg()\n            .required(false)\n            .desc(\"Recurse (true|false), default is false.\")\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_RECURSE =\n    // @formatter:off\n        Option.builder(\"r\")\n            .longOpt(\"recurse\")\n            .argName(\"recurse\")\n            .hasArg()\n            .required(false)\n            .desc(\"Recurse (true|false), default is false.\")\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_CREDENTIALS =\n    // @formatter:off\n        Option.builder(\"u\")\n            .longOpt(\"credentials\")\n            .argName(\"credentials\")\n            .hasArg()\n            .required(false)\n            .desc(\"Credentials in the format username:password. Example: --credentials solr:SolrRocks\")\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_CREDENTIALS =\n    // @formatter:off\n        Option.builder(\"u\")\n            .longOpt(\"credentials\")\n            .argName(\"credentials\")\n            .hasArg()\n            .required(false)\n            .desc(\"Credentials in the format username:password. Example: --credentials solr:SolrRocks\")\n            .build()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static String getDefaultSolrUrl() {\n        final String scheme = \"http\";\n        final String host = \"localhost\";\n        final String port = \"8983\";\n        return String.format(Locale.ROOT, \"%s://%s:%s\", scheme.toLowerCase(Locale.ROOT), host, port);\n    }", "docstring": " @formatter:on", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "getDefaultSolrUrl", "params": [], "body": "                                             {\n        final String scheme = \"http\";\n        final String host = \"localhost\";\n        final String port = \"8983\";\n        return String.format(Locale.ROOT, \"%s://%s:%s\", scheme.toLowerCase(Locale.ROOT), host, port);\n    }", "signature": "public static String getDefaultSolrUrl()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptions() {\n        // sanity checks\n        assertNotNull(DEFAULT_CONFIG_SET);\n        assertNotNull(OPTION_CREDENTIALS);\n        assertNotNull(OPTION_HELP);\n        assertNotNull(OPTION_RECURSE);\n        assertNotNull(OPTION_SOLRURL);\n        assertNotNull(OPTION_SOLRURL_DEPRECATED);\n        assertNotNull(OPTION_VERBOSE);\n        assertNotNull(OPTION_ZKHOST);\n        assertNotNull(OPTION_ZKHOST_DEPRECATED);\n        assertNotNull(ZK_HOST);\n        assertNotNull(getDefaultSolrUrl());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptions", "params": [], "body": "                              {\n        // sanity checks\n        assertNotNull(DEFAULT_CONFIG_SET);\n        assertNotNull(OPTION_CREDENTIALS);\n        assertNotNull(OPTION_HELP);\n        assertNotNull(OPTION_RECURSE);\n        assertNotNull(OPTION_SOLRURL);\n        assertNotNull(OPTION_SOLRURL_DEPRECATED);\n        assertNotNull(OPTION_VERBOSE);\n        assertNotNull(OPTION_ZKHOST);\n        assertNotNull(OPTION_ZKHOST_DEPRECATED);\n        assertNotNull(ZK_HOST);\n        assertNotNull(getDefaultSolrUrl());\n    }", "signature": "@Test\n    public void testOptions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/Options_addOptionGroupTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Options_addOptionGroupTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testAddOptionGroupRequired() {\n        OptionGroup group = new OptionGroup();\n        group.setRequired(true);\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertTrue(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }\n\n    @Test\n    public void testAddOptionGroupNotRequired() {\n        OptionGroup group = new OptionGroup();\n        group.setRequired(false);\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertFalse(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }\n\n    @Test\n    public void testAddOptionGroupWithExistingOptions() {\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        options.addOption(option1);\n        options.addOption(option2);\n\n        OptionGroup group = new OptionGroup();\n        group.setRequired(true);\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertTrue(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }\n}\n", "file_hash": "760e87fb30eca29af88c28914b9eff313c16a501507298251ef50ee560bfd478", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.*;"], "methods": [], "classes": [{"original_string": "public class Options_addOptionGroupTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testAddOptionGroupRequired() {\n        OptionGroup group = new OptionGroup();\n        group.setRequired(true);\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertTrue(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }\n\n    @Test\n    public void testAddOptionGroupNotRequired() {\n        OptionGroup group = new OptionGroup();\n        group.setRequired(false);\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertFalse(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }\n\n    @Test\n    public void testAddOptionGroupWithExistingOptions() {\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        options.addOption(option1);\n        options.addOption(option2);\n\n        OptionGroup group = new OptionGroup();\n        group.setRequired(true);\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertTrue(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }\n}", "definition": "public class Options_addOptionGroupTest", "class_docstring": "", "name": "Options_addOptionGroupTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        options = new Options();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionGroupRequired() {\n        OptionGroup group = new OptionGroup();\n        group.setRequired(true);\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertTrue(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionGroupRequired", "params": [], "body": "                                             {\n        OptionGroup group = new OptionGroup();\n        group.setRequired(true);\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertTrue(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }", "signature": "@Test\n    public void testAddOptionGroupRequired()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionGroupNotRequired() {\n        OptionGroup group = new OptionGroup();\n        group.setRequired(false);\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertFalse(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionGroupNotRequired", "params": [], "body": "                                                {\n        OptionGroup group = new OptionGroup();\n        group.setRequired(false);\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertFalse(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }", "signature": "@Test\n    public void testAddOptionGroupNotRequired()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionGroupWithExistingOptions() {\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        options.addOption(option1);\n        options.addOption(option2);\n\n        OptionGroup group = new OptionGroup();\n        group.setRequired(true);\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertTrue(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionGroupWithExistingOptions", "params": [], "body": "                                                        {\n        Option option1 = new Option(\"a\", \"optionA\");\n        Option option2 = new Option(\"b\", \"optionB\");\n        options.addOption(option1);\n        options.addOption(option2);\n\n        OptionGroup group = new OptionGroup();\n        group.setRequired(true);\n        group.addOption(option1);\n        group.addOption(option2);\n\n        options.addOptionGroup(group);\n\n        assertTrue(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(option1));\n        assertEquals(group, options.getOptionGroup(option2));\n        assertFalse(option1.isRequired());\n        assertFalse(option2.isRequired());\n    }", "signature": "@Test\n    public void testAddOptionGroupWithExistingOptions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/Options_addOptionsTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Options_addOptionsTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testAddOptionsSuccess() {\n        Options newOptions = new Options();\n        newOptions.addOption(\"a\", \"optionA\", false, \"Description A\");\n        newOptions.addOption(\"b\", \"optionB\", true, \"Description B\");\n\n        options.addOptions(newOptions);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }\n\n    @Test\n    public void testAddOptionsDuplicateKey() {\n        Options newOptions = new Options();\n        newOptions.addOption(\"a\", \"optionA\", false, \"Description A\");\n        newOptions.addOption(\"b\", \"optionB\", true, \"Description B\");\n\n        options.addOption(\"a\", \"optionA\", false, \"Description A\");\n\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            options.addOptions(newOptions);\n        });\n\n        assertEquals(\"Duplicate key: a\", exception.getMessage());\n    }\n\n    @Test\n    public void testAddOptionsWithOptionGroups() {\n        Options newOptions = new Options();\n        OptionGroup group1 = new OptionGroup();\n        group1.addOption(OptionBuilder.create('a'));\n        group1.addOption(OptionBuilder.create('b'));\n        newOptions.addOptionGroup(group1);\n\n        options.addOptions(newOptions);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n        assertEquals(1, options.getOptionGroups().size());\n    }\n}\n", "file_hash": "e61a5fc498e3fc48c86d9778d3830c157ded03474c87a94919398c37fd9fcb77", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class Options_addOptionsTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testAddOptionsSuccess() {\n        Options newOptions = new Options();\n        newOptions.addOption(\"a\", \"optionA\", false, \"Description A\");\n        newOptions.addOption(\"b\", \"optionB\", true, \"Description B\");\n\n        options.addOptions(newOptions);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }\n\n    @Test\n    public void testAddOptionsDuplicateKey() {\n        Options newOptions = new Options();\n        newOptions.addOption(\"a\", \"optionA\", false, \"Description A\");\n        newOptions.addOption(\"b\", \"optionB\", true, \"Description B\");\n\n        options.addOption(\"a\", \"optionA\", false, \"Description A\");\n\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            options.addOptions(newOptions);\n        });\n\n        assertEquals(\"Duplicate key: a\", exception.getMessage());\n    }\n\n    @Test\n    public void testAddOptionsWithOptionGroups() {\n        Options newOptions = new Options();\n        OptionGroup group1 = new OptionGroup();\n        group1.addOption(OptionBuilder.create('a'));\n        group1.addOption(OptionBuilder.create('b'));\n        newOptions.addOptionGroup(group1);\n\n        options.addOptions(newOptions);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n        assertEquals(1, options.getOptionGroups().size());\n    }\n}", "definition": "public class Options_addOptionsTest", "class_docstring": "", "name": "Options_addOptionsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        options = new Options();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionsSuccess() {\n        Options newOptions = new Options();\n        newOptions.addOption(\"a\", \"optionA\", false, \"Description A\");\n        newOptions.addOption(\"b\", \"optionB\", true, \"Description B\");\n\n        options.addOptions(newOptions);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionsSuccess", "params": [], "body": "                                        {\n        Options newOptions = new Options();\n        newOptions.addOption(\"a\", \"optionA\", false, \"Description A\");\n        newOptions.addOption(\"b\", \"optionB\", true, \"Description B\");\n\n        options.addOptions(newOptions);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }", "signature": "@Test\n    public void testAddOptionsSuccess()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionsDuplicateKey() {\n        Options newOptions = new Options();\n        newOptions.addOption(\"a\", \"optionA\", false, \"Description A\");\n        newOptions.addOption(\"b\", \"optionB\", true, \"Description B\");\n\n        options.addOption(\"a\", \"optionA\", false, \"Description A\");\n\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            options.addOptions(newOptions);\n        });\n\n        assertEquals(\"Duplicate key: a\", exception.getMessage());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionsDuplicateKey", "params": [], "body": "                                             {\n        Options newOptions = new Options();\n        newOptions.addOption(\"a\", \"optionA\", false, \"Description A\");\n        newOptions.addOption(\"b\", \"optionB\", true, \"Description B\");\n\n        options.addOption(\"a\", \"optionA\", false, \"Description A\");\n\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            options.addOptions(newOptions);\n        });\n\n        assertEquals(\"Duplicate key: a\", exception.getMessage());\n    }", "signature": "@Test\n    public void testAddOptionsDuplicateKey()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionsWithOptionGroups() {\n        Options newOptions = new Options();\n        OptionGroup group1 = new OptionGroup();\n        group1.addOption(OptionBuilder.create('a'));\n        group1.addOption(OptionBuilder.create('b'));\n        newOptions.addOptionGroup(group1);\n\n        options.addOptions(newOptions);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n        assertEquals(1, options.getOptionGroups().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionsWithOptionGroups", "params": [], "body": "                                                 {\n        Options newOptions = new Options();\n        OptionGroup group1 = new OptionGroup();\n        group1.addOption(OptionBuilder.create('a'));\n        group1.addOption(OptionBuilder.create('b'));\n        newOptions.addOptionGroup(group1);\n\n        options.addOptions(newOptions);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n        assertEquals(1, options.getOptionGroups().size());\n    }", "signature": "@Test\n    public void testAddOptionsWithOptionGroups()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/SolrCreateToolTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\npublic class SolrCreateToolTest {\n\n    public List<Option> getOptions() {\n        // @formatter:off\n        return Arrays.asList(\n            SolrCliTest.OPTION_ZKHOST,\n            SolrCliTest.OPTION_SOLRURL,\n            SolrCliTest.OPTION_ZKHOST_DEPRECATED,\n            SolrCliTest.OPTION_SOLRURL,\n            Option.builder(\"c\")\n                .longOpt(\"name\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(true)\n                .desc(\"Name of collection or core to create.\")\n                .build(),\n            Option.builder(\"s\")\n                .longOpt(\"shards\")\n                .argName(\"#\")\n                .hasArg()\n                .required(false)\n                .desc(\"Number of shards; default is 1.\")\n                .build(),\n            Option.builder(\"rf\")\n                .longOpt(\"replication-factor\")\n                .argName(\"#\")\n                .hasArg()\n                .required(false)\n                .desc(\"Number of copies of each document across the collection (replicas per shard); default is 1.\")\n                .build(),\n            Option.builder(\"d\")\n                .longOpt(\"confdir\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(false)\n                .desc(\"Configuration directory to copy when creating the new collection; default is \"\n                        + SolrCliTest.DEFAULT_CONFIG_SET\n                        + '.')\n                .build(),\n            Option.builder(\"n\")\n                .longOpt(\"confname\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(false)\n                .desc(\"Configuration name; default is the collection name.\")\n                .build(),\n            SolrCliTest.OPTION_CREDENTIALS);\n      // @formatter:on\n    }\n\n    private String printHelp(final HelpFormatter formatter) {\n        final Options options = new Options();\n        getOptions().forEach(options::addOption);\n        final String cmdLineSyntax = getClass().getName();\n        final StringWriter out = new StringWriter();\n        final PrintWriter pw = new PrintWriter(out);\n        formatter.printHelp(pw, formatter.getWidth(), cmdLineSyntax, null, options, formatter.getLeftPadding(), formatter.getDescPadding(), null, false);\n        pw.flush();\n        final String actual = out.toString();\n        assertTrue(actual.contains(\"-z,--zk-host <HOST>              Zookeeper connection string; unnecessary\"));\n        return actual;\n    }\n\n    @Test\n    public void testHelpFormatter() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final String actual = printHelp(formatter);\n        assertFalse(actual.contains(\"Deprecated\"));\n    }\n\n    @Test\n    public void testHelpFormatterDeprecated() {\n        final HelpFormatter formatter = HelpFormatter.builder().setShowDeprecated(true).get();\n        final String actual = printHelp(formatter);\n        assertTrue(actual.contains(\"-zkHost,--zkHost <HOST>          [Deprecated] Zookeeper connection\"));\n    }\n}\n", "file_hash": "d0f0bbfc8288c783bbaab61156a979382954a473cb8748306eee3d5ebb91ba07", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import java.io.PrintWriter;", "import java.io.StringWriter;", "import java.util.Arrays;", "import java.util.List;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class SolrCreateToolTest {\n\n    public List<Option> getOptions() {\n        // @formatter:off\n        return Arrays.asList(\n            SolrCliTest.OPTION_ZKHOST,\n            SolrCliTest.OPTION_SOLRURL,\n            SolrCliTest.OPTION_ZKHOST_DEPRECATED,\n            SolrCliTest.OPTION_SOLRURL,\n            Option.builder(\"c\")\n                .longOpt(\"name\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(true)\n                .desc(\"Name of collection or core to create.\")\n                .build(),\n            Option.builder(\"s\")\n                .longOpt(\"shards\")\n                .argName(\"#\")\n                .hasArg()\n                .required(false)\n                .desc(\"Number of shards; default is 1.\")\n                .build(),\n            Option.builder(\"rf\")\n                .longOpt(\"replication-factor\")\n                .argName(\"#\")\n                .hasArg()\n                .required(false)\n                .desc(\"Number of copies of each document across the collection (replicas per shard); default is 1.\")\n                .build(),\n            Option.builder(\"d\")\n                .longOpt(\"confdir\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(false)\n                .desc(\"Configuration directory to copy when creating the new collection; default is \"\n                        + SolrCliTest.DEFAULT_CONFIG_SET\n                        + '.')\n                .build(),\n            Option.builder(\"n\")\n                .longOpt(\"confname\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(false)\n                .desc(\"Configuration name; default is the collection name.\")\n                .build(),\n            SolrCliTest.OPTION_CREDENTIALS);\n      // @formatter:on\n    }\n\n    private String printHelp(final HelpFormatter formatter) {\n        final Options options = new Options();\n        getOptions().forEach(options::addOption);\n        final String cmdLineSyntax = getClass().getName();\n        final StringWriter out = new StringWriter();\n        final PrintWriter pw = new PrintWriter(out);\n        formatter.printHelp(pw, formatter.getWidth(), cmdLineSyntax, null, options, formatter.getLeftPadding(), formatter.getDescPadding(), null, false);\n        pw.flush();\n        final String actual = out.toString();\n        assertTrue(actual.contains(\"-z,--zk-host <HOST>              Zookeeper connection string; unnecessary\"));\n        return actual;\n    }\n\n    @Test\n    public void testHelpFormatter() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final String actual = printHelp(formatter);\n        assertFalse(actual.contains(\"Deprecated\"));\n    }\n\n    @Test\n    public void testHelpFormatterDeprecated() {\n        final HelpFormatter formatter = HelpFormatter.builder().setShowDeprecated(true).get();\n        final String actual = printHelp(formatter);\n        assertTrue(actual.contains(\"-zkHost,--zkHost <HOST>          [Deprecated] Zookeeper connection\"));\n    }\n}", "definition": "public class SolrCreateToolTest", "class_docstring": "", "name": "SolrCreateToolTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public List<Option> getOptions() {\n        // @formatter:off\n        return Arrays.asList(\n            SolrCliTest.OPTION_ZKHOST,\n            SolrCliTest.OPTION_SOLRURL,\n            SolrCliTest.OPTION_ZKHOST_DEPRECATED,\n            SolrCliTest.OPTION_SOLRURL,\n            Option.builder(\"c\")\n                .longOpt(\"name\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(true)\n                .desc(\"Name of collection or core to create.\")\n                .build(),\n            Option.builder(\"s\")\n                .longOpt(\"shards\")\n                .argName(\"#\")\n                .hasArg()\n                .required(false)\n                .desc(\"Number of shards; default is 1.\")\n                .build(),\n            Option.builder(\"rf\")\n                .longOpt(\"replication-factor\")\n                .argName(\"#\")\n                .hasArg()\n                .required(false)\n                .desc(\"Number of copies of each document across the collection (replicas per shard); default is 1.\")\n                .build(),\n            Option.builder(\"d\")\n                .longOpt(\"confdir\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(false)\n                .desc(\"Configuration directory to copy when creating the new collection; default is \"\n                        + SolrCliTest.DEFAULT_CONFIG_SET\n                        + '.')\n                .build(),\n            Option.builder(\"n\")\n                .longOpt(\"confname\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(false)\n                .desc(\"Configuration name; default is the collection name.\")\n                .build(),\n            SolrCliTest.OPTION_CREDENTIALS);\n      // @formatter:on\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Option>", "classes": []}, "name": "getOptions", "params": [], "body": "                                     {\n        // @formatter:off\n        return Arrays.asList(\n            SolrCliTest.OPTION_ZKHOST,\n            SolrCliTest.OPTION_SOLRURL,\n            SolrCliTest.OPTION_ZKHOST_DEPRECATED,\n            SolrCliTest.OPTION_SOLRURL,\n            Option.builder(\"c\")\n                .longOpt(\"name\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(true)\n                .desc(\"Name of collection or core to create.\")\n                .build(),\n            Option.builder(\"s\")\n                .longOpt(\"shards\")\n                .argName(\"#\")\n                .hasArg()\n                .required(false)\n                .desc(\"Number of shards; default is 1.\")\n                .build(),\n            Option.builder(\"rf\")\n                .longOpt(\"replication-factor\")\n                .argName(\"#\")\n                .hasArg()\n                .required(false)\n                .desc(\"Number of copies of each document across the collection (replicas per shard); default is 1.\")\n                .build(),\n            Option.builder(\"d\")\n                .longOpt(\"confdir\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(false)\n                .desc(\"Configuration directory to copy when creating the new collection; default is \"\n                        + SolrCliTest.DEFAULT_CONFIG_SET\n                        + '.')\n                .build(),\n            Option.builder(\"n\")\n                .longOpt(\"confname\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(false)\n                .desc(\"Configuration name; default is the collection name.\")\n                .build(),\n            SolrCliTest.OPTION_CREDENTIALS);\n      // @formatter:on\n    }", "signature": "public List<Option> getOptions()"}, {"syntax_pass": true, "original_string": "    private String printHelp(final HelpFormatter formatter) {\n        final Options options = new Options();\n        getOptions().forEach(options::addOption);\n        final String cmdLineSyntax = getClass().getName();\n        final StringWriter out = new StringWriter();\n        final PrintWriter pw = new PrintWriter(out);\n        formatter.printHelp(pw, formatter.getWidth(), cmdLineSyntax, null, options, formatter.getLeftPadding(), formatter.getDescPadding(), null, false);\n        pw.flush();\n        final String actual = out.toString();\n        assertTrue(actual.contains(\"-z,--zk-host <HOST>              Zookeeper connection string; unnecessary\"));\n        return actual;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "printHelp", "params": [{"name": "formatter", "type": "HelpFormatter"}], "body": "                                                            {\n        final Options options = new Options();\n        getOptions().forEach(options::addOption);\n        final String cmdLineSyntax = getClass().getName();\n        final StringWriter out = new StringWriter();\n        final PrintWriter pw = new PrintWriter(out);\n        formatter.printHelp(pw, formatter.getWidth(), cmdLineSyntax, null, options, formatter.getLeftPadding(), formatter.getDescPadding(), null, false);\n        pw.flush();\n        final String actual = out.toString();\n        assertTrue(actual.contains(\"-z,--zk-host <HOST>              Zookeeper connection string; unnecessary\"));\n        return actual;\n    }", "signature": "private String printHelp(final HelpFormatter formatter)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHelpFormatter() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final String actual = printHelp(formatter);\n        assertFalse(actual.contains(\"Deprecated\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHelpFormatter", "params": [], "body": "                                    {\n        final HelpFormatter formatter = new HelpFormatter();\n        final String actual = printHelp(formatter);\n        assertFalse(actual.contains(\"Deprecated\"));\n    }", "signature": "@Test\n    public void testHelpFormatter()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHelpFormatterDeprecated() {\n        final HelpFormatter formatter = HelpFormatter.builder().setShowDeprecated(true).get();\n        final String actual = printHelp(formatter);\n        assertTrue(actual.contains(\"-zkHost,--zkHost <HOST>          [Deprecated] Zookeeper connection\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHelpFormatterDeprecated", "params": [], "body": "                                              {\n        final HelpFormatter formatter = HelpFormatter.builder().setShowDeprecated(true).get();\n        final String actual = printHelp(formatter);\n        assertTrue(actual.contains(\"-zkHost,--zkHost <HOST>          [Deprecated] Zookeeper connection\"));\n    }", "signature": "@Test\n    public void testHelpFormatterDeprecated()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/PatternOptionBuilderTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertInstanceOf;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Vector;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for the PatternOptionBuilder class.\n */\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class PatternOptionBuilderTest {\n\n    @Test\n    public void testClassPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"c+d+\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-c\", \"java.util.Calendar\", \"-d\", \"System.DateTime\"});\n\n        assertEquals(Calendar.class, line.getOptionObject(\"c\"), \"c value\");\n        assertNull(line.getOptionObject(\"d\"), \"d value\");\n    }\n\n    @Test\n    public void testEmptyPattern() {\n        final Options options = PatternOptionBuilder.parsePattern(\"\");\n        assertTrue(options.getOptions().isEmpty());\n    }\n\n    @Test\n    public void testExistingFilePattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"g<\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-g\", \"src/test/resources/org/apache/commons/cli/existing-readable.file\"});\n\n        final Object parsedReadableFileStream = line.getOptionObject(\"g\");\n\n        assertNotNull(parsedReadableFileStream, \"option g not parsed\");\n        assertInstanceOf(FileInputStream.class, parsedReadableFileStream, \"option g not FileInputStream\");\n    }\n\n    @Test\n    public void testExistingFilePatternFileNotExist() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"f<\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-f\", \"non-existing.file\"});\n\n        assertNull(line.getOptionObject(\"f\"), \"option f parsed\");\n    }\n\n    @Test\n    public void testNumberPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"n%d%x%\");\n        final CommandLineParser parser = new PosixParser();\n        // 3,5 fails validation.\n        //assertThrows(ParseException.class, () -> parser.parse(options, new String[] {\"-n\", \"1\", \"-d\", \"2.1\", \"-x\", \"3,5\"}));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-n\", \"1\", \"-d\", \"2.1\", \"-x\", \"3,5\"});\n        assertEquals(Long.class, line.getOptionObject(\"n\").getClass(), \"n object class\");\n        assertEquals(Long.valueOf(1), line.getOptionObject(\"n\"), \"n value\");\n\n        assertEquals(Double.class, line.getOptionObject(\"d\").getClass(), \"d object class\");\n        assertEquals(Double.valueOf(2.1), line.getOptionObject(\"d\"), \"d value\");\n\n        assertNull(line.getOptionObject(\"x\"), \"x object\");\n    }\n\n    @Test\n    public void testObjectPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"o@i@n@\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-o\", \"java.lang.String\", \"-i\", \"java.util.Calendar\", \"-n\", \"System.DateTime\"});\n\n        assertEquals(\"\", line.getOptionObject(\"o\"), \"o value\");\n        assertNull(line.getOptionObject(\"i\"), \"i value\");\n        assertNull(line.getOptionObject(\"n\"), \"n value\");\n    }\n\n    @Test\n    public void testRequiredOption() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"!n%m%\");\n        final CommandLineParser parser = new PosixParser();\n\n        try {\n            parser.parse(options, new String[] {\"\"});\n            fail(\"MissingOptionException wasn't thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(1, e.getMissingOptions().size());\n            assertTrue(e.getMissingOptions().contains(\"n\"));\n        }\n    }\n\n    @Test\n    public void testSimplePattern() throws Exception {\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the\n         * machine on which the test is running.  To avoid this problem, convert the time into a string\n         * and then unparse that using the converter.  This produces strings that always match the correct\n         * time zone.\n         */\n        final Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/m*z#\");\n        final Date expectedDate = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n        final String[] args = {\"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\",\n            \"https://commons.apache.org\", \"-z\", dateFormat.format(expectedDate), \"-m\", \"test*\"};\n\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, args);\n\n        assertEquals(\"foo\", line.getOptionValue(\"a\"), \"flag a\");\n        assertEquals(\"foo\", line.getOptionObject(\"a\"), \"string flag a\");\n        assertEquals(new Vector<>(), line.getOptionObject(\"b\"), \"object flag b\");\n        assertTrue(line.hasOption(\"c\"), \"boolean true flag c\");\n        assertFalse(line.hasOption(\"d\"), \"boolean false flag d\");\n        assertEquals(new File(\"build.xml\"), line.getOptionObject(\"e\"), \"file flag e\");\n        assertEquals(Calendar.class, line.getOptionObject(\"f\"), \"class flag f\");\n        assertEquals(Double.valueOf(4.5), line.getOptionObject(\"n\"), \"number flag n\");\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject(\"t\"), \"url flag t\");\n\n        // tests the char methods of CommandLine that delegate to the String methods\n        assertEquals(\"foo\", line.getOptionValue('a'), \"flag a\");\n        assertEquals(\"foo\", line.getOptionObject('a'), \"string flag a\");\n        assertEquals(new Vector<>(), line.getOptionObject('b'), \"object flag b\");\n        assertTrue(line.hasOption('c'), \"boolean true flag c\");\n        assertFalse(line.hasOption('d'), \"boolean false flag d\");\n        assertEquals(new File(\"build.xml\"), line.getOptionObject('e'), \"file flag e\");\n        assertEquals(Calendar.class, line.getOptionObject('f'), \"class flag f\");\n        assertEquals(Double.valueOf(4.5), line.getOptionObject('n'), \"number flag n\");\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject('t'), \"url flag t\");\n\n        // FILES NOT SUPPORTED YET\n        assertThrows(UnsupportedOperationException.class, () -> line.getOptionObject('m'));\n\n        assertEquals(expectedDate, line.getOptionObject('z'), \"date flag z\");\n\n    }\n\n    @Test\n    public void testUntypedPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"abc\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-abc\"});\n\n        assertTrue(line.hasOption('a'));\n        assertNull(line.getOptionObject('a'), \"value a\");\n        assertTrue(line.hasOption('b'));\n        assertNull(line.getOptionObject('b'), \"value b\");\n        assertTrue(line.hasOption('c'));\n        assertNull(line.getOptionObject('c'), \"value c\");\n    }\n\n    @Test\n    public void testURLPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"u/v/\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-u\", \"https://commons.apache.org\", \"-v\", \"foo://commons.apache.org\"});\n\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject(\"u\"), \"u value\");\n        assertNull(line.getOptionObject(\"v\"), \"v value\");\n    }\n}\n", "file_hash": "a8121c1524ffe727f12fe8888d996c7ce923cda1cb3feeeb90085c0da736f114", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertInstanceOf;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import static org.junit.jupiter.api.Assertions.fail;", "import java.io.File;", "import java.io.FileInputStream;", "import java.net.URL;", "import java.text.DateFormat;", "import java.text.SimpleDateFormat;", "import java.util.Calendar;", "import java.util.Date;", "import java.util.Vector;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class PatternOptionBuilderTest {\n\n    @Test\n    public void testClassPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"c+d+\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-c\", \"java.util.Calendar\", \"-d\", \"System.DateTime\"});\n\n        assertEquals(Calendar.class, line.getOptionObject(\"c\"), \"c value\");\n        assertNull(line.getOptionObject(\"d\"), \"d value\");\n    }\n\n    @Test\n    public void testEmptyPattern() {\n        final Options options = PatternOptionBuilder.parsePattern(\"\");\n        assertTrue(options.getOptions().isEmpty());\n    }\n\n    @Test\n    public void testExistingFilePattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"g<\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-g\", \"src/test/resources/org/apache/commons/cli/existing-readable.file\"});\n\n        final Object parsedReadableFileStream = line.getOptionObject(\"g\");\n\n        assertNotNull(parsedReadableFileStream, \"option g not parsed\");\n        assertInstanceOf(FileInputStream.class, parsedReadableFileStream, \"option g not FileInputStream\");\n    }\n\n    @Test\n    public void testExistingFilePatternFileNotExist() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"f<\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-f\", \"non-existing.file\"});\n\n        assertNull(line.getOptionObject(\"f\"), \"option f parsed\");\n    }\n\n    @Test\n    public void testNumberPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"n%d%x%\");\n        final CommandLineParser parser = new PosixParser();\n        // 3,5 fails validation.\n        //assertThrows(ParseException.class, () -> parser.parse(options, new String[] {\"-n\", \"1\", \"-d\", \"2.1\", \"-x\", \"3,5\"}));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-n\", \"1\", \"-d\", \"2.1\", \"-x\", \"3,5\"});\n        assertEquals(Long.class, line.getOptionObject(\"n\").getClass(), \"n object class\");\n        assertEquals(Long.valueOf(1), line.getOptionObject(\"n\"), \"n value\");\n\n        assertEquals(Double.class, line.getOptionObject(\"d\").getClass(), \"d object class\");\n        assertEquals(Double.valueOf(2.1), line.getOptionObject(\"d\"), \"d value\");\n\n        assertNull(line.getOptionObject(\"x\"), \"x object\");\n    }\n\n    @Test\n    public void testObjectPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"o@i@n@\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-o\", \"java.lang.String\", \"-i\", \"java.util.Calendar\", \"-n\", \"System.DateTime\"});\n\n        assertEquals(\"\", line.getOptionObject(\"o\"), \"o value\");\n        assertNull(line.getOptionObject(\"i\"), \"i value\");\n        assertNull(line.getOptionObject(\"n\"), \"n value\");\n    }\n\n    @Test\n    public void testRequiredOption() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"!n%m%\");\n        final CommandLineParser parser = new PosixParser();\n\n        try {\n            parser.parse(options, new String[] {\"\"});\n            fail(\"MissingOptionException wasn't thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(1, e.getMissingOptions().size());\n            assertTrue(e.getMissingOptions().contains(\"n\"));\n        }\n    }\n\n    @Test\n    public void testSimplePattern() throws Exception {\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the\n         * machine on which the test is running.  To avoid this problem, convert the time into a string\n         * and then unparse that using the converter.  This produces strings that always match the correct\n         * time zone.\n         */\n        final Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/m*z#\");\n        final Date expectedDate = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n        final String[] args = {\"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\",\n            \"https://commons.apache.org\", \"-z\", dateFormat.format(expectedDate), \"-m\", \"test*\"};\n\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, args);\n\n        assertEquals(\"foo\", line.getOptionValue(\"a\"), \"flag a\");\n        assertEquals(\"foo\", line.getOptionObject(\"a\"), \"string flag a\");\n        assertEquals(new Vector<>(), line.getOptionObject(\"b\"), \"object flag b\");\n        assertTrue(line.hasOption(\"c\"), \"boolean true flag c\");\n        assertFalse(line.hasOption(\"d\"), \"boolean false flag d\");\n        assertEquals(new File(\"build.xml\"), line.getOptionObject(\"e\"), \"file flag e\");\n        assertEquals(Calendar.class, line.getOptionObject(\"f\"), \"class flag f\");\n        assertEquals(Double.valueOf(4.5), line.getOptionObject(\"n\"), \"number flag n\");\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject(\"t\"), \"url flag t\");\n\n        // tests the char methods of CommandLine that delegate to the String methods\n        assertEquals(\"foo\", line.getOptionValue('a'), \"flag a\");\n        assertEquals(\"foo\", line.getOptionObject('a'), \"string flag a\");\n        assertEquals(new Vector<>(), line.getOptionObject('b'), \"object flag b\");\n        assertTrue(line.hasOption('c'), \"boolean true flag c\");\n        assertFalse(line.hasOption('d'), \"boolean false flag d\");\n        assertEquals(new File(\"build.xml\"), line.getOptionObject('e'), \"file flag e\");\n        assertEquals(Calendar.class, line.getOptionObject('f'), \"class flag f\");\n        assertEquals(Double.valueOf(4.5), line.getOptionObject('n'), \"number flag n\");\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject('t'), \"url flag t\");\n\n        // FILES NOT SUPPORTED YET\n        assertThrows(UnsupportedOperationException.class, () -> line.getOptionObject('m'));\n\n        assertEquals(expectedDate, line.getOptionObject('z'), \"date flag z\");\n\n    }\n\n    @Test\n    public void testUntypedPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"abc\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-abc\"});\n\n        assertTrue(line.hasOption('a'));\n        assertNull(line.getOptionObject('a'), \"value a\");\n        assertTrue(line.hasOption('b'));\n        assertNull(line.getOptionObject('b'), \"value b\");\n        assertTrue(line.hasOption('c'));\n        assertNull(line.getOptionObject('c'), \"value c\");\n    }\n\n    @Test\n    public void testURLPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"u/v/\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-u\", \"https://commons.apache.org\", \"-v\", \"foo://commons.apache.org\"});\n\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject(\"u\"), \"u value\");\n        assertNull(line.getOptionObject(\"v\"), \"v value\");\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class PatternOptionBuilderTest", "class_docstring": "\nTest case for the PatternOptionBuilder class.\n", "name": "PatternOptionBuilderTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testClassPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"c+d+\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-c\", \"java.util.Calendar\", \"-d\", \"System.DateTime\"});\n\n        assertEquals(Calendar.class, line.getOptionObject(\"c\"), \"c value\");\n        assertNull(line.getOptionObject(\"d\"), \"d value\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testClassPattern", "params": [], "body": "                                                    {\n        final Options options = PatternOptionBuilder.parsePattern(\"c+d+\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-c\", \"java.util.Calendar\", \"-d\", \"System.DateTime\"});\n\n        assertEquals(Calendar.class, line.getOptionObject(\"c\"), \"c value\");\n        assertNull(line.getOptionObject(\"d\"), \"d value\");\n    }", "signature": "@Test\n    public void testClassPattern()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEmptyPattern() {\n        final Options options = PatternOptionBuilder.parsePattern(\"\");\n        assertTrue(options.getOptions().isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyPattern", "params": [], "body": "                                   {\n        final Options options = PatternOptionBuilder.parsePattern(\"\");\n        assertTrue(options.getOptions().isEmpty());\n    }", "signature": "@Test\n    public void testEmptyPattern()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExistingFilePattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"g<\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-g\", \"src/test/resources/org/apache/commons/cli/existing-readable.file\"});\n\n        final Object parsedReadableFileStream = line.getOptionObject(\"g\");\n\n        assertNotNull(parsedReadableFileStream, \"option g not parsed\");\n        assertInstanceOf(FileInputStream.class, parsedReadableFileStream, \"option g not FileInputStream\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExistingFilePattern", "params": [], "body": "                                                           {\n        final Options options = PatternOptionBuilder.parsePattern(\"g<\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-g\", \"src/test/resources/org/apache/commons/cli/existing-readable.file\"});\n\n        final Object parsedReadableFileStream = line.getOptionObject(\"g\");\n\n        assertNotNull(parsedReadableFileStream, \"option g not parsed\");\n        assertInstanceOf(FileInputStream.class, parsedReadableFileStream, \"option g not FileInputStream\");\n    }", "signature": "@Test\n    public void testExistingFilePattern()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExistingFilePatternFileNotExist() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"f<\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-f\", \"non-existing.file\"});\n\n        assertNull(line.getOptionObject(\"f\"), \"option f parsed\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExistingFilePatternFileNotExist", "params": [], "body": "                                                                       {\n        final Options options = PatternOptionBuilder.parsePattern(\"f<\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-f\", \"non-existing.file\"});\n\n        assertNull(line.getOptionObject(\"f\"), \"option f parsed\");\n    }", "signature": "@Test\n    public void testExistingFilePatternFileNotExist()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNumberPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"n%d%x%\");\n        final CommandLineParser parser = new PosixParser();\n        // 3,5 fails validation.\n        //assertThrows(ParseException.class, () -> parser.parse(options, new String[] {\"-n\", \"1\", \"-d\", \"2.1\", \"-x\", \"3,5\"}));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-n\", \"1\", \"-d\", \"2.1\", \"-x\", \"3,5\"});\n        assertEquals(Long.class, line.getOptionObject(\"n\").getClass(), \"n object class\");\n        assertEquals(Long.valueOf(1), line.getOptionObject(\"n\"), \"n value\");\n\n        assertEquals(Double.class, line.getOptionObject(\"d\").getClass(), \"d object class\");\n        assertEquals(Double.valueOf(2.1), line.getOptionObject(\"d\"), \"d value\");\n\n        assertNull(line.getOptionObject(\"x\"), \"x object\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNumberPattern", "params": [], "body": "                                                     {\n        final Options options = PatternOptionBuilder.parsePattern(\"n%d%x%\");\n        final CommandLineParser parser = new PosixParser();\n        // 3,5 fails validation.\n        //assertThrows(ParseException.class, () -> parser.parse(options, new String[] {\"-n\", \"1\", \"-d\", \"2.1\", \"-x\", \"3,5\"}));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-n\", \"1\", \"-d\", \"2.1\", \"-x\", \"3,5\"});\n        assertEquals(Long.class, line.getOptionObject(\"n\").getClass(), \"n object class\");\n        assertEquals(Long.valueOf(1), line.getOptionObject(\"n\"), \"n value\");\n\n        assertEquals(Double.class, line.getOptionObject(\"d\").getClass(), \"d object class\");\n        assertEquals(Double.valueOf(2.1), line.getOptionObject(\"d\"), \"d value\");\n\n        assertNull(line.getOptionObject(\"x\"), \"x object\");\n    }", "signature": "@Test\n    public void testNumberPattern()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testObjectPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"o@i@n@\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-o\", \"java.lang.String\", \"-i\", \"java.util.Calendar\", \"-n\", \"System.DateTime\"});\n\n        assertEquals(\"\", line.getOptionObject(\"o\"), \"o value\");\n        assertNull(line.getOptionObject(\"i\"), \"i value\");\n        assertNull(line.getOptionObject(\"n\"), \"n value\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testObjectPattern", "params": [], "body": "                                                     {\n        final Options options = PatternOptionBuilder.parsePattern(\"o@i@n@\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-o\", \"java.lang.String\", \"-i\", \"java.util.Calendar\", \"-n\", \"System.DateTime\"});\n\n        assertEquals(\"\", line.getOptionObject(\"o\"), \"o value\");\n        assertNull(line.getOptionObject(\"i\"), \"i value\");\n        assertNull(line.getOptionObject(\"n\"), \"n value\");\n    }", "signature": "@Test\n    public void testObjectPattern()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRequiredOption() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"!n%m%\");\n        final CommandLineParser parser = new PosixParser();\n\n        try {\n            parser.parse(options, new String[] {\"\"});\n            fail(\"MissingOptionException wasn't thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(1, e.getMissingOptions().size());\n            assertTrue(e.getMissingOptions().contains(\"n\"));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRequiredOption", "params": [], "body": "                                                      {\n        final Options options = PatternOptionBuilder.parsePattern(\"!n%m%\");\n        final CommandLineParser parser = new PosixParser();\n\n        try {\n            parser.parse(options, new String[] {\"\"});\n            fail(\"MissingOptionException wasn't thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(1, e.getMissingOptions().size());\n            assertTrue(e.getMissingOptions().contains(\"n\"));\n        }\n    }", "signature": "@Test\n    public void testRequiredOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSimplePattern() throws Exception {\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the\n         * machine on which the test is running.  To avoid this problem, convert the time into a string\n         * and then unparse that using the converter.  This produces strings that always match the correct\n         * time zone.\n         */\n        final Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/m*z#\");\n        final Date expectedDate = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n        final String[] args = {\"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\",\n            \"https://commons.apache.org\", \"-z\", dateFormat.format(expectedDate), \"-m\", \"test*\"};\n\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, args);\n\n        assertEquals(\"foo\", line.getOptionValue(\"a\"), \"flag a\");\n        assertEquals(\"foo\", line.getOptionObject(\"a\"), \"string flag a\");\n        assertEquals(new Vector<>(), line.getOptionObject(\"b\"), \"object flag b\");\n        assertTrue(line.hasOption(\"c\"), \"boolean true flag c\");\n        assertFalse(line.hasOption(\"d\"), \"boolean false flag d\");\n        assertEquals(new File(\"build.xml\"), line.getOptionObject(\"e\"), \"file flag e\");\n        assertEquals(Calendar.class, line.getOptionObject(\"f\"), \"class flag f\");\n        assertEquals(Double.valueOf(4.5), line.getOptionObject(\"n\"), \"number flag n\");\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject(\"t\"), \"url flag t\");\n\n        // tests the char methods of CommandLine that delegate to the String methods\n        assertEquals(\"foo\", line.getOptionValue('a'), \"flag a\");\n        assertEquals(\"foo\", line.getOptionObject('a'), \"string flag a\");\n        assertEquals(new Vector<>(), line.getOptionObject('b'), \"object flag b\");\n        assertTrue(line.hasOption('c'), \"boolean true flag c\");\n        assertFalse(line.hasOption('d'), \"boolean false flag d\");\n        assertEquals(new File(\"build.xml\"), line.getOptionObject('e'), \"file flag e\");\n        assertEquals(Calendar.class, line.getOptionObject('f'), \"class flag f\");\n        assertEquals(Double.valueOf(4.5), line.getOptionObject('n'), \"number flag n\");\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject('t'), \"url flag t\");\n\n        // FILES NOT SUPPORTED YET\n        assertThrows(UnsupportedOperationException.class, () -> line.getOptionObject('m'));\n\n        assertEquals(expectedDate, line.getOptionObject('z'), \"date flag z\");\n\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSimplePattern", "params": [], "body": "                                                     {\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the\n         * machine on which the test is running.  To avoid this problem, convert the time into a string\n         * and then unparse that using the converter.  This produces strings that always match the correct\n         * time zone.\n         */\n        final Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/m*z#\");\n        final Date expectedDate = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n        final String[] args = {\"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\",\n            \"https://commons.apache.org\", \"-z\", dateFormat.format(expectedDate), \"-m\", \"test*\"};\n\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, args);\n\n        assertEquals(\"foo\", line.getOptionValue(\"a\"), \"flag a\");\n        assertEquals(\"foo\", line.getOptionObject(\"a\"), \"string flag a\");\n        assertEquals(new Vector<>(), line.getOptionObject(\"b\"), \"object flag b\");\n        assertTrue(line.hasOption(\"c\"), \"boolean true flag c\");\n        assertFalse(line.hasOption(\"d\"), \"boolean false flag d\");\n        assertEquals(new File(\"build.xml\"), line.getOptionObject(\"e\"), \"file flag e\");\n        assertEquals(Calendar.class, line.getOptionObject(\"f\"), \"class flag f\");\n        assertEquals(Double.valueOf(4.5), line.getOptionObject(\"n\"), \"number flag n\");\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject(\"t\"), \"url flag t\");\n\n        // tests the char methods of CommandLine that delegate to the String methods\n        assertEquals(\"foo\", line.getOptionValue('a'), \"flag a\");\n        assertEquals(\"foo\", line.getOptionObject('a'), \"string flag a\");\n        assertEquals(new Vector<>(), line.getOptionObject('b'), \"object flag b\");\n        assertTrue(line.hasOption('c'), \"boolean true flag c\");\n        assertFalse(line.hasOption('d'), \"boolean false flag d\");\n        assertEquals(new File(\"build.xml\"), line.getOptionObject('e'), \"file flag e\");\n        assertEquals(Calendar.class, line.getOptionObject('f'), \"class flag f\");\n        assertEquals(Double.valueOf(4.5), line.getOptionObject('n'), \"number flag n\");\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject('t'), \"url flag t\");\n\n        // FILES NOT SUPPORTED YET\n        assertThrows(UnsupportedOperationException.class, () -> line.getOptionObject('m'));\n\n        assertEquals(expectedDate, line.getOptionObject('z'), \"date flag z\");\n\n    }", "signature": "@Test\n    public void testSimplePattern()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUntypedPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"abc\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-abc\"});\n\n        assertTrue(line.hasOption('a'));\n        assertNull(line.getOptionObject('a'), \"value a\");\n        assertTrue(line.hasOption('b'));\n        assertNull(line.getOptionObject('b'), \"value b\");\n        assertTrue(line.hasOption('c'));\n        assertNull(line.getOptionObject('c'), \"value c\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUntypedPattern", "params": [], "body": "                                                      {\n        final Options options = PatternOptionBuilder.parsePattern(\"abc\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-abc\"});\n\n        assertTrue(line.hasOption('a'));\n        assertNull(line.getOptionObject('a'), \"value a\");\n        assertTrue(line.hasOption('b'));\n        assertNull(line.getOptionObject('b'), \"value b\");\n        assertTrue(line.hasOption('c'));\n        assertNull(line.getOptionObject('c'), \"value c\");\n    }", "signature": "@Test\n    public void testUntypedPattern()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testURLPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"u/v/\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-u\", \"https://commons.apache.org\", \"-v\", \"foo://commons.apache.org\"});\n\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject(\"u\"), \"u value\");\n        assertNull(line.getOptionObject(\"v\"), \"v value\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testURLPattern", "params": [], "body": "                                                  {\n        final Options options = PatternOptionBuilder.parsePattern(\"u/v/\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-u\", \"https://commons.apache.org\", \"-v\", \"foo://commons.apache.org\"});\n\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject(\"u\"), \"u value\");\n        assertNull(line.getOptionObject(\"v\"), \"v value\");\n    }", "signature": "@Test\n    public void testURLPattern()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/OptionGroup_setSelectedTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class OptionGroup_setSelectedTest {\n\n    private OptionGroup optionGroup;\n    private Option optionA;\n    private Option optionB;\n\n    @BeforeEach\n    public void setUp() {\n        optionGroup = new OptionGroup();\n        optionA = Option.builder(\"a\").build();\n        optionB = Option.builder(\"b\").build();\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n    }\n\n    @Test\n    public void testSetSelectedSuccess() throws AlreadySelectedException {\n        optionGroup.setSelected(optionA);\n        assertEquals(\"a\", optionGroup.getSelected());\n    }\n\n    @Test\n    public void testSetSelectedAlreadySelected() {\n        try {\n            optionGroup.setSelected(optionA);\n            optionGroup.setSelected(optionB);\n            fail(\"Expected AlreadySelectedException was not thrown\");\n        } catch (AlreadySelectedException e) {\n            assertEquals(optionGroup, e.getOptionGroup());\n            assertEquals(optionB, e.getOption());\n        }\n    }\n\n    @Test\n    public void testSetSelectedNull() throws AlreadySelectedException {\n        optionGroup.setSelected(optionA);\n        optionGroup.setSelected(null);\n        assertNull(optionGroup.getSelected());\n    }\n\n    @Test\n    public void testSetSelectedSameOption() throws AlreadySelectedException {\n        optionGroup.setSelected(optionA);\n        optionGroup.setSelected(optionA);\n        assertEquals(\"a\", optionGroup.getSelected());\n    }\n}\n", "file_hash": "d25a6038d2c53cf7397cd48e5d1258848d734dbc1dc5f22d6a436400ead5c380", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.*;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class OptionGroup_setSelectedTest {\n\n    private OptionGroup optionGroup;\n    private Option optionA;\n    private Option optionB;\n\n    @BeforeEach\n    public void setUp() {\n        optionGroup = new OptionGroup();\n        optionA = Option.builder(\"a\").build();\n        optionB = Option.builder(\"b\").build();\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n    }\n\n    @Test\n    public void testSetSelectedSuccess() throws AlreadySelectedException {\n        optionGroup.setSelected(optionA);\n        assertEquals(\"a\", optionGroup.getSelected());\n    }\n\n    @Test\n    public void testSetSelectedAlreadySelected() {\n        try {\n            optionGroup.setSelected(optionA);\n            optionGroup.setSelected(optionB);\n            fail(\"Expected AlreadySelectedException was not thrown\");\n        } catch (AlreadySelectedException e) {\n            assertEquals(optionGroup, e.getOptionGroup());\n            assertEquals(optionB, e.getOption());\n        }\n    }\n\n    @Test\n    public void testSetSelectedNull() throws AlreadySelectedException {\n        optionGroup.setSelected(optionA);\n        optionGroup.setSelected(null);\n        assertNull(optionGroup.getSelected());\n    }\n\n    @Test\n    public void testSetSelectedSameOption() throws AlreadySelectedException {\n        optionGroup.setSelected(optionA);\n        optionGroup.setSelected(optionA);\n        assertEquals(\"a\", optionGroup.getSelected());\n    }\n}", "definition": "public class OptionGroup_setSelectedTest", "class_docstring": "", "name": "OptionGroup_setSelectedTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private OptionGroup optionGroup;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OptionGroup", "name": "optionGroup", "syntax_pass": true}, {"attribute_expression": "private Option optionA;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "optionA", "syntax_pass": true}, {"attribute_expression": "private Option optionB;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "optionB", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        optionGroup = new OptionGroup();\n        optionA = Option.builder(\"a\").build();\n        optionB = Option.builder(\"b\").build();\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        optionGroup = new OptionGroup();\n        optionA = Option.builder(\"a\").build();\n        optionB = Option.builder(\"b\").build();\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSetSelectedSuccess() throws AlreadySelectedException {\n        optionGroup.setSelected(optionA);\n        assertEquals(\"a\", optionGroup.getSelected());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetSelectedSuccess", "params": [], "body": "                                                                         {\n        optionGroup.setSelected(optionA);\n        assertEquals(\"a\", optionGroup.getSelected());\n    }", "signature": "@Test\n    public void testSetSelectedSuccess()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSetSelectedAlreadySelected() {\n        try {\n            optionGroup.setSelected(optionA);\n            optionGroup.setSelected(optionB);\n            fail(\"Expected AlreadySelectedException was not thrown\");\n        } catch (AlreadySelectedException e) {\n            assertEquals(optionGroup, e.getOptionGroup());\n            assertEquals(optionB, e.getOption());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetSelectedAlreadySelected", "params": [], "body": "                                                 {\n        try {\n            optionGroup.setSelected(optionA);\n            optionGroup.setSelected(optionB);\n            fail(\"Expected AlreadySelectedException was not thrown\");\n        } catch (AlreadySelectedException e) {\n            assertEquals(optionGroup, e.getOptionGroup());\n            assertEquals(optionB, e.getOption());\n        }\n    }", "signature": "@Test\n    public void testSetSelectedAlreadySelected()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSetSelectedNull() throws AlreadySelectedException {\n        optionGroup.setSelected(optionA);\n        optionGroup.setSelected(null);\n        assertNull(optionGroup.getSelected());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetSelectedNull", "params": [], "body": "                                                                      {\n        optionGroup.setSelected(optionA);\n        optionGroup.setSelected(null);\n        assertNull(optionGroup.getSelected());\n    }", "signature": "@Test\n    public void testSetSelectedNull()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSetSelectedSameOption() throws AlreadySelectedException {\n        optionGroup.setSelected(optionA);\n        optionGroup.setSelected(optionA);\n        assertEquals(\"a\", optionGroup.getSelected());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetSelectedSameOption", "params": [], "body": "                                                                            {\n        optionGroup.setSelected(optionA);\n        optionGroup.setSelected(optionA);\n        assertEquals(\"a\", optionGroup.getSelected());\n    }", "signature": "@Test\n    public void testSetSelectedSameOption()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/DeprecatedAttributesTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class DeprecatedAttributesTest {\n\n    @Test\n    public void testBuilderNonDefaults() {\n        // @formatter:off\n        final DeprecatedAttributes value = DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .setSince(\"2.0\")\n                .get();\n        // @formatter:on\n        assertEquals(\"Use Bar instead!\", value.getDescription());\n        assertEquals(\"2.0\", value.getSince());\n        assertEquals(true, value.isForRemoval());\n    }\n\n    @Test\n    public void testBuilderNonDefaultsToString() {\n        // @formatter:off\n        assertEquals(\"Deprecated for removal since 2.0: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .setSince(\"2.0\")\n                .get().toString());\n        assertEquals(\"Deprecated for removal: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .get().toString());\n        assertEquals(\"Deprecated since 2.0: Use Bar instead!\",\n                DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setSince(\"2.0\")\n                .get().toString());\n        assertEquals(\"Deprecated: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .get().toString());\n        // @formatter:on\n    }\n\n    @Test\n    public void testDefaultBuilder() {\n        final DeprecatedAttributes defaultValue = DeprecatedAttributes.builder().get();\n        assertEquals(DeprecatedAttributes.DEFAULT.getDescription(), defaultValue.getDescription());\n        assertEquals(DeprecatedAttributes.DEFAULT.getSince(), defaultValue.getSince());\n        assertEquals(DeprecatedAttributes.DEFAULT.isForRemoval(), defaultValue.isForRemoval());\n    }\n\n    @Test\n    public void testDefaultToString() {\n        assertEquals(\"Deprecated\", DeprecatedAttributes.DEFAULT.toString());\n    }\n}\n", "file_hash": "444c08ee875529046204dbbf138d84fde56693deee7e89ff6a104487fc5a14d2", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class DeprecatedAttributesTest {\n\n    @Test\n    public void testBuilderNonDefaults() {\n        // @formatter:off\n        final DeprecatedAttributes value = DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .setSince(\"2.0\")\n                .get();\n        // @formatter:on\n        assertEquals(\"Use Bar instead!\", value.getDescription());\n        assertEquals(\"2.0\", value.getSince());\n        assertEquals(true, value.isForRemoval());\n    }\n\n    @Test\n    public void testBuilderNonDefaultsToString() {\n        // @formatter:off\n        assertEquals(\"Deprecated for removal since 2.0: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .setSince(\"2.0\")\n                .get().toString());\n        assertEquals(\"Deprecated for removal: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .get().toString());\n        assertEquals(\"Deprecated since 2.0: Use Bar instead!\",\n                DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setSince(\"2.0\")\n                .get().toString());\n        assertEquals(\"Deprecated: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .get().toString());\n        // @formatter:on\n    }\n\n    @Test\n    public void testDefaultBuilder() {\n        final DeprecatedAttributes defaultValue = DeprecatedAttributes.builder().get();\n        assertEquals(DeprecatedAttributes.DEFAULT.getDescription(), defaultValue.getDescription());\n        assertEquals(DeprecatedAttributes.DEFAULT.getSince(), defaultValue.getSince());\n        assertEquals(DeprecatedAttributes.DEFAULT.isForRemoval(), defaultValue.isForRemoval());\n    }\n\n    @Test\n    public void testDefaultToString() {\n        assertEquals(\"Deprecated\", DeprecatedAttributes.DEFAULT.toString());\n    }\n}", "definition": "public class DeprecatedAttributesTest", "class_docstring": "", "name": "DeprecatedAttributesTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderNonDefaults() {\n        // @formatter:off\n        final DeprecatedAttributes value = DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .setSince(\"2.0\")\n                .get();\n        // @formatter:on\n        assertEquals(\"Use Bar instead!\", value.getDescription());\n        assertEquals(\"2.0\", value.getSince());\n        assertEquals(true, value.isForRemoval());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderNonDefaults", "params": [], "body": "                                         {\n        // @formatter:off\n        final DeprecatedAttributes value = DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .setSince(\"2.0\")\n                .get();\n        // @formatter:on\n        assertEquals(\"Use Bar instead!\", value.getDescription());\n        assertEquals(\"2.0\", value.getSince());\n        assertEquals(true, value.isForRemoval());\n    }", "signature": "@Test\n    public void testBuilderNonDefaults()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderNonDefaultsToString() {\n        // @formatter:off\n        assertEquals(\"Deprecated for removal since 2.0: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .setSince(\"2.0\")\n                .get().toString());\n        assertEquals(\"Deprecated for removal: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .get().toString());\n        assertEquals(\"Deprecated since 2.0: Use Bar instead!\",\n                DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setSince(\"2.0\")\n                .get().toString());\n        assertEquals(\"Deprecated: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .get().toString());\n        // @formatter:on\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderNonDefaultsToString", "params": [], "body": "                                                 {\n        // @formatter:off\n        assertEquals(\"Deprecated for removal since 2.0: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .setSince(\"2.0\")\n                .get().toString());\n        assertEquals(\"Deprecated for removal: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .get().toString());\n        assertEquals(\"Deprecated since 2.0: Use Bar instead!\",\n                DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setSince(\"2.0\")\n                .get().toString());\n        assertEquals(\"Deprecated: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .get().toString());\n        // @formatter:on\n    }", "signature": "@Test\n    public void testBuilderNonDefaultsToString()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDefaultBuilder() {\n        final DeprecatedAttributes defaultValue = DeprecatedAttributes.builder().get();\n        assertEquals(DeprecatedAttributes.DEFAULT.getDescription(), defaultValue.getDescription());\n        assertEquals(DeprecatedAttributes.DEFAULT.getSince(), defaultValue.getSince());\n        assertEquals(DeprecatedAttributes.DEFAULT.isForRemoval(), defaultValue.isForRemoval());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDefaultBuilder", "params": [], "body": "                                     {\n        final DeprecatedAttributes defaultValue = DeprecatedAttributes.builder().get();\n        assertEquals(DeprecatedAttributes.DEFAULT.getDescription(), defaultValue.getDescription());\n        assertEquals(DeprecatedAttributes.DEFAULT.getSince(), defaultValue.getSince());\n        assertEquals(DeprecatedAttributes.DEFAULT.isForRemoval(), defaultValue.isForRemoval());\n    }", "signature": "@Test\n    public void testDefaultBuilder()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDefaultToString() {\n        assertEquals(\"Deprecated\", DeprecatedAttributes.DEFAULT.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDefaultToString", "params": [], "body": "                                      {\n        assertEquals(\"Deprecated\", DeprecatedAttributes.DEFAULT.toString());\n    }", "signature": "@Test\n    public void testDefaultToString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/PatternOptionBuilder_getValueTypeTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PatternOptionBuilder_getValueTypeTest {\n\n    @Test\n    public void testGetValueType_Object() {\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, PatternOptionBuilder.getValueType('@'));\n    }\n\n    @Test\n    public void testGetValueType_String() {\n        assertEquals(PatternOptionBuilder.STRING_VALUE, PatternOptionBuilder.getValueType(':'));\n    }\n\n    @Test\n    public void testGetValueType_Number() {\n        assertEquals(PatternOptionBuilder.NUMBER_VALUE, PatternOptionBuilder.getValueType('%'));\n    }\n\n    @Test\n    public void testGetValueType_Class() {\n        assertEquals(PatternOptionBuilder.CLASS_VALUE, PatternOptionBuilder.getValueType('+'));\n    }\n\n    @Test\n    public void testGetValueType_Date() {\n        assertEquals(PatternOptionBuilder.DATE_VALUE, PatternOptionBuilder.getValueType('#'));\n    }\n\n    @Test\n    public void testGetValueType_ExistingFile() {\n        assertEquals(PatternOptionBuilder.EXISTING_FILE_VALUE, PatternOptionBuilder.getValueType('<'));\n    }\n\n    @Test\n    public void testGetValueType_File() {\n        assertEquals(PatternOptionBuilder.FILE_VALUE, PatternOptionBuilder.getValueType('>'));\n    }\n\n    @Test\n    public void testGetValueType_Files() {\n        assertEquals(PatternOptionBuilder.FILES_VALUE, PatternOptionBuilder.getValueType('*'));\n    }\n\n    @Test\n    public void testGetValueType_URL() {\n        assertEquals(PatternOptionBuilder.URL_VALUE, PatternOptionBuilder.getValueType('/'));\n    }\n\n    @Test\n    public void testGetValueType_Null() {\n        assertNull(PatternOptionBuilder.getValueType('X'));\n    }\n}\n", "file_hash": "945ec5de523dfa54e6ab1767415261c194ddf2067e84ff1a543672ed34834c4f", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class PatternOptionBuilder_getValueTypeTest {\n\n    @Test\n    public void testGetValueType_Object() {\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, PatternOptionBuilder.getValueType('@'));\n    }\n\n    @Test\n    public void testGetValueType_String() {\n        assertEquals(PatternOptionBuilder.STRING_VALUE, PatternOptionBuilder.getValueType(':'));\n    }\n\n    @Test\n    public void testGetValueType_Number() {\n        assertEquals(PatternOptionBuilder.NUMBER_VALUE, PatternOptionBuilder.getValueType('%'));\n    }\n\n    @Test\n    public void testGetValueType_Class() {\n        assertEquals(PatternOptionBuilder.CLASS_VALUE, PatternOptionBuilder.getValueType('+'));\n    }\n\n    @Test\n    public void testGetValueType_Date() {\n        assertEquals(PatternOptionBuilder.DATE_VALUE, PatternOptionBuilder.getValueType('#'));\n    }\n\n    @Test\n    public void testGetValueType_ExistingFile() {\n        assertEquals(PatternOptionBuilder.EXISTING_FILE_VALUE, PatternOptionBuilder.getValueType('<'));\n    }\n\n    @Test\n    public void testGetValueType_File() {\n        assertEquals(PatternOptionBuilder.FILE_VALUE, PatternOptionBuilder.getValueType('>'));\n    }\n\n    @Test\n    public void testGetValueType_Files() {\n        assertEquals(PatternOptionBuilder.FILES_VALUE, PatternOptionBuilder.getValueType('*'));\n    }\n\n    @Test\n    public void testGetValueType_URL() {\n        assertEquals(PatternOptionBuilder.URL_VALUE, PatternOptionBuilder.getValueType('/'));\n    }\n\n    @Test\n    public void testGetValueType_Null() {\n        assertNull(PatternOptionBuilder.getValueType('X'));\n    }\n}", "definition": "public class PatternOptionBuilder_getValueTypeTest", "class_docstring": "", "name": "PatternOptionBuilder_getValueTypeTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testGetValueType_Object() {\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, PatternOptionBuilder.getValueType('@'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetValueType_Object", "params": [], "body": "                                          {\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, PatternOptionBuilder.getValueType('@'));\n    }", "signature": "@Test\n    public void testGetValueType_Object()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetValueType_String() {\n        assertEquals(PatternOptionBuilder.STRING_VALUE, PatternOptionBuilder.getValueType(':'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetValueType_String", "params": [], "body": "                                          {\n        assertEquals(PatternOptionBuilder.STRING_VALUE, PatternOptionBuilder.getValueType(':'));\n    }", "signature": "@Test\n    public void testGetValueType_String()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetValueType_Number() {\n        assertEquals(PatternOptionBuilder.NUMBER_VALUE, PatternOptionBuilder.getValueType('%'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetValueType_Number", "params": [], "body": "                                          {\n        assertEquals(PatternOptionBuilder.NUMBER_VALUE, PatternOptionBuilder.getValueType('%'));\n    }", "signature": "@Test\n    public void testGetValueType_Number()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetValueType_Class() {\n        assertEquals(PatternOptionBuilder.CLASS_VALUE, PatternOptionBuilder.getValueType('+'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetValueType_Class", "params": [], "body": "                                         {\n        assertEquals(PatternOptionBuilder.CLASS_VALUE, PatternOptionBuilder.getValueType('+'));\n    }", "signature": "@Test\n    public void testGetValueType_Class()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetValueType_Date() {\n        assertEquals(PatternOptionBuilder.DATE_VALUE, PatternOptionBuilder.getValueType('#'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetValueType_Date", "params": [], "body": "                                        {\n        assertEquals(PatternOptionBuilder.DATE_VALUE, PatternOptionBuilder.getValueType('#'));\n    }", "signature": "@Test\n    public void testGetValueType_Date()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetValueType_ExistingFile() {\n        assertEquals(PatternOptionBuilder.EXISTING_FILE_VALUE, PatternOptionBuilder.getValueType('<'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetValueType_ExistingFile", "params": [], "body": "                                                {\n        assertEquals(PatternOptionBuilder.EXISTING_FILE_VALUE, PatternOptionBuilder.getValueType('<'));\n    }", "signature": "@Test\n    public void testGetValueType_ExistingFile()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetValueType_File() {\n        assertEquals(PatternOptionBuilder.FILE_VALUE, PatternOptionBuilder.getValueType('>'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetValueType_File", "params": [], "body": "                                        {\n        assertEquals(PatternOptionBuilder.FILE_VALUE, PatternOptionBuilder.getValueType('>'));\n    }", "signature": "@Test\n    public void testGetValueType_File()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetValueType_Files() {\n        assertEquals(PatternOptionBuilder.FILES_VALUE, PatternOptionBuilder.getValueType('*'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetValueType_Files", "params": [], "body": "                                         {\n        assertEquals(PatternOptionBuilder.FILES_VALUE, PatternOptionBuilder.getValueType('*'));\n    }", "signature": "@Test\n    public void testGetValueType_Files()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetValueType_URL() {\n        assertEquals(PatternOptionBuilder.URL_VALUE, PatternOptionBuilder.getValueType('/'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetValueType_URL", "params": [], "body": "                                       {\n        assertEquals(PatternOptionBuilder.URL_VALUE, PatternOptionBuilder.getValueType('/'));\n    }", "signature": "@Test\n    public void testGetValueType_URL()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetValueType_Null() {\n        assertNull(PatternOptionBuilder.getValueType('X'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetValueType_Null", "params": [], "body": "                                        {\n        assertNull(PatternOptionBuilder.getValueType('X'));\n    }", "signature": "@Test\n    public void testGetValueType_Null()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/UtilTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.junit.jupiter.api.Test;\n\npublic class UtilTest {\n\n    @Test\n    public void testStripLeadingAndTrailingQuotes() {\n        assertNull(Util.stripLeadingAndTrailingQuotes(null));\n        assertEquals(\"\", Util.stripLeadingAndTrailingQuotes(\"\"));\n        assertEquals(\"foo\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\"\"));\n        assertEquals(\"foo \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"foo \\\"bar\\\"\"));\n        assertEquals(\"\\\"foo\\\" bar\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" bar\"));\n        assertEquals(\"\\\"foo\\\" and \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" and \\\"bar\\\"\"));\n        assertEquals(\"\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"\"));\n    }\n\n    @Test\n    public void testStripLeadingHyphens() {\n        assertEquals(\"f\", Util.stripLeadingHyphens(\"-f\"));\n        assertEquals(\"foo\", Util.stripLeadingHyphens(\"--foo\"));\n        assertEquals(\"-foo\", Util.stripLeadingHyphens(\"---foo\"));\n        assertNull(Util.stripLeadingHyphens(null));\n    }\n}\n", "file_hash": "43e5e9c2cd285a9a9590f69b64d74b45ae33d1d2841441c6c2a052c98382da97", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class UtilTest {\n\n    @Test\n    public void testStripLeadingAndTrailingQuotes() {\n        assertNull(Util.stripLeadingAndTrailingQuotes(null));\n        assertEquals(\"\", Util.stripLeadingAndTrailingQuotes(\"\"));\n        assertEquals(\"foo\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\"\"));\n        assertEquals(\"foo \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"foo \\\"bar\\\"\"));\n        assertEquals(\"\\\"foo\\\" bar\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" bar\"));\n        assertEquals(\"\\\"foo\\\" and \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" and \\\"bar\\\"\"));\n        assertEquals(\"\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"\"));\n    }\n\n    @Test\n    public void testStripLeadingHyphens() {\n        assertEquals(\"f\", Util.stripLeadingHyphens(\"-f\"));\n        assertEquals(\"foo\", Util.stripLeadingHyphens(\"--foo\"));\n        assertEquals(\"-foo\", Util.stripLeadingHyphens(\"---foo\"));\n        assertNull(Util.stripLeadingHyphens(null));\n    }\n}", "definition": "public class UtilTest", "class_docstring": "", "name": "UtilTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testStripLeadingAndTrailingQuotes() {\n        assertNull(Util.stripLeadingAndTrailingQuotes(null));\n        assertEquals(\"\", Util.stripLeadingAndTrailingQuotes(\"\"));\n        assertEquals(\"foo\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\"\"));\n        assertEquals(\"foo \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"foo \\\"bar\\\"\"));\n        assertEquals(\"\\\"foo\\\" bar\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" bar\"));\n        assertEquals(\"\\\"foo\\\" and \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" and \\\"bar\\\"\"));\n        assertEquals(\"\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStripLeadingAndTrailingQuotes", "params": [], "body": "                                                    {\n        assertNull(Util.stripLeadingAndTrailingQuotes(null));\n        assertEquals(\"\", Util.stripLeadingAndTrailingQuotes(\"\"));\n        assertEquals(\"foo\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\"\"));\n        assertEquals(\"foo \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"foo \\\"bar\\\"\"));\n        assertEquals(\"\\\"foo\\\" bar\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" bar\"));\n        assertEquals(\"\\\"foo\\\" and \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" and \\\"bar\\\"\"));\n        assertEquals(\"\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"\"));\n    }", "signature": "@Test\n    public void testStripLeadingAndTrailingQuotes()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStripLeadingHyphens() {\n        assertEquals(\"f\", Util.stripLeadingHyphens(\"-f\"));\n        assertEquals(\"foo\", Util.stripLeadingHyphens(\"--foo\"));\n        assertEquals(\"-foo\", Util.stripLeadingHyphens(\"---foo\"));\n        assertNull(Util.stripLeadingHyphens(null));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStripLeadingHyphens", "params": [], "body": "                                          {\n        assertEquals(\"f\", Util.stripLeadingHyphens(\"-f\"));\n        assertEquals(\"foo\", Util.stripLeadingHyphens(\"--foo\"));\n        assertEquals(\"-foo\", Util.stripLeadingHyphens(\"---foo\"));\n        assertNull(Util.stripLeadingHyphens(null));\n    }", "signature": "@Test\n    public void testStripLeadingHyphens()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/Options_addOptionTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Options_addOptionTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testAddOptionWithShortAndLongOpt() {\n        Option opt = new Option(\"a\", \"apple\", false, \"description\");\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasLongOption(\"apple\"));\n        assertEquals(opt, options.getOption(\"a\"));\n        assertEquals(opt, options.getOption(\"apple\"));\n    }\n\n    @Test\n    public void testAddOptionWithRequired() {\n        Option opt = new Option(\"b\", \"banana\", true, \"description\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"b\"));\n        assertTrue(options.hasLongOption(\"banana\"));\n        assertTrue(options.getRequiredOptions().contains(\"b\"));\n    }\n\n    @Test\n    public void testAddOptionWithoutLongOpt() {\n        Option opt = new Option(\"c\", false, \"description\");\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"c\"));\n        assertFalse(options.hasLongOption(\"c\"));\n        assertEquals(opt, options.getOption(\"c\"));\n    }\n\n    @Test\n    public void testAddOptionWithDuplicateKey() {\n        Option opt1 = new Option(\"d\", \"date\", false, \"description1\");\n        Option opt2 = new Option(\"d\", \"date\", false, \"description2\");\n        options.addOption(opt1);\n        options.addOption(opt2);\n\n        assertTrue(options.hasOption(\"d\"));\n        assertTrue(options.hasLongOption(\"date\"));\n        assertEquals(opt2, options.getOption(\"d\"));\n        assertEquals(opt2, options.getOption(\"date\"));\n    }\n\n    @Test\n    public void testAddOptionWithRequiredAndDuplicateKey() {\n        Option opt1 = new Option(\"e\", \"egg\", false, \"description1\");\n        opt1.setRequired(true);\n        Option opt2 = new Option(\"e\", \"egg\", false, \"description2\");\n        opt2.setRequired(true);\n        options.addOption(opt1);\n        options.addOption(opt2);\n\n        assertTrue(options.hasOption(\"e\"));\n        assertTrue(options.hasLongOption(\"egg\"));\n        assertTrue(options.getRequiredOptions().contains(\"e\"));\n        assertEquals(opt2, options.getOption(\"e\"));\n        assertEquals(opt2, options.getOption(\"egg\"));\n    }\n}\n", "file_hash": "5d80caadafc4bc1708532c7143ed372eb65b7e6279f5a18c0a09998442f330e3", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class Options_addOptionTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testAddOptionWithShortAndLongOpt() {\n        Option opt = new Option(\"a\", \"apple\", false, \"description\");\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasLongOption(\"apple\"));\n        assertEquals(opt, options.getOption(\"a\"));\n        assertEquals(opt, options.getOption(\"apple\"));\n    }\n\n    @Test\n    public void testAddOptionWithRequired() {\n        Option opt = new Option(\"b\", \"banana\", true, \"description\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"b\"));\n        assertTrue(options.hasLongOption(\"banana\"));\n        assertTrue(options.getRequiredOptions().contains(\"b\"));\n    }\n\n    @Test\n    public void testAddOptionWithoutLongOpt() {\n        Option opt = new Option(\"c\", false, \"description\");\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"c\"));\n        assertFalse(options.hasLongOption(\"c\"));\n        assertEquals(opt, options.getOption(\"c\"));\n    }\n\n    @Test\n    public void testAddOptionWithDuplicateKey() {\n        Option opt1 = new Option(\"d\", \"date\", false, \"description1\");\n        Option opt2 = new Option(\"d\", \"date\", false, \"description2\");\n        options.addOption(opt1);\n        options.addOption(opt2);\n\n        assertTrue(options.hasOption(\"d\"));\n        assertTrue(options.hasLongOption(\"date\"));\n        assertEquals(opt2, options.getOption(\"d\"));\n        assertEquals(opt2, options.getOption(\"date\"));\n    }\n\n    @Test\n    public void testAddOptionWithRequiredAndDuplicateKey() {\n        Option opt1 = new Option(\"e\", \"egg\", false, \"description1\");\n        opt1.setRequired(true);\n        Option opt2 = new Option(\"e\", \"egg\", false, \"description2\");\n        opt2.setRequired(true);\n        options.addOption(opt1);\n        options.addOption(opt2);\n\n        assertTrue(options.hasOption(\"e\"));\n        assertTrue(options.hasLongOption(\"egg\"));\n        assertTrue(options.getRequiredOptions().contains(\"e\"));\n        assertEquals(opt2, options.getOption(\"e\"));\n        assertEquals(opt2, options.getOption(\"egg\"));\n    }\n}", "definition": "public class Options_addOptionTest", "class_docstring": "", "name": "Options_addOptionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        options = new Options();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionWithShortAndLongOpt() {\n        Option opt = new Option(\"a\", \"apple\", false, \"description\");\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasLongOption(\"apple\"));\n        assertEquals(opt, options.getOption(\"a\"));\n        assertEquals(opt, options.getOption(\"apple\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionWithShortAndLongOpt", "params": [], "body": "                                                   {\n        Option opt = new Option(\"a\", \"apple\", false, \"description\");\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasLongOption(\"apple\"));\n        assertEquals(opt, options.getOption(\"a\"));\n        assertEquals(opt, options.getOption(\"apple\"));\n    }", "signature": "@Test\n    public void testAddOptionWithShortAndLongOpt()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionWithRequired() {\n        Option opt = new Option(\"b\", \"banana\", true, \"description\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"b\"));\n        assertTrue(options.hasLongOption(\"banana\"));\n        assertTrue(options.getRequiredOptions().contains(\"b\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionWithRequired", "params": [], "body": "                                            {\n        Option opt = new Option(\"b\", \"banana\", true, \"description\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"b\"));\n        assertTrue(options.hasLongOption(\"banana\"));\n        assertTrue(options.getRequiredOptions().contains(\"b\"));\n    }", "signature": "@Test\n    public void testAddOptionWithRequired()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionWithoutLongOpt() {\n        Option opt = new Option(\"c\", false, \"description\");\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"c\"));\n        assertFalse(options.hasLongOption(\"c\"));\n        assertEquals(opt, options.getOption(\"c\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionWithoutLongOpt", "params": [], "body": "                                              {\n        Option opt = new Option(\"c\", false, \"description\");\n        options.addOption(opt);\n\n        assertTrue(options.hasOption(\"c\"));\n        assertFalse(options.hasLongOption(\"c\"));\n        assertEquals(opt, options.getOption(\"c\"));\n    }", "signature": "@Test\n    public void testAddOptionWithoutLongOpt()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionWithDuplicateKey() {\n        Option opt1 = new Option(\"d\", \"date\", false, \"description1\");\n        Option opt2 = new Option(\"d\", \"date\", false, \"description2\");\n        options.addOption(opt1);\n        options.addOption(opt2);\n\n        assertTrue(options.hasOption(\"d\"));\n        assertTrue(options.hasLongOption(\"date\"));\n        assertEquals(opt2, options.getOption(\"d\"));\n        assertEquals(opt2, options.getOption(\"date\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionWithDuplicateKey", "params": [], "body": "                                                {\n        Option opt1 = new Option(\"d\", \"date\", false, \"description1\");\n        Option opt2 = new Option(\"d\", \"date\", false, \"description2\");\n        options.addOption(opt1);\n        options.addOption(opt2);\n\n        assertTrue(options.hasOption(\"d\"));\n        assertTrue(options.hasLongOption(\"date\"));\n        assertEquals(opt2, options.getOption(\"d\"));\n        assertEquals(opt2, options.getOption(\"date\"));\n    }", "signature": "@Test\n    public void testAddOptionWithDuplicateKey()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionWithRequiredAndDuplicateKey() {\n        Option opt1 = new Option(\"e\", \"egg\", false, \"description1\");\n        opt1.setRequired(true);\n        Option opt2 = new Option(\"e\", \"egg\", false, \"description2\");\n        opt2.setRequired(true);\n        options.addOption(opt1);\n        options.addOption(opt2);\n\n        assertTrue(options.hasOption(\"e\"));\n        assertTrue(options.hasLongOption(\"egg\"));\n        assertTrue(options.getRequiredOptions().contains(\"e\"));\n        assertEquals(opt2, options.getOption(\"e\"));\n        assertEquals(opt2, options.getOption(\"egg\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionWithRequiredAndDuplicateKey", "params": [], "body": "                                                           {\n        Option opt1 = new Option(\"e\", \"egg\", false, \"description1\");\n        opt1.setRequired(true);\n        Option opt2 = new Option(\"e\", \"egg\", false, \"description2\");\n        opt2.setRequired(true);\n        options.addOption(opt1);\n        options.addOption(opt2);\n\n        assertTrue(options.hasOption(\"e\"));\n        assertTrue(options.hasLongOption(\"egg\"));\n        assertTrue(options.getRequiredOptions().contains(\"e\"));\n        assertEquals(opt2, options.getOption(\"e\"));\n        assertEquals(opt2, options.getOption(\"egg\"));\n    }", "signature": "@Test\n    public void testAddOptionWithRequiredAndDuplicateKey()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/OptionGroupTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Properties;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class OptionGroupTest {\n    private Options options;\n    private final Parser parser = new PosixParser();\n\n    @BeforeEach\n    public void setUp() {\n        final Option file = new Option(\"f\", \"file\", false, \"file to process\");\n        final Option dir = new Option(\"d\", \"directory\", false, \"directory to process\");\n        final OptionGroup group = new OptionGroup();\n        group.addOption(file);\n        group.addOption(dir);\n        options = new Options().addOptionGroup(group);\n\n        final Option section = new Option(\"s\", \"section\", false, \"section to process\");\n        final Option chapter = new Option(\"c\", \"chapter\", false, \"chapter to process\");\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(section);\n        group2.addOption(chapter);\n\n        options.addOptionGroup(group2);\n\n        final Option importOpt = new Option(null, \"import\", false, \"section to process\");\n        final Option exportOpt = new Option(null, \"export\", false, \"chapter to process\");\n        final OptionGroup group3 = new OptionGroup();\n        group3.addOption(importOpt);\n        group3.addOption(exportOpt);\n        options.addOptionGroup(group3);\n\n        options.addOption(\"r\", \"revision\", false, \"revision number\");\n    }\n\n    @Test\n    public void testGetNames() {\n        final OptionGroup group = new OptionGroup();\n        assertFalse(group.isSelected());\n\n        group.addOption(OptionBuilder.create('a'));\n        group.addOption(OptionBuilder.create('b'));\n\n        assertNotNull(group.getNames(), \"null names\");\n        assertEquals(2, group.getNames().size());\n        assertTrue(group.getNames().contains(\"a\"));\n        assertTrue(group.getNames().contains(\"b\"));\n    }\n\n    @Test\n    public void testNoOptionsExtraArgs() throws Exception {\n        final String[] args = {\"arg1\", \"arg2\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertFalse(cl.hasOption(\"f\"), \"Confirm -f is NOT set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm TWO extra args\");\n    }\n\n    @Test\n    public void testSingleLongOption() throws Exception {\n        final String[] args = {\"--file\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testSingleOption() throws Exception {\n        final String[] args = {\"-r\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertFalse(cl.hasOption(\"f\"), \"Confirm -f is NOT set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testSingleOptionFromGroup() throws Exception {\n        final String[] args = {\"-f\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testToString() {\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(null, \"foo\", false, \"Foo\"));\n        group1.addOption(new Option(null, \"bar\", false, \"Bar\"));\n\n        if (!\"[--bar Bar, --foo Foo]\".equals(group1.toString())) {\n            assertEquals(\"[--foo Foo, --bar Bar]\", group1.toString());\n        }\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"f\", \"foo\", false, \"Foo\"));\n        group2.addOption(new Option(\"b\", \"bar\", false, \"Bar\"));\n\n        if (!\"[-b Bar, -f Foo]\".equals(group2.toString())) {\n            assertEquals(\"[-f Foo, -b Bar]\", group2.toString());\n        }\n    }\n\n    @Test\n    public void testTwoLongOptionsFromGroup() throws Exception {\n        final String[] args = {\"--file\", \"--directory\"};\n\n        try {\n            parser.parse(options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(e.getOptionGroup(), \"null option group\");\n            assertTrue(e.getOptionGroup().isSelected());\n            assertEquals(\"f\", e.getOptionGroup().getSelected(), \"selected option\");\n            assertEquals(\"d\", e.getOption().getOpt(), \"option\");\n        }\n    }\n\n    @Test\n    public void testTwoOptionsFromDifferentGroup() throws Exception {\n        final String[] args = {\"-f\", \"-s\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertTrue(cl.hasOption(\"s\"), \"Confirm -s is set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO extra args\");\n    }\n\n    @Test\n    public void testTwoOptionsFromGroup() throws Exception {\n        final String[] args = {\"-f\", \"-d\"};\n\n        try {\n            parser.parse(options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(e.getOptionGroup(), \"null option group\");\n            assertTrue(e.getOptionGroup().isSelected());\n            assertEquals(\"f\", e.getOptionGroup().getSelected(), \"selected option\");\n            assertEquals(\"d\", e.getOption().getOpt(), \"option\");\n        }\n    }\n\n    @Test\n    public void testTwoOptionsFromGroupWithProperties() throws Exception {\n        final String[] args = {\"-f\"};\n\n        final Properties properties = new Properties();\n        properties.put(\"d\", \"true\");\n\n        final CommandLine cl = parser.parse(options, args, properties);\n        assertTrue(cl.hasOption(\"f\"));\n        assertFalse(cl.hasOption(\"d\"));\n    }\n\n    @Test\n    public void testTwoValidLongOptions() throws Exception {\n        final String[] args = {\"--revision\", \"--file\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testTwoValidOptions() throws Exception {\n        final String[] args = {\"-r\", \"-f\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testValidLongOnlyOptions() throws Exception {\n        final CommandLine cl1 = parser.parse(options, new String[] {\"--export\"});\n        assertTrue(cl1.hasOption(\"export\"), \"Confirm --export is set\");\n\n        final CommandLine cl2 = parser.parse(options, new String[] {\"--import\"});\n        assertTrue(cl2.hasOption(\"import\"), \"Confirm --import is set\");\n    }\n}\n", "file_hash": "b8e6bd666738a87eb14974c51df5595d85b0bed82ff3d80b60f2f083460b5ca7", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import static org.junit.jupiter.api.Assertions.fail;", "import java.util.Properties;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class OptionGroupTest {\n    private Options options;\n    private final Parser parser = new PosixParser();\n\n    @BeforeEach\n    public void setUp() {\n        final Option file = new Option(\"f\", \"file\", false, \"file to process\");\n        final Option dir = new Option(\"d\", \"directory\", false, \"directory to process\");\n        final OptionGroup group = new OptionGroup();\n        group.addOption(file);\n        group.addOption(dir);\n        options = new Options().addOptionGroup(group);\n\n        final Option section = new Option(\"s\", \"section\", false, \"section to process\");\n        final Option chapter = new Option(\"c\", \"chapter\", false, \"chapter to process\");\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(section);\n        group2.addOption(chapter);\n\n        options.addOptionGroup(group2);\n\n        final Option importOpt = new Option(null, \"import\", false, \"section to process\");\n        final Option exportOpt = new Option(null, \"export\", false, \"chapter to process\");\n        final OptionGroup group3 = new OptionGroup();\n        group3.addOption(importOpt);\n        group3.addOption(exportOpt);\n        options.addOptionGroup(group3);\n\n        options.addOption(\"r\", \"revision\", false, \"revision number\");\n    }\n\n    @Test\n    public void testGetNames() {\n        final OptionGroup group = new OptionGroup();\n        assertFalse(group.isSelected());\n\n        group.addOption(OptionBuilder.create('a'));\n        group.addOption(OptionBuilder.create('b'));\n\n        assertNotNull(group.getNames(), \"null names\");\n        assertEquals(2, group.getNames().size());\n        assertTrue(group.getNames().contains(\"a\"));\n        assertTrue(group.getNames().contains(\"b\"));\n    }\n\n    @Test\n    public void testNoOptionsExtraArgs() throws Exception {\n        final String[] args = {\"arg1\", \"arg2\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertFalse(cl.hasOption(\"f\"), \"Confirm -f is NOT set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm TWO extra args\");\n    }\n\n    @Test\n    public void testSingleLongOption() throws Exception {\n        final String[] args = {\"--file\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testSingleOption() throws Exception {\n        final String[] args = {\"-r\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertFalse(cl.hasOption(\"f\"), \"Confirm -f is NOT set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testSingleOptionFromGroup() throws Exception {\n        final String[] args = {\"-f\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testToString() {\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(null, \"foo\", false, \"Foo\"));\n        group1.addOption(new Option(null, \"bar\", false, \"Bar\"));\n\n        if (!\"[--bar Bar, --foo Foo]\".equals(group1.toString())) {\n            assertEquals(\"[--foo Foo, --bar Bar]\", group1.toString());\n        }\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"f\", \"foo\", false, \"Foo\"));\n        group2.addOption(new Option(\"b\", \"bar\", false, \"Bar\"));\n\n        if (!\"[-b Bar, -f Foo]\".equals(group2.toString())) {\n            assertEquals(\"[-f Foo, -b Bar]\", group2.toString());\n        }\n    }\n\n    @Test\n    public void testTwoLongOptionsFromGroup() throws Exception {\n        final String[] args = {\"--file\", \"--directory\"};\n\n        try {\n            parser.parse(options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(e.getOptionGroup(), \"null option group\");\n            assertTrue(e.getOptionGroup().isSelected());\n            assertEquals(\"f\", e.getOptionGroup().getSelected(), \"selected option\");\n            assertEquals(\"d\", e.getOption().getOpt(), \"option\");\n        }\n    }\n\n    @Test\n    public void testTwoOptionsFromDifferentGroup() throws Exception {\n        final String[] args = {\"-f\", \"-s\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertTrue(cl.hasOption(\"s\"), \"Confirm -s is set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO extra args\");\n    }\n\n    @Test\n    public void testTwoOptionsFromGroup() throws Exception {\n        final String[] args = {\"-f\", \"-d\"};\n\n        try {\n            parser.parse(options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(e.getOptionGroup(), \"null option group\");\n            assertTrue(e.getOptionGroup().isSelected());\n            assertEquals(\"f\", e.getOptionGroup().getSelected(), \"selected option\");\n            assertEquals(\"d\", e.getOption().getOpt(), \"option\");\n        }\n    }\n\n    @Test\n    public void testTwoOptionsFromGroupWithProperties() throws Exception {\n        final String[] args = {\"-f\"};\n\n        final Properties properties = new Properties();\n        properties.put(\"d\", \"true\");\n\n        final CommandLine cl = parser.parse(options, args, properties);\n        assertTrue(cl.hasOption(\"f\"));\n        assertFalse(cl.hasOption(\"d\"));\n    }\n\n    @Test\n    public void testTwoValidLongOptions() throws Exception {\n        final String[] args = {\"--revision\", \"--file\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testTwoValidOptions() throws Exception {\n        final String[] args = {\"-r\", \"-f\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testValidLongOnlyOptions() throws Exception {\n        final CommandLine cl1 = parser.parse(options, new String[] {\"--export\"});\n        assertTrue(cl1.hasOption(\"export\"), \"Confirm --export is set\");\n\n        final CommandLine cl2 = parser.parse(options, new String[] {\"--import\"});\n        assertTrue(cl2.hasOption(\"import\"), \"Confirm --import is set\");\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class OptionGroupTest", "class_docstring": "", "name": "OptionGroupTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}, {"attribute_expression": "private final Parser parser = new PosixParser();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Parser", "name": "parser = new PosixParser()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        final Option file = new Option(\"f\", \"file\", false, \"file to process\");\n        final Option dir = new Option(\"d\", \"directory\", false, \"directory to process\");\n        final OptionGroup group = new OptionGroup();\n        group.addOption(file);\n        group.addOption(dir);\n        options = new Options().addOptionGroup(group);\n\n        final Option section = new Option(\"s\", \"section\", false, \"section to process\");\n        final Option chapter = new Option(\"c\", \"chapter\", false, \"chapter to process\");\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(section);\n        group2.addOption(chapter);\n\n        options.addOptionGroup(group2);\n\n        final Option importOpt = new Option(null, \"import\", false, \"section to process\");\n        final Option exportOpt = new Option(null, \"export\", false, \"chapter to process\");\n        final OptionGroup group3 = new OptionGroup();\n        group3.addOption(importOpt);\n        group3.addOption(exportOpt);\n        options.addOptionGroup(group3);\n\n        options.addOption(\"r\", \"revision\", false, \"revision number\");\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        final Option file = new Option(\"f\", \"file\", false, \"file to process\");\n        final Option dir = new Option(\"d\", \"directory\", false, \"directory to process\");\n        final OptionGroup group = new OptionGroup();\n        group.addOption(file);\n        group.addOption(dir);\n        options = new Options().addOptionGroup(group);\n\n        final Option section = new Option(\"s\", \"section\", false, \"section to process\");\n        final Option chapter = new Option(\"c\", \"chapter\", false, \"chapter to process\");\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(section);\n        group2.addOption(chapter);\n\n        options.addOptionGroup(group2);\n\n        final Option importOpt = new Option(null, \"import\", false, \"section to process\");\n        final Option exportOpt = new Option(null, \"export\", false, \"chapter to process\");\n        final OptionGroup group3 = new OptionGroup();\n        group3.addOption(importOpt);\n        group3.addOption(exportOpt);\n        options.addOptionGroup(group3);\n\n        options.addOption(\"r\", \"revision\", false, \"revision number\");\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetNames() {\n        final OptionGroup group = new OptionGroup();\n        assertFalse(group.isSelected());\n\n        group.addOption(OptionBuilder.create('a'));\n        group.addOption(OptionBuilder.create('b'));\n\n        assertNotNull(group.getNames(), \"null names\");\n        assertEquals(2, group.getNames().size());\n        assertTrue(group.getNames().contains(\"a\"));\n        assertTrue(group.getNames().contains(\"b\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetNames", "params": [], "body": "                               {\n        final OptionGroup group = new OptionGroup();\n        assertFalse(group.isSelected());\n\n        group.addOption(OptionBuilder.create('a'));\n        group.addOption(OptionBuilder.create('b'));\n\n        assertNotNull(group.getNames(), \"null names\");\n        assertEquals(2, group.getNames().size());\n        assertTrue(group.getNames().contains(\"a\"));\n        assertTrue(group.getNames().contains(\"b\"));\n    }", "signature": "@Test\n    public void testGetNames()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNoOptionsExtraArgs() throws Exception {\n        final String[] args = {\"arg1\", \"arg2\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertFalse(cl.hasOption(\"f\"), \"Confirm -f is NOT set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm TWO extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNoOptionsExtraArgs", "params": [], "body": "                                                          {\n        final String[] args = {\"arg1\", \"arg2\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertFalse(cl.hasOption(\"f\"), \"Confirm -f is NOT set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm TWO extra args\");\n    }", "signature": "@Test\n    public void testNoOptionsExtraArgs()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSingleLongOption() throws Exception {\n        final String[] args = {\"--file\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSingleLongOption", "params": [], "body": "                                                        {\n        final String[] args = {\"--file\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }", "signature": "@Test\n    public void testSingleLongOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSingleOption() throws Exception {\n        final String[] args = {\"-r\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertFalse(cl.hasOption(\"f\"), \"Confirm -f is NOT set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSingleOption", "params": [], "body": "                                                    {\n        final String[] args = {\"-r\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertFalse(cl.hasOption(\"f\"), \"Confirm -f is NOT set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }", "signature": "@Test\n    public void testSingleOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSingleOptionFromGroup() throws Exception {\n        final String[] args = {\"-f\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSingleOptionFromGroup", "params": [], "body": "                                                             {\n        final String[] args = {\"-f\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }", "signature": "@Test\n    public void testSingleOptionFromGroup()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToString() {\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(null, \"foo\", false, \"Foo\"));\n        group1.addOption(new Option(null, \"bar\", false, \"Bar\"));\n\n        if (!\"[--bar Bar, --foo Foo]\".equals(group1.toString())) {\n            assertEquals(\"[--foo Foo, --bar Bar]\", group1.toString());\n        }\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"f\", \"foo\", false, \"Foo\"));\n        group2.addOption(new Option(\"b\", \"bar\", false, \"Bar\"));\n\n        if (!\"[-b Bar, -f Foo]\".equals(group2.toString())) {\n            assertEquals(\"[-f Foo, -b Bar]\", group2.toString());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToString", "params": [], "body": "                               {\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(null, \"foo\", false, \"Foo\"));\n        group1.addOption(new Option(null, \"bar\", false, \"Bar\"));\n\n        if (!\"[--bar Bar, --foo Foo]\".equals(group1.toString())) {\n            assertEquals(\"[--foo Foo, --bar Bar]\", group1.toString());\n        }\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"f\", \"foo\", false, \"Foo\"));\n        group2.addOption(new Option(\"b\", \"bar\", false, \"Bar\"));\n\n        if (!\"[-b Bar, -f Foo]\".equals(group2.toString())) {\n            assertEquals(\"[-f Foo, -b Bar]\", group2.toString());\n        }\n    }", "signature": "@Test\n    public void testToString()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTwoLongOptionsFromGroup() throws Exception {\n        final String[] args = {\"--file\", \"--directory\"};\n\n        try {\n            parser.parse(options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(e.getOptionGroup(), \"null option group\");\n            assertTrue(e.getOptionGroup().isSelected());\n            assertEquals(\"f\", e.getOptionGroup().getSelected(), \"selected option\");\n            assertEquals(\"d\", e.getOption().getOpt(), \"option\");\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTwoLongOptionsFromGroup", "params": [], "body": "                                                               {\n        final String[] args = {\"--file\", \"--directory\"};\n\n        try {\n            parser.parse(options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(e.getOptionGroup(), \"null option group\");\n            assertTrue(e.getOptionGroup().isSelected());\n            assertEquals(\"f\", e.getOptionGroup().getSelected(), \"selected option\");\n            assertEquals(\"d\", e.getOption().getOpt(), \"option\");\n        }\n    }", "signature": "@Test\n    public void testTwoLongOptionsFromGroup()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTwoOptionsFromDifferentGroup() throws Exception {\n        final String[] args = {\"-f\", \"-s\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertTrue(cl.hasOption(\"s\"), \"Confirm -s is set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTwoOptionsFromDifferentGroup", "params": [], "body": "                                                                    {\n        final String[] args = {\"-f\", \"-s\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertTrue(cl.hasOption(\"s\"), \"Confirm -s is set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO extra args\");\n    }", "signature": "@Test\n    public void testTwoOptionsFromDifferentGroup()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTwoOptionsFromGroup() throws Exception {\n        final String[] args = {\"-f\", \"-d\"};\n\n        try {\n            parser.parse(options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(e.getOptionGroup(), \"null option group\");\n            assertTrue(e.getOptionGroup().isSelected());\n            assertEquals(\"f\", e.getOptionGroup().getSelected(), \"selected option\");\n            assertEquals(\"d\", e.getOption().getOpt(), \"option\");\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTwoOptionsFromGroup", "params": [], "body": "                                                           {\n        final String[] args = {\"-f\", \"-d\"};\n\n        try {\n            parser.parse(options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(e.getOptionGroup(), \"null option group\");\n            assertTrue(e.getOptionGroup().isSelected());\n            assertEquals(\"f\", e.getOptionGroup().getSelected(), \"selected option\");\n            assertEquals(\"d\", e.getOption().getOpt(), \"option\");\n        }\n    }", "signature": "@Test\n    public void testTwoOptionsFromGroup()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTwoOptionsFromGroupWithProperties() throws Exception {\n        final String[] args = {\"-f\"};\n\n        final Properties properties = new Properties();\n        properties.put(\"d\", \"true\");\n\n        final CommandLine cl = parser.parse(options, args, properties);\n        assertTrue(cl.hasOption(\"f\"));\n        assertFalse(cl.hasOption(\"d\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTwoOptionsFromGroupWithProperties", "params": [], "body": "                                                                         {\n        final String[] args = {\"-f\"};\n\n        final Properties properties = new Properties();\n        properties.put(\"d\", \"true\");\n\n        final CommandLine cl = parser.parse(options, args, properties);\n        assertTrue(cl.hasOption(\"f\"));\n        assertFalse(cl.hasOption(\"d\"));\n    }", "signature": "@Test\n    public void testTwoOptionsFromGroupWithProperties()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTwoValidLongOptions() throws Exception {\n        final String[] args = {\"--revision\", \"--file\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTwoValidLongOptions", "params": [], "body": "                                                           {\n        final String[] args = {\"--revision\", \"--file\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }", "signature": "@Test\n    public void testTwoValidLongOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTwoValidOptions() throws Exception {\n        final String[] args = {\"-r\", \"-f\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTwoValidOptions", "params": [], "body": "                                                       {\n        final String[] args = {\"-r\", \"-f\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }", "signature": "@Test\n    public void testTwoValidOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testValidLongOnlyOptions() throws Exception {\n        final CommandLine cl1 = parser.parse(options, new String[] {\"--export\"});\n        assertTrue(cl1.hasOption(\"export\"), \"Confirm --export is set\");\n\n        final CommandLine cl2 = parser.parse(options, new String[] {\"--import\"});\n        assertTrue(cl2.hasOption(\"import\"), \"Confirm --import is set\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testValidLongOnlyOptions", "params": [], "body": "                                                            {\n        final CommandLine cl1 = parser.parse(options, new String[] {\"--export\"});\n        assertTrue(cl1.hasOption(\"export\"), \"Confirm --export is set\");\n\n        final CommandLine cl2 = parser.parse(options, new String[] {\"--import\"});\n        assertTrue(cl2.hasOption(\"import\"), \"Confirm --import is set\");\n    }", "signature": "@Test\n    public void testValidLongOnlyOptions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/CommandLineTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class CommandLineTest {\n\n    private enum Count { ONE, TWO, THREE }\n\n    private static Stream<Arguments> createHasOptionParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        final String[] foobar = { \"foo\", \"bar\" };\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optT, optionGroup, true, true, true, true, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"}, optT, optionGroup, false, false, false, true, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optU, optionGroup, false, false, true, true, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"},  optU, optionGroup, false, true, false, true, optU));\n\n        return lst.stream();\n    }\n\n    private static Stream<Arguments> createOptionValueParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optT, optionGroup, true, \"foo\", true, \"foo\", optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optT, optionGroup, true, \"foo\", true, \"foo\", optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\"}, optT, optionGroup, false, null, false, \"foo\", optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\"}, optT, optionGroup, false, null, false, \"foo\", optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optU, optionGroup, false, null, true, \"foo\", optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optU, optionGroup, false, null, true, \"foo\", optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\"}, optU, optionGroup, false, \"foo\", false, \"foo\", optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\"},  optU, optionGroup, false, \"foo\", false, \"foo\", optU));\n\n        return lst.stream();\n    }\n\n    private static Stream<Arguments> createOptionValuesParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").numberOfArgs(2).deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").numberOfArgs(2).optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        final String[] foobar = { \"foo\", \"bar\" };\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optT, optionGroup, true, foobar, true, foobar, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optT, optionGroup, true, foobar, true, foobar, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optT, optionGroup, false, null, false, foobar, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"}, optT, optionGroup, false, null, false, foobar, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optU, optionGroup, false, null, true, foobar, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optU, optionGroup, false, null, true, foobar, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optU, optionGroup, false, foobar, false, foobar, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"},  optU, optionGroup, false, foobar, false, foobar, optU));\n\n        return lst.stream();\n    }\n\n    private static Stream<Arguments> createParsedOptionValueParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().type(Integer.class).optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").type(Integer.class).optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n        final Integer expected = Integer.valueOf(1);\n\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"1\"}, optT, optionGroup, true, expected, true, expected, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"1\"}, optT, optionGroup, true, expected, true, expected, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"1\"}, optT, optionGroup, false, null, false, expected, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"1\"}, optT, optionGroup, false, null, false, expected, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"1\"}, optU, optionGroup, false, null, true, expected, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"1\"}, optU, optionGroup, false, null, true, expected, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"1\"}, optU, optionGroup, false, expected, false, expected, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"1\"},  optU, optionGroup, false, expected, false, expected, optU));\n\n        return lst.stream();\n    }\n\n    char asChar(final Option opt) {\n        return opt.getOpt().charAt(0);\n    }\n\n    private void assertWritten(final boolean optDep, final ByteArrayOutputStream baos) {\n        System.out.flush();\n        if (optDep) {\n            assertEquals(\"Option 'T''tee': Deprecated\", baos.toString().trim());\n        } else {\n            assertEquals(\"\", baos.toString());\n        }\n        baos.reset();\n    }\n\n    /**\n     * verifies that the deprecation handler has been called only once or not at all.\n     * @param optDep {@code true} if the dependency should have been logged.\n     * @param handler The list that the deprecation is logged to.\n     * @param opt The option that triggered the logging. May be (@code null} if {@code optDep} is {@code false}.\n     */\n    void checkHandler(final boolean optDep, final List<Option> handler, final Option opt) {\n        if (optDep) {\n            assertEquals(1, handler.size());\n            assertEquals(opt, handler.get(0));\n        } else {\n            assertEquals(0, handler.size());\n        }\n        handler.clear();\n    }\n\n    /**\n     * Test for get option values with and without default values.  Verifies that deprecated options only report as\n     * deprecated once.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param optValue  The value expected from opt.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param grpValue the value expected from the group.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parse error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValuesParameters\")\n    public void getOptionValuesTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                    final String[] optValue, final boolean grpDep, final String[] grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt));\n        checkHandler(optDep, handler, opt);\n\n\n        // test OptionGroup arg\n        assertArrayEquals(grpValue, commandLine.getOptionValues(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test not an option\n        assertNull(commandLine.getOptionValues(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        // test other group arg\n        assertNull(commandLine.getOptionValues(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        // test null group arg\n        assertNull(commandLine.getOptionValues(nullGroup));\n        checkHandler(false, handler, grpOpt);\n    }\n\n    /**\n     * Test for get option value with and without default values.  Verifies that deprecated options only report as\n     * deprecated once.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param optValue  The value expected from opt.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param grpValue the value expected from the group.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parse error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public void getOptionValueTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                   final String optValue, final boolean grpDep, final String grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final Supplier<String> thinger = () -> \"thing\";\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option\n        assertEquals(optValue, commandLine.getOptionValue(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test option group  arg\n        assertEquals(grpValue, commandLine.getOptionValue(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, \"thing\"));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, thinger));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other group arg\n        assertNull(commandLine.getOptionValue(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, \"thing\"));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test null Group arg\n        assertNull(commandLine.getOptionValue(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, \"thing\"));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test not an option\n        assertNull(commandLine.getOptionValue(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", \"thing\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", thinger));\n        checkHandler(false, handler, opt);\n    }\n\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createParsedOptionValueParameters\")\n    public void getParsedOptionValueTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                         final Integer optValue, final boolean grpDep, final Integer grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final Supplier<Integer> thinger = () -> 2;\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n        final Integer thing = 2;\n\n        // test char option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(asChar(opt), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(asChar(opt), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getOpt(), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getLongOpt(), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getLongOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n\n        // test Option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt, thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt, thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test OptionGroup arg\n        assertEquals(grpValue, commandLine.getParsedOptionValue(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? thing : grpValue, commandLine.getParsedOptionValue(optionGroup, thing));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? thing : grpValue, commandLine.getParsedOptionValue(optionGroup, thinger));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other Group arg\n        assertNull(commandLine.getParsedOptionValue(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(otherGroup, thing));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(otherGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test null Group arg\n        assertNull(commandLine.getParsedOptionValue(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(nullGroup, thing));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(nullGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n\n        // test not an option\n        assertNull(commandLine.getParsedOptionValue(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(\"Nope\", thing));\n        checkHandler(false, handler, opt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(\"Nope\", thinger));\n        checkHandler(false, handler, opt);\n    }\n\n    /**\n     * Tests the hasOption calls.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param has {@code true} if the opt is present.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param hasGrp {@code true} if the group is present.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parsing error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionNoDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                              final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final CommandLine commandLine = DefaultParser.builder().build().parse(options, args);\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            // test char option arg\n            assertEquals(has, commandLine.hasOption(asChar(opt)));\n            assertWritten(optDep, baos);\n\n\n            // test short option arg\n            assertEquals(has, commandLine.hasOption(opt.getOpt()));\n            assertWritten(optDep, baos);\n\n            // test long option arg\n            assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n            assertWritten(optDep, baos);\n\n            // test Option arg\n            assertEquals(has, commandLine.hasOption(opt));\n            assertWritten(optDep, baos);\n\n            // test OptionGroup arg\n            assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n            assertWritten(grpDep, baos);\n\n            // test not an option\n            assertFalse(commandLine.hasOption(\"Nope\"));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }\n\n    /**\n     * Tests the hasOption calls.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param has {@code true} if the opt is present.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param hasGrp {@code true} if the group is present.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parsing error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionNullDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                                  final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(null).build().parse(options, args);\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            // test char option arg\n            assertEquals(has, commandLine.hasOption(asChar(opt)));\n            assertWritten(false, baos);\n\n\n            // test short option arg\n            assertEquals(has, commandLine.hasOption(opt.getOpt()));\n            assertWritten(false, baos);\n\n            // test long option arg\n            assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n            assertWritten(false, baos);\n\n            // test Option arg\n            assertEquals(has, commandLine.hasOption(opt));\n            assertWritten(false, baos);\n\n            // test OptionGroup arg\n            assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n            assertWritten(false, baos);\n\n            // test not an option\n            assertFalse(commandLine.hasOption(\"Nope\"));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }\n\n    /**\n     * Tests the hasOption calls.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param has {@code true} if the opt is present.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param hasGrp {@code true} if the group is present.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parsing error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                              final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option arg\n        assertEquals(has, commandLine.hasOption(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(has, commandLine.hasOption(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertEquals(has, commandLine.hasOption(opt));\n        checkHandler(optDep, handler, opt);\n\n        // test OptionGroup arg\n        assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other group arg\n        assertFalse(commandLine.hasOption(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n\n        // test null group arg\n        assertFalse(commandLine.hasOption(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        // test not an option\n        assertFalse(commandLine.hasOption(\"Nope\"));\n        checkHandler(false, handler, opt);\n    }\n\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public void noDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                   final String optValue, final boolean grpDep, final String grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final CommandLine commandLine = DefaultParser.builder().build().parse(options, args);\n        final Supplier<String> thinger = () -> \"thing\";\n        final Supplier<String> nullSupplier = null;\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                    .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n            final OptionGroup nullGroup = null;\n\n            // test char option\n            assertEquals(optValue, commandLine.getOptionValue(asChar(opt)));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(asChar(opt), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test short option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt.getOpt()));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt.getOpt(), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test long option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt()));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt(), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test Option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt, nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test optionGroup  arg\n            assertEquals(grpValue, commandLine.getOptionValue(optionGroup));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, \"thing\"));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, thinger));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue, commandLine.getOptionValue(optionGroup, nullSupplier));\n            assertWritten(grpDep, baos);\n\n            // test other group arg\n            assertNull(commandLine.getOptionValue(otherGroup));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(otherGroup, nullSupplier));\n            assertWritten(false, baos);\n\n            // test null Group arg\n            assertNull(commandLine.getOptionValue(nullGroup));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(nullGroup, nullSupplier));\n            assertWritten(false, baos);\n\n            // test not an option\n            assertNull(commandLine.getOptionValue(\"Nope\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(\"Nope\", nullSupplier));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }\n\n    @Test\n    public void testBadGetParsedOptionValue() throws Exception {\n\n        final Options options = new Options();\n        options.addOption(Option.builder(\"i\").hasArg().type(Number.class).build());\n        options.addOption(Option.builder(\"c\").hasArg().converter(s -> Count.valueOf(s.toUpperCase())).build());\n\n\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(options, new String[] {\"-i\", \"foo\", \"-c\", \"bar\"});\n\n        assertEquals(NumberFormatException.class, assertThrows(ParseException.class, () -> cmd.getParsedOptionValue(\"i\")).getCause().getClass());\n        assertEquals(IllegalArgumentException.class, assertThrows(ParseException.class, () -> cmd.getParsedOptionValue(\"c\")).getCause().getClass());\n    }\n\n\n    @Test\n    public void testBuilder() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(\"foo\").addArg(\"bar\");\n        builder.addOption(Option.builder(\"T\").build());\n        final CommandLine cmd = builder.build();\n\n        assertEquals(\"foo\", cmd.getArgs()[0]);\n        assertEquals(\"bar\", cmd.getArgList().get(1));\n        assertEquals(\"T\", cmd.getOptions()[0].getOpt());\n    }\n\n    @Test\n    public void testBuilderNullArgs() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(null).addArg(null);\n        builder.addOption(Option.builder(\"T\").build());\n        final CommandLine cmd = builder.build();\n\n        assertEquals(0, cmd.getArgs().length);\n        assertEquals(\"T\", cmd.getOptions()[0].getOpt());\n    }\n\n    @Test\n    public void testBuilderNullOption() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(\"foo\").addArg(\"bar\");\n        builder.addOption(null);\n        builder.addOption(null);\n        builder.addOption(null);\n        final CommandLine cmd = builder.build();\n\n        assertEquals(\"foo\", cmd.getArgs()[0]);\n        assertEquals(\"bar\", cmd.getArgList().get(1));\n        assertEquals(0, cmd.getOptions().length);\n    }\n\n    @Test\n    public void testGetOptionProperties() throws Exception {\n        final String[] args = {\"-Dparam1=value1\", \"-Dparam2=value2\", \"-Dparam3\", \"-Dparam4=value4\", \"-D\", \"--property\", \"foo=bar\"};\n\n        final Options options = new Options();\n        options.addOption(Option.builder(\"D\").valueSeparator().optionalArg(true).numberOfArgs(2).build());\n        options.addOption(Option.builder().valueSeparator().numberOfArgs(2).longOpt(\"property\").build());\n\n        final Parser parser = new GnuParser();\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(\"D\");\n        assertNotNull(props, \"null properties\");\n        assertEquals(4, props.size(), \"number of properties in \" + props);\n        assertEquals(\"value1\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n        assertEquals(\"true\", props.getProperty(\"param3\"), \"property 3\");\n        assertEquals(\"value4\", props.getProperty(\"param4\"), \"property 4\");\n\n        assertEquals(\"bar\", cl.getOptionProperties(\"property\").getProperty(\"foo\"), \"property with long format\");\n    }\n\n    @Test\n    public void testGetOptionPropertiesWithOption() throws Exception {\n        final String[] args = {\"-Dparam1=value1\", \"-Dparam2=value2\", \"-Dparam3\", \"-Dparam4=value4\", \"-D\", \"--property\", \"foo=bar\"};\n\n        final Options options = new Options();\n        final Option optionD = Option.builder(\"D\").valueSeparator().numberOfArgs(2).optionalArg(true).build();\n        final Option optionProperty = Option.builder().valueSeparator().numberOfArgs(2).longOpt(\"property\").build();\n        options.addOption(optionD);\n        options.addOption(optionProperty);\n\n        final Parser parser = new GnuParser();\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(optionD);\n        assertNotNull(props, \"null properties\");\n        assertEquals(4, props.size(), \"number of properties in \" + props);\n        assertEquals(\"value1\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n        assertEquals(\"true\", props.getProperty(\"param3\"), \"property 3\");\n        assertEquals(\"value4\", props.getProperty(\"param4\"), \"property 4\");\n\n        assertEquals(\"bar\", cl.getOptionProperties(optionProperty).getProperty(\"foo\"), \"property with long format\");\n    }\n\n    @Test\n    public void testGetOptionsBuilder() {\n        final CommandLine cmd = CommandLine.builder().build();\n        assertNotNull(cmd.getOptions());\n        assertEquals(0, cmd.getOptions().length);\n\n        cmd.addOption(null);\n        cmd.addOption(new Option(\"a\", null));\n        cmd.addOption(new Option(\"b\", null));\n        cmd.addOption(new Option(\"c\", null));\n\n        assertEquals(3, cmd.getOptions().length);\n    }\n\n    @Test\n    public void testGetOptionsCtor() {\n        final CommandLine cmd = new CommandLine();\n        assertNotNull(cmd.getOptions());\n        assertEquals(0, cmd.getOptions().length);\n\n        cmd.addOption(new Option(\"a\", null));\n        cmd.addOption(new Option(\"b\", null));\n        cmd.addOption(new Option(\"c\", null));\n        cmd.addOption(null);\n\n        assertEquals(3, cmd.getOptions().length);\n    }\n\n    @Test\n    public void testNullOption() throws Exception {\n        final Options options = new Options();\n        final Option optI = Option.builder(\"i\").hasArg().type(Number.class).build();\n        final Option optF = Option.builder(\"f\").hasArg().build();\n        options.addOption(optI);\n        options.addOption(optF);\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(options, new String[] {\"-i\", \"123\", \"-f\", \"foo\"});\n        assertNull(cmd.getOptionValue((Option) null));\n        assertNull(cmd.getParsedOptionValue((Option) null));\n        assertNull(cmd.getOptionValue((OptionGroup) null));\n        assertNull(cmd.getParsedOptionValue((OptionGroup) null));\n    }\n}\n", "file_hash": "a5e982487dffb75012a45e2ec9b579f6008c26cd8f39bb9bdf6178ff14979dce", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertArrayEquals;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import java.io.ByteArrayOutputStream;", "import java.io.PrintStream;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Properties;", "import java.util.function.Supplier;", "import java.util.stream.Stream;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.provider.Arguments;", "import org.junit.jupiter.params.provider.MethodSource;"], "methods": [], "classes": [{"original_string": "public class CommandLineTest {\n\n    private enum Count { ONE, TWO, THREE }\n\n    private static Stream<Arguments> createHasOptionParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        final String[] foobar = { \"foo\", \"bar\" };\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optT, optionGroup, true, true, true, true, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"}, optT, optionGroup, false, false, false, true, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optU, optionGroup, false, false, true, true, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"},  optU, optionGroup, false, true, false, true, optU));\n\n        return lst.stream();\n    }\n\n    private static Stream<Arguments> createOptionValueParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optT, optionGroup, true, \"foo\", true, \"foo\", optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optT, optionGroup, true, \"foo\", true, \"foo\", optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\"}, optT, optionGroup, false, null, false, \"foo\", optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\"}, optT, optionGroup, false, null, false, \"foo\", optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optU, optionGroup, false, null, true, \"foo\", optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optU, optionGroup, false, null, true, \"foo\", optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\"}, optU, optionGroup, false, \"foo\", false, \"foo\", optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\"},  optU, optionGroup, false, \"foo\", false, \"foo\", optU));\n\n        return lst.stream();\n    }\n\n    private static Stream<Arguments> createOptionValuesParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").numberOfArgs(2).deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").numberOfArgs(2).optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        final String[] foobar = { \"foo\", \"bar\" };\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optT, optionGroup, true, foobar, true, foobar, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optT, optionGroup, true, foobar, true, foobar, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optT, optionGroup, false, null, false, foobar, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"}, optT, optionGroup, false, null, false, foobar, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optU, optionGroup, false, null, true, foobar, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optU, optionGroup, false, null, true, foobar, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optU, optionGroup, false, foobar, false, foobar, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"},  optU, optionGroup, false, foobar, false, foobar, optU));\n\n        return lst.stream();\n    }\n\n    private static Stream<Arguments> createParsedOptionValueParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().type(Integer.class).optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").type(Integer.class).optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n        final Integer expected = Integer.valueOf(1);\n\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"1\"}, optT, optionGroup, true, expected, true, expected, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"1\"}, optT, optionGroup, true, expected, true, expected, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"1\"}, optT, optionGroup, false, null, false, expected, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"1\"}, optT, optionGroup, false, null, false, expected, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"1\"}, optU, optionGroup, false, null, true, expected, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"1\"}, optU, optionGroup, false, null, true, expected, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"1\"}, optU, optionGroup, false, expected, false, expected, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"1\"},  optU, optionGroup, false, expected, false, expected, optU));\n\n        return lst.stream();\n    }\n\n    char asChar(final Option opt) {\n        return opt.getOpt().charAt(0);\n    }\n\n    private void assertWritten(final boolean optDep, final ByteArrayOutputStream baos) {\n        System.out.flush();\n        if (optDep) {\n            assertEquals(\"Option 'T''tee': Deprecated\", baos.toString().trim());\n        } else {\n            assertEquals(\"\", baos.toString());\n        }\n        baos.reset();\n    }\n\n    /**\n     * verifies that the deprecation handler has been called only once or not at all.\n     * @param optDep {@code true} if the dependency should have been logged.\n     * @param handler The list that the deprecation is logged to.\n     * @param opt The option that triggered the logging. May be (@code null} if {@code optDep} is {@code false}.\n     */\n    void checkHandler(final boolean optDep, final List<Option> handler, final Option opt) {\n        if (optDep) {\n            assertEquals(1, handler.size());\n            assertEquals(opt, handler.get(0));\n        } else {\n            assertEquals(0, handler.size());\n        }\n        handler.clear();\n    }\n\n    /**\n     * Test for get option values with and without default values.  Verifies that deprecated options only report as\n     * deprecated once.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param optValue  The value expected from opt.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param grpValue the value expected from the group.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parse error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValuesParameters\")\n    public void getOptionValuesTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                    final String[] optValue, final boolean grpDep, final String[] grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt));\n        checkHandler(optDep, handler, opt);\n\n\n        // test OptionGroup arg\n        assertArrayEquals(grpValue, commandLine.getOptionValues(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test not an option\n        assertNull(commandLine.getOptionValues(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        // test other group arg\n        assertNull(commandLine.getOptionValues(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        // test null group arg\n        assertNull(commandLine.getOptionValues(nullGroup));\n        checkHandler(false, handler, grpOpt);\n    }\n\n    /**\n     * Test for get option value with and without default values.  Verifies that deprecated options only report as\n     * deprecated once.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param optValue  The value expected from opt.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param grpValue the value expected from the group.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parse error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public void getOptionValueTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                   final String optValue, final boolean grpDep, final String grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final Supplier<String> thinger = () -> \"thing\";\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option\n        assertEquals(optValue, commandLine.getOptionValue(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test option group  arg\n        assertEquals(grpValue, commandLine.getOptionValue(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, \"thing\"));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, thinger));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other group arg\n        assertNull(commandLine.getOptionValue(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, \"thing\"));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test null Group arg\n        assertNull(commandLine.getOptionValue(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, \"thing\"));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test not an option\n        assertNull(commandLine.getOptionValue(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", \"thing\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", thinger));\n        checkHandler(false, handler, opt);\n    }\n\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createParsedOptionValueParameters\")\n    public void getParsedOptionValueTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                         final Integer optValue, final boolean grpDep, final Integer grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final Supplier<Integer> thinger = () -> 2;\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n        final Integer thing = 2;\n\n        // test char option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(asChar(opt), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(asChar(opt), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getOpt(), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getLongOpt(), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getLongOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n\n        // test Option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt, thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt, thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test OptionGroup arg\n        assertEquals(grpValue, commandLine.getParsedOptionValue(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? thing : grpValue, commandLine.getParsedOptionValue(optionGroup, thing));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? thing : grpValue, commandLine.getParsedOptionValue(optionGroup, thinger));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other Group arg\n        assertNull(commandLine.getParsedOptionValue(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(otherGroup, thing));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(otherGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test null Group arg\n        assertNull(commandLine.getParsedOptionValue(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(nullGroup, thing));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(nullGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n\n        // test not an option\n        assertNull(commandLine.getParsedOptionValue(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(\"Nope\", thing));\n        checkHandler(false, handler, opt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(\"Nope\", thinger));\n        checkHandler(false, handler, opt);\n    }\n\n    /**\n     * Tests the hasOption calls.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param has {@code true} if the opt is present.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param hasGrp {@code true} if the group is present.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parsing error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionNoDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                              final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final CommandLine commandLine = DefaultParser.builder().build().parse(options, args);\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            // test char option arg\n            assertEquals(has, commandLine.hasOption(asChar(opt)));\n            assertWritten(optDep, baos);\n\n\n            // test short option arg\n            assertEquals(has, commandLine.hasOption(opt.getOpt()));\n            assertWritten(optDep, baos);\n\n            // test long option arg\n            assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n            assertWritten(optDep, baos);\n\n            // test Option arg\n            assertEquals(has, commandLine.hasOption(opt));\n            assertWritten(optDep, baos);\n\n            // test OptionGroup arg\n            assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n            assertWritten(grpDep, baos);\n\n            // test not an option\n            assertFalse(commandLine.hasOption(\"Nope\"));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }\n\n    /**\n     * Tests the hasOption calls.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param has {@code true} if the opt is present.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param hasGrp {@code true} if the group is present.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parsing error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionNullDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                                  final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(null).build().parse(options, args);\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            // test char option arg\n            assertEquals(has, commandLine.hasOption(asChar(opt)));\n            assertWritten(false, baos);\n\n\n            // test short option arg\n            assertEquals(has, commandLine.hasOption(opt.getOpt()));\n            assertWritten(false, baos);\n\n            // test long option arg\n            assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n            assertWritten(false, baos);\n\n            // test Option arg\n            assertEquals(has, commandLine.hasOption(opt));\n            assertWritten(false, baos);\n\n            // test OptionGroup arg\n            assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n            assertWritten(false, baos);\n\n            // test not an option\n            assertFalse(commandLine.hasOption(\"Nope\"));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }\n\n    /**\n     * Tests the hasOption calls.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param has {@code true} if the opt is present.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param hasGrp {@code true} if the group is present.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parsing error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                              final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option arg\n        assertEquals(has, commandLine.hasOption(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(has, commandLine.hasOption(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertEquals(has, commandLine.hasOption(opt));\n        checkHandler(optDep, handler, opt);\n\n        // test OptionGroup arg\n        assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other group arg\n        assertFalse(commandLine.hasOption(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n\n        // test null group arg\n        assertFalse(commandLine.hasOption(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        // test not an option\n        assertFalse(commandLine.hasOption(\"Nope\"));\n        checkHandler(false, handler, opt);\n    }\n\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public void noDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                   final String optValue, final boolean grpDep, final String grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final CommandLine commandLine = DefaultParser.builder().build().parse(options, args);\n        final Supplier<String> thinger = () -> \"thing\";\n        final Supplier<String> nullSupplier = null;\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                    .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n            final OptionGroup nullGroup = null;\n\n            // test char option\n            assertEquals(optValue, commandLine.getOptionValue(asChar(opt)));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(asChar(opt), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test short option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt.getOpt()));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt.getOpt(), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test long option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt()));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt(), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test Option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt, nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test optionGroup  arg\n            assertEquals(grpValue, commandLine.getOptionValue(optionGroup));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, \"thing\"));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, thinger));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue, commandLine.getOptionValue(optionGroup, nullSupplier));\n            assertWritten(grpDep, baos);\n\n            // test other group arg\n            assertNull(commandLine.getOptionValue(otherGroup));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(otherGroup, nullSupplier));\n            assertWritten(false, baos);\n\n            // test null Group arg\n            assertNull(commandLine.getOptionValue(nullGroup));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(nullGroup, nullSupplier));\n            assertWritten(false, baos);\n\n            // test not an option\n            assertNull(commandLine.getOptionValue(\"Nope\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(\"Nope\", nullSupplier));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }\n\n    @Test\n    public void testBadGetParsedOptionValue() throws Exception {\n\n        final Options options = new Options();\n        options.addOption(Option.builder(\"i\").hasArg().type(Number.class).build());\n        options.addOption(Option.builder(\"c\").hasArg().converter(s -> Count.valueOf(s.toUpperCase())).build());\n\n\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(options, new String[] {\"-i\", \"foo\", \"-c\", \"bar\"});\n\n        assertEquals(NumberFormatException.class, assertThrows(ParseException.class, () -> cmd.getParsedOptionValue(\"i\")).getCause().getClass());\n        assertEquals(IllegalArgumentException.class, assertThrows(ParseException.class, () -> cmd.getParsedOptionValue(\"c\")).getCause().getClass());\n    }\n\n\n    @Test\n    public void testBuilder() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(\"foo\").addArg(\"bar\");\n        builder.addOption(Option.builder(\"T\").build());\n        final CommandLine cmd = builder.build();\n\n        assertEquals(\"foo\", cmd.getArgs()[0]);\n        assertEquals(\"bar\", cmd.getArgList().get(1));\n        assertEquals(\"T\", cmd.getOptions()[0].getOpt());\n    }\n\n    @Test\n    public void testBuilderNullArgs() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(null).addArg(null);\n        builder.addOption(Option.builder(\"T\").build());\n        final CommandLine cmd = builder.build();\n\n        assertEquals(0, cmd.getArgs().length);\n        assertEquals(\"T\", cmd.getOptions()[0].getOpt());\n    }\n\n    @Test\n    public void testBuilderNullOption() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(\"foo\").addArg(\"bar\");\n        builder.addOption(null);\n        builder.addOption(null);\n        builder.addOption(null);\n        final CommandLine cmd = builder.build();\n\n        assertEquals(\"foo\", cmd.getArgs()[0]);\n        assertEquals(\"bar\", cmd.getArgList().get(1));\n        assertEquals(0, cmd.getOptions().length);\n    }\n\n    @Test\n    public void testGetOptionProperties() throws Exception {\n        final String[] args = {\"-Dparam1=value1\", \"-Dparam2=value2\", \"-Dparam3\", \"-Dparam4=value4\", \"-D\", \"--property\", \"foo=bar\"};\n\n        final Options options = new Options();\n        options.addOption(Option.builder(\"D\").valueSeparator().optionalArg(true).numberOfArgs(2).build());\n        options.addOption(Option.builder().valueSeparator().numberOfArgs(2).longOpt(\"property\").build());\n\n        final Parser parser = new GnuParser();\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(\"D\");\n        assertNotNull(props, \"null properties\");\n        assertEquals(4, props.size(), \"number of properties in \" + props);\n        assertEquals(\"value1\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n        assertEquals(\"true\", props.getProperty(\"param3\"), \"property 3\");\n        assertEquals(\"value4\", props.getProperty(\"param4\"), \"property 4\");\n\n        assertEquals(\"bar\", cl.getOptionProperties(\"property\").getProperty(\"foo\"), \"property with long format\");\n    }\n\n    @Test\n    public void testGetOptionPropertiesWithOption() throws Exception {\n        final String[] args = {\"-Dparam1=value1\", \"-Dparam2=value2\", \"-Dparam3\", \"-Dparam4=value4\", \"-D\", \"--property\", \"foo=bar\"};\n\n        final Options options = new Options();\n        final Option optionD = Option.builder(\"D\").valueSeparator().numberOfArgs(2).optionalArg(true).build();\n        final Option optionProperty = Option.builder().valueSeparator().numberOfArgs(2).longOpt(\"property\").build();\n        options.addOption(optionD);\n        options.addOption(optionProperty);\n\n        final Parser parser = new GnuParser();\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(optionD);\n        assertNotNull(props, \"null properties\");\n        assertEquals(4, props.size(), \"number of properties in \" + props);\n        assertEquals(\"value1\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n        assertEquals(\"true\", props.getProperty(\"param3\"), \"property 3\");\n        assertEquals(\"value4\", props.getProperty(\"param4\"), \"property 4\");\n\n        assertEquals(\"bar\", cl.getOptionProperties(optionProperty).getProperty(\"foo\"), \"property with long format\");\n    }\n\n    @Test\n    public void testGetOptionsBuilder() {\n        final CommandLine cmd = CommandLine.builder().build();\n        assertNotNull(cmd.getOptions());\n        assertEquals(0, cmd.getOptions().length);\n\n        cmd.addOption(null);\n        cmd.addOption(new Option(\"a\", null));\n        cmd.addOption(new Option(\"b\", null));\n        cmd.addOption(new Option(\"c\", null));\n\n        assertEquals(3, cmd.getOptions().length);\n    }\n\n    @Test\n    public void testGetOptionsCtor() {\n        final CommandLine cmd = new CommandLine();\n        assertNotNull(cmd.getOptions());\n        assertEquals(0, cmd.getOptions().length);\n\n        cmd.addOption(new Option(\"a\", null));\n        cmd.addOption(new Option(\"b\", null));\n        cmd.addOption(new Option(\"c\", null));\n        cmd.addOption(null);\n\n        assertEquals(3, cmd.getOptions().length);\n    }\n\n    @Test\n    public void testNullOption() throws Exception {\n        final Options options = new Options();\n        final Option optI = Option.builder(\"i\").hasArg().type(Number.class).build();\n        final Option optF = Option.builder(\"f\").hasArg().build();\n        options.addOption(optI);\n        options.addOption(optF);\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(options, new String[] {\"-i\", \"123\", \"-f\", \"foo\"});\n        assertNull(cmd.getOptionValue((Option) null));\n        assertNull(cmd.getParsedOptionValue((Option) null));\n        assertNull(cmd.getOptionValue((OptionGroup) null));\n        assertNull(cmd.getParsedOptionValue((OptionGroup) null));\n    }\n}", "definition": "public class CommandLineTest", "class_docstring": "", "name": "CommandLineTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static Stream<Arguments> createHasOptionParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        final String[] foobar = { \"foo\", \"bar\" };\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optT, optionGroup, true, true, true, true, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"}, optT, optionGroup, false, false, false, true, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optU, optionGroup, false, false, true, true, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"},  optU, optionGroup, false, true, false, true, optU));\n\n        return lst.stream();\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Stream<Arguments>", "classes": []}, "name": "createHasOptionParameters", "params": [], "body": "                                                                                       {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        final String[] foobar = { \"foo\", \"bar\" };\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optT, optionGroup, true, true, true, true, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"}, optT, optionGroup, false, false, false, true, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optU, optionGroup, false, false, true, true, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"},  optU, optionGroup, false, true, false, true, optU));\n\n        return lst.stream();\n    }", "signature": "private static Stream<Arguments> createHasOptionParameters()"}, {"syntax_pass": true, "original_string": "    private static Stream<Arguments> createOptionValueParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optT, optionGroup, true, \"foo\", true, \"foo\", optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optT, optionGroup, true, \"foo\", true, \"foo\", optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\"}, optT, optionGroup, false, null, false, \"foo\", optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\"}, optT, optionGroup, false, null, false, \"foo\", optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optU, optionGroup, false, null, true, \"foo\", optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optU, optionGroup, false, null, true, \"foo\", optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\"}, optU, optionGroup, false, \"foo\", false, \"foo\", optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\"},  optU, optionGroup, false, \"foo\", false, \"foo\", optU));\n\n        return lst.stream();\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Stream<Arguments>", "classes": []}, "name": "createOptionValueParameters", "params": [], "body": "                                                                                         {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optT, optionGroup, true, \"foo\", true, \"foo\", optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optT, optionGroup, true, \"foo\", true, \"foo\", optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\"}, optT, optionGroup, false, null, false, \"foo\", optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\"}, optT, optionGroup, false, null, false, \"foo\", optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optU, optionGroup, false, null, true, \"foo\", optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optU, optionGroup, false, null, true, \"foo\", optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\"}, optU, optionGroup, false, \"foo\", false, \"foo\", optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\"},  optU, optionGroup, false, \"foo\", false, \"foo\", optU));\n\n        return lst.stream();\n    }", "signature": "private static Stream<Arguments> createOptionValueParameters()"}, {"syntax_pass": true, "original_string": "    private static Stream<Arguments> createOptionValuesParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").numberOfArgs(2).deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").numberOfArgs(2).optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        final String[] foobar = { \"foo\", \"bar\" };\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optT, optionGroup, true, foobar, true, foobar, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optT, optionGroup, true, foobar, true, foobar, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optT, optionGroup, false, null, false, foobar, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"}, optT, optionGroup, false, null, false, foobar, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optU, optionGroup, false, null, true, foobar, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optU, optionGroup, false, null, true, foobar, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optU, optionGroup, false, foobar, false, foobar, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"},  optU, optionGroup, false, foobar, false, foobar, optU));\n\n        return lst.stream();\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Stream<Arguments>", "classes": []}, "name": "createOptionValuesParameters", "params": [], "body": "                                                                                          {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").numberOfArgs(2).deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").numberOfArgs(2).optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        final String[] foobar = { \"foo\", \"bar\" };\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optT, optionGroup, true, foobar, true, foobar, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optT, optionGroup, true, foobar, true, foobar, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optT, optionGroup, false, null, false, foobar, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"}, optT, optionGroup, false, null, false, foobar, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optU, optionGroup, false, null, true, foobar, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optU, optionGroup, false, null, true, foobar, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optU, optionGroup, false, foobar, false, foobar, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"},  optU, optionGroup, false, foobar, false, foobar, optU));\n\n        return lst.stream();\n    }", "signature": "private static Stream<Arguments> createOptionValuesParameters()"}, {"syntax_pass": true, "original_string": "    private static Stream<Arguments> createParsedOptionValueParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().type(Integer.class).optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").type(Integer.class).optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n        final Integer expected = Integer.valueOf(1);\n\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"1\"}, optT, optionGroup, true, expected, true, expected, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"1\"}, optT, optionGroup, true, expected, true, expected, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"1\"}, optT, optionGroup, false, null, false, expected, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"1\"}, optT, optionGroup, false, null, false, expected, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"1\"}, optU, optionGroup, false, null, true, expected, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"1\"}, optU, optionGroup, false, null, true, expected, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"1\"}, optU, optionGroup, false, expected, false, expected, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"1\"},  optU, optionGroup, false, expected, false, expected, optU));\n\n        return lst.stream();\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Stream<Arguments>", "classes": []}, "name": "createParsedOptionValueParameters", "params": [], "body": "                                                                                               {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().type(Integer.class).optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").type(Integer.class).optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n        final Integer expected = Integer.valueOf(1);\n\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"1\"}, optT, optionGroup, true, expected, true, expected, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"1\"}, optT, optionGroup, true, expected, true, expected, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"1\"}, optT, optionGroup, false, null, false, expected, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"1\"}, optT, optionGroup, false, null, false, expected, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"1\"}, optU, optionGroup, false, null, true, expected, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"1\"}, optU, optionGroup, false, null, true, expected, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"1\"}, optU, optionGroup, false, expected, false, expected, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"1\"},  optU, optionGroup, false, expected, false, expected, optU));\n\n        return lst.stream();\n    }", "signature": "private static Stream<Arguments> createParsedOptionValueParameters()"}, {"syntax_pass": true, "original_string": "    char asChar(final Option opt) {\n        return opt.getOpt().charAt(0);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "char", "classes": []}, "name": "asChar", "params": [{"name": "opt", "type": "Option"}], "body": "                                  {\n        return opt.getOpt().charAt(0);\n    }", "signature": "char asChar(final Option opt)"}, {"syntax_pass": true, "original_string": "    private void assertWritten(final boolean optDep, final ByteArrayOutputStream baos) {\n        System.out.flush();\n        if (optDep) {\n            assertEquals(\"Option 'T''tee': Deprecated\", baos.toString().trim());\n        } else {\n            assertEquals(\"\", baos.toString());\n        }\n        baos.reset();\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertWritten", "params": [{"name": "optDep", "type": "boolean"}, {"name": "baos", "type": "ByteArrayOutputStream"}], "body": "                                                                                       {\n        System.out.flush();\n        if (optDep) {\n            assertEquals(\"Option 'T''tee': Deprecated\", baos.toString().trim());\n        } else {\n            assertEquals(\"\", baos.toString());\n        }\n        baos.reset();\n    }", "signature": "private void assertWritten(final boolean optDep, final ByteArrayOutputStream baos)"}, {"syntax_pass": true, "original_string": "    void checkHandler(final boolean optDep, final List<Option> handler, final Option opt) {\n        if (optDep) {\n            assertEquals(1, handler.size());\n            assertEquals(opt, handler.get(0));\n        } else {\n            assertEquals(0, handler.size());\n        }\n        handler.clear();\n    }", "docstring": "\nverifies that the deprecation handler has been called only once or not at all.\n@param optDep {@code true} if the dependency should have been logged.\n@param handler The list that the deprecation is logged to.\n@param opt The option that triggered the logging. May be (@code null} if {@code optDep} is {@code false}.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "checkHandler", "params": [{"name": "optDep", "type": "boolean"}, {"name": "handler", "type": "List<Option>"}, {"name": "opt", "type": "Option"}], "body": "                                                                                          {\n        if (optDep) {\n            assertEquals(1, handler.size());\n            assertEquals(opt, handler.get(0));\n        } else {\n            assertEquals(0, handler.size());\n        }\n        handler.clear();\n    }", "signature": "void checkHandler(final boolean optDep, final List<Option> handler, final Option opt)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValuesParameters\")\n    public void getOptionValuesTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                    final String[] optValue, final boolean grpDep, final String[] grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt));\n        checkHandler(optDep, handler, opt);\n\n\n        // test OptionGroup arg\n        assertArrayEquals(grpValue, commandLine.getOptionValues(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test not an option\n        assertNull(commandLine.getOptionValues(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        // test other group arg\n        assertNull(commandLine.getOptionValues(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        // test null group arg\n        assertNull(commandLine.getOptionValues(nullGroup));\n        checkHandler(false, handler, grpOpt);\n    }", "docstring": "\nTest for get option values with and without default values.  Verifies that deprecated options only report as\ndeprecated once.\n@param args the argument strings to parse.\n@param opt the option to check for values with.\n@param optionGroup the option group to check for values with.\n@param optDep {@code true} if the opt is deprecated.\n@param optValue  The value expected from opt.\n@param grpDep {@code true} if the group is deprecated.\n@param grpValue the value expected from the group.\n@param grpOpt the option that is expected to be processed by the group.\n@throws ParseException on parse error.\n", "attributes": {"modifiers": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValuesParameters\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@ParameterizedTest(name = \"{0}, {1}\")", "@MethodSource(\"createOptionValuesParameters\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "getOptionValuesTest", "params": [{"name": "args", "type": "String[]"}, {"name": "opt", "type": "Option"}, {"name": "optionGroup", "type": "OptionGroup"}, {"name": "optDep", "type": "boolean"}, {"name": "optValue", "type": "String[]"}, {"name": "grpDep", "type": "boolean"}, {"name": "grpValue", "type": "String[]"}, {"name": "grpOpt", "type": "Option"}], "body": "                                                                                                                                                       {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt));\n        checkHandler(optDep, handler, opt);\n\n\n        // test OptionGroup arg\n        assertArrayEquals(grpValue, commandLine.getOptionValues(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test not an option\n        assertNull(commandLine.getOptionValues(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        // test other group arg\n        assertNull(commandLine.getOptionValues(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        // test null group arg\n        assertNull(commandLine.getOptionValues(nullGroup));\n        checkHandler(false, handler, grpOpt);\n    }", "signature": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValuesParameters\")\n    public void getOptionValuesTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                    final String[] optValue, final boolean grpDep, final String[] grpValue, final Option grpOpt)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public void getOptionValueTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                   final String optValue, final boolean grpDep, final String grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final Supplier<String> thinger = () -> \"thing\";\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option\n        assertEquals(optValue, commandLine.getOptionValue(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test option group  arg\n        assertEquals(grpValue, commandLine.getOptionValue(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, \"thing\"));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, thinger));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other group arg\n        assertNull(commandLine.getOptionValue(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, \"thing\"));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test null Group arg\n        assertNull(commandLine.getOptionValue(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, \"thing\"));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test not an option\n        assertNull(commandLine.getOptionValue(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", \"thing\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", thinger));\n        checkHandler(false, handler, opt);\n    }", "docstring": "\nTest for get option value with and without default values.  Verifies that deprecated options only report as\ndeprecated once.\n@param args the argument strings to parse.\n@param opt the option to check for values with.\n@param optionGroup the option group to check for values with.\n@param optDep {@code true} if the opt is deprecated.\n@param optValue  The value expected from opt.\n@param grpDep {@code true} if the group is deprecated.\n@param grpValue the value expected from the group.\n@param grpOpt the option that is expected to be processed by the group.\n@throws ParseException on parse error.\n", "attributes": {"modifiers": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@ParameterizedTest(name = \"{0}, {1}\")", "@MethodSource(\"createOptionValueParameters\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "getOptionValueTest", "params": [{"name": "args", "type": "String[]"}, {"name": "opt", "type": "Option"}, {"name": "optionGroup", "type": "OptionGroup"}, {"name": "optDep", "type": "boolean"}, {"name": "optValue", "type": "String"}, {"name": "grpDep", "type": "boolean"}, {"name": "grpValue", "type": "String"}, {"name": "grpOpt", "type": "Option"}], "body": "                                                                                                                                                  {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final Supplier<String> thinger = () -> \"thing\";\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option\n        assertEquals(optValue, commandLine.getOptionValue(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test option group  arg\n        assertEquals(grpValue, commandLine.getOptionValue(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, \"thing\"));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, thinger));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other group arg\n        assertNull(commandLine.getOptionValue(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, \"thing\"));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test null Group arg\n        assertNull(commandLine.getOptionValue(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, \"thing\"));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test not an option\n        assertNull(commandLine.getOptionValue(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", \"thing\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", thinger));\n        checkHandler(false, handler, opt);\n    }", "signature": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public void getOptionValueTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                   final String optValue, final boolean grpDep, final String grpValue, final Option grpOpt)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createParsedOptionValueParameters\")\n    public void getParsedOptionValueTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                         final Integer optValue, final boolean grpDep, final Integer grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final Supplier<Integer> thinger = () -> 2;\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n        final Integer thing = 2;\n\n        // test char option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(asChar(opt), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(asChar(opt), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getOpt(), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getLongOpt(), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getLongOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n\n        // test Option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt, thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt, thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test OptionGroup arg\n        assertEquals(grpValue, commandLine.getParsedOptionValue(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? thing : grpValue, commandLine.getParsedOptionValue(optionGroup, thing));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? thing : grpValue, commandLine.getParsedOptionValue(optionGroup, thinger));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other Group arg\n        assertNull(commandLine.getParsedOptionValue(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(otherGroup, thing));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(otherGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test null Group arg\n        assertNull(commandLine.getParsedOptionValue(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(nullGroup, thing));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(nullGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n\n        // test not an option\n        assertNull(commandLine.getParsedOptionValue(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(\"Nope\", thing));\n        checkHandler(false, handler, opt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(\"Nope\", thinger));\n        checkHandler(false, handler, opt);\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createParsedOptionValueParameters\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@ParameterizedTest(name = \"{0}, {1}\")", "@MethodSource(\"createParsedOptionValueParameters\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "getParsedOptionValueTest", "params": [{"name": "args", "type": "String[]"}, {"name": "opt", "type": "Option"}, {"name": "optionGroup", "type": "OptionGroup"}, {"name": "optDep", "type": "boolean"}, {"name": "optValue", "type": "Integer"}, {"name": "grpDep", "type": "boolean"}, {"name": "grpValue", "type": "Integer"}, {"name": "grpOpt", "type": "Option"}], "body": "                                                                                                                                                          {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final Supplier<Integer> thinger = () -> 2;\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n        final Integer thing = 2;\n\n        // test char option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(asChar(opt), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(asChar(opt), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getOpt(), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getLongOpt(), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getLongOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n\n        // test Option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt, thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt, thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test OptionGroup arg\n        assertEquals(grpValue, commandLine.getParsedOptionValue(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? thing : grpValue, commandLine.getParsedOptionValue(optionGroup, thing));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? thing : grpValue, commandLine.getParsedOptionValue(optionGroup, thinger));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other Group arg\n        assertNull(commandLine.getParsedOptionValue(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(otherGroup, thing));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(otherGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test null Group arg\n        assertNull(commandLine.getParsedOptionValue(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(nullGroup, thing));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(nullGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n\n        // test not an option\n        assertNull(commandLine.getParsedOptionValue(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(\"Nope\", thing));\n        checkHandler(false, handler, opt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(\"Nope\", thinger));\n        checkHandler(false, handler, opt);\n    }", "signature": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createParsedOptionValueParameters\")\n    public void getParsedOptionValueTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                         final Integer optValue, final boolean grpDep, final Integer grpValue, final Option grpOpt)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionNoDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                              final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final CommandLine commandLine = DefaultParser.builder().build().parse(options, args);\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            // test char option arg\n            assertEquals(has, commandLine.hasOption(asChar(opt)));\n            assertWritten(optDep, baos);\n\n\n            // test short option arg\n            assertEquals(has, commandLine.hasOption(opt.getOpt()));\n            assertWritten(optDep, baos);\n\n            // test long option arg\n            assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n            assertWritten(optDep, baos);\n\n            // test Option arg\n            assertEquals(has, commandLine.hasOption(opt));\n            assertWritten(optDep, baos);\n\n            // test OptionGroup arg\n            assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n            assertWritten(grpDep, baos);\n\n            // test not an option\n            assertFalse(commandLine.hasOption(\"Nope\"));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }", "docstring": "\nTests the hasOption calls.\n@param args the argument strings to parse.\n@param opt the option to check for values with.\n@param optionGroup the option group to check for values with.\n@param optDep {@code true} if the opt is deprecated.\n@param has {@code true} if the opt is present.\n@param grpDep {@code true} if the group is deprecated.\n@param hasGrp {@code true} if the group is present.\n@param grpOpt the option that is expected to be processed by the group.\n@throws ParseException on parsing error.\n", "attributes": {"modifiers": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@ParameterizedTest(name = \"{0}, {1}\")", "@MethodSource(\"createHasOptionParameters\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "hasOptionNoDeprecationHandlerTest", "params": [{"name": "args", "type": "String[]"}, {"name": "opt", "type": "Option"}, {"name": "optionGroup", "type": "OptionGroup"}, {"name": "optDep", "type": "boolean"}, {"name": "has", "type": "boolean"}, {"name": "grpDep", "type": "boolean"}, {"name": "hasGrp", "type": "boolean"}, {"name": "grpOpt", "type": "Option"}], "body": "                                                                                                                                        {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final CommandLine commandLine = DefaultParser.builder().build().parse(options, args);\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            // test char option arg\n            assertEquals(has, commandLine.hasOption(asChar(opt)));\n            assertWritten(optDep, baos);\n\n\n            // test short option arg\n            assertEquals(has, commandLine.hasOption(opt.getOpt()));\n            assertWritten(optDep, baos);\n\n            // test long option arg\n            assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n            assertWritten(optDep, baos);\n\n            // test Option arg\n            assertEquals(has, commandLine.hasOption(opt));\n            assertWritten(optDep, baos);\n\n            // test OptionGroup arg\n            assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n            assertWritten(grpDep, baos);\n\n            // test not an option\n            assertFalse(commandLine.hasOption(\"Nope\"));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }", "signature": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionNoDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                              final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionNullDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                                  final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(null).build().parse(options, args);\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            // test char option arg\n            assertEquals(has, commandLine.hasOption(asChar(opt)));\n            assertWritten(false, baos);\n\n\n            // test short option arg\n            assertEquals(has, commandLine.hasOption(opt.getOpt()));\n            assertWritten(false, baos);\n\n            // test long option arg\n            assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n            assertWritten(false, baos);\n\n            // test Option arg\n            assertEquals(has, commandLine.hasOption(opt));\n            assertWritten(false, baos);\n\n            // test OptionGroup arg\n            assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n            assertWritten(false, baos);\n\n            // test not an option\n            assertFalse(commandLine.hasOption(\"Nope\"));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }", "docstring": "\nTests the hasOption calls.\n@param args the argument strings to parse.\n@param opt the option to check for values with.\n@param optionGroup the option group to check for values with.\n@param optDep {@code true} if the opt is deprecated.\n@param has {@code true} if the opt is present.\n@param grpDep {@code true} if the group is deprecated.\n@param hasGrp {@code true} if the group is present.\n@param grpOpt the option that is expected to be processed by the group.\n@throws ParseException on parsing error.\n", "attributes": {"modifiers": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@ParameterizedTest(name = \"{0}, {1}\")", "@MethodSource(\"createHasOptionParameters\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "hasOptionNullDeprecationHandlerTest", "params": [{"name": "args", "type": "String[]"}, {"name": "opt", "type": "Option"}, {"name": "optionGroup", "type": "OptionGroup"}, {"name": "optDep", "type": "boolean"}, {"name": "has", "type": "boolean"}, {"name": "grpDep", "type": "boolean"}, {"name": "hasGrp", "type": "boolean"}, {"name": "grpOpt", "type": "Option"}], "body": "                                                                                                                                                            {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(null).build().parse(options, args);\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            // test char option arg\n            assertEquals(has, commandLine.hasOption(asChar(opt)));\n            assertWritten(false, baos);\n\n\n            // test short option arg\n            assertEquals(has, commandLine.hasOption(opt.getOpt()));\n            assertWritten(false, baos);\n\n            // test long option arg\n            assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n            assertWritten(false, baos);\n\n            // test Option arg\n            assertEquals(has, commandLine.hasOption(opt));\n            assertWritten(false, baos);\n\n            // test OptionGroup arg\n            assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n            assertWritten(false, baos);\n\n            // test not an option\n            assertFalse(commandLine.hasOption(\"Nope\"));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }", "signature": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionNullDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                                  final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                              final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option arg\n        assertEquals(has, commandLine.hasOption(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(has, commandLine.hasOption(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertEquals(has, commandLine.hasOption(opt));\n        checkHandler(optDep, handler, opt);\n\n        // test OptionGroup arg\n        assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other group arg\n        assertFalse(commandLine.hasOption(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n\n        // test null group arg\n        assertFalse(commandLine.hasOption(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        // test not an option\n        assertFalse(commandLine.hasOption(\"Nope\"));\n        checkHandler(false, handler, opt);\n    }", "docstring": "\nTests the hasOption calls.\n@param args the argument strings to parse.\n@param opt the option to check for values with.\n@param optionGroup the option group to check for values with.\n@param optDep {@code true} if the opt is deprecated.\n@param has {@code true} if the opt is present.\n@param grpDep {@code true} if the group is deprecated.\n@param hasGrp {@code true} if the group is present.\n@param grpOpt the option that is expected to be processed by the group.\n@throws ParseException on parsing error.\n", "attributes": {"modifiers": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@ParameterizedTest(name = \"{0}, {1}\")", "@MethodSource(\"createHasOptionParameters\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "hasOptionTest", "params": [{"name": "args", "type": "String[]"}, {"name": "opt", "type": "Option"}, {"name": "optionGroup", "type": "OptionGroup"}, {"name": "optDep", "type": "boolean"}, {"name": "has", "type": "boolean"}, {"name": "grpDep", "type": "boolean"}, {"name": "hasGrp", "type": "boolean"}, {"name": "grpOpt", "type": "Option"}], "body": "                                                                                                                                        {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option arg\n        assertEquals(has, commandLine.hasOption(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(has, commandLine.hasOption(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertEquals(has, commandLine.hasOption(opt));\n        checkHandler(optDep, handler, opt);\n\n        // test OptionGroup arg\n        assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other group arg\n        assertFalse(commandLine.hasOption(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n\n        // test null group arg\n        assertFalse(commandLine.hasOption(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        // test not an option\n        assertFalse(commandLine.hasOption(\"Nope\"));\n        checkHandler(false, handler, opt);\n    }", "signature": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                              final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public void noDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                   final String optValue, final boolean grpDep, final String grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final CommandLine commandLine = DefaultParser.builder().build().parse(options, args);\n        final Supplier<String> thinger = () -> \"thing\";\n        final Supplier<String> nullSupplier = null;\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                    .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n            final OptionGroup nullGroup = null;\n\n            // test char option\n            assertEquals(optValue, commandLine.getOptionValue(asChar(opt)));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(asChar(opt), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test short option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt.getOpt()));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt.getOpt(), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test long option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt()));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt(), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test Option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt, nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test optionGroup  arg\n            assertEquals(grpValue, commandLine.getOptionValue(optionGroup));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, \"thing\"));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, thinger));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue, commandLine.getOptionValue(optionGroup, nullSupplier));\n            assertWritten(grpDep, baos);\n\n            // test other group arg\n            assertNull(commandLine.getOptionValue(otherGroup));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(otherGroup, nullSupplier));\n            assertWritten(false, baos);\n\n            // test null Group arg\n            assertNull(commandLine.getOptionValue(nullGroup));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(nullGroup, nullSupplier));\n            assertWritten(false, baos);\n\n            // test not an option\n            assertNull(commandLine.getOptionValue(\"Nope\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(\"Nope\", nullSupplier));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@ParameterizedTest(name = \"{0}, {1}\")", "@MethodSource(\"createOptionValueParameters\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "noDeprecationHandlerTest", "params": [{"name": "args", "type": "String[]"}, {"name": "opt", "type": "Option"}, {"name": "optionGroup", "type": "OptionGroup"}, {"name": "optDep", "type": "boolean"}, {"name": "optValue", "type": "String"}, {"name": "grpDep", "type": "boolean"}, {"name": "grpValue", "type": "String"}, {"name": "grpOpt", "type": "Option"}], "body": "                                                                                                                                                  {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final CommandLine commandLine = DefaultParser.builder().build().parse(options, args);\n        final Supplier<String> thinger = () -> \"thing\";\n        final Supplier<String> nullSupplier = null;\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                    .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n            final OptionGroup nullGroup = null;\n\n            // test char option\n            assertEquals(optValue, commandLine.getOptionValue(asChar(opt)));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(asChar(opt), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test short option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt.getOpt()));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt.getOpt(), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test long option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt()));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt(), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test Option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt, nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test optionGroup  arg\n            assertEquals(grpValue, commandLine.getOptionValue(optionGroup));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, \"thing\"));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, thinger));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue, commandLine.getOptionValue(optionGroup, nullSupplier));\n            assertWritten(grpDep, baos);\n\n            // test other group arg\n            assertNull(commandLine.getOptionValue(otherGroup));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(otherGroup, nullSupplier));\n            assertWritten(false, baos);\n\n            // test null Group arg\n            assertNull(commandLine.getOptionValue(nullGroup));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(nullGroup, nullSupplier));\n            assertWritten(false, baos);\n\n            // test not an option\n            assertNull(commandLine.getOptionValue(\"Nope\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(\"Nope\", nullSupplier));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }", "signature": "@ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public void noDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                   final String optValue, final boolean grpDep, final String grpValue, final Option grpOpt)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBadGetParsedOptionValue() throws Exception {\n\n        final Options options = new Options();\n        options.addOption(Option.builder(\"i\").hasArg().type(Number.class).build());\n        options.addOption(Option.builder(\"c\").hasArg().converter(s -> Count.valueOf(s.toUpperCase())).build());\n\n\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(options, new String[] {\"-i\", \"foo\", \"-c\", \"bar\"});\n\n        assertEquals(NumberFormatException.class, assertThrows(ParseException.class, () -> cmd.getParsedOptionValue(\"i\")).getCause().getClass());\n        assertEquals(IllegalArgumentException.class, assertThrows(ParseException.class, () -> cmd.getParsedOptionValue(\"c\")).getCause().getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBadGetParsedOptionValue", "params": [], "body": "                                                               {\n\n        final Options options = new Options();\n        options.addOption(Option.builder(\"i\").hasArg().type(Number.class).build());\n        options.addOption(Option.builder(\"c\").hasArg().converter(s -> Count.valueOf(s.toUpperCase())).build());\n\n\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(options, new String[] {\"-i\", \"foo\", \"-c\", \"bar\"});\n\n        assertEquals(NumberFormatException.class, assertThrows(ParseException.class, () -> cmd.getParsedOptionValue(\"i\")).getCause().getClass());\n        assertEquals(IllegalArgumentException.class, assertThrows(ParseException.class, () -> cmd.getParsedOptionValue(\"c\")).getCause().getClass());\n    }", "signature": "@Test\n    public void testBadGetParsedOptionValue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilder() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(\"foo\").addArg(\"bar\");\n        builder.addOption(Option.builder(\"T\").build());\n        final CommandLine cmd = builder.build();\n\n        assertEquals(\"foo\", cmd.getArgs()[0]);\n        assertEquals(\"bar\", cmd.getArgList().get(1));\n        assertEquals(\"T\", cmd.getOptions()[0].getOpt());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilder", "params": [], "body": "                              {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(\"foo\").addArg(\"bar\");\n        builder.addOption(Option.builder(\"T\").build());\n        final CommandLine cmd = builder.build();\n\n        assertEquals(\"foo\", cmd.getArgs()[0]);\n        assertEquals(\"bar\", cmd.getArgList().get(1));\n        assertEquals(\"T\", cmd.getOptions()[0].getOpt());\n    }", "signature": "@Test\n    public void testBuilder()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderNullArgs() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(null).addArg(null);\n        builder.addOption(Option.builder(\"T\").build());\n        final CommandLine cmd = builder.build();\n\n        assertEquals(0, cmd.getArgs().length);\n        assertEquals(\"T\", cmd.getOptions()[0].getOpt());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderNullArgs", "params": [], "body": "                                      {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(null).addArg(null);\n        builder.addOption(Option.builder(\"T\").build());\n        final CommandLine cmd = builder.build();\n\n        assertEquals(0, cmd.getArgs().length);\n        assertEquals(\"T\", cmd.getOptions()[0].getOpt());\n    }", "signature": "@Test\n    public void testBuilderNullArgs()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderNullOption() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(\"foo\").addArg(\"bar\");\n        builder.addOption(null);\n        builder.addOption(null);\n        builder.addOption(null);\n        final CommandLine cmd = builder.build();\n\n        assertEquals(\"foo\", cmd.getArgs()[0]);\n        assertEquals(\"bar\", cmd.getArgList().get(1));\n        assertEquals(0, cmd.getOptions().length);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderNullOption", "params": [], "body": "                                        {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(\"foo\").addArg(\"bar\");\n        builder.addOption(null);\n        builder.addOption(null);\n        builder.addOption(null);\n        final CommandLine cmd = builder.build();\n\n        assertEquals(\"foo\", cmd.getArgs()[0]);\n        assertEquals(\"bar\", cmd.getArgList().get(1));\n        assertEquals(0, cmd.getOptions().length);\n    }", "signature": "@Test\n    public void testBuilderNullOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetOptionProperties() throws Exception {\n        final String[] args = {\"-Dparam1=value1\", \"-Dparam2=value2\", \"-Dparam3\", \"-Dparam4=value4\", \"-D\", \"--property\", \"foo=bar\"};\n\n        final Options options = new Options();\n        options.addOption(Option.builder(\"D\").valueSeparator().optionalArg(true).numberOfArgs(2).build());\n        options.addOption(Option.builder().valueSeparator().numberOfArgs(2).longOpt(\"property\").build());\n\n        final Parser parser = new GnuParser();\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(\"D\");\n        assertNotNull(props, \"null properties\");\n        assertEquals(4, props.size(), \"number of properties in \" + props);\n        assertEquals(\"value1\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n        assertEquals(\"true\", props.getProperty(\"param3\"), \"property 3\");\n        assertEquals(\"value4\", props.getProperty(\"param4\"), \"property 4\");\n\n        assertEquals(\"bar\", cl.getOptionProperties(\"property\").getProperty(\"foo\"), \"property with long format\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetOptionProperties", "params": [], "body": "                                                           {\n        final String[] args = {\"-Dparam1=value1\", \"-Dparam2=value2\", \"-Dparam3\", \"-Dparam4=value4\", \"-D\", \"--property\", \"foo=bar\"};\n\n        final Options options = new Options();\n        options.addOption(Option.builder(\"D\").valueSeparator().optionalArg(true).numberOfArgs(2).build());\n        options.addOption(Option.builder().valueSeparator().numberOfArgs(2).longOpt(\"property\").build());\n\n        final Parser parser = new GnuParser();\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(\"D\");\n        assertNotNull(props, \"null properties\");\n        assertEquals(4, props.size(), \"number of properties in \" + props);\n        assertEquals(\"value1\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n        assertEquals(\"true\", props.getProperty(\"param3\"), \"property 3\");\n        assertEquals(\"value4\", props.getProperty(\"param4\"), \"property 4\");\n\n        assertEquals(\"bar\", cl.getOptionProperties(\"property\").getProperty(\"foo\"), \"property with long format\");\n    }", "signature": "@Test\n    public void testGetOptionProperties()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetOptionPropertiesWithOption() throws Exception {\n        final String[] args = {\"-Dparam1=value1\", \"-Dparam2=value2\", \"-Dparam3\", \"-Dparam4=value4\", \"-D\", \"--property\", \"foo=bar\"};\n\n        final Options options = new Options();\n        final Option optionD = Option.builder(\"D\").valueSeparator().numberOfArgs(2).optionalArg(true).build();\n        final Option optionProperty = Option.builder().valueSeparator().numberOfArgs(2).longOpt(\"property\").build();\n        options.addOption(optionD);\n        options.addOption(optionProperty);\n\n        final Parser parser = new GnuParser();\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(optionD);\n        assertNotNull(props, \"null properties\");\n        assertEquals(4, props.size(), \"number of properties in \" + props);\n        assertEquals(\"value1\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n        assertEquals(\"true\", props.getProperty(\"param3\"), \"property 3\");\n        assertEquals(\"value4\", props.getProperty(\"param4\"), \"property 4\");\n\n        assertEquals(\"bar\", cl.getOptionProperties(optionProperty).getProperty(\"foo\"), \"property with long format\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetOptionPropertiesWithOption", "params": [], "body": "                                                                     {\n        final String[] args = {\"-Dparam1=value1\", \"-Dparam2=value2\", \"-Dparam3\", \"-Dparam4=value4\", \"-D\", \"--property\", \"foo=bar\"};\n\n        final Options options = new Options();\n        final Option optionD = Option.builder(\"D\").valueSeparator().numberOfArgs(2).optionalArg(true).build();\n        final Option optionProperty = Option.builder().valueSeparator().numberOfArgs(2).longOpt(\"property\").build();\n        options.addOption(optionD);\n        options.addOption(optionProperty);\n\n        final Parser parser = new GnuParser();\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(optionD);\n        assertNotNull(props, \"null properties\");\n        assertEquals(4, props.size(), \"number of properties in \" + props);\n        assertEquals(\"value1\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n        assertEquals(\"true\", props.getProperty(\"param3\"), \"property 3\");\n        assertEquals(\"value4\", props.getProperty(\"param4\"), \"property 4\");\n\n        assertEquals(\"bar\", cl.getOptionProperties(optionProperty).getProperty(\"foo\"), \"property with long format\");\n    }", "signature": "@Test\n    public void testGetOptionPropertiesWithOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetOptionsBuilder() {\n        final CommandLine cmd = CommandLine.builder().build();\n        assertNotNull(cmd.getOptions());\n        assertEquals(0, cmd.getOptions().length);\n\n        cmd.addOption(null);\n        cmd.addOption(new Option(\"a\", null));\n        cmd.addOption(new Option(\"b\", null));\n        cmd.addOption(new Option(\"c\", null));\n\n        assertEquals(3, cmd.getOptions().length);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetOptionsBuilder", "params": [], "body": "                                        {\n        final CommandLine cmd = CommandLine.builder().build();\n        assertNotNull(cmd.getOptions());\n        assertEquals(0, cmd.getOptions().length);\n\n        cmd.addOption(null);\n        cmd.addOption(new Option(\"a\", null));\n        cmd.addOption(new Option(\"b\", null));\n        cmd.addOption(new Option(\"c\", null));\n\n        assertEquals(3, cmd.getOptions().length);\n    }", "signature": "@Test\n    public void testGetOptionsBuilder()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetOptionsCtor() {\n        final CommandLine cmd = new CommandLine();\n        assertNotNull(cmd.getOptions());\n        assertEquals(0, cmd.getOptions().length);\n\n        cmd.addOption(new Option(\"a\", null));\n        cmd.addOption(new Option(\"b\", null));\n        cmd.addOption(new Option(\"c\", null));\n        cmd.addOption(null);\n\n        assertEquals(3, cmd.getOptions().length);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetOptionsCtor", "params": [], "body": "                                     {\n        final CommandLine cmd = new CommandLine();\n        assertNotNull(cmd.getOptions());\n        assertEquals(0, cmd.getOptions().length);\n\n        cmd.addOption(new Option(\"a\", null));\n        cmd.addOption(new Option(\"b\", null));\n        cmd.addOption(new Option(\"c\", null));\n        cmd.addOption(null);\n\n        assertEquals(3, cmd.getOptions().length);\n    }", "signature": "@Test\n    public void testGetOptionsCtor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNullOption() throws Exception {\n        final Options options = new Options();\n        final Option optI = Option.builder(\"i\").hasArg().type(Number.class).build();\n        final Option optF = Option.builder(\"f\").hasArg().build();\n        options.addOption(optI);\n        options.addOption(optF);\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(options, new String[] {\"-i\", \"123\", \"-f\", \"foo\"});\n        assertNull(cmd.getOptionValue((Option) null));\n        assertNull(cmd.getParsedOptionValue((Option) null));\n        assertNull(cmd.getOptionValue((OptionGroup) null));\n        assertNull(cmd.getParsedOptionValue((OptionGroup) null));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullOption", "params": [], "body": "                                                  {\n        final Options options = new Options();\n        final Option optI = Option.builder(\"i\").hasArg().type(Number.class).build();\n        final Option optF = Option.builder(\"f\").hasArg().build();\n        options.addOption(optI);\n        options.addOption(optF);\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(options, new String[] {\"-i\", \"123\", \"-f\", \"foo\"});\n        assertNull(cmd.getOptionValue((Option) null));\n        assertNull(cmd.getParsedOptionValue((Option) null));\n        assertNull(cmd.getOptionValue((OptionGroup) null));\n        assertNull(cmd.getParsedOptionValue((OptionGroup) null));\n    }", "signature": "@Test\n    public void testNullOption()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/OptionGroup_toStringTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class OptionGroup_toStringTest {\n\n    private OptionGroup optionGroup;\n\n    @BeforeEach\n    public void setUp() {\n        optionGroup = new OptionGroup();\n    }\n\n    @Test\n    public void testToStringWithNoOptions() {\n        assertEquals(\"[]\", optionGroup.toString());\n    }\n\n    @Test\n    public void testToStringWithSingleOption() {\n        Option option = new Option(\"a\", \"Option A\");\n        optionGroup.addOption(option);\n        assertEquals(\"[-a Option A]\", optionGroup.toString());\n    }\n\n    @Test\n    public void testToStringWithMultipleOptions() {\n        Option optionA = new Option(\"a\", \"Option A\");\n        Option optionB = new Option(\"b\", \"Option B\");\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n        assertEquals(\"[-a Option A, -b Option B]\", optionGroup.toString());\n    }\n\n    @Test\n    public void testToStringWithLongOption() {\n        Option option = new Option(null, \"long-option\", false, \"Long Option\");\n        optionGroup.addOption(option);\n        assertEquals(\"[--long-option Long Option]\", optionGroup.toString());\n    }\n\n    @Test\n    public void testToStringWithMixedOptions() {\n        Option optionA = new Option(\"a\", \"Option A\");\n        Option optionB = new Option(null, \"long-option\", false, \"Long Option\");\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n        assertEquals(\"[-a Option A, --long-option Long Option]\", optionGroup.toString());\n    }\n\n    @Test\n    public void testToStringWithOptionWithoutDescription() {\n        Option option = new Option(\"a\", null);\n        optionGroup.addOption(option);\n        assertEquals(\"[-a]\", optionGroup.toString());\n    }\n}\n", "file_hash": "910110e6af478872d84d43d45da01e55753863a4d37d1e8d2579941c7c681a3e", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class OptionGroup_toStringTest {\n\n    private OptionGroup optionGroup;\n\n    @BeforeEach\n    public void setUp() {\n        optionGroup = new OptionGroup();\n    }\n\n    @Test\n    public void testToStringWithNoOptions() {\n        assertEquals(\"[]\", optionGroup.toString());\n    }\n\n    @Test\n    public void testToStringWithSingleOption() {\n        Option option = new Option(\"a\", \"Option A\");\n        optionGroup.addOption(option);\n        assertEquals(\"[-a Option A]\", optionGroup.toString());\n    }\n\n    @Test\n    public void testToStringWithMultipleOptions() {\n        Option optionA = new Option(\"a\", \"Option A\");\n        Option optionB = new Option(\"b\", \"Option B\");\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n        assertEquals(\"[-a Option A, -b Option B]\", optionGroup.toString());\n    }\n\n    @Test\n    public void testToStringWithLongOption() {\n        Option option = new Option(null, \"long-option\", false, \"Long Option\");\n        optionGroup.addOption(option);\n        assertEquals(\"[--long-option Long Option]\", optionGroup.toString());\n    }\n\n    @Test\n    public void testToStringWithMixedOptions() {\n        Option optionA = new Option(\"a\", \"Option A\");\n        Option optionB = new Option(null, \"long-option\", false, \"Long Option\");\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n        assertEquals(\"[-a Option A, --long-option Long Option]\", optionGroup.toString());\n    }\n\n    @Test\n    public void testToStringWithOptionWithoutDescription() {\n        Option option = new Option(\"a\", null);\n        optionGroup.addOption(option);\n        assertEquals(\"[-a]\", optionGroup.toString());\n    }\n}", "definition": "public class OptionGroup_toStringTest", "class_docstring": "", "name": "OptionGroup_toStringTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private OptionGroup optionGroup;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OptionGroup", "name": "optionGroup", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        optionGroup = new OptionGroup();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        optionGroup = new OptionGroup();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringWithNoOptions() {\n        assertEquals(\"[]\", optionGroup.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringWithNoOptions", "params": [], "body": "                                            {\n        assertEquals(\"[]\", optionGroup.toString());\n    }", "signature": "@Test\n    public void testToStringWithNoOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringWithSingleOption() {\n        Option option = new Option(\"a\", \"Option A\");\n        optionGroup.addOption(option);\n        assertEquals(\"[-a Option A]\", optionGroup.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringWithSingleOption", "params": [], "body": "                                               {\n        Option option = new Option(\"a\", \"Option A\");\n        optionGroup.addOption(option);\n        assertEquals(\"[-a Option A]\", optionGroup.toString());\n    }", "signature": "@Test\n    public void testToStringWithSingleOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringWithMultipleOptions() {\n        Option optionA = new Option(\"a\", \"Option A\");\n        Option optionB = new Option(\"b\", \"Option B\");\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n        assertEquals(\"[-a Option A, -b Option B]\", optionGroup.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringWithMultipleOptions", "params": [], "body": "                                                  {\n        Option optionA = new Option(\"a\", \"Option A\");\n        Option optionB = new Option(\"b\", \"Option B\");\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n        assertEquals(\"[-a Option A, -b Option B]\", optionGroup.toString());\n    }", "signature": "@Test\n    public void testToStringWithMultipleOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringWithLongOption() {\n        Option option = new Option(null, \"long-option\", false, \"Long Option\");\n        optionGroup.addOption(option);\n        assertEquals(\"[--long-option Long Option]\", optionGroup.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringWithLongOption", "params": [], "body": "                                             {\n        Option option = new Option(null, \"long-option\", false, \"Long Option\");\n        optionGroup.addOption(option);\n        assertEquals(\"[--long-option Long Option]\", optionGroup.toString());\n    }", "signature": "@Test\n    public void testToStringWithLongOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringWithMixedOptions() {\n        Option optionA = new Option(\"a\", \"Option A\");\n        Option optionB = new Option(null, \"long-option\", false, \"Long Option\");\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n        assertEquals(\"[-a Option A, --long-option Long Option]\", optionGroup.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringWithMixedOptions", "params": [], "body": "                                               {\n        Option optionA = new Option(\"a\", \"Option A\");\n        Option optionB = new Option(null, \"long-option\", false, \"Long Option\");\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n        assertEquals(\"[-a Option A, --long-option Long Option]\", optionGroup.toString());\n    }", "signature": "@Test\n    public void testToStringWithMixedOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringWithOptionWithoutDescription() {\n        Option option = new Option(\"a\", null);\n        optionGroup.addOption(option);\n        assertEquals(\"[-a]\", optionGroup.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringWithOptionWithoutDescription", "params": [], "body": "                                                           {\n        Option option = new Option(\"a\", null);\n        optionGroup.addOption(option);\n        assertEquals(\"[-a]\", optionGroup.toString());\n    }", "signature": "@Test\n    public void testToStringWithOptionWithoutDescription()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/BasicParserTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\n\n/**\n * TODO Needs a rework using JUnit parameterized tests.\n */\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BasicParserTest extends AbstractParserTestCase {\n    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new BasicParser();\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testDoubleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithEqualDoubleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testMissingArgWithBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPartialLongOptionSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPropertiesOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPropertiesOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortWithEqual() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortWithoutEqual() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testStopBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testStopBursting2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n    }\n}\n", "file_hash": "67b242626a0566cb8f50715a33cb359abdfdfb2e6cfadfd80ce3ec4e11e4f576", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Disabled;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BasicParserTest extends AbstractParserTestCase {\n    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new BasicParser();\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testDoubleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithEqualDoubleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testMissingArgWithBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPartialLongOptionSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPropertiesOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPropertiesOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortWithEqual() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortWithoutEqual() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testStopBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testStopBursting2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BasicParserTest extends AbstractParserTestCase", "class_docstring": "\nTODO Needs a rework using JUnit parameterized tests.\n", "name": "BasicParserTest", "super_interfaces": [], "superclasses": "AbstractParserTestCase", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new BasicParser();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @BeforeEach\n    public", "marker_annotations": ["@Override", "@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        super.setUp();\n        parser = new BasicParser();\n    }", "signature": "@Override\n    @BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousLongWithoutEqualSingleDash", "params": [], "body": "                                                                           {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousLongWithoutEqualSingleDash2", "params": [], "body": "                                                                            {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption1() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption1", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption1()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption2", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption3() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption3", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption3()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption4", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption4()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testBursting() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBursting", "params": [], "body": "                                                {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testBursting()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testDoubleDash2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoubleDash2", "params": [], "body": "                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testDoubleDash2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionWithEqualsQuoteHandling", "params": [], "body": "                                                                         {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongOptionWithEqualsQuoteHandling()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithEqualDoubleDash() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithEqualDoubleDash", "params": [], "body": "                                                               {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithEqualDoubleDash()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithEqualSingleDash() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithEqualSingleDash", "params": [], "body": "                                                               {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithEqualSingleDash()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithoutEqualSingleDash", "params": [], "body": "                                                                  {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithoutEqualSingleDash()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testMissingArgWithBursting() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMissingArgWithBursting", "params": [], "body": "                                                              {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testMissingArgWithBursting()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser (CLI-184)\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser (CLI-184)\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNegativeOption", "params": [], "body": "                                                      {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser (CLI-184)\")\n    public void testNegativeOption()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPartialLongOptionSingleDash() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPartialLongOptionSingleDash", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPartialLongOptionSingleDash()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPropertiesOption1() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertiesOption1", "params": [], "body": "                                                         {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPropertiesOption1()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPropertiesOption2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertiesOption2", "params": [], "body": "                                                         {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPropertiesOption2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionConcatenatedQuoteHandling", "params": [], "body": "                                                                            {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortOptionConcatenatedQuoteHandling()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortWithEqual() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortWithEqual", "params": [], "body": "                                                      {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortWithEqual()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortWithoutEqual() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortWithoutEqual", "params": [], "body": "                                                         {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortWithoutEqual()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testStopBursting() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStopBursting", "params": [], "body": "                                                    {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testStopBursting()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testStopBursting2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStopBursting2", "params": [], "body": "                                                     {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testStopBursting2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption1() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption1", "params": [], "body": "                                                                     {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption1()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption2", "params": [], "body": "                                                                     {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption3() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption3", "params": [], "body": "                                                                     {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption3()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption4", "params": [], "body": "                                                                     {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption4()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the BasicParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnrecognizedOptionWithBursting", "params": [], "body": "                                                                      {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnrecognizedOptionWithBursting()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/Options_getOptionTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Options_getOptionTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testGetOptionShort() {\n        Option option = new Option(\"s\", \"shortOption\", false, \"Short option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"s\");\n        assertEquals(option, retrievedOption);\n    }\n\n    @Test\n    public void testGetOptionLong() {\n        Option option = new Option(\"l\", \"longOption\", false, \"Long option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"longOption\");\n        assertEquals(option, retrievedOption);\n    }\n\n    @Test\n    public void testGetOptionNonexistent() {\n        Option retrievedOption = options.getOption(\"nonexistent\");\n        assertNull(retrievedOption);\n    }\n\n    @Test\n    public void testGetOptionWithHyphens() {\n        Option option = new Option(\"h\", \"hyphenOption\", false, \"Option with hyphens description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"--hyphenOption\");\n        assertEquals(option, retrievedOption);\n\n        retrievedOption = options.getOption(\"-h\");\n        assertEquals(option, retrievedOption);\n    }\n\n    @Test\n    public void testGetOptionMixedCase() {\n        Option option = new Option(\"m\", \"mixedCase\", false, \"Mixed case option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"mixedCase\");\n        assertEquals(option, retrievedOption);\n\n        retrievedOption = options.getOption(\"m\");\n        assertEquals(option, retrievedOption);\n    }\n}\n", "file_hash": "da699679b2c49efa3c94481a32a52c64c73120f93f5fb7b485216d56395ceba4", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class Options_getOptionTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testGetOptionShort() {\n        Option option = new Option(\"s\", \"shortOption\", false, \"Short option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"s\");\n        assertEquals(option, retrievedOption);\n    }\n\n    @Test\n    public void testGetOptionLong() {\n        Option option = new Option(\"l\", \"longOption\", false, \"Long option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"longOption\");\n        assertEquals(option, retrievedOption);\n    }\n\n    @Test\n    public void testGetOptionNonexistent() {\n        Option retrievedOption = options.getOption(\"nonexistent\");\n        assertNull(retrievedOption);\n    }\n\n    @Test\n    public void testGetOptionWithHyphens() {\n        Option option = new Option(\"h\", \"hyphenOption\", false, \"Option with hyphens description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"--hyphenOption\");\n        assertEquals(option, retrievedOption);\n\n        retrievedOption = options.getOption(\"-h\");\n        assertEquals(option, retrievedOption);\n    }\n\n    @Test\n    public void testGetOptionMixedCase() {\n        Option option = new Option(\"m\", \"mixedCase\", false, \"Mixed case option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"mixedCase\");\n        assertEquals(option, retrievedOption);\n\n        retrievedOption = options.getOption(\"m\");\n        assertEquals(option, retrievedOption);\n    }\n}", "definition": "public class Options_getOptionTest", "class_docstring": "", "name": "Options_getOptionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        options = new Options();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetOptionShort() {\n        Option option = new Option(\"s\", \"shortOption\", false, \"Short option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"s\");\n        assertEquals(option, retrievedOption);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetOptionShort", "params": [], "body": "                                     {\n        Option option = new Option(\"s\", \"shortOption\", false, \"Short option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"s\");\n        assertEquals(option, retrievedOption);\n    }", "signature": "@Test\n    public void testGetOptionShort()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetOptionLong() {\n        Option option = new Option(\"l\", \"longOption\", false, \"Long option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"longOption\");\n        assertEquals(option, retrievedOption);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetOptionLong", "params": [], "body": "                                    {\n        Option option = new Option(\"l\", \"longOption\", false, \"Long option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"longOption\");\n        assertEquals(option, retrievedOption);\n    }", "signature": "@Test\n    public void testGetOptionLong()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetOptionNonexistent() {\n        Option retrievedOption = options.getOption(\"nonexistent\");\n        assertNull(retrievedOption);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetOptionNonexistent", "params": [], "body": "                                           {\n        Option retrievedOption = options.getOption(\"nonexistent\");\n        assertNull(retrievedOption);\n    }", "signature": "@Test\n    public void testGetOptionNonexistent()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetOptionWithHyphens() {\n        Option option = new Option(\"h\", \"hyphenOption\", false, \"Option with hyphens description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"--hyphenOption\");\n        assertEquals(option, retrievedOption);\n\n        retrievedOption = options.getOption(\"-h\");\n        assertEquals(option, retrievedOption);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetOptionWithHyphens", "params": [], "body": "                                           {\n        Option option = new Option(\"h\", \"hyphenOption\", false, \"Option with hyphens description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"--hyphenOption\");\n        assertEquals(option, retrievedOption);\n\n        retrievedOption = options.getOption(\"-h\");\n        assertEquals(option, retrievedOption);\n    }", "signature": "@Test\n    public void testGetOptionWithHyphens()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetOptionMixedCase() {\n        Option option = new Option(\"m\", \"mixedCase\", false, \"Mixed case option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"mixedCase\");\n        assertEquals(option, retrievedOption);\n\n        retrievedOption = options.getOption(\"m\");\n        assertEquals(option, retrievedOption);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetOptionMixedCase", "params": [], "body": "                                         {\n        Option option = new Option(\"m\", \"mixedCase\", false, \"Mixed case option description\");\n        options.addOption(option);\n\n        Option retrievedOption = options.getOption(\"mixedCase\");\n        assertEquals(option, retrievedOption);\n\n        retrievedOption = options.getOption(\"m\");\n        assertEquals(option, retrievedOption);\n    }", "signature": "@Test\n    public void testGetOptionMixedCase()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/OptionGroup_addOptionTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class OptionGroup_addOptionTest {\n\n    private OptionGroup optionGroup;\n\n    @BeforeEach\n    public void setUp() {\n        optionGroup = new OptionGroup();\n    }\n\n    @Test\n    public void testAddOption() {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        assertNotNull(optionGroup.getNames(), \"null names\");\n        assertEquals(2, optionGroup.getNames().size());\n        assertTrue(optionGroup.getNames().contains(\"a\"));\n        assertTrue(optionGroup.getNames().contains(\"b\"));\n    }\n\n    @Test\n    public void testAddOptionAndSetSelected() throws AlreadySelectedException {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        optionGroup.setSelected(optionA);\n\n        assertTrue(optionGroup.isSelected());\n        assertEquals(\"a\", optionGroup.getSelected());\n    }\n\n    @Test\n    public void testAddOptionAndCheckSelected() throws AlreadySelectedException {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        assertFalse(optionGroup.isSelected());\n\n        optionGroup.setSelected(optionA);\n\n        assertTrue(optionGroup.isSelected());\n    }\n}\n", "file_hash": "eecbe26d21bba3060a47a9b5da6fd203f7d06e3186d39e5062c68705c9405cab", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class OptionGroup_addOptionTest {\n\n    private OptionGroup optionGroup;\n\n    @BeforeEach\n    public void setUp() {\n        optionGroup = new OptionGroup();\n    }\n\n    @Test\n    public void testAddOption() {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        assertNotNull(optionGroup.getNames(), \"null names\");\n        assertEquals(2, optionGroup.getNames().size());\n        assertTrue(optionGroup.getNames().contains(\"a\"));\n        assertTrue(optionGroup.getNames().contains(\"b\"));\n    }\n\n    @Test\n    public void testAddOptionAndSetSelected() throws AlreadySelectedException {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        optionGroup.setSelected(optionA);\n\n        assertTrue(optionGroup.isSelected());\n        assertEquals(\"a\", optionGroup.getSelected());\n    }\n\n    @Test\n    public void testAddOptionAndCheckSelected() throws AlreadySelectedException {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        assertFalse(optionGroup.isSelected());\n\n        optionGroup.setSelected(optionA);\n\n        assertTrue(optionGroup.isSelected());\n    }\n}", "definition": "public class OptionGroup_addOptionTest", "class_docstring": "", "name": "OptionGroup_addOptionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private OptionGroup optionGroup;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OptionGroup", "name": "optionGroup", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        optionGroup = new OptionGroup();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        optionGroup = new OptionGroup();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOption() {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        assertNotNull(optionGroup.getNames(), \"null names\");\n        assertEquals(2, optionGroup.getNames().size());\n        assertTrue(optionGroup.getNames().contains(\"a\"));\n        assertTrue(optionGroup.getNames().contains(\"b\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOption", "params": [], "body": "                                {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        assertNotNull(optionGroup.getNames(), \"null names\");\n        assertEquals(2, optionGroup.getNames().size());\n        assertTrue(optionGroup.getNames().contains(\"a\"));\n        assertTrue(optionGroup.getNames().contains(\"b\"));\n    }", "signature": "@Test\n    public void testAddOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionAndSetSelected() throws AlreadySelectedException {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        optionGroup.setSelected(optionA);\n\n        assertTrue(optionGroup.isSelected());\n        assertEquals(\"a\", optionGroup.getSelected());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionAndSetSelected", "params": [], "body": "                                                                              {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        optionGroup.setSelected(optionA);\n\n        assertTrue(optionGroup.isSelected());\n        assertEquals(\"a\", optionGroup.getSelected());\n    }", "signature": "@Test\n    public void testAddOptionAndSetSelected()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptionAndCheckSelected() throws AlreadySelectedException {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        assertFalse(optionGroup.isSelected());\n\n        optionGroup.setSelected(optionA);\n\n        assertTrue(optionGroup.isSelected());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptionAndCheckSelected", "params": [], "body": "                                                                                {\n        Option optionA = OptionBuilder.create('a');\n        Option optionB = OptionBuilder.create('b');\n\n        optionGroup.addOption(optionA);\n        optionGroup.addOption(optionB);\n\n        assertFalse(optionGroup.isSelected());\n\n        optionGroup.setSelected(optionA);\n\n        assertTrue(optionGroup.isSelected());\n    }", "signature": "@Test\n    public void testAddOptionAndCheckSelected()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/PosixParserTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for the PosixParser.\n *\n * TODO Needs a rework using JUnit parameterized tests.\n */\npublic class PosixParserTest extends AbstractParserTestCase {\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new PosixParser();\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testDoubleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithUnexpectedArgument1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testShortWithEqual() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }\n}\n", "file_hash": "8b9cea227281253c38de9ff96bfd410aceb134704d17bc21fb6a3f2aad7fce87", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Disabled;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class PosixParserTest extends AbstractParserTestCase {\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new PosixParser();\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testDoubleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithUnexpectedArgument1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testShortWithEqual() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }\n}", "definition": "public class PosixParserTest extends AbstractParserTestCase", "class_docstring": "\nTest case for the PosixParser.\n\nTODO Needs a rework using JUnit parameterized tests.\n", "name": "PosixParserTest", "super_interfaces": [], "superclasses": "AbstractParserTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    @SuppressWarnings(\"deprecation\")\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new PosixParser();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @SuppressWarnings(\"deprecation\")\n    @BeforeEach\n    public", "marker_annotations": ["@Override", "@BeforeEach"], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        super.setUp();\n        parser = new PosixParser();\n    }", "signature": "@Override\n    @SuppressWarnings(\"deprecation\")\n    @BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the PosixParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousLongWithoutEqualSingleDash", "params": [], "body": "                                                                           {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the PosixParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousLongWithoutEqualSingleDash2", "params": [], "body": "                                                                            {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the PosixParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption4", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousPartialLongOption4()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testDoubleDash2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the PosixParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoubleDash2", "params": [], "body": "                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testDoubleDash2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithEqualSingleDash() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the PosixParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithEqualSingleDash", "params": [], "body": "                                                               {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithEqualSingleDash()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the PosixParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithoutEqualSingleDash", "params": [], "body": "                                                                  {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithoutEqualSingleDash()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithUnexpectedArgument1() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the PosixParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithUnexpectedArgument1", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithUnexpectedArgument1()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser (CLI-184)\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the PosixParser (CLI-184)\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNegativeOption", "params": [], "body": "                                                      {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser (CLI-184)\")\n    public void testNegativeOption()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testShortWithEqual() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the PosixParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortWithEqual", "params": [], "body": "                                                      {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testShortWithEqual()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the PosixParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption4", "params": [], "body": "                                                                     {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testUnambiguousPartialLongOption4()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/GnuParserTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\n\n/**\n * TODO Needs a rework using JUnit parameterized tests.\n */\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class GnuParserTest extends AbstractParserTestCase {\n    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new GnuParser();\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testDoubleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithUnexpectedArgument1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithUnexpectedArgument2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testMissingArgWithBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testPartialLongOptionSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testShortWithUnexpectedArgument() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testStopBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testStopBursting2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n    }\n}\n", "file_hash": "35faedf3e2a7a37a169ec9e6cff15b5f4c499086b4a5dea7950351d735294558", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Disabled;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class GnuParserTest extends AbstractParserTestCase {\n    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new GnuParser();\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testDoubleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithUnexpectedArgument1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithUnexpectedArgument2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testMissingArgWithBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testPartialLongOptionSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testShortWithUnexpectedArgument() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testStopBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testStopBursting2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class GnuParserTest extends AbstractParserTestCase", "class_docstring": "\nTODO Needs a rework using JUnit parameterized tests.\n", "name": "GnuParserTest", "super_interfaces": [], "superclasses": "AbstractParserTestCase", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new GnuParser();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @BeforeEach\n    public", "marker_annotations": ["@Override", "@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        super.setUp();\n        parser = new GnuParser();\n    }", "signature": "@Override\n    @BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousLongWithoutEqualSingleDash", "params": [], "body": "                                                                           {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousLongWithoutEqualSingleDash2", "params": [], "body": "                                                                            {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption1() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption1", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption1()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption2", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption3() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption3", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption3()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption4", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption4()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testBursting() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBursting", "params": [], "body": "                                                {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testBursting()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testDoubleDash2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoubleDash2", "params": [], "body": "                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testDoubleDash2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithoutEqualSingleDash", "params": [], "body": "                                                                  {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithoutEqualSingleDash()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithUnexpectedArgument1() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithUnexpectedArgument1", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithUnexpectedArgument1()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithUnexpectedArgument2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithUnexpectedArgument2", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithUnexpectedArgument2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testMissingArgWithBursting() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMissingArgWithBursting", "params": [], "body": "                                                              {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testMissingArgWithBursting()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser (CLI-184)\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser (CLI-184)\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNegativeOption", "params": [], "body": "                                                      {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser (CLI-184)\")\n    public void testNegativeOption()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testPartialLongOptionSingleDash() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPartialLongOptionSingleDash", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testPartialLongOptionSingleDash()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testShortWithUnexpectedArgument() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortWithUnexpectedArgument", "params": [], "body": "                                                                   {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testShortWithUnexpectedArgument()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testStopBursting() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStopBursting", "params": [], "body": "                                                    {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testStopBursting()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testStopBursting2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStopBursting2", "params": [], "body": "                                                     {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testStopBursting2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption1() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption1", "params": [], "body": "                                                                     {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption1()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption2() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption2", "params": [], "body": "                                                                     {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption2()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption3() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption3", "params": [], "body": "                                                                     {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption3()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption4", "params": [], "body": "                                                                     {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption4()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["@Disabled(\"not supported by the GnuParser\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnrecognizedOptionWithBursting", "params": [], "body": "                                                                      {\n    }", "signature": "@Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnrecognizedOptionWithBursting()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/HelpFormatter_printHelpTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class HelpFormatter_printHelpTest {\n\n    private HelpFormatter formatter;\n    private StringWriter stringWriter;\n    private PrintWriter printWriter;\n\n    @BeforeEach\n    public void setUp() {\n        formatter = new HelpFormatter();\n        stringWriter = new StringWriter();\n        printWriter = new PrintWriter(stringWriter);\n    }\n\n    @Test\n    public void testPrintHelpWithHeaderAndFooter() {\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").build());\n        options.addOption(Option.builder(\"v\").longOpt(\"version\").desc(\"Print the version of the application\").build());\n        options.addOption(Option.builder(\"h\").longOpt(\"help\").desc(\"Print this help message\").build());\n\n        String header = \"Do something useful with an input file\\n\\n\";\n        String footer = \"\\nPlease report issues at https://example.com/issues\";\n\n        formatter.printHelp(printWriter, 80, \"myapp\", header, options, 1, 3, footer, true);\n        printWriter.flush();\n\n        String expectedOutput = \"usage: myapp [-f <FILE>] [-h] [-v]\\n\" +\n                                \"Do something useful with an input file\\n\\n\" +\n                                \" -f,--file <FILE>   The file to be processed\\n\" +\n                                \" -h,--help          Print this help message\\n\" +\n                                \" -v,--version       Print the version of the application\\n\\n\" +\n                                \"Please report issues at https://example.com/issues\\n\";\n\n        assertEquals(expectedOutput, stringWriter.toString());\n    }\n\n    @Test\n    public void testPrintHelpWithoutHeaderAndFooter() {\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").build());\n        options.addOption(Option.builder(\"v\").longOpt(\"version\").desc(\"Print the version of the application\").build());\n        options.addOption(Option.builder(\"h\").longOpt(\"help\").desc(\"Print this help message\").build());\n\n        formatter.printHelp(printWriter, 80, \"myapp\", null, options, 1, 3, null, true);\n        printWriter.flush();\n\n        String expectedOutput = \"usage: myapp [-f <FILE>] [-h] [-v]\\n\" +\n                                \" -f,--file <FILE>   The file to be processed\\n\" +\n                                \" -h,--help          Print this help message\\n\" +\n                                \" -v,--version       Print the version of the application\\n\";\n\n        assertEquals(expectedOutput, stringWriter.toString());\n    }\n}\n", "file_hash": "f91ebf2ea60318bca7acfd74ad2fd13ef53d7cac0afb389a408574df80ecef22", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import java.io.PrintWriter;", "import java.io.StringWriter;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class HelpFormatter_printHelpTest {\n\n    private HelpFormatter formatter;\n    private StringWriter stringWriter;\n    private PrintWriter printWriter;\n\n    @BeforeEach\n    public void setUp() {\n        formatter = new HelpFormatter();\n        stringWriter = new StringWriter();\n        printWriter = new PrintWriter(stringWriter);\n    }\n\n    @Test\n    public void testPrintHelpWithHeaderAndFooter() {\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").build());\n        options.addOption(Option.builder(\"v\").longOpt(\"version\").desc(\"Print the version of the application\").build());\n        options.addOption(Option.builder(\"h\").longOpt(\"help\").desc(\"Print this help message\").build());\n\n        String header = \"Do something useful with an input file\\n\\n\";\n        String footer = \"\\nPlease report issues at https://example.com/issues\";\n\n        formatter.printHelp(printWriter, 80, \"myapp\", header, options, 1, 3, footer, true);\n        printWriter.flush();\n\n        String expectedOutput = \"usage: myapp [-f <FILE>] [-h] [-v]\\n\" +\n                                \"Do something useful with an input file\\n\\n\" +\n                                \" -f,--file <FILE>   The file to be processed\\n\" +\n                                \" -h,--help          Print this help message\\n\" +\n                                \" -v,--version       Print the version of the application\\n\\n\" +\n                                \"Please report issues at https://example.com/issues\\n\";\n\n        assertEquals(expectedOutput, stringWriter.toString());\n    }\n\n    @Test\n    public void testPrintHelpWithoutHeaderAndFooter() {\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").build());\n        options.addOption(Option.builder(\"v\").longOpt(\"version\").desc(\"Print the version of the application\").build());\n        options.addOption(Option.builder(\"h\").longOpt(\"help\").desc(\"Print this help message\").build());\n\n        formatter.printHelp(printWriter, 80, \"myapp\", null, options, 1, 3, null, true);\n        printWriter.flush();\n\n        String expectedOutput = \"usage: myapp [-f <FILE>] [-h] [-v]\\n\" +\n                                \" -f,--file <FILE>   The file to be processed\\n\" +\n                                \" -h,--help          Print this help message\\n\" +\n                                \" -v,--version       Print the version of the application\\n\";\n\n        assertEquals(expectedOutput, stringWriter.toString());\n    }\n}", "definition": "public class HelpFormatter_printHelpTest", "class_docstring": "", "name": "HelpFormatter_printHelpTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private HelpFormatter formatter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HelpFormatter", "name": "formatter", "syntax_pass": true}, {"attribute_expression": "private StringWriter stringWriter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StringWriter", "name": "stringWriter", "syntax_pass": true}, {"attribute_expression": "private PrintWriter printWriter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PrintWriter", "name": "printWriter", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        formatter = new HelpFormatter();\n        stringWriter = new StringWriter();\n        printWriter = new PrintWriter(stringWriter);\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        formatter = new HelpFormatter();\n        stringWriter = new StringWriter();\n        printWriter = new PrintWriter(stringWriter);\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintHelpWithHeaderAndFooter() {\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").build());\n        options.addOption(Option.builder(\"v\").longOpt(\"version\").desc(\"Print the version of the application\").build());\n        options.addOption(Option.builder(\"h\").longOpt(\"help\").desc(\"Print this help message\").build());\n\n        String header = \"Do something useful with an input file\\n\\n\";\n        String footer = \"\\nPlease report issues at https://example.com/issues\";\n\n        formatter.printHelp(printWriter, 80, \"myapp\", header, options, 1, 3, footer, true);\n        printWriter.flush();\n\n        String expectedOutput = \"usage: myapp [-f <FILE>] [-h] [-v]\\n\" +\n                                \"Do something useful with an input file\\n\\n\" +\n                                \" -f,--file <FILE>   The file to be processed\\n\" +\n                                \" -h,--help          Print this help message\\n\" +\n                                \" -v,--version       Print the version of the application\\n\\n\" +\n                                \"Please report issues at https://example.com/issues\\n\";\n\n        assertEquals(expectedOutput, stringWriter.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintHelpWithHeaderAndFooter", "params": [], "body": "                                                   {\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").build());\n        options.addOption(Option.builder(\"v\").longOpt(\"version\").desc(\"Print the version of the application\").build());\n        options.addOption(Option.builder(\"h\").longOpt(\"help\").desc(\"Print this help message\").build());\n\n        String header = \"Do something useful with an input file\\n\\n\";\n        String footer = \"\\nPlease report issues at https://example.com/issues\";\n\n        formatter.printHelp(printWriter, 80, \"myapp\", header, options, 1, 3, footer, true);\n        printWriter.flush();\n\n        String expectedOutput = \"usage: myapp [-f <FILE>] [-h] [-v]\\n\" +\n                                \"Do something useful with an input file\\n\\n\" +\n                                \" -f,--file <FILE>   The file to be processed\\n\" +\n                                \" -h,--help          Print this help message\\n\" +\n                                \" -v,--version       Print the version of the application\\n\\n\" +\n                                \"Please report issues at https://example.com/issues\\n\";\n\n        assertEquals(expectedOutput, stringWriter.toString());\n    }", "signature": "@Test\n    public void testPrintHelpWithHeaderAndFooter()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintHelpWithoutHeaderAndFooter() {\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").build());\n        options.addOption(Option.builder(\"v\").longOpt(\"version\").desc(\"Print the version of the application\").build());\n        options.addOption(Option.builder(\"h\").longOpt(\"help\").desc(\"Print this help message\").build());\n\n        formatter.printHelp(printWriter, 80, \"myapp\", null, options, 1, 3, null, true);\n        printWriter.flush();\n\n        String expectedOutput = \"usage: myapp [-f <FILE>] [-h] [-v]\\n\" +\n                                \" -f,--file <FILE>   The file to be processed\\n\" +\n                                \" -h,--help          Print this help message\\n\" +\n                                \" -v,--version       Print the version of the application\\n\";\n\n        assertEquals(expectedOutput, stringWriter.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintHelpWithoutHeaderAndFooter", "params": [], "body": "                                                      {\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").build());\n        options.addOption(Option.builder(\"v\").longOpt(\"version\").desc(\"Print the version of the application\").build());\n        options.addOption(Option.builder(\"h\").longOpt(\"help\").desc(\"Print this help message\").build());\n\n        formatter.printHelp(printWriter, 80, \"myapp\", null, options, 1, 3, null, true);\n        printWriter.flush();\n\n        String expectedOutput = \"usage: myapp [-f <FILE>] [-h] [-v]\\n\" +\n                                \" -f,--file <FILE>   The file to be processed\\n\" +\n                                \" -h,--help          Print this help message\\n\" +\n                                \" -v,--version       Print the version of the application\\n\";\n\n        assertEquals(expectedOutput, stringWriter.toString());\n    }", "signature": "@Test\n    public void testPrintHelpWithoutHeaderAndFooter()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/OptionValidatorTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class OptionValidatorTest {\n\n    /*\n     * Exemplars of various types of characters\n     */\n\n    private static final String LETTERS = \"a\\u00D1\"; // a and \u00d1\n\n    // '\\u0660' through '\\u0669', Arabic-Indic digits, '\\u06F0' through '\\u06F9',\n    // Extended Arabic-Indic digits\n    // '\\u0966' through '\\u096F', Devanagari digits, '\\uFF10' through '\\uFF19',\n    // Fullwidth digits\n    private static final String DIGITS = \"1\\u0661\\u06f2\\u0968\\uFF14\";\n\n    private static final String CURRENCY = \"\u20ac$\";\n\n    // this is the complete puncutation set do not modify it as Character.isJavaIdentifierPart filters\n    // the good and bad ones out in the setup.\n    private static final String PUNCTUATION = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\n\n    private static final String COMBINING_MARK = \"\\u0303\";\n\n    private static final String NON_SPACING_MARK = \"\\u0CBF\";\n\n    private static final String IDENTIFIER_IGNORABLE = \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\u0008\";\n\n    private static String acceptablePunctuation;\n\n    private static String notAcceptablePunctuation;\n\n    private static String additionalOptonChars;\n    private static String additionalLongChars;\n\n    private static String firstChars;\n    private static String notFirstChars;\n\n    private static String restChars;\n    private static String notRestChars;\n\n    private static Stream<Arguments> optionParameters() {\n\n        final List<Arguments> args = new ArrayList<>();\n\n        args.add(Arguments.of(\"CamelCase\", true, \"Camel case error\"));\n        args.add(Arguments.of(\"Snake_case\", true, \"Snake case error\"));\n        args.add(Arguments.of(\"_leadingUnderscore\", true, \"Leading underscore error\"));\n        args.add(Arguments.of(\"kabob-case\", true, \"Kabob case error\"));\n        args.add(Arguments.of(\"-leadingDash\", false, \"Leading dash error\"));\n        args.add(Arguments.of(\"lowercase\", true, \"Lower case error\"));\n        args.add(Arguments.of(\"UPPERCASE\", true, \"Upper case error\"));\n\n        // build passing test cases\n        for (final char c : firstChars.toCharArray()) {\n            final String s = String.format(\"%sMoreText\", c);\n            args.add(Arguments.of(s, true, String.format(\"testing: First character '%s'\", c)));\n        }\n\n        for (final char c : restChars.toCharArray()) {\n            final String s = String.format(\"Some%sText\", c);\n            args.add(Arguments.of(s, true, String.format(\"testing: Middle character '%s'\", c)));\n        }\n\n        // build failing test cases\n        for (final char c : notFirstChars.toCharArray()) {\n            final String s = String.format(\"%sMoreText\", c);\n            args.add(Arguments.of(s, false, String.format(\"testing: Bad first character '%s'\", c)));\n        }\n\n        for (final char c : notRestChars.toCharArray()) {\n            final String s = String.format(\"Some%sText\", c);\n            args.add(Arguments.of(s, false, String.format(\"testing: Bad middle character '%s'\", c)));\n        }\n\n        return args.stream();\n    }\n\n    @BeforeAll\n    public static void setup() {\n        StringBuilder sb = new StringBuilder();\n        final StringBuilder sb2 = new StringBuilder();\n        int idx;\n\n        for (final char c : PUNCTUATION.toCharArray()) {\n            if (Character.isJavaIdentifierPart(c)) {\n                sb.append(c);\n            } else {\n                sb2.append(c);\n            }\n        }\n        acceptablePunctuation = sb.toString();\n        notAcceptablePunctuation = sb2.toString();\n\n        sb = new StringBuilder();\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            sb.append(c);\n        }\n        additionalLongChars = sb.toString();\n\n        sb = new StringBuilder();\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            sb.append(c);\n        }\n        additionalOptonChars = sb.toString();\n\n        final String javaIdentifierPart = LETTERS + DIGITS + CURRENCY + acceptablePunctuation + COMBINING_MARK\n                + NON_SPACING_MARK + IDENTIFIER_IGNORABLE;\n\n        firstChars = additionalOptonChars + javaIdentifierPart;\n\n        sb = new StringBuilder(notAcceptablePunctuation).append(additionalLongChars);\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            while ((idx = sb.indexOf(Character.toString(c))) > -1) {\n                sb.deleteCharAt(idx);\n            }\n        }\n        notFirstChars = sb.toString();\n\n        restChars = additionalLongChars + javaIdentifierPart;\n        sb = new StringBuilder(notAcceptablePunctuation).append(additionalOptonChars);\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            while ((idx = sb.indexOf(Character.toString(c))) > -1) {\n                sb.deleteCharAt(idx);\n            }\n        }\n        notRestChars = sb.toString();\n\n    }\n\n    @Test\n    public void testExclusivity() {\n        /* since we modify acceptable chars by add and removing ADDITIONAL* chars we must verify that they do not exist in the\n         * base javaIdentiferPart that is used in OptionValidator to validate basic characters  */\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            assertFalse(Character.isJavaIdentifierPart(c), () -> String.format(\"'%s' should not be in 'ADDITIONAL_LONG_CHARS\", c));\n        }\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            assertFalse(Character.isJavaIdentifierPart(c), () -> String.format(\"'%s' should not be in 'ADDITIONAL_OPTION_CHARS\", c));\n        }\n    }\n\n    @ParameterizedTest(name = \"{2}\")\n    @MethodSource(\"optionParameters\")\n    public void validateTest(final String str, final boolean expected, final String name) {\n        if (expected) {\n            assertEquals(str, OptionValidator.validate(str));\n        } else {\n            assertThrows(IllegalArgumentException.class, () -> OptionValidator.validate(str));\n        }\n    }\n}\n", "file_hash": "41159976f35dc4403d6da07d1c325ec352c5b8da09b312188ce0507852ddc527", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.stream.Stream;", "import org.junit.jupiter.api.BeforeAll;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.provider.Arguments;", "import org.junit.jupiter.params.provider.MethodSource;"], "methods": [], "classes": [{"original_string": "public class OptionValidatorTest {\n\n    /*\n     * Exemplars of various types of characters\n     */\n\n    private static final String LETTERS = \"a\\u00D1\"; // a and \u00d1\n\n    // '\\u0660' through '\\u0669', Arabic-Indic digits, '\\u06F0' through '\\u06F9',\n    // Extended Arabic-Indic digits\n    // '\\u0966' through '\\u096F', Devanagari digits, '\\uFF10' through '\\uFF19',\n    // Fullwidth digits\n    private static final String DIGITS = \"1\\u0661\\u06f2\\u0968\\uFF14\";\n\n    private static final String CURRENCY = \"\u20ac$\";\n\n    // this is the complete puncutation set do not modify it as Character.isJavaIdentifierPart filters\n    // the good and bad ones out in the setup.\n    private static final String PUNCTUATION = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\n\n    private static final String COMBINING_MARK = \"\\u0303\";\n\n    private static final String NON_SPACING_MARK = \"\\u0CBF\";\n\n    private static final String IDENTIFIER_IGNORABLE = \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\u0008\";\n\n    private static String acceptablePunctuation;\n\n    private static String notAcceptablePunctuation;\n\n    private static String additionalOptonChars;\n    private static String additionalLongChars;\n\n    private static String firstChars;\n    private static String notFirstChars;\n\n    private static String restChars;\n    private static String notRestChars;\n\n    private static Stream<Arguments> optionParameters() {\n\n        final List<Arguments> args = new ArrayList<>();\n\n        args.add(Arguments.of(\"CamelCase\", true, \"Camel case error\"));\n        args.add(Arguments.of(\"Snake_case\", true, \"Snake case error\"));\n        args.add(Arguments.of(\"_leadingUnderscore\", true, \"Leading underscore error\"));\n        args.add(Arguments.of(\"kabob-case\", true, \"Kabob case error\"));\n        args.add(Arguments.of(\"-leadingDash\", false, \"Leading dash error\"));\n        args.add(Arguments.of(\"lowercase\", true, \"Lower case error\"));\n        args.add(Arguments.of(\"UPPERCASE\", true, \"Upper case error\"));\n\n        // build passing test cases\n        for (final char c : firstChars.toCharArray()) {\n            final String s = String.format(\"%sMoreText\", c);\n            args.add(Arguments.of(s, true, String.format(\"testing: First character '%s'\", c)));\n        }\n\n        for (final char c : restChars.toCharArray()) {\n            final String s = String.format(\"Some%sText\", c);\n            args.add(Arguments.of(s, true, String.format(\"testing: Middle character '%s'\", c)));\n        }\n\n        // build failing test cases\n        for (final char c : notFirstChars.toCharArray()) {\n            final String s = String.format(\"%sMoreText\", c);\n            args.add(Arguments.of(s, false, String.format(\"testing: Bad first character '%s'\", c)));\n        }\n\n        for (final char c : notRestChars.toCharArray()) {\n            final String s = String.format(\"Some%sText\", c);\n            args.add(Arguments.of(s, false, String.format(\"testing: Bad middle character '%s'\", c)));\n        }\n\n        return args.stream();\n    }\n\n    @BeforeAll\n    public static void setup() {\n        StringBuilder sb = new StringBuilder();\n        final StringBuilder sb2 = new StringBuilder();\n        int idx;\n\n        for (final char c : PUNCTUATION.toCharArray()) {\n            if (Character.isJavaIdentifierPart(c)) {\n                sb.append(c);\n            } else {\n                sb2.append(c);\n            }\n        }\n        acceptablePunctuation = sb.toString();\n        notAcceptablePunctuation = sb2.toString();\n\n        sb = new StringBuilder();\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            sb.append(c);\n        }\n        additionalLongChars = sb.toString();\n\n        sb = new StringBuilder();\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            sb.append(c);\n        }\n        additionalOptonChars = sb.toString();\n\n        final String javaIdentifierPart = LETTERS + DIGITS + CURRENCY + acceptablePunctuation + COMBINING_MARK\n                + NON_SPACING_MARK + IDENTIFIER_IGNORABLE;\n\n        firstChars = additionalOptonChars + javaIdentifierPart;\n\n        sb = new StringBuilder(notAcceptablePunctuation).append(additionalLongChars);\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            while ((idx = sb.indexOf(Character.toString(c))) > -1) {\n                sb.deleteCharAt(idx);\n            }\n        }\n        notFirstChars = sb.toString();\n\n        restChars = additionalLongChars + javaIdentifierPart;\n        sb = new StringBuilder(notAcceptablePunctuation).append(additionalOptonChars);\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            while ((idx = sb.indexOf(Character.toString(c))) > -1) {\n                sb.deleteCharAt(idx);\n            }\n        }\n        notRestChars = sb.toString();\n\n    }\n\n    @Test\n    public void testExclusivity() {\n        /* since we modify acceptable chars by add and removing ADDITIONAL* chars we must verify that they do not exist in the\n         * base javaIdentiferPart that is used in OptionValidator to validate basic characters  */\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            assertFalse(Character.isJavaIdentifierPart(c), () -> String.format(\"'%s' should not be in 'ADDITIONAL_LONG_CHARS\", c));\n        }\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            assertFalse(Character.isJavaIdentifierPart(c), () -> String.format(\"'%s' should not be in 'ADDITIONAL_OPTION_CHARS\", c));\n        }\n    }\n\n    @ParameterizedTest(name = \"{2}\")\n    @MethodSource(\"optionParameters\")\n    public void validateTest(final String str, final boolean expected, final String name) {\n        if (expected) {\n            assertEquals(str, OptionValidator.validate(str));\n        } else {\n            assertThrows(IllegalArgumentException.class, () -> OptionValidator.validate(str));\n        }\n    }\n}", "definition": "public class OptionValidatorTest", "class_docstring": "", "name": "OptionValidatorTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final String LETTERS = \"a\\u00D1\";", "docstring": "\nExemplars of various types of characters\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LETTERS = \"a\\u00D1\"", "syntax_pass": true}, {"attribute_expression": "private static final String DIGITS = \"1\\u0661\\u06f2\\u0968\\uFF14\";", "docstring": " Fullwidth digits", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "DIGITS = \"1\\u0661\\u06f2\\u0968\\uFF14\"", "syntax_pass": true}, {"attribute_expression": "private static final String CURRENCY = \"\u20ac$\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "CURRENCY = \"\u20ac$\"", "syntax_pass": true}, {"attribute_expression": "private static final String PUNCTUATION = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";", "docstring": " the good and bad ones out in the setup.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PUNCTUATION = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"", "syntax_pass": true}, {"attribute_expression": "private static final String COMBINING_MARK = \"\\u0303\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "COMBINING_MARK = \"\\u0303\"", "syntax_pass": true}, {"attribute_expression": "private static final String NON_SPACING_MARK = \"\\u0CBF\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "NON_SPACING_MARK = \"\\u0CBF\"", "syntax_pass": true}, {"attribute_expression": "private static final String IDENTIFIER_IGNORABLE = \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\u0008\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "IDENTIFIER_IGNORABLE = \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\u0008\"", "syntax_pass": true}, {"attribute_expression": "private static String acceptablePunctuation;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "acceptablePunctuation", "syntax_pass": true}, {"attribute_expression": "private static String notAcceptablePunctuation;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "notAcceptablePunctuation", "syntax_pass": true}, {"attribute_expression": "private static String additionalOptonChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "additionalOptonChars", "syntax_pass": true}, {"attribute_expression": "private static String additionalLongChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "additionalLongChars", "syntax_pass": true}, {"attribute_expression": "private static String firstChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "firstChars", "syntax_pass": true}, {"attribute_expression": "private static String notFirstChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "notFirstChars", "syntax_pass": true}, {"attribute_expression": "private static String restChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "restChars", "syntax_pass": true}, {"attribute_expression": "private static String notRestChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "notRestChars", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static Stream<Arguments> optionParameters() {\n\n        final List<Arguments> args = new ArrayList<>();\n\n        args.add(Arguments.of(\"CamelCase\", true, \"Camel case error\"));\n        args.add(Arguments.of(\"Snake_case\", true, \"Snake case error\"));\n        args.add(Arguments.of(\"_leadingUnderscore\", true, \"Leading underscore error\"));\n        args.add(Arguments.of(\"kabob-case\", true, \"Kabob case error\"));\n        args.add(Arguments.of(\"-leadingDash\", false, \"Leading dash error\"));\n        args.add(Arguments.of(\"lowercase\", true, \"Lower case error\"));\n        args.add(Arguments.of(\"UPPERCASE\", true, \"Upper case error\"));\n\n        // build passing test cases\n        for (final char c : firstChars.toCharArray()) {\n            final String s = String.format(\"%sMoreText\", c);\n            args.add(Arguments.of(s, true, String.format(\"testing: First character '%s'\", c)));\n        }\n\n        for (final char c : restChars.toCharArray()) {\n            final String s = String.format(\"Some%sText\", c);\n            args.add(Arguments.of(s, true, String.format(\"testing: Middle character '%s'\", c)));\n        }\n\n        // build failing test cases\n        for (final char c : notFirstChars.toCharArray()) {\n            final String s = String.format(\"%sMoreText\", c);\n            args.add(Arguments.of(s, false, String.format(\"testing: Bad first character '%s'\", c)));\n        }\n\n        for (final char c : notRestChars.toCharArray()) {\n            final String s = String.format(\"Some%sText\", c);\n            args.add(Arguments.of(s, false, String.format(\"testing: Bad middle character '%s'\", c)));\n        }\n\n        return args.stream();\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Stream<Arguments>", "classes": []}, "name": "optionParameters", "params": [], "body": "                                                        {\n\n        final List<Arguments> args = new ArrayList<>();\n\n        args.add(Arguments.of(\"CamelCase\", true, \"Camel case error\"));\n        args.add(Arguments.of(\"Snake_case\", true, \"Snake case error\"));\n        args.add(Arguments.of(\"_leadingUnderscore\", true, \"Leading underscore error\"));\n        args.add(Arguments.of(\"kabob-case\", true, \"Kabob case error\"));\n        args.add(Arguments.of(\"-leadingDash\", false, \"Leading dash error\"));\n        args.add(Arguments.of(\"lowercase\", true, \"Lower case error\"));\n        args.add(Arguments.of(\"UPPERCASE\", true, \"Upper case error\"));\n\n        // build passing test cases\n        for (final char c : firstChars.toCharArray()) {\n            final String s = String.format(\"%sMoreText\", c);\n            args.add(Arguments.of(s, true, String.format(\"testing: First character '%s'\", c)));\n        }\n\n        for (final char c : restChars.toCharArray()) {\n            final String s = String.format(\"Some%sText\", c);\n            args.add(Arguments.of(s, true, String.format(\"testing: Middle character '%s'\", c)));\n        }\n\n        // build failing test cases\n        for (final char c : notFirstChars.toCharArray()) {\n            final String s = String.format(\"%sMoreText\", c);\n            args.add(Arguments.of(s, false, String.format(\"testing: Bad first character '%s'\", c)));\n        }\n\n        for (final char c : notRestChars.toCharArray()) {\n            final String s = String.format(\"Some%sText\", c);\n            args.add(Arguments.of(s, false, String.format(\"testing: Bad middle character '%s'\", c)));\n        }\n\n        return args.stream();\n    }", "signature": "private static Stream<Arguments> optionParameters()"}, {"syntax_pass": true, "original_string": "    @BeforeAll\n    public static void setup() {\n        StringBuilder sb = new StringBuilder();\n        final StringBuilder sb2 = new StringBuilder();\n        int idx;\n\n        for (final char c : PUNCTUATION.toCharArray()) {\n            if (Character.isJavaIdentifierPart(c)) {\n                sb.append(c);\n            } else {\n                sb2.append(c);\n            }\n        }\n        acceptablePunctuation = sb.toString();\n        notAcceptablePunctuation = sb2.toString();\n\n        sb = new StringBuilder();\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            sb.append(c);\n        }\n        additionalLongChars = sb.toString();\n\n        sb = new StringBuilder();\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            sb.append(c);\n        }\n        additionalOptonChars = sb.toString();\n\n        final String javaIdentifierPart = LETTERS + DIGITS + CURRENCY + acceptablePunctuation + COMBINING_MARK\n                + NON_SPACING_MARK + IDENTIFIER_IGNORABLE;\n\n        firstChars = additionalOptonChars + javaIdentifierPart;\n\n        sb = new StringBuilder(notAcceptablePunctuation).append(additionalLongChars);\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            while ((idx = sb.indexOf(Character.toString(c))) > -1) {\n                sb.deleteCharAt(idx);\n            }\n        }\n        notFirstChars = sb.toString();\n\n        restChars = additionalLongChars + javaIdentifierPart;\n        sb = new StringBuilder(notAcceptablePunctuation).append(additionalOptonChars);\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            while ((idx = sb.indexOf(Character.toString(c))) > -1) {\n                sb.deleteCharAt(idx);\n            }\n        }\n        notRestChars = sb.toString();\n\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeAll\n    public static", "marker_annotations": ["@BeforeAll"], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "setup", "params": [], "body": "                               {\n        StringBuilder sb = new StringBuilder();\n        final StringBuilder sb2 = new StringBuilder();\n        int idx;\n\n        for (final char c : PUNCTUATION.toCharArray()) {\n            if (Character.isJavaIdentifierPart(c)) {\n                sb.append(c);\n            } else {\n                sb2.append(c);\n            }\n        }\n        acceptablePunctuation = sb.toString();\n        notAcceptablePunctuation = sb2.toString();\n\n        sb = new StringBuilder();\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            sb.append(c);\n        }\n        additionalLongChars = sb.toString();\n\n        sb = new StringBuilder();\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            sb.append(c);\n        }\n        additionalOptonChars = sb.toString();\n\n        final String javaIdentifierPart = LETTERS + DIGITS + CURRENCY + acceptablePunctuation + COMBINING_MARK\n                + NON_SPACING_MARK + IDENTIFIER_IGNORABLE;\n\n        firstChars = additionalOptonChars + javaIdentifierPart;\n\n        sb = new StringBuilder(notAcceptablePunctuation).append(additionalLongChars);\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            while ((idx = sb.indexOf(Character.toString(c))) > -1) {\n                sb.deleteCharAt(idx);\n            }\n        }\n        notFirstChars = sb.toString();\n\n        restChars = additionalLongChars + javaIdentifierPart;\n        sb = new StringBuilder(notAcceptablePunctuation).append(additionalOptonChars);\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            while ((idx = sb.indexOf(Character.toString(c))) > -1) {\n                sb.deleteCharAt(idx);\n            }\n        }\n        notRestChars = sb.toString();\n\n    }", "signature": "@BeforeAll\n    public static void setup()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExclusivity() {\n        /* since we modify acceptable chars by add and removing ADDITIONAL* chars we must verify that they do not exist in the\n         * base javaIdentiferPart that is used in OptionValidator to validate basic characters  */\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            assertFalse(Character.isJavaIdentifierPart(c), () -> String.format(\"'%s' should not be in 'ADDITIONAL_LONG_CHARS\", c));\n        }\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            assertFalse(Character.isJavaIdentifierPart(c), () -> String.format(\"'%s' should not be in 'ADDITIONAL_OPTION_CHARS\", c));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExclusivity", "params": [], "body": "                                  {\n        /* since we modify acceptable chars by add and removing ADDITIONAL* chars we must verify that they do not exist in the\n         * base javaIdentiferPart that is used in OptionValidator to validate basic characters  */\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            assertFalse(Character.isJavaIdentifierPart(c), () -> String.format(\"'%s' should not be in 'ADDITIONAL_LONG_CHARS\", c));\n        }\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            assertFalse(Character.isJavaIdentifierPart(c), () -> String.format(\"'%s' should not be in 'ADDITIONAL_OPTION_CHARS\", c));\n        }\n    }", "signature": "@Test\n    public void testExclusivity()"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest(name = \"{2}\")\n    @MethodSource(\"optionParameters\")\n    public void validateTest(final String str, final boolean expected, final String name) {\n        if (expected) {\n            assertEquals(str, OptionValidator.validate(str));\n        } else {\n            assertThrows(IllegalArgumentException.class, () -> OptionValidator.validate(str));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest(name = \"{2}\")\n    @MethodSource(\"optionParameters\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@ParameterizedTest(name = \"{2}\")", "@MethodSource(\"optionParameters\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "validateTest", "params": [{"name": "str", "type": "String"}, {"name": "expected", "type": "boolean"}, {"name": "name", "type": "String"}], "body": "                                                                                          {\n        if (expected) {\n            assertEquals(str, OptionValidator.validate(str));\n        } else {\n            assertThrows(IllegalArgumentException.class, () -> OptionValidator.validate(str));\n        }\n    }", "signature": "@ParameterizedTest(name = \"{2}\")\n    @MethodSource(\"optionParameters\")\n    public void validateTest(final String str, final boolean expected, final String name)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/OptionBuilder_createTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class OptionBuilder_createTest {\n\n    @Test\n    public void testCreateWithLongOpt() {\n        // Given\n        OptionBuilder.withLongOpt(\"testLongOpt\");\n\n        // When\n        Option option = OptionBuilder.create();\n\n        // Then\n        assertNotNull(option);\n        assertEquals(\"testLongOpt\", option.getLongOpt());\n    }\n\n    @Test\n    public void testCreateWithoutLongOpt() {\n        // Given\n        OptionBuilder.withLongOpt(null);\n\n        // When & Then\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            OptionBuilder.create();\n        });\n        assertEquals(\"must specify longopt\", exception.getMessage());\n    }\n}\n", "file_hash": "81e2f993c8b58a858f8e89323a16d3585eea11f6153c871637e7e92bfc5d7731", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.*;"], "methods": [], "classes": [{"original_string": "public class OptionBuilder_createTest {\n\n    @Test\n    public void testCreateWithLongOpt() {\n        // Given\n        OptionBuilder.withLongOpt(\"testLongOpt\");\n\n        // When\n        Option option = OptionBuilder.create();\n\n        // Then\n        assertNotNull(option);\n        assertEquals(\"testLongOpt\", option.getLongOpt());\n    }\n\n    @Test\n    public void testCreateWithoutLongOpt() {\n        // Given\n        OptionBuilder.withLongOpt(null);\n\n        // When & Then\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            OptionBuilder.create();\n        });\n        assertEquals(\"must specify longopt\", exception.getMessage());\n    }\n}", "definition": "public class OptionBuilder_createTest", "class_docstring": "", "name": "OptionBuilder_createTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testCreateWithLongOpt() {\n        // Given\n        OptionBuilder.withLongOpt(\"testLongOpt\");\n\n        // When\n        Option option = OptionBuilder.create();\n\n        // Then\n        assertNotNull(option);\n        assertEquals(\"testLongOpt\", option.getLongOpt());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateWithLongOpt", "params": [], "body": "                                        {\n        // Given\n        OptionBuilder.withLongOpt(\"testLongOpt\");\n\n        // When\n        Option option = OptionBuilder.create();\n\n        // Then\n        assertNotNull(option);\n        assertEquals(\"testLongOpt\", option.getLongOpt());\n    }", "signature": "@Test\n    public void testCreateWithLongOpt()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCreateWithoutLongOpt() {\n        // Given\n        OptionBuilder.withLongOpt(null);\n\n        // When & Then\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            OptionBuilder.create();\n        });\n        assertEquals(\"must specify longopt\", exception.getMessage());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateWithoutLongOpt", "params": [], "body": "                                           {\n        // Given\n        OptionBuilder.withLongOpt(null);\n\n        // When & Then\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            OptionBuilder.create();\n        });\n        assertEquals(\"must specify longopt\", exception.getMessage());\n    }", "signature": "@Test\n    public void testCreateWithoutLongOpt()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/HelpFormatter_printUsageTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport org.junit.jupiter.api.Test;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class HelpFormatter_printUsageTest {\n\n    @Test\n    public void testPrintUsageWithSingleOption() {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").required().build());\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp -f <FILE>\\n\";\n        assertEquals(expected, sw.toString());\n    }\n\n    @Test\n    public void testPrintUsageWithOptionGroup() {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").longOpt(\"optionA\").desc(\"Option A\").build());\n        group.addOption(Option.builder(\"b\").longOpt(\"optionB\").desc(\"Option B\").build());\n        options.addOptionGroup(group);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp [-a | -b]\\n\";\n        assertEquals(expected, sw.toString());\n    }\n\n    @Test\n    public void testPrintUsageWithOptionComparator() {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        options.addOption(Option.builder(\"b\").longOpt(\"optionB\").desc(\"Option B\").required().build());\n        options.addOption(Option.builder(\"a\").longOpt(\"optionA\").desc(\"Option A\").required().build());\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp -a -b\\n\";\n        assertEquals(expected, sw.toString());\n    }\n}\n", "file_hash": "da0711405ffa4af6d2e3712cba6c390b55728396415ec1c7062a599eaa6d0b46", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import org.junit.jupiter.api.Test;", "import java.io.PrintWriter;", "import java.io.StringWriter;", "import java.util.ArrayList;", "import java.util.List;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class HelpFormatter_printUsageTest {\n\n    @Test\n    public void testPrintUsageWithSingleOption() {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").required().build());\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp -f <FILE>\\n\";\n        assertEquals(expected, sw.toString());\n    }\n\n    @Test\n    public void testPrintUsageWithOptionGroup() {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").longOpt(\"optionA\").desc(\"Option A\").build());\n        group.addOption(Option.builder(\"b\").longOpt(\"optionB\").desc(\"Option B\").build());\n        options.addOptionGroup(group);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp [-a | -b]\\n\";\n        assertEquals(expected, sw.toString());\n    }\n\n    @Test\n    public void testPrintUsageWithOptionComparator() {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        options.addOption(Option.builder(\"b\").longOpt(\"optionB\").desc(\"Option B\").required().build());\n        options.addOption(Option.builder(\"a\").longOpt(\"optionA\").desc(\"Option A\").required().build());\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp -a -b\\n\";\n        assertEquals(expected, sw.toString());\n    }\n}", "definition": "public class HelpFormatter_printUsageTest", "class_docstring": "", "name": "HelpFormatter_printUsageTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testPrintUsageWithSingleOption() {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").required().build());\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp -f <FILE>\\n\";\n        assertEquals(expected, sw.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintUsageWithSingleOption", "params": [], "body": "                                                 {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"FILE\").desc(\"The file to be processed\").required().build());\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp -f <FILE>\\n\";\n        assertEquals(expected, sw.toString());\n    }", "signature": "@Test\n    public void testPrintUsageWithSingleOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintUsageWithOptionGroup() {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").longOpt(\"optionA\").desc(\"Option A\").build());\n        group.addOption(Option.builder(\"b\").longOpt(\"optionB\").desc(\"Option B\").build());\n        options.addOptionGroup(group);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp [-a | -b]\\n\";\n        assertEquals(expected, sw.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintUsageWithOptionGroup", "params": [], "body": "                                                {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").longOpt(\"optionA\").desc(\"Option A\").build());\n        group.addOption(Option.builder(\"b\").longOpt(\"optionB\").desc(\"Option B\").build());\n        options.addOptionGroup(group);\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp [-a | -b]\\n\";\n        assertEquals(expected, sw.toString());\n    }", "signature": "@Test\n    public void testPrintUsageWithOptionGroup()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintUsageWithOptionComparator() {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        options.addOption(Option.builder(\"b\").longOpt(\"optionB\").desc(\"Option B\").required().build());\n        options.addOption(Option.builder(\"a\").longOpt(\"optionA\").desc(\"Option A\").required().build());\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp -a -b\\n\";\n        assertEquals(expected, sw.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintUsageWithOptionComparator", "params": [], "body": "                                                     {\n        // Given\n        HelpFormatter formatter = new HelpFormatter();\n        Options options = new Options();\n        options.addOption(Option.builder(\"b\").longOpt(\"optionB\").desc(\"Option B\").required().build());\n        options.addOption(Option.builder(\"a\").longOpt(\"optionA\").desc(\"Option A\").required().build());\n        StringWriter sw = new StringWriter();\n        PrintWriter pw = new PrintWriter(sw);\n\n        // When\n        formatter.printUsage(pw, 80, \"myapp\", options);\n        pw.flush();\n\n        // Then\n        String expected = \"usage: myapp -a -b\\n\";\n        assertEquals(expected, sw.toString());\n    }", "signature": "@Test\n    public void testPrintUsageWithOptionComparator()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/DisablePartialMatchingTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\npublic class DisablePartialMatchingTest {\n    @Test\n    public void testDisablePartialMatching() throws Exception {\n        final CommandLineParser parser = new DefaultParser(false);\n\n        final Options options = new Options();\n\n        options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n        options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n        options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-de\", \"--option=foobar\"});\n\n        assertTrue(line.hasOption(\"debug\"), \"There should be an option debug in any case...\");\n        assertTrue(line.hasOption(\"extract\"), \"There should be an extract option because partial matching is off\");\n        assertTrue(line.hasOption(\"option\"), \"There should be an option option with a argument value\");\n    }\n\n    @Test\n    public void testRegularPartialMatching() throws Exception {\n        final CommandLineParser parser = new DefaultParser();\n\n        final Options options = new Options();\n\n        options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n        options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n        options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-de\", \"--option=foobar\"});\n\n        assertTrue(line.hasOption(\"debug\"), \"There should be an option debug in any case...\");\n        assertFalse(line.hasOption(\"extract\"), \"There should not be an extract option because partial matching only selects debug\");\n        assertTrue(line.hasOption(\"option\"), \"There should be an option option with a argument value\");\n    }\n}\n", "file_hash": "ad56c8c23591aa6ef813dc0da64ee038e3168ad78f00de035d7c0b281761dac1", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class DisablePartialMatchingTest {\n    @Test\n    public void testDisablePartialMatching() throws Exception {\n        final CommandLineParser parser = new DefaultParser(false);\n\n        final Options options = new Options();\n\n        options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n        options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n        options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-de\", \"--option=foobar\"});\n\n        assertTrue(line.hasOption(\"debug\"), \"There should be an option debug in any case...\");\n        assertTrue(line.hasOption(\"extract\"), \"There should be an extract option because partial matching is off\");\n        assertTrue(line.hasOption(\"option\"), \"There should be an option option with a argument value\");\n    }\n\n    @Test\n    public void testRegularPartialMatching() throws Exception {\n        final CommandLineParser parser = new DefaultParser();\n\n        final Options options = new Options();\n\n        options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n        options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n        options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-de\", \"--option=foobar\"});\n\n        assertTrue(line.hasOption(\"debug\"), \"There should be an option debug in any case...\");\n        assertFalse(line.hasOption(\"extract\"), \"There should not be an extract option because partial matching only selects debug\");\n        assertTrue(line.hasOption(\"option\"), \"There should be an option option with a argument value\");\n    }\n}", "definition": "public class DisablePartialMatchingTest", "class_docstring": "", "name": "DisablePartialMatchingTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testDisablePartialMatching() throws Exception {\n        final CommandLineParser parser = new DefaultParser(false);\n\n        final Options options = new Options();\n\n        options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n        options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n        options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-de\", \"--option=foobar\"});\n\n        assertTrue(line.hasOption(\"debug\"), \"There should be an option debug in any case...\");\n        assertTrue(line.hasOption(\"extract\"), \"There should be an extract option because partial matching is off\");\n        assertTrue(line.hasOption(\"option\"), \"There should be an option option with a argument value\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDisablePartialMatching", "params": [], "body": "                                                              {\n        final CommandLineParser parser = new DefaultParser(false);\n\n        final Options options = new Options();\n\n        options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n        options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n        options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-de\", \"--option=foobar\"});\n\n        assertTrue(line.hasOption(\"debug\"), \"There should be an option debug in any case...\");\n        assertTrue(line.hasOption(\"extract\"), \"There should be an extract option because partial matching is off\");\n        assertTrue(line.hasOption(\"option\"), \"There should be an option option with a argument value\");\n    }", "signature": "@Test\n    public void testDisablePartialMatching()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRegularPartialMatching() throws Exception {\n        final CommandLineParser parser = new DefaultParser();\n\n        final Options options = new Options();\n\n        options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n        options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n        options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-de\", \"--option=foobar\"});\n\n        assertTrue(line.hasOption(\"debug\"), \"There should be an option debug in any case...\");\n        assertFalse(line.hasOption(\"extract\"), \"There should not be an extract option because partial matching only selects debug\");\n        assertTrue(line.hasOption(\"option\"), \"There should be an option option with a argument value\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRegularPartialMatching", "params": [], "body": "                                                              {\n        final CommandLineParser parser = new DefaultParser();\n\n        final Options options = new Options();\n\n        options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n        options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n        options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-de\", \"--option=foobar\"});\n\n        assertTrue(line.hasOption(\"debug\"), \"There should be an option debug in any case...\");\n        assertFalse(line.hasOption(\"extract\"), \"There should not be an extract option because partial matching only selects debug\");\n        assertTrue(line.hasOption(\"option\"), \"There should be an option option with a argument value\");\n    }", "signature": "@Test\n    public void testRegularPartialMatching()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/HelpFormatterTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.when;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.UncheckedIOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.cli.HelpFormatter.Builder;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n\n/**\n * Test case for the HelpFormatter class.\n */\npublic class HelpFormatterTest {\n    private static final String EOL = System.lineSeparator();\n\n    static Stream<Arguments> deprecatedOptionsProvider() {\n        final List<Arguments> lst = new ArrayList<>();\n        Option option = Option.builder(\"a\").longOpt(\"aaa\").desc(\"dddd dddd dddd\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"now\")\n                        .setDescription(\"Why why why\").get())\n                .build();\n\n        HelpFormatter hf = HelpFormatter.builder().get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated] dddd dddd dddd\"));\n\n\n        hf = HelpFormatter.builder().setShowDeprecated(false).get();\n        lst.add(Arguments.of(hf, option, \"dddd dddd dddd\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(true).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated] dddd dddd dddd\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(o -> String.format(\"%s [%s]\", HelpFormatter.getDescription(o), o.getDeprecated())).get();\n        lst.add(Arguments.of(hf, option, \"dddd dddd dddd [Deprecated for removal since now: Why why why]\"));\n\n        option = Option.builder(\"a\").longOpt(\"aaa\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"now\")\n                        .setDescription(\"Why why why\").get())\n                .build();\n\n        hf = HelpFormatter.builder().get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated]\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(false).get();\n        lst.add(Arguments.of(hf, option, \"\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(true).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated]\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(o -> String.format(\"%s [%s]\", HelpFormatter.getDescription(o), o.getDeprecated())).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated for removal since now: Why why why]\"));\n\n        return lst.stream();\n    }\n\n    @Test\n    public void testAccessors() {\n        final HelpFormatter formatter = new HelpFormatter();\n\n        formatter.setArgName(\"argname\");\n        assertEquals(\"argname\", formatter.getArgName(), \"arg name\");\n\n        formatter.setDescPadding(3);\n        assertEquals(3, formatter.getDescPadding(), \"desc padding\");\n\n        formatter.setLeftPadding(7);\n        assertEquals(7, formatter.getLeftPadding(), \"left padding\");\n\n        formatter.setLongOptPrefix(\"~~\");\n        assertEquals(\"~~\", formatter.getLongOptPrefix(), \"long opt prefix\");\n\n        formatter.setNewLine(\"\\n\");\n        assertEquals(\"\\n\", formatter.getNewLine(), \"new line\");\n\n        formatter.setOptPrefix(\"~\");\n        assertEquals(\"~\", formatter.getOptPrefix(), \"opt prefix\");\n\n        formatter.setSyntaxPrefix(\"-> \");\n        assertEquals(\"-> \", formatter.getSyntaxPrefix(), \"syntax prefix\");\n\n        formatter.setWidth(80);\n        assertEquals(80, formatter.getWidth(), \"width\");\n    }\n\n    @Test\n    public void testAutomaticUsage() {\n        final HelpFormatter hf = new HelpFormatter();\n        Options options;\n        String expected = \"usage: app [-a]\";\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n        hf.printUsage(pw, 60, \"app\", options);\n        pw.flush();\n        assertEquals(expected, out.toString().trim(), \"simple auto usage\");\n        out.reset();\n\n        expected = \"usage: app [-a] [-b]\";\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\").addOption(\"b\", false, \"bbb\");\n        hf.printUsage(pw, 60, \"app\", options);\n        pw.flush();\n        assertEquals(expected, out.toString().trim(), \"simple auto usage\");\n        out.reset();\n    }\n\n    @Test\n    public void testDefaultArgName() {\n        final Option option = Option.builder(\"f\").hasArg().required(true).build();\n\n        final Options options = new Options();\n        options.addOption(option);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.setArgName(\"argument\");\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f <argument>\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testFindWrapPos() {\n        final HelpFormatter hf = new HelpFormatter();\n\n        String text = \"This is a test.\";\n        // text width should be max 8; the wrap position is 7\n        assertEquals(7, hf.findWrapPos(text, 8, 0), \"wrap position\");\n\n        // starting from 8 must give -1 - the wrap pos is after end\n        assertEquals(-1, hf.findWrapPos(text, 8, 8), \"wrap position 2\");\n\n        // words longer than the width are cut\n        text = \"aaaa aa\";\n        assertEquals(3, hf.findWrapPos(text, 3, 0), \"wrap position 3\");\n\n        // last word length is equal to the width\n        text = \"aaaaaa aaaaaa\";\n        assertEquals(6, hf.findWrapPos(text, 6, 0), \"wrap position 4\");\n        assertEquals(-1, hf.findWrapPos(text, 6, 7), \"wrap position 4\");\n\n        text = \"aaaaaa\\n aaaaaa\";\n        assertEquals(7, hf.findWrapPos(text, 6, 0), \"wrap position 5\");\n\n        text = \"aaaaaa\\t aaaaaa\";\n        assertEquals(7, hf.findWrapPos(text, 6, 0), \"wrap position 6\");\n    }\n\n    @Test\n    public void testHeaderStartingWithLineSeparator0() {\n        // related to Bugzilla #21215\n        final Options options = new Options();\n        final HelpFormatter formatter = new HelpFormatter();\n        final String header = EOL + \"Header\";\n        final String footer = \"Footer\";\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testHeaderStartingWithLineSeparator1() {\n        // related to Bugzilla #21215\n        final Options options = new Options();\n        final String header = EOL + \"Header\";\n        final String footer = \"Footer\";\n        final Builder builder = HelpFormatter.builder();\n        StringWriter out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"\" + EOL +\n                \"Header\" + EOL +\n                \"\" + EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(80, \"foobar\", header, options, footer);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer, false);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", options, false);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testHelpWithLongOptSeparator() {\n        final Options options = new Options();\n        options.addOption(\"f\", true, \"the file\");\n        options.addOption(Option.builder(\"s\").longOpt(\"size\").desc(\"the size\").hasArg().argName(\"SIZE\").build());\n        options.addOption(Option.builder().longOpt(\"age\").desc(\"the age\").hasArg().build());\n\n        final HelpFormatter formatter = new HelpFormatter();\n        assertEquals(HelpFormatter.DEFAULT_LONG_OPT_SEPARATOR, formatter.getLongOptSeparator());\n        formatter.setLongOptSeparator(\"=\");\n        assertEquals(\"=\", formatter.getLongOptSeparator());\n\n        final StringWriter out = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(out), 80, \"create\", \"header\", options, 2, 2, \"footer\");\n\n        //@formatter:off\n        assertEquals(\n                \"usage: create\" + EOL +\n                \"header\" + EOL +\n                \"     --age=<arg>    the age\" + EOL +\n                \"  -f <arg>          the file\" + EOL +\n                \"  -s,--size=<SIZE>  the size\" + EOL +\n                \"footer\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testIndentedHeaderAndFooter() {\n        // related to CLI-207\n        final Options options = new Options();\n        final HelpFormatter formatter = new HelpFormatter();\n        final String header = \"  Header1\\n  Header2\";\n        final String footer = \"  Footer1\\n  Footer2\";\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"  Header1\" + EOL +\n                \"  Header2\" + EOL +\n                \"\" + EOL +\n                \"  Footer1\" + EOL +\n                \"  Footer2\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testOptionWithoutShortFormat() {\n        // related to Bugzilla #19383 (CLI-67)\n        final Options options = new Options();\n        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb\"));\n        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", \"\", options, 2, 2, \"\", true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar [-a] [--bbb] [-c]\" + EOL +\n                \"  -a,--aaa  aaaaaaa\" + EOL +\n                \"     --bbb  bbbbbbb\" + EOL +\n                \"  -c        ccccccc\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testOptionWithoutShortFormat2() {\n        // related to Bugzilla #27635 (CLI-26)\n        final Option help = new Option(\"h\", \"help\", false, \"print this message\");\n        final Option version = new Option(\"v\", \"version\", false, \"print version information\");\n        final Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n        final Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n        //@formatter:off\n        final Option timeLimit = Option.builder(\"l\")\n                .longOpt(\"limit\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Set time limit for execution, in mintues\")\n                .build();\n        final Option age = Option.builder(\"a\").longOpt(\"age\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Age (in days) of cache item before being recomputed\")\n                .build();\n        final Option server = Option.builder(\"s\").longOpt(\"server\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"The NLT server address\")\n                .build();\n        final Option numResults = Option.builder(\"r\").longOpt(\"results\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Number of results per item\")\n                .build();\n        final Option configFile = Option.builder().longOpt(\"config\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Use the specified configuration file\")\n                .build();\n        //@formatter:on\n\n        final Options mOptions = new Options();\n        mOptions.addOption(help);\n        mOptions.addOption(version);\n        mOptions.addOption(newRun);\n        mOptions.addOption(trackerRun);\n        mOptions.addOption(timeLimit);\n        mOptions.addOption(age);\n        mOptions.addOption(server);\n        mOptions.addOption(numResults);\n        mOptions.addOption(configFile);\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final String eol = System.lineSeparator();\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"commandline\", \"header\", mOptions, 2, 2, \"footer\", true);\n        //@formatter:off\n        assertEquals(\n                \"usage: commandline [-a <arg>] [--config <arg>] [-h] [-l <arg>] [-n] [-r <arg>]\" + eol +\n                \"       [-s <arg>] [-t] [-v]\" + eol +\n                \"header\" + eol +\n                \"  -a,--age <arg>      Age (in days) of cache item before being recomputed\" + eol +\n                \"     --config <arg>   Use the specified configuration file\" + eol +\n                \"  -h,--help           print this message\" + eol +\n                \"  -l,--limit <arg>    Set time limit for execution, in mintues\" + eol +\n                \"  -n,--new            Create NLT cache entries only for new items\" + eol +\n                \"  -r,--results <arg>  Number of results per item\" + eol +\n                \"  -s,--server <arg>   The NLT server address\" + eol +\n                \"  -t,--tracker        Create NLT cache entries only for tracker items\" + eol +\n                \"  -v,--version        print version information\" + eol +\n                \"footer\" + eol,\n                out.toString());\n        //@formatter:on\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"deprecatedOptionsProvider\")\n    public void testPrintDeprecatedOptions(final HelpFormatter hf, final Option option, final String expectedTxt) {\n        final StringBuffer sb = new StringBuffer();\n\n        final int leftPad = 1;\n        final int descPad = 3;\n        final String lpad = hf.createPadding(leftPad);\n        final String dpad = hf.createPadding(descPad);\n        Options options;\n        final StringBuilder expected = new StringBuilder().append(lpad).append(\"-a,--aaa\");\n\n        options = new Options().addOption(option);\n        if (expectedTxt.length() > 0) {\n            expected.append(dpad).append(expectedTxt);\n        }\n        hf.renderOptions(sb, 160, options, leftPad, descPad);\n        assertEquals(expected.toString(), sb.toString());\n    }\n\n    @Test\n    public void testPrintHelpNewlineFooter() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"b\");\n\n        formatter.printHelp(\n            pw,\n            80,\n            \"test\" + EOL,\n            \"header\" + EOL,\n            options,\n            0,\n            0,\n            EOL\n        );\n        final String expected = \"usage: test\" + EOL +\n                          \"header\" + EOL +\n                          \"-ab\" + EOL +\n                          EOL;\n        pw.flush();\n        assertEquals(expected, out.toString(), \"footer newline\");\n    }\n\n    @Test\n    public void testPrintHelpNewlineHeader() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"b\");\n\n        formatter.printHelp(\n            pw,\n            80,\n            \"test\" + EOL,\n            EOL,\n            options,\n            0,\n            0,\n            \"footer\" + EOL\n        );\n        final String expected = \"usage: test\" + EOL +\n                          EOL +\n                          \"-ab\" + EOL +\n                          \"footer\" + EOL;\n        pw.flush();\n        assertEquals(expected, out.toString(), \"header newline\");\n    }\n\n    @Test\n    public void testPrintHelpWithEmptySyntax() {\n        final HelpFormatter formatter = new HelpFormatter();\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options()), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options(), true), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options(), false), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(\"\", new Options(), true), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(\"\", new Options(), false), \"null command line syntax should be rejected\");\n    }\n\n    @Test\n    public void testPrintHelpWithSince() {\n        final String [] expected = {\"usage: Command syntax\", \"Header\", \"Options            Since   Description\",\n                \"  -n,--no-since    -          Description for n\", \"  -W,--with-since  1.19.0     Descripton for W\", \"footer\"};\n        final Options options = new Options()\n                .addOption(Option.builder(\"W\").longOpt(\"with-since\").since(\"1.19.0\").desc(\"Descripton for W\").build())\n                .addOption(Option.builder(\"n\").longOpt(\"no-since\").desc(\"Description for n\").build());\n\n        final HelpFormatter formatter = HelpFormatter.builder().setShowSince(true).get();\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (PrintWriter pw = new PrintWriter(new OutputStreamWriter(baos))) {\n            formatter.printHelp(pw, 80, \"Command syntax\", \"Header\", options, 2, 5, \"footer\", false);\n        }\n        assertArrayEquals(expected, baos.toString().split(System.lineSeparator()));\n    }\n\n    @Test\n    public void testPrintOptionGroupUsage() {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").build());\n        group.addOption(Option.builder(\"b\").build());\n        group.addOption(Option.builder(\"c\").build());\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app [-a | -b | -c]\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testPrintOptions() {\n        final StringBuffer sb = new StringBuffer();\n        final HelpFormatter hf = new HelpFormatter();\n        final int leftPad = 1;\n        final int descPad = 3;\n        final String lpad = hf.createPadding(leftPad);\n        final String dpad = hf.createPadding(descPad);\n        Options options;\n        String expected;\n\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa aaaa aaaa\";\n        hf.renderOptions(sb, 60, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"simple non-wrapped option\");\n\n        int nextLineTabStop = leftPad + descPad + \"-a\".length();\n        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa\" + EOL + hf.createPadding(nextLineTabStop) + \"aaaa aaaa\";\n        sb.setLength(0);\n        hf.renderOptions(sb, nextLineTabStop + 17, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"simple wrapped option\");\n\n        options = new Options().addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\");\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd dddd dddd\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 60, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"long non-wrapped option\");\n\n        nextLineTabStop = leftPad + descPad + \"-a,--aaa\".length();\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + EOL + hf.createPadding(nextLineTabStop) + \"dddd dddd\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"long wrapped option\");\n\n        options = new Options().addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\").addOption(\"b\", false, \"feeee eeee eeee eeee\");\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + EOL + hf.createPadding(nextLineTabStop) + \"dddd dddd\" + EOL + lpad + \"-b      \" + dpad\n            + \"feeee eeee\" + EOL + hf.createPadding(nextLineTabStop) + \"eeee eeee\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"multiple wrapped options\");\n    }\n\n    @Test\n    public void testPrintOptionWithEmptyArgNameUsage() {\n        final Option option = new Option(\"f\", true, null);\n        option.setArgName(\"\");\n        option.setRequired(true);\n\n        final Options options = new Options();\n        options.addOption(option);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testPrintRequiredOptionGroupUsage() {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").build());\n        group.addOption(Option.builder(\"b\").build());\n        group.addOption(Option.builder(\"c\").build());\n        group.setRequired(true);\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -a | -b | -c\" + EOL, out.toString());\n    }\n\n    // uses the test for CLI-131 to implement CLI-155\n    @Test\n    public void testPrintSortedUsage() {\n        final Options opts = new Options();\n        opts.addOption(new Option(\"a\", \"first\"));\n        opts.addOption(new Option(\"b\", \"second\"));\n        opts.addOption(new Option(\"c\", \"third\"));\n\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.setOptionComparator((opt1, opt2) -> opt2.getKey().compareToIgnoreCase(opt1.getKey()));\n\n        final StringWriter out = new StringWriter();\n        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n\n        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testPrintSortedUsageWithNullComparator() {\n        final Options opts = new Options();\n        opts.addOption(new Option(\"c\", \"first\"));\n        opts.addOption(new Option(\"b\", \"second\"));\n        opts.addOption(new Option(\"a\", \"third\"));\n\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.setOptionComparator(null);\n\n        final StringWriter out = new StringWriter();\n        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n\n        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n    }\n\n    // This test ensures the options are properly sorted\n    // See https://issues.apache.org/jira/browse/CLI-131\n    @Test\n    public void testPrintUsage() {\n        final Option optionA = new Option(\"a\", \"first\");\n        final Option optionB = new Option(\"b\", \"second\");\n        final Option optionC = new Option(\"c\", \"third\");\n        final Options opts = new Options();\n        opts.addOption(optionA);\n        opts.addOption(optionB);\n        opts.addOption(optionC);\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n        try (PrintWriter printWriter = new PrintWriter(bytesOut)) {\n            helpFormatter.printUsage(printWriter, 80, \"app\", opts);\n        }\n        assertEquals(\"usage: app [-a] [-b] [-c]\" + EOL, bytesOut.toString());\n    }\n\n    @Test\n    public void testRenderSince() throws IOException {\n        final String[] expected = {\"Options            Since   Description\", \"  -n,--no-since    -          Description for n\",\n            \"  -W,--with-since  1.19.0     Descripton for W\"};\n        final Options options = new Options()\n                .addOption(Option.builder(\"W\").longOpt(\"with-since\").since(\"1.19.0\").desc(\"Descripton for W\").build())\n                .addOption(Option.builder(\"n\").longOpt(\"no-since\").desc(\"Description for n\").build());\n        final HelpFormatter formatter = HelpFormatter.builder().setShowSince(true).get();\n\n        final StringBuffer sb = new StringBuffer();\n        formatter.renderOptions(sb, 50, options, 2, 5);\n        assertArrayEquals(expected, sb.toString().split(System.lineSeparator()));\n        // check internal exception handling for coverage\n        final HelpFormatter spy = spy(formatter);\n        when(spy.appendOptions(sb, 50, options, 2, 5)).thenThrow(IOException.class);\n        assertThrows(UncheckedIOException.class, () -> spy.renderOptions(sb, 50, options, 2, 5));\n    }\n\n    @Test\n    public void testRenderWrappedTextMultiLine() {\n        // multi line text\n        final int width = 16;\n        final int padding = 0;\n        //@formatter:off\n        final String expected = \"aaaa aaaa aaaa\" + EOL +\n                                \"aaaaaa\" + EOL +\n                                \"aaaaa\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, expected);\n        assertEquals(expected, sb.toString(), \"multi line text\");\n    }\n\n    @Test\n    public void testRenderWrappedTextMultiLinePadded() {\n        // multi-line padded text\n        final int width = 16;\n        final int padding = 4;\n        //@formatter:off\n        final String text = \"aaaa aaaa aaaa\" + EOL +\n                      \"aaaaaa\" + EOL +\n                      \"aaaaa\";\n        final String expected = \"aaaa aaaa aaaa\" + EOL +\n                          \"    aaaaaa\" + EOL +\n                          \"    aaaaa\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"multi-line padded text\");\n    }\n\n    @Test\n    public void testRenderWrappedTextSingleLine() throws IOException {\n        // single line text\n        final int width = 12;\n        final int padding = 0;\n        final String text = \"This is a test.\";\n        final String expected = \"This is a\" + EOL + \"test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line text\");\n        // check internal exception handling for coverage\n        final HelpFormatter spy = spy(new HelpFormatter());\n        when(spy.appendWrappedText(sb, width, padding, text)).thenThrow(IOException.class);\n        assertThrows(UncheckedIOException.class, () -> spy.renderWrappedText(sb, width, padding, text));\n\n    }\n\n    @Test\n    public void testRenderWrappedTextSingleLinePadded() {\n        // single line padded text\n        final int width = 12;\n        final int padding = 4;\n        final String text = \"This is a test.\";\n        final String expected = \"This is a\" + EOL + \"    test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line padded text\");\n    }\n\n    @Test\n    public void testRenderWrappedTextSingleLinePadded2() {\n        // single line padded text 2\n        final int width = 53;\n        final int padding = 24;\n        //@formatter:off\n        final String text = \"  -p,--period <PERIOD>  PERIOD is time duration of form \" +\n                            \"DATE[-DATE] where DATE has form YYYY[MM[DD]]\";\n        final String expected = \"  -p,--period <PERIOD>  PERIOD is time duration of\" + EOL +\n                                \"                        form DATE[-DATE] where DATE\" + EOL +\n                                \"                        has form YYYY[MM[DD]]\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line padded text 2\");\n    }\n\n    @Test\n    public void testRenderWrappedTextWordCut() {\n        final int width = 7;\n        final int padding = 0;\n        final String text = \"Thisisatest.\";\n        final String expected = \"Thisisa\" + EOL + \"test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"cut and wrap\");\n    }\n\n    @Test\n    public void testRtrim() {\n        final HelpFormatter formatter = new HelpFormatter();\n\n        assertNull(formatter.rtrim(null));\n        assertEquals(\"\", formatter.rtrim(\"\"));\n        assertEquals(\"  foo\", formatter.rtrim(\"  foo  \"));\n    }\n\n    @Test\n    public void testUsageWithLongOptSeparator() {\n        final Options options = new Options();\n        options.addOption(\"f\", true, \"the file\");\n        options.addOption(Option.builder(\"s\").longOpt(\"size\").desc(\"the size\").hasArg().argName(\"SIZE\").build());\n        options.addOption(Option.builder().longOpt(\"age\").desc(\"the age\").hasArg().build());\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.setLongOptSeparator(\"=\");\n\n        final StringWriter out = new StringWriter();\n\n        formatter.printUsage(new PrintWriter(out), 80, \"create\", options);\n\n        assertEquals(\"usage: create [--age=<arg>] [-f <arg>] [-s <SIZE>]\", out.toString().trim());\n    }\n}\n", "file_hash": "bca9ca508cc52d18373ad48fda9e1db542883864f79c017a64cc597375791a6a", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertArrayEquals;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import static org.mockito.Mockito.spy;", "import static org.mockito.Mockito.when;", "import java.io.ByteArrayOutputStream;", "import java.io.IOException;", "import java.io.OutputStreamWriter;", "import java.io.PrintWriter;", "import java.io.StringWriter;", "import java.io.UncheckedIOException;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.stream.Stream;", "import org.apache.commons.cli.HelpFormatter.Builder;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.provider.Arguments;", "import org.junit.jupiter.params.provider.MethodSource;"], "methods": [], "classes": [{"original_string": "public class HelpFormatterTest {\n    private static final String EOL = System.lineSeparator();\n\n    static Stream<Arguments> deprecatedOptionsProvider() {\n        final List<Arguments> lst = new ArrayList<>();\n        Option option = Option.builder(\"a\").longOpt(\"aaa\").desc(\"dddd dddd dddd\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"now\")\n                        .setDescription(\"Why why why\").get())\n                .build();\n\n        HelpFormatter hf = HelpFormatter.builder().get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated] dddd dddd dddd\"));\n\n\n        hf = HelpFormatter.builder().setShowDeprecated(false).get();\n        lst.add(Arguments.of(hf, option, \"dddd dddd dddd\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(true).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated] dddd dddd dddd\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(o -> String.format(\"%s [%s]\", HelpFormatter.getDescription(o), o.getDeprecated())).get();\n        lst.add(Arguments.of(hf, option, \"dddd dddd dddd [Deprecated for removal since now: Why why why]\"));\n\n        option = Option.builder(\"a\").longOpt(\"aaa\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"now\")\n                        .setDescription(\"Why why why\").get())\n                .build();\n\n        hf = HelpFormatter.builder().get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated]\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(false).get();\n        lst.add(Arguments.of(hf, option, \"\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(true).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated]\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(o -> String.format(\"%s [%s]\", HelpFormatter.getDescription(o), o.getDeprecated())).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated for removal since now: Why why why]\"));\n\n        return lst.stream();\n    }\n\n    @Test\n    public void testAccessors() {\n        final HelpFormatter formatter = new HelpFormatter();\n\n        formatter.setArgName(\"argname\");\n        assertEquals(\"argname\", formatter.getArgName(), \"arg name\");\n\n        formatter.setDescPadding(3);\n        assertEquals(3, formatter.getDescPadding(), \"desc padding\");\n\n        formatter.setLeftPadding(7);\n        assertEquals(7, formatter.getLeftPadding(), \"left padding\");\n\n        formatter.setLongOptPrefix(\"~~\");\n        assertEquals(\"~~\", formatter.getLongOptPrefix(), \"long opt prefix\");\n\n        formatter.setNewLine(\"\\n\");\n        assertEquals(\"\\n\", formatter.getNewLine(), \"new line\");\n\n        formatter.setOptPrefix(\"~\");\n        assertEquals(\"~\", formatter.getOptPrefix(), \"opt prefix\");\n\n        formatter.setSyntaxPrefix(\"-> \");\n        assertEquals(\"-> \", formatter.getSyntaxPrefix(), \"syntax prefix\");\n\n        formatter.setWidth(80);\n        assertEquals(80, formatter.getWidth(), \"width\");\n    }\n\n    @Test\n    public void testAutomaticUsage() {\n        final HelpFormatter hf = new HelpFormatter();\n        Options options;\n        String expected = \"usage: app [-a]\";\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n        hf.printUsage(pw, 60, \"app\", options);\n        pw.flush();\n        assertEquals(expected, out.toString().trim(), \"simple auto usage\");\n        out.reset();\n\n        expected = \"usage: app [-a] [-b]\";\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\").addOption(\"b\", false, \"bbb\");\n        hf.printUsage(pw, 60, \"app\", options);\n        pw.flush();\n        assertEquals(expected, out.toString().trim(), \"simple auto usage\");\n        out.reset();\n    }\n\n    @Test\n    public void testDefaultArgName() {\n        final Option option = Option.builder(\"f\").hasArg().required(true).build();\n\n        final Options options = new Options();\n        options.addOption(option);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.setArgName(\"argument\");\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f <argument>\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testFindWrapPos() {\n        final HelpFormatter hf = new HelpFormatter();\n\n        String text = \"This is a test.\";\n        // text width should be max 8; the wrap position is 7\n        assertEquals(7, hf.findWrapPos(text, 8, 0), \"wrap position\");\n\n        // starting from 8 must give -1 - the wrap pos is after end\n        assertEquals(-1, hf.findWrapPos(text, 8, 8), \"wrap position 2\");\n\n        // words longer than the width are cut\n        text = \"aaaa aa\";\n        assertEquals(3, hf.findWrapPos(text, 3, 0), \"wrap position 3\");\n\n        // last word length is equal to the width\n        text = \"aaaaaa aaaaaa\";\n        assertEquals(6, hf.findWrapPos(text, 6, 0), \"wrap position 4\");\n        assertEquals(-1, hf.findWrapPos(text, 6, 7), \"wrap position 4\");\n\n        text = \"aaaaaa\\n aaaaaa\";\n        assertEquals(7, hf.findWrapPos(text, 6, 0), \"wrap position 5\");\n\n        text = \"aaaaaa\\t aaaaaa\";\n        assertEquals(7, hf.findWrapPos(text, 6, 0), \"wrap position 6\");\n    }\n\n    @Test\n    public void testHeaderStartingWithLineSeparator0() {\n        // related to Bugzilla #21215\n        final Options options = new Options();\n        final HelpFormatter formatter = new HelpFormatter();\n        final String header = EOL + \"Header\";\n        final String footer = \"Footer\";\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testHeaderStartingWithLineSeparator1() {\n        // related to Bugzilla #21215\n        final Options options = new Options();\n        final String header = EOL + \"Header\";\n        final String footer = \"Footer\";\n        final Builder builder = HelpFormatter.builder();\n        StringWriter out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"\" + EOL +\n                \"Header\" + EOL +\n                \"\" + EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(80, \"foobar\", header, options, footer);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer, false);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", options, false);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testHelpWithLongOptSeparator() {\n        final Options options = new Options();\n        options.addOption(\"f\", true, \"the file\");\n        options.addOption(Option.builder(\"s\").longOpt(\"size\").desc(\"the size\").hasArg().argName(\"SIZE\").build());\n        options.addOption(Option.builder().longOpt(\"age\").desc(\"the age\").hasArg().build());\n\n        final HelpFormatter formatter = new HelpFormatter();\n        assertEquals(HelpFormatter.DEFAULT_LONG_OPT_SEPARATOR, formatter.getLongOptSeparator());\n        formatter.setLongOptSeparator(\"=\");\n        assertEquals(\"=\", formatter.getLongOptSeparator());\n\n        final StringWriter out = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(out), 80, \"create\", \"header\", options, 2, 2, \"footer\");\n\n        //@formatter:off\n        assertEquals(\n                \"usage: create\" + EOL +\n                \"header\" + EOL +\n                \"     --age=<arg>    the age\" + EOL +\n                \"  -f <arg>          the file\" + EOL +\n                \"  -s,--size=<SIZE>  the size\" + EOL +\n                \"footer\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testIndentedHeaderAndFooter() {\n        // related to CLI-207\n        final Options options = new Options();\n        final HelpFormatter formatter = new HelpFormatter();\n        final String header = \"  Header1\\n  Header2\";\n        final String footer = \"  Footer1\\n  Footer2\";\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"  Header1\" + EOL +\n                \"  Header2\" + EOL +\n                \"\" + EOL +\n                \"  Footer1\" + EOL +\n                \"  Footer2\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testOptionWithoutShortFormat() {\n        // related to Bugzilla #19383 (CLI-67)\n        final Options options = new Options();\n        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb\"));\n        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", \"\", options, 2, 2, \"\", true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar [-a] [--bbb] [-c]\" + EOL +\n                \"  -a,--aaa  aaaaaaa\" + EOL +\n                \"     --bbb  bbbbbbb\" + EOL +\n                \"  -c        ccccccc\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testOptionWithoutShortFormat2() {\n        // related to Bugzilla #27635 (CLI-26)\n        final Option help = new Option(\"h\", \"help\", false, \"print this message\");\n        final Option version = new Option(\"v\", \"version\", false, \"print version information\");\n        final Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n        final Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n        //@formatter:off\n        final Option timeLimit = Option.builder(\"l\")\n                .longOpt(\"limit\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Set time limit for execution, in mintues\")\n                .build();\n        final Option age = Option.builder(\"a\").longOpt(\"age\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Age (in days) of cache item before being recomputed\")\n                .build();\n        final Option server = Option.builder(\"s\").longOpt(\"server\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"The NLT server address\")\n                .build();\n        final Option numResults = Option.builder(\"r\").longOpt(\"results\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Number of results per item\")\n                .build();\n        final Option configFile = Option.builder().longOpt(\"config\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Use the specified configuration file\")\n                .build();\n        //@formatter:on\n\n        final Options mOptions = new Options();\n        mOptions.addOption(help);\n        mOptions.addOption(version);\n        mOptions.addOption(newRun);\n        mOptions.addOption(trackerRun);\n        mOptions.addOption(timeLimit);\n        mOptions.addOption(age);\n        mOptions.addOption(server);\n        mOptions.addOption(numResults);\n        mOptions.addOption(configFile);\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final String eol = System.lineSeparator();\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"commandline\", \"header\", mOptions, 2, 2, \"footer\", true);\n        //@formatter:off\n        assertEquals(\n                \"usage: commandline [-a <arg>] [--config <arg>] [-h] [-l <arg>] [-n] [-r <arg>]\" + eol +\n                \"       [-s <arg>] [-t] [-v]\" + eol +\n                \"header\" + eol +\n                \"  -a,--age <arg>      Age (in days) of cache item before being recomputed\" + eol +\n                \"     --config <arg>   Use the specified configuration file\" + eol +\n                \"  -h,--help           print this message\" + eol +\n                \"  -l,--limit <arg>    Set time limit for execution, in mintues\" + eol +\n                \"  -n,--new            Create NLT cache entries only for new items\" + eol +\n                \"  -r,--results <arg>  Number of results per item\" + eol +\n                \"  -s,--server <arg>   The NLT server address\" + eol +\n                \"  -t,--tracker        Create NLT cache entries only for tracker items\" + eol +\n                \"  -v,--version        print version information\" + eol +\n                \"footer\" + eol,\n                out.toString());\n        //@formatter:on\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"deprecatedOptionsProvider\")\n    public void testPrintDeprecatedOptions(final HelpFormatter hf, final Option option, final String expectedTxt) {\n        final StringBuffer sb = new StringBuffer();\n\n        final int leftPad = 1;\n        final int descPad = 3;\n        final String lpad = hf.createPadding(leftPad);\n        final String dpad = hf.createPadding(descPad);\n        Options options;\n        final StringBuilder expected = new StringBuilder().append(lpad).append(\"-a,--aaa\");\n\n        options = new Options().addOption(option);\n        if (expectedTxt.length() > 0) {\n            expected.append(dpad).append(expectedTxt);\n        }\n        hf.renderOptions(sb, 160, options, leftPad, descPad);\n        assertEquals(expected.toString(), sb.toString());\n    }\n\n    @Test\n    public void testPrintHelpNewlineFooter() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"b\");\n\n        formatter.printHelp(\n            pw,\n            80,\n            \"test\" + EOL,\n            \"header\" + EOL,\n            options,\n            0,\n            0,\n            EOL\n        );\n        final String expected = \"usage: test\" + EOL +\n                          \"header\" + EOL +\n                          \"-ab\" + EOL +\n                          EOL;\n        pw.flush();\n        assertEquals(expected, out.toString(), \"footer newline\");\n    }\n\n    @Test\n    public void testPrintHelpNewlineHeader() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"b\");\n\n        formatter.printHelp(\n            pw,\n            80,\n            \"test\" + EOL,\n            EOL,\n            options,\n            0,\n            0,\n            \"footer\" + EOL\n        );\n        final String expected = \"usage: test\" + EOL +\n                          EOL +\n                          \"-ab\" + EOL +\n                          \"footer\" + EOL;\n        pw.flush();\n        assertEquals(expected, out.toString(), \"header newline\");\n    }\n\n    @Test\n    public void testPrintHelpWithEmptySyntax() {\n        final HelpFormatter formatter = new HelpFormatter();\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options()), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options(), true), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options(), false), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(\"\", new Options(), true), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(\"\", new Options(), false), \"null command line syntax should be rejected\");\n    }\n\n    @Test\n    public void testPrintHelpWithSince() {\n        final String [] expected = {\"usage: Command syntax\", \"Header\", \"Options            Since   Description\",\n                \"  -n,--no-since    -          Description for n\", \"  -W,--with-since  1.19.0     Descripton for W\", \"footer\"};\n        final Options options = new Options()\n                .addOption(Option.builder(\"W\").longOpt(\"with-since\").since(\"1.19.0\").desc(\"Descripton for W\").build())\n                .addOption(Option.builder(\"n\").longOpt(\"no-since\").desc(\"Description for n\").build());\n\n        final HelpFormatter formatter = HelpFormatter.builder().setShowSince(true).get();\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (PrintWriter pw = new PrintWriter(new OutputStreamWriter(baos))) {\n            formatter.printHelp(pw, 80, \"Command syntax\", \"Header\", options, 2, 5, \"footer\", false);\n        }\n        assertArrayEquals(expected, baos.toString().split(System.lineSeparator()));\n    }\n\n    @Test\n    public void testPrintOptionGroupUsage() {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").build());\n        group.addOption(Option.builder(\"b\").build());\n        group.addOption(Option.builder(\"c\").build());\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app [-a | -b | -c]\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testPrintOptions() {\n        final StringBuffer sb = new StringBuffer();\n        final HelpFormatter hf = new HelpFormatter();\n        final int leftPad = 1;\n        final int descPad = 3;\n        final String lpad = hf.createPadding(leftPad);\n        final String dpad = hf.createPadding(descPad);\n        Options options;\n        String expected;\n\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa aaaa aaaa\";\n        hf.renderOptions(sb, 60, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"simple non-wrapped option\");\n\n        int nextLineTabStop = leftPad + descPad + \"-a\".length();\n        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa\" + EOL + hf.createPadding(nextLineTabStop) + \"aaaa aaaa\";\n        sb.setLength(0);\n        hf.renderOptions(sb, nextLineTabStop + 17, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"simple wrapped option\");\n\n        options = new Options().addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\");\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd dddd dddd\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 60, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"long non-wrapped option\");\n\n        nextLineTabStop = leftPad + descPad + \"-a,--aaa\".length();\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + EOL + hf.createPadding(nextLineTabStop) + \"dddd dddd\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"long wrapped option\");\n\n        options = new Options().addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\").addOption(\"b\", false, \"feeee eeee eeee eeee\");\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + EOL + hf.createPadding(nextLineTabStop) + \"dddd dddd\" + EOL + lpad + \"-b      \" + dpad\n            + \"feeee eeee\" + EOL + hf.createPadding(nextLineTabStop) + \"eeee eeee\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"multiple wrapped options\");\n    }\n\n    @Test\n    public void testPrintOptionWithEmptyArgNameUsage() {\n        final Option option = new Option(\"f\", true, null);\n        option.setArgName(\"\");\n        option.setRequired(true);\n\n        final Options options = new Options();\n        options.addOption(option);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testPrintRequiredOptionGroupUsage() {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").build());\n        group.addOption(Option.builder(\"b\").build());\n        group.addOption(Option.builder(\"c\").build());\n        group.setRequired(true);\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -a | -b | -c\" + EOL, out.toString());\n    }\n\n    // uses the test for CLI-131 to implement CLI-155\n    @Test\n    public void testPrintSortedUsage() {\n        final Options opts = new Options();\n        opts.addOption(new Option(\"a\", \"first\"));\n        opts.addOption(new Option(\"b\", \"second\"));\n        opts.addOption(new Option(\"c\", \"third\"));\n\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.setOptionComparator((opt1, opt2) -> opt2.getKey().compareToIgnoreCase(opt1.getKey()));\n\n        final StringWriter out = new StringWriter();\n        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n\n        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testPrintSortedUsageWithNullComparator() {\n        final Options opts = new Options();\n        opts.addOption(new Option(\"c\", \"first\"));\n        opts.addOption(new Option(\"b\", \"second\"));\n        opts.addOption(new Option(\"a\", \"third\"));\n\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.setOptionComparator(null);\n\n        final StringWriter out = new StringWriter();\n        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n\n        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n    }\n\n    // This test ensures the options are properly sorted\n    // See https://issues.apache.org/jira/browse/CLI-131\n    @Test\n    public void testPrintUsage() {\n        final Option optionA = new Option(\"a\", \"first\");\n        final Option optionB = new Option(\"b\", \"second\");\n        final Option optionC = new Option(\"c\", \"third\");\n        final Options opts = new Options();\n        opts.addOption(optionA);\n        opts.addOption(optionB);\n        opts.addOption(optionC);\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n        try (PrintWriter printWriter = new PrintWriter(bytesOut)) {\n            helpFormatter.printUsage(printWriter, 80, \"app\", opts);\n        }\n        assertEquals(\"usage: app [-a] [-b] [-c]\" + EOL, bytesOut.toString());\n    }\n\n    @Test\n    public void testRenderSince() throws IOException {\n        final String[] expected = {\"Options            Since   Description\", \"  -n,--no-since    -          Description for n\",\n            \"  -W,--with-since  1.19.0     Descripton for W\"};\n        final Options options = new Options()\n                .addOption(Option.builder(\"W\").longOpt(\"with-since\").since(\"1.19.0\").desc(\"Descripton for W\").build())\n                .addOption(Option.builder(\"n\").longOpt(\"no-since\").desc(\"Description for n\").build());\n        final HelpFormatter formatter = HelpFormatter.builder().setShowSince(true).get();\n\n        final StringBuffer sb = new StringBuffer();\n        formatter.renderOptions(sb, 50, options, 2, 5);\n        assertArrayEquals(expected, sb.toString().split(System.lineSeparator()));\n        // check internal exception handling for coverage\n        final HelpFormatter spy = spy(formatter);\n        when(spy.appendOptions(sb, 50, options, 2, 5)).thenThrow(IOException.class);\n        assertThrows(UncheckedIOException.class, () -> spy.renderOptions(sb, 50, options, 2, 5));\n    }\n\n    @Test\n    public void testRenderWrappedTextMultiLine() {\n        // multi line text\n        final int width = 16;\n        final int padding = 0;\n        //@formatter:off\n        final String expected = \"aaaa aaaa aaaa\" + EOL +\n                                \"aaaaaa\" + EOL +\n                                \"aaaaa\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, expected);\n        assertEquals(expected, sb.toString(), \"multi line text\");\n    }\n\n    @Test\n    public void testRenderWrappedTextMultiLinePadded() {\n        // multi-line padded text\n        final int width = 16;\n        final int padding = 4;\n        //@formatter:off\n        final String text = \"aaaa aaaa aaaa\" + EOL +\n                      \"aaaaaa\" + EOL +\n                      \"aaaaa\";\n        final String expected = \"aaaa aaaa aaaa\" + EOL +\n                          \"    aaaaaa\" + EOL +\n                          \"    aaaaa\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"multi-line padded text\");\n    }\n\n    @Test\n    public void testRenderWrappedTextSingleLine() throws IOException {\n        // single line text\n        final int width = 12;\n        final int padding = 0;\n        final String text = \"This is a test.\";\n        final String expected = \"This is a\" + EOL + \"test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line text\");\n        // check internal exception handling for coverage\n        final HelpFormatter spy = spy(new HelpFormatter());\n        when(spy.appendWrappedText(sb, width, padding, text)).thenThrow(IOException.class);\n        assertThrows(UncheckedIOException.class, () -> spy.renderWrappedText(sb, width, padding, text));\n\n    }\n\n    @Test\n    public void testRenderWrappedTextSingleLinePadded() {\n        // single line padded text\n        final int width = 12;\n        final int padding = 4;\n        final String text = \"This is a test.\";\n        final String expected = \"This is a\" + EOL + \"    test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line padded text\");\n    }\n\n    @Test\n    public void testRenderWrappedTextSingleLinePadded2() {\n        // single line padded text 2\n        final int width = 53;\n        final int padding = 24;\n        //@formatter:off\n        final String text = \"  -p,--period <PERIOD>  PERIOD is time duration of form \" +\n                            \"DATE[-DATE] where DATE has form YYYY[MM[DD]]\";\n        final String expected = \"  -p,--period <PERIOD>  PERIOD is time duration of\" + EOL +\n                                \"                        form DATE[-DATE] where DATE\" + EOL +\n                                \"                        has form YYYY[MM[DD]]\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line padded text 2\");\n    }\n\n    @Test\n    public void testRenderWrappedTextWordCut() {\n        final int width = 7;\n        final int padding = 0;\n        final String text = \"Thisisatest.\";\n        final String expected = \"Thisisa\" + EOL + \"test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"cut and wrap\");\n    }\n\n    @Test\n    public void testRtrim() {\n        final HelpFormatter formatter = new HelpFormatter();\n\n        assertNull(formatter.rtrim(null));\n        assertEquals(\"\", formatter.rtrim(\"\"));\n        assertEquals(\"  foo\", formatter.rtrim(\"  foo  \"));\n    }\n\n    @Test\n    public void testUsageWithLongOptSeparator() {\n        final Options options = new Options();\n        options.addOption(\"f\", true, \"the file\");\n        options.addOption(Option.builder(\"s\").longOpt(\"size\").desc(\"the size\").hasArg().argName(\"SIZE\").build());\n        options.addOption(Option.builder().longOpt(\"age\").desc(\"the age\").hasArg().build());\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.setLongOptSeparator(\"=\");\n\n        final StringWriter out = new StringWriter();\n\n        formatter.printUsage(new PrintWriter(out), 80, \"create\", options);\n\n        assertEquals(\"usage: create [--age=<arg>] [-f <arg>] [-s <SIZE>]\", out.toString().trim());\n    }\n}", "definition": "public class HelpFormatterTest", "class_docstring": "\nTest case for the HelpFormatter class.\n", "name": "HelpFormatterTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final String EOL = System.lineSeparator();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "EOL = System.lineSeparator()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    static Stream<Arguments> deprecatedOptionsProvider() {\n        final List<Arguments> lst = new ArrayList<>();\n        Option option = Option.builder(\"a\").longOpt(\"aaa\").desc(\"dddd dddd dddd\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"now\")\n                        .setDescription(\"Why why why\").get())\n                .build();\n\n        HelpFormatter hf = HelpFormatter.builder().get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated] dddd dddd dddd\"));\n\n\n        hf = HelpFormatter.builder().setShowDeprecated(false).get();\n        lst.add(Arguments.of(hf, option, \"dddd dddd dddd\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(true).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated] dddd dddd dddd\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(o -> String.format(\"%s [%s]\", HelpFormatter.getDescription(o), o.getDeprecated())).get();\n        lst.add(Arguments.of(hf, option, \"dddd dddd dddd [Deprecated for removal since now: Why why why]\"));\n\n        option = Option.builder(\"a\").longOpt(\"aaa\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"now\")\n                        .setDescription(\"Why why why\").get())\n                .build();\n\n        hf = HelpFormatter.builder().get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated]\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(false).get();\n        lst.add(Arguments.of(hf, option, \"\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(true).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated]\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(o -> String.format(\"%s [%s]\", HelpFormatter.getDescription(o), o.getDeprecated())).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated for removal since now: Why why why]\"));\n\n        return lst.stream();\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Stream<Arguments>", "classes": []}, "name": "deprecatedOptionsProvider", "params": [], "body": "                                                         {\n        final List<Arguments> lst = new ArrayList<>();\n        Option option = Option.builder(\"a\").longOpt(\"aaa\").desc(\"dddd dddd dddd\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"now\")\n                        .setDescription(\"Why why why\").get())\n                .build();\n\n        HelpFormatter hf = HelpFormatter.builder().get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated] dddd dddd dddd\"));\n\n\n        hf = HelpFormatter.builder().setShowDeprecated(false).get();\n        lst.add(Arguments.of(hf, option, \"dddd dddd dddd\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(true).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated] dddd dddd dddd\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(o -> String.format(\"%s [%s]\", HelpFormatter.getDescription(o), o.getDeprecated())).get();\n        lst.add(Arguments.of(hf, option, \"dddd dddd dddd [Deprecated for removal since now: Why why why]\"));\n\n        option = Option.builder(\"a\").longOpt(\"aaa\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"now\")\n                        .setDescription(\"Why why why\").get())\n                .build();\n\n        hf = HelpFormatter.builder().get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated]\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(false).get();\n        lst.add(Arguments.of(hf, option, \"\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(true).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated]\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(o -> String.format(\"%s [%s]\", HelpFormatter.getDescription(o), o.getDeprecated())).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated for removal since now: Why why why]\"));\n\n        return lst.stream();\n    }", "signature": "static Stream<Arguments> deprecatedOptionsProvider()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAccessors() {\n        final HelpFormatter formatter = new HelpFormatter();\n\n        formatter.setArgName(\"argname\");\n        assertEquals(\"argname\", formatter.getArgName(), \"arg name\");\n\n        formatter.setDescPadding(3);\n        assertEquals(3, formatter.getDescPadding(), \"desc padding\");\n\n        formatter.setLeftPadding(7);\n        assertEquals(7, formatter.getLeftPadding(), \"left padding\");\n\n        formatter.setLongOptPrefix(\"~~\");\n        assertEquals(\"~~\", formatter.getLongOptPrefix(), \"long opt prefix\");\n\n        formatter.setNewLine(\"\\n\");\n        assertEquals(\"\\n\", formatter.getNewLine(), \"new line\");\n\n        formatter.setOptPrefix(\"~\");\n        assertEquals(\"~\", formatter.getOptPrefix(), \"opt prefix\");\n\n        formatter.setSyntaxPrefix(\"-> \");\n        assertEquals(\"-> \", formatter.getSyntaxPrefix(), \"syntax prefix\");\n\n        formatter.setWidth(80);\n        assertEquals(80, formatter.getWidth(), \"width\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAccessors", "params": [], "body": "                                {\n        final HelpFormatter formatter = new HelpFormatter();\n\n        formatter.setArgName(\"argname\");\n        assertEquals(\"argname\", formatter.getArgName(), \"arg name\");\n\n        formatter.setDescPadding(3);\n        assertEquals(3, formatter.getDescPadding(), \"desc padding\");\n\n        formatter.setLeftPadding(7);\n        assertEquals(7, formatter.getLeftPadding(), \"left padding\");\n\n        formatter.setLongOptPrefix(\"~~\");\n        assertEquals(\"~~\", formatter.getLongOptPrefix(), \"long opt prefix\");\n\n        formatter.setNewLine(\"\\n\");\n        assertEquals(\"\\n\", formatter.getNewLine(), \"new line\");\n\n        formatter.setOptPrefix(\"~\");\n        assertEquals(\"~\", formatter.getOptPrefix(), \"opt prefix\");\n\n        formatter.setSyntaxPrefix(\"-> \");\n        assertEquals(\"-> \", formatter.getSyntaxPrefix(), \"syntax prefix\");\n\n        formatter.setWidth(80);\n        assertEquals(80, formatter.getWidth(), \"width\");\n    }", "signature": "@Test\n    public void testAccessors()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAutomaticUsage() {\n        final HelpFormatter hf = new HelpFormatter();\n        Options options;\n        String expected = \"usage: app [-a]\";\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n        hf.printUsage(pw, 60, \"app\", options);\n        pw.flush();\n        assertEquals(expected, out.toString().trim(), \"simple auto usage\");\n        out.reset();\n\n        expected = \"usage: app [-a] [-b]\";\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\").addOption(\"b\", false, \"bbb\");\n        hf.printUsage(pw, 60, \"app\", options);\n        pw.flush();\n        assertEquals(expected, out.toString().trim(), \"simple auto usage\");\n        out.reset();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAutomaticUsage", "params": [], "body": "                                     {\n        final HelpFormatter hf = new HelpFormatter();\n        Options options;\n        String expected = \"usage: app [-a]\";\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n        hf.printUsage(pw, 60, \"app\", options);\n        pw.flush();\n        assertEquals(expected, out.toString().trim(), \"simple auto usage\");\n        out.reset();\n\n        expected = \"usage: app [-a] [-b]\";\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\").addOption(\"b\", false, \"bbb\");\n        hf.printUsage(pw, 60, \"app\", options);\n        pw.flush();\n        assertEquals(expected, out.toString().trim(), \"simple auto usage\");\n        out.reset();\n    }", "signature": "@Test\n    public void testAutomaticUsage()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDefaultArgName() {\n        final Option option = Option.builder(\"f\").hasArg().required(true).build();\n\n        final Options options = new Options();\n        options.addOption(option);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.setArgName(\"argument\");\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f <argument>\" + EOL, out.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDefaultArgName", "params": [], "body": "                                     {\n        final Option option = Option.builder(\"f\").hasArg().required(true).build();\n\n        final Options options = new Options();\n        options.addOption(option);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.setArgName(\"argument\");\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f <argument>\" + EOL, out.toString());\n    }", "signature": "@Test\n    public void testDefaultArgName()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testFindWrapPos() {\n        final HelpFormatter hf = new HelpFormatter();\n\n        String text = \"This is a test.\";\n        // text width should be max 8; the wrap position is 7\n        assertEquals(7, hf.findWrapPos(text, 8, 0), \"wrap position\");\n\n        // starting from 8 must give -1 - the wrap pos is after end\n        assertEquals(-1, hf.findWrapPos(text, 8, 8), \"wrap position 2\");\n\n        // words longer than the width are cut\n        text = \"aaaa aa\";\n        assertEquals(3, hf.findWrapPos(text, 3, 0), \"wrap position 3\");\n\n        // last word length is equal to the width\n        text = \"aaaaaa aaaaaa\";\n        assertEquals(6, hf.findWrapPos(text, 6, 0), \"wrap position 4\");\n        assertEquals(-1, hf.findWrapPos(text, 6, 7), \"wrap position 4\");\n\n        text = \"aaaaaa\\n aaaaaa\";\n        assertEquals(7, hf.findWrapPos(text, 6, 0), \"wrap position 5\");\n\n        text = \"aaaaaa\\t aaaaaa\";\n        assertEquals(7, hf.findWrapPos(text, 6, 0), \"wrap position 6\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testFindWrapPos", "params": [], "body": "                                  {\n        final HelpFormatter hf = new HelpFormatter();\n\n        String text = \"This is a test.\";\n        // text width should be max 8; the wrap position is 7\n        assertEquals(7, hf.findWrapPos(text, 8, 0), \"wrap position\");\n\n        // starting from 8 must give -1 - the wrap pos is after end\n        assertEquals(-1, hf.findWrapPos(text, 8, 8), \"wrap position 2\");\n\n        // words longer than the width are cut\n        text = \"aaaa aa\";\n        assertEquals(3, hf.findWrapPos(text, 3, 0), \"wrap position 3\");\n\n        // last word length is equal to the width\n        text = \"aaaaaa aaaaaa\";\n        assertEquals(6, hf.findWrapPos(text, 6, 0), \"wrap position 4\");\n        assertEquals(-1, hf.findWrapPos(text, 6, 7), \"wrap position 4\");\n\n        text = \"aaaaaa\\n aaaaaa\";\n        assertEquals(7, hf.findWrapPos(text, 6, 0), \"wrap position 5\");\n\n        text = \"aaaaaa\\t aaaaaa\";\n        assertEquals(7, hf.findWrapPos(text, 6, 0), \"wrap position 6\");\n    }", "signature": "@Test\n    public void testFindWrapPos()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHeaderStartingWithLineSeparator0() {\n        // related to Bugzilla #21215\n        final Options options = new Options();\n        final HelpFormatter formatter = new HelpFormatter();\n        final String header = EOL + \"Header\";\n        final String footer = \"Footer\";\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHeaderStartingWithLineSeparator0", "params": [], "body": "                                                       {\n        // related to Bugzilla #21215\n        final Options options = new Options();\n        final HelpFormatter formatter = new HelpFormatter();\n        final String header = EOL + \"Header\";\n        final String footer = \"Footer\";\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n    }", "signature": "@Test\n    public void testHeaderStartingWithLineSeparator0()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHeaderStartingWithLineSeparator1() {\n        // related to Bugzilla #21215\n        final Options options = new Options();\n        final String header = EOL + \"Header\";\n        final String footer = \"Footer\";\n        final Builder builder = HelpFormatter.builder();\n        StringWriter out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"\" + EOL +\n                \"Header\" + EOL +\n                \"\" + EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(80, \"foobar\", header, options, footer);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer, false);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", options, false);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"\" + EOL,\n                out.toString());\n        //@formatter:on\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHeaderStartingWithLineSeparator1", "params": [], "body": "                                                       {\n        // related to Bugzilla #21215\n        final Options options = new Options();\n        final String header = EOL + \"Header\";\n        final String footer = \"Footer\";\n        final Builder builder = HelpFormatter.builder();\n        StringWriter out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"\" + EOL +\n                \"Header\" + EOL +\n                \"\" + EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(80, \"foobar\", header, options, footer);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer, false);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", options, false);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"\" + EOL,\n                out.toString());\n        //@formatter:on\n    }", "signature": "@Test\n    public void testHeaderStartingWithLineSeparator1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHelpWithLongOptSeparator() {\n        final Options options = new Options();\n        options.addOption(\"f\", true, \"the file\");\n        options.addOption(Option.builder(\"s\").longOpt(\"size\").desc(\"the size\").hasArg().argName(\"SIZE\").build());\n        options.addOption(Option.builder().longOpt(\"age\").desc(\"the age\").hasArg().build());\n\n        final HelpFormatter formatter = new HelpFormatter();\n        assertEquals(HelpFormatter.DEFAULT_LONG_OPT_SEPARATOR, formatter.getLongOptSeparator());\n        formatter.setLongOptSeparator(\"=\");\n        assertEquals(\"=\", formatter.getLongOptSeparator());\n\n        final StringWriter out = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(out), 80, \"create\", \"header\", options, 2, 2, \"footer\");\n\n        //@formatter:off\n        assertEquals(\n                \"usage: create\" + EOL +\n                \"header\" + EOL +\n                \"     --age=<arg>    the age\" + EOL +\n                \"  -f <arg>          the file\" + EOL +\n                \"  -s,--size=<SIZE>  the size\" + EOL +\n                \"footer\" + EOL,\n                out.toString());\n        //@formatter:on\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHelpWithLongOptSeparator", "params": [], "body": "                                               {\n        final Options options = new Options();\n        options.addOption(\"f\", true, \"the file\");\n        options.addOption(Option.builder(\"s\").longOpt(\"size\").desc(\"the size\").hasArg().argName(\"SIZE\").build());\n        options.addOption(Option.builder().longOpt(\"age\").desc(\"the age\").hasArg().build());\n\n        final HelpFormatter formatter = new HelpFormatter();\n        assertEquals(HelpFormatter.DEFAULT_LONG_OPT_SEPARATOR, formatter.getLongOptSeparator());\n        formatter.setLongOptSeparator(\"=\");\n        assertEquals(\"=\", formatter.getLongOptSeparator());\n\n        final StringWriter out = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(out), 80, \"create\", \"header\", options, 2, 2, \"footer\");\n\n        //@formatter:off\n        assertEquals(\n                \"usage: create\" + EOL +\n                \"header\" + EOL +\n                \"     --age=<arg>    the age\" + EOL +\n                \"  -f <arg>          the file\" + EOL +\n                \"  -s,--size=<SIZE>  the size\" + EOL +\n                \"footer\" + EOL,\n                out.toString());\n        //@formatter:on\n    }", "signature": "@Test\n    public void testHelpWithLongOptSeparator()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIndentedHeaderAndFooter() {\n        // related to CLI-207\n        final Options options = new Options();\n        final HelpFormatter formatter = new HelpFormatter();\n        final String header = \"  Header1\\n  Header2\";\n        final String footer = \"  Footer1\\n  Footer2\";\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"  Header1\" + EOL +\n                \"  Header2\" + EOL +\n                \"\" + EOL +\n                \"  Footer1\" + EOL +\n                \"  Footer2\" + EOL,\n                out.toString());\n        //@formatter:on\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIndentedHeaderAndFooter", "params": [], "body": "                                              {\n        // related to CLI-207\n        final Options options = new Options();\n        final HelpFormatter formatter = new HelpFormatter();\n        final String header = \"  Header1\\n  Header2\";\n        final String footer = \"  Footer1\\n  Footer2\";\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"  Header1\" + EOL +\n                \"  Header2\" + EOL +\n                \"\" + EOL +\n                \"  Footer1\" + EOL +\n                \"  Footer2\" + EOL,\n                out.toString());\n        //@formatter:on\n    }", "signature": "@Test\n    public void testIndentedHeaderAndFooter()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionWithoutShortFormat() {\n        // related to Bugzilla #19383 (CLI-67)\n        final Options options = new Options();\n        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb\"));\n        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", \"\", options, 2, 2, \"\", true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar [-a] [--bbb] [-c]\" + EOL +\n                \"  -a,--aaa  aaaaaaa\" + EOL +\n                \"     --bbb  bbbbbbb\" + EOL +\n                \"  -c        ccccccc\" + EOL,\n                out.toString());\n        //@formatter:on\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionWithoutShortFormat", "params": [], "body": "                                               {\n        // related to Bugzilla #19383 (CLI-67)\n        final Options options = new Options();\n        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb\"));\n        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", \"\", options, 2, 2, \"\", true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar [-a] [--bbb] [-c]\" + EOL +\n                \"  -a,--aaa  aaaaaaa\" + EOL +\n                \"     --bbb  bbbbbbb\" + EOL +\n                \"  -c        ccccccc\" + EOL,\n                out.toString());\n        //@formatter:on\n    }", "signature": "@Test\n    public void testOptionWithoutShortFormat()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionWithoutShortFormat2() {\n        // related to Bugzilla #27635 (CLI-26)\n        final Option help = new Option(\"h\", \"help\", false, \"print this message\");\n        final Option version = new Option(\"v\", \"version\", false, \"print version information\");\n        final Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n        final Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n        //@formatter:off\n        final Option timeLimit = Option.builder(\"l\")\n                .longOpt(\"limit\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Set time limit for execution, in mintues\")\n                .build();\n        final Option age = Option.builder(\"a\").longOpt(\"age\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Age (in days) of cache item before being recomputed\")\n                .build();\n        final Option server = Option.builder(\"s\").longOpt(\"server\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"The NLT server address\")\n                .build();\n        final Option numResults = Option.builder(\"r\").longOpt(\"results\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Number of results per item\")\n                .build();\n        final Option configFile = Option.builder().longOpt(\"config\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Use the specified configuration file\")\n                .build();\n        //@formatter:on\n\n        final Options mOptions = new Options();\n        mOptions.addOption(help);\n        mOptions.addOption(version);\n        mOptions.addOption(newRun);\n        mOptions.addOption(trackerRun);\n        mOptions.addOption(timeLimit);\n        mOptions.addOption(age);\n        mOptions.addOption(server);\n        mOptions.addOption(numResults);\n        mOptions.addOption(configFile);\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final String eol = System.lineSeparator();\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"commandline\", \"header\", mOptions, 2, 2, \"footer\", true);\n        //@formatter:off\n        assertEquals(\n                \"usage: commandline [-a <arg>] [--config <arg>] [-h] [-l <arg>] [-n] [-r <arg>]\" + eol +\n                \"       [-s <arg>] [-t] [-v]\" + eol +\n                \"header\" + eol +\n                \"  -a,--age <arg>      Age (in days) of cache item before being recomputed\" + eol +\n                \"     --config <arg>   Use the specified configuration file\" + eol +\n                \"  -h,--help           print this message\" + eol +\n                \"  -l,--limit <arg>    Set time limit for execution, in mintues\" + eol +\n                \"  -n,--new            Create NLT cache entries only for new items\" + eol +\n                \"  -r,--results <arg>  Number of results per item\" + eol +\n                \"  -s,--server <arg>   The NLT server address\" + eol +\n                \"  -t,--tracker        Create NLT cache entries only for tracker items\" + eol +\n                \"  -v,--version        print version information\" + eol +\n                \"footer\" + eol,\n                out.toString());\n        //@formatter:on\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionWithoutShortFormat2", "params": [], "body": "                                                {\n        // related to Bugzilla #27635 (CLI-26)\n        final Option help = new Option(\"h\", \"help\", false, \"print this message\");\n        final Option version = new Option(\"v\", \"version\", false, \"print version information\");\n        final Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n        final Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n        //@formatter:off\n        final Option timeLimit = Option.builder(\"l\")\n                .longOpt(\"limit\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Set time limit for execution, in mintues\")\n                .build();\n        final Option age = Option.builder(\"a\").longOpt(\"age\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Age (in days) of cache item before being recomputed\")\n                .build();\n        final Option server = Option.builder(\"s\").longOpt(\"server\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"The NLT server address\")\n                .build();\n        final Option numResults = Option.builder(\"r\").longOpt(\"results\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Number of results per item\")\n                .build();\n        final Option configFile = Option.builder().longOpt(\"config\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Use the specified configuration file\")\n                .build();\n        //@formatter:on\n\n        final Options mOptions = new Options();\n        mOptions.addOption(help);\n        mOptions.addOption(version);\n        mOptions.addOption(newRun);\n        mOptions.addOption(trackerRun);\n        mOptions.addOption(timeLimit);\n        mOptions.addOption(age);\n        mOptions.addOption(server);\n        mOptions.addOption(numResults);\n        mOptions.addOption(configFile);\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final String eol = System.lineSeparator();\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"commandline\", \"header\", mOptions, 2, 2, \"footer\", true);\n        //@formatter:off\n        assertEquals(\n                \"usage: commandline [-a <arg>] [--config <arg>] [-h] [-l <arg>] [-n] [-r <arg>]\" + eol +\n                \"       [-s <arg>] [-t] [-v]\" + eol +\n                \"header\" + eol +\n                \"  -a,--age <arg>      Age (in days) of cache item before being recomputed\" + eol +\n                \"     --config <arg>   Use the specified configuration file\" + eol +\n                \"  -h,--help           print this message\" + eol +\n                \"  -l,--limit <arg>    Set time limit for execution, in mintues\" + eol +\n                \"  -n,--new            Create NLT cache entries only for new items\" + eol +\n                \"  -r,--results <arg>  Number of results per item\" + eol +\n                \"  -s,--server <arg>   The NLT server address\" + eol +\n                \"  -t,--tracker        Create NLT cache entries only for tracker items\" + eol +\n                \"  -v,--version        print version information\" + eol +\n                \"footer\" + eol,\n                out.toString());\n        //@formatter:on\n    }", "signature": "@Test\n    public void testOptionWithoutShortFormat2()"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"deprecatedOptionsProvider\")\n    public void testPrintDeprecatedOptions(final HelpFormatter hf, final Option option, final String expectedTxt) {\n        final StringBuffer sb = new StringBuffer();\n\n        final int leftPad = 1;\n        final int descPad = 3;\n        final String lpad = hf.createPadding(leftPad);\n        final String dpad = hf.createPadding(descPad);\n        Options options;\n        final StringBuilder expected = new StringBuilder().append(lpad).append(\"-a,--aaa\");\n\n        options = new Options().addOption(option);\n        if (expectedTxt.length() > 0) {\n            expected.append(dpad).append(expectedTxt);\n        }\n        hf.renderOptions(sb, 160, options, leftPad, descPad);\n        assertEquals(expected.toString(), sb.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"deprecatedOptionsProvider\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"deprecatedOptionsProvider\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintDeprecatedOptions", "params": [{"name": "hf", "type": "HelpFormatter"}, {"name": "option", "type": "Option"}, {"name": "expectedTxt", "type": "String"}], "body": "                                                                                                                  {\n        final StringBuffer sb = new StringBuffer();\n\n        final int leftPad = 1;\n        final int descPad = 3;\n        final String lpad = hf.createPadding(leftPad);\n        final String dpad = hf.createPadding(descPad);\n        Options options;\n        final StringBuilder expected = new StringBuilder().append(lpad).append(\"-a,--aaa\");\n\n        options = new Options().addOption(option);\n        if (expectedTxt.length() > 0) {\n            expected.append(dpad).append(expectedTxt);\n        }\n        hf.renderOptions(sb, 160, options, leftPad, descPad);\n        assertEquals(expected.toString(), sb.toString());\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"deprecatedOptionsProvider\")\n    public void testPrintDeprecatedOptions(final HelpFormatter hf, final Option option, final String expectedTxt)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintHelpNewlineFooter() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"b\");\n\n        formatter.printHelp(\n            pw,\n            80,\n            \"test\" + EOL,\n            \"header\" + EOL,\n            options,\n            0,\n            0,\n            EOL\n        );\n        final String expected = \"usage: test\" + EOL +\n                          \"header\" + EOL +\n                          \"-ab\" + EOL +\n                          EOL;\n        pw.flush();\n        assertEquals(expected, out.toString(), \"footer newline\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintHelpNewlineFooter", "params": [], "body": "                                             {\n        final HelpFormatter formatter = new HelpFormatter();\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"b\");\n\n        formatter.printHelp(\n            pw,\n            80,\n            \"test\" + EOL,\n            \"header\" + EOL,\n            options,\n            0,\n            0,\n            EOL\n        );\n        final String expected = \"usage: test\" + EOL +\n                          \"header\" + EOL +\n                          \"-ab\" + EOL +\n                          EOL;\n        pw.flush();\n        assertEquals(expected, out.toString(), \"footer newline\");\n    }", "signature": "@Test\n    public void testPrintHelpNewlineFooter()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintHelpNewlineHeader() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"b\");\n\n        formatter.printHelp(\n            pw,\n            80,\n            \"test\" + EOL,\n            EOL,\n            options,\n            0,\n            0,\n            \"footer\" + EOL\n        );\n        final String expected = \"usage: test\" + EOL +\n                          EOL +\n                          \"-ab\" + EOL +\n                          \"footer\" + EOL;\n        pw.flush();\n        assertEquals(expected, out.toString(), \"header newline\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintHelpNewlineHeader", "params": [], "body": "                                             {\n        final HelpFormatter formatter = new HelpFormatter();\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"b\");\n\n        formatter.printHelp(\n            pw,\n            80,\n            \"test\" + EOL,\n            EOL,\n            options,\n            0,\n            0,\n            \"footer\" + EOL\n        );\n        final String expected = \"usage: test\" + EOL +\n                          EOL +\n                          \"-ab\" + EOL +\n                          \"footer\" + EOL;\n        pw.flush();\n        assertEquals(expected, out.toString(), \"header newline\");\n    }", "signature": "@Test\n    public void testPrintHelpNewlineHeader()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintHelpWithEmptySyntax() {\n        final HelpFormatter formatter = new HelpFormatter();\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options()), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options(), true), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options(), false), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(\"\", new Options(), true), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(\"\", new Options(), false), \"null command line syntax should be rejected\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintHelpWithEmptySyntax", "params": [], "body": "                                               {\n        final HelpFormatter formatter = new HelpFormatter();\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options()), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options(), true), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options(), false), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(\"\", new Options(), true), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(\"\", new Options(), false), \"null command line syntax should be rejected\");\n    }", "signature": "@Test\n    public void testPrintHelpWithEmptySyntax()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintHelpWithSince() {\n        final String [] expected = {\"usage: Command syntax\", \"Header\", \"Options            Since   Description\",\n                \"  -n,--no-since    -          Description for n\", \"  -W,--with-since  1.19.0     Descripton for W\", \"footer\"};\n        final Options options = new Options()\n                .addOption(Option.builder(\"W\").longOpt(\"with-since\").since(\"1.19.0\").desc(\"Descripton for W\").build())\n                .addOption(Option.builder(\"n\").longOpt(\"no-since\").desc(\"Description for n\").build());\n\n        final HelpFormatter formatter = HelpFormatter.builder().setShowSince(true).get();\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (PrintWriter pw = new PrintWriter(new OutputStreamWriter(baos))) {\n            formatter.printHelp(pw, 80, \"Command syntax\", \"Header\", options, 2, 5, \"footer\", false);\n        }\n        assertArrayEquals(expected, baos.toString().split(System.lineSeparator()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintHelpWithSince", "params": [], "body": "                                         {\n        final String [] expected = {\"usage: Command syntax\", \"Header\", \"Options            Since   Description\",\n                \"  -n,--no-since    -          Description for n\", \"  -W,--with-since  1.19.0     Descripton for W\", \"footer\"};\n        final Options options = new Options()\n                .addOption(Option.builder(\"W\").longOpt(\"with-since\").since(\"1.19.0\").desc(\"Descripton for W\").build())\n                .addOption(Option.builder(\"n\").longOpt(\"no-since\").desc(\"Description for n\").build());\n\n        final HelpFormatter formatter = HelpFormatter.builder().setShowSince(true).get();\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (PrintWriter pw = new PrintWriter(new OutputStreamWriter(baos))) {\n            formatter.printHelp(pw, 80, \"Command syntax\", \"Header\", options, 2, 5, \"footer\", false);\n        }\n        assertArrayEquals(expected, baos.toString().split(System.lineSeparator()));\n    }", "signature": "@Test\n    public void testPrintHelpWithSince()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintOptionGroupUsage() {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").build());\n        group.addOption(Option.builder(\"b\").build());\n        group.addOption(Option.builder(\"c\").build());\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app [-a | -b | -c]\" + EOL, out.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintOptionGroupUsage", "params": [], "body": "                                            {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").build());\n        group.addOption(Option.builder(\"b\").build());\n        group.addOption(Option.builder(\"c\").build());\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app [-a | -b | -c]\" + EOL, out.toString());\n    }", "signature": "@Test\n    public void testPrintOptionGroupUsage()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintOptions() {\n        final StringBuffer sb = new StringBuffer();\n        final HelpFormatter hf = new HelpFormatter();\n        final int leftPad = 1;\n        final int descPad = 3;\n        final String lpad = hf.createPadding(leftPad);\n        final String dpad = hf.createPadding(descPad);\n        Options options;\n        String expected;\n\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa aaaa aaaa\";\n        hf.renderOptions(sb, 60, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"simple non-wrapped option\");\n\n        int nextLineTabStop = leftPad + descPad + \"-a\".length();\n        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa\" + EOL + hf.createPadding(nextLineTabStop) + \"aaaa aaaa\";\n        sb.setLength(0);\n        hf.renderOptions(sb, nextLineTabStop + 17, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"simple wrapped option\");\n\n        options = new Options().addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\");\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd dddd dddd\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 60, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"long non-wrapped option\");\n\n        nextLineTabStop = leftPad + descPad + \"-a,--aaa\".length();\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + EOL + hf.createPadding(nextLineTabStop) + \"dddd dddd\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"long wrapped option\");\n\n        options = new Options().addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\").addOption(\"b\", false, \"feeee eeee eeee eeee\");\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + EOL + hf.createPadding(nextLineTabStop) + \"dddd dddd\" + EOL + lpad + \"-b      \" + dpad\n            + \"feeee eeee\" + EOL + hf.createPadding(nextLineTabStop) + \"eeee eeee\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"multiple wrapped options\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintOptions", "params": [], "body": "                                   {\n        final StringBuffer sb = new StringBuffer();\n        final HelpFormatter hf = new HelpFormatter();\n        final int leftPad = 1;\n        final int descPad = 3;\n        final String lpad = hf.createPadding(leftPad);\n        final String dpad = hf.createPadding(descPad);\n        Options options;\n        String expected;\n\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa aaaa aaaa\";\n        hf.renderOptions(sb, 60, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"simple non-wrapped option\");\n\n        int nextLineTabStop = leftPad + descPad + \"-a\".length();\n        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa\" + EOL + hf.createPadding(nextLineTabStop) + \"aaaa aaaa\";\n        sb.setLength(0);\n        hf.renderOptions(sb, nextLineTabStop + 17, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"simple wrapped option\");\n\n        options = new Options().addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\");\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd dddd dddd\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 60, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"long non-wrapped option\");\n\n        nextLineTabStop = leftPad + descPad + \"-a,--aaa\".length();\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + EOL + hf.createPadding(nextLineTabStop) + \"dddd dddd\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"long wrapped option\");\n\n        options = new Options().addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\").addOption(\"b\", false, \"feeee eeee eeee eeee\");\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + EOL + hf.createPadding(nextLineTabStop) + \"dddd dddd\" + EOL + lpad + \"-b      \" + dpad\n            + \"feeee eeee\" + EOL + hf.createPadding(nextLineTabStop) + \"eeee eeee\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"multiple wrapped options\");\n    }", "signature": "@Test\n    public void testPrintOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintOptionWithEmptyArgNameUsage() {\n        final Option option = new Option(\"f\", true, null);\n        option.setArgName(\"\");\n        option.setRequired(true);\n\n        final Options options = new Options();\n        options.addOption(option);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f\" + EOL, out.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintOptionWithEmptyArgNameUsage", "params": [], "body": "                                                       {\n        final Option option = new Option(\"f\", true, null);\n        option.setArgName(\"\");\n        option.setRequired(true);\n\n        final Options options = new Options();\n        options.addOption(option);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f\" + EOL, out.toString());\n    }", "signature": "@Test\n    public void testPrintOptionWithEmptyArgNameUsage()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintRequiredOptionGroupUsage() {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").build());\n        group.addOption(Option.builder(\"b\").build());\n        group.addOption(Option.builder(\"c\").build());\n        group.setRequired(true);\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -a | -b | -c\" + EOL, out.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintRequiredOptionGroupUsage", "params": [], "body": "                                                    {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").build());\n        group.addOption(Option.builder(\"b\").build());\n        group.addOption(Option.builder(\"c\").build());\n        group.setRequired(true);\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -a | -b | -c\" + EOL, out.toString());\n    }", "signature": "@Test\n    public void testPrintRequiredOptionGroupUsage()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintSortedUsage() {\n        final Options opts = new Options();\n        opts.addOption(new Option(\"a\", \"first\"));\n        opts.addOption(new Option(\"b\", \"second\"));\n        opts.addOption(new Option(\"c\", \"third\"));\n\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.setOptionComparator((opt1, opt2) -> opt2.getKey().compareToIgnoreCase(opt1.getKey()));\n\n        final StringWriter out = new StringWriter();\n        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n\n        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n    }", "docstring": " uses the test for CLI-131 to implement CLI-155", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintSortedUsage", "params": [], "body": "                                       {\n        final Options opts = new Options();\n        opts.addOption(new Option(\"a\", \"first\"));\n        opts.addOption(new Option(\"b\", \"second\"));\n        opts.addOption(new Option(\"c\", \"third\"));\n\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.setOptionComparator((opt1, opt2) -> opt2.getKey().compareToIgnoreCase(opt1.getKey()));\n\n        final StringWriter out = new StringWriter();\n        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n\n        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n    }", "signature": "@Test\n    public void testPrintSortedUsage()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintSortedUsageWithNullComparator() {\n        final Options opts = new Options();\n        opts.addOption(new Option(\"c\", \"first\"));\n        opts.addOption(new Option(\"b\", \"second\"));\n        opts.addOption(new Option(\"a\", \"third\"));\n\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.setOptionComparator(null);\n\n        final StringWriter out = new StringWriter();\n        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n\n        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintSortedUsageWithNullComparator", "params": [], "body": "                                                         {\n        final Options opts = new Options();\n        opts.addOption(new Option(\"c\", \"first\"));\n        opts.addOption(new Option(\"b\", \"second\"));\n        opts.addOption(new Option(\"a\", \"third\"));\n\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.setOptionComparator(null);\n\n        final StringWriter out = new StringWriter();\n        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n\n        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n    }", "signature": "@Test\n    public void testPrintSortedUsageWithNullComparator()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintUsage() {\n        final Option optionA = new Option(\"a\", \"first\");\n        final Option optionB = new Option(\"b\", \"second\");\n        final Option optionC = new Option(\"c\", \"third\");\n        final Options opts = new Options();\n        opts.addOption(optionA);\n        opts.addOption(optionB);\n        opts.addOption(optionC);\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n        try (PrintWriter printWriter = new PrintWriter(bytesOut)) {\n            helpFormatter.printUsage(printWriter, 80, \"app\", opts);\n        }\n        assertEquals(\"usage: app [-a] [-b] [-c]\" + EOL, bytesOut.toString());\n    }", "docstring": " See https://issues.apache.org/jira/browse/CLI-131", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintUsage", "params": [], "body": "                                 {\n        final Option optionA = new Option(\"a\", \"first\");\n        final Option optionB = new Option(\"b\", \"second\");\n        final Option optionC = new Option(\"c\", \"third\");\n        final Options opts = new Options();\n        opts.addOption(optionA);\n        opts.addOption(optionB);\n        opts.addOption(optionC);\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n        try (PrintWriter printWriter = new PrintWriter(bytesOut)) {\n            helpFormatter.printUsage(printWriter, 80, \"app\", opts);\n        }\n        assertEquals(\"usage: app [-a] [-b] [-c]\" + EOL, bytesOut.toString());\n    }", "signature": "@Test\n    public void testPrintUsage()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRenderSince() throws IOException {\n        final String[] expected = {\"Options            Since   Description\", \"  -n,--no-since    -          Description for n\",\n            \"  -W,--with-since  1.19.0     Descripton for W\"};\n        final Options options = new Options()\n                .addOption(Option.builder(\"W\").longOpt(\"with-since\").since(\"1.19.0\").desc(\"Descripton for W\").build())\n                .addOption(Option.builder(\"n\").longOpt(\"no-since\").desc(\"Description for n\").build());\n        final HelpFormatter formatter = HelpFormatter.builder().setShowSince(true).get();\n\n        final StringBuffer sb = new StringBuffer();\n        formatter.renderOptions(sb, 50, options, 2, 5);\n        assertArrayEquals(expected, sb.toString().split(System.lineSeparator()));\n        // check internal exception handling for coverage\n        final HelpFormatter spy = spy(formatter);\n        when(spy.appendOptions(sb, 50, options, 2, 5)).thenThrow(IOException.class);\n        assertThrows(UncheckedIOException.class, () -> spy.renderOptions(sb, 50, options, 2, 5));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRenderSince", "params": [], "body": "                                                     {\n        final String[] expected = {\"Options            Since   Description\", \"  -n,--no-since    -          Description for n\",\n            \"  -W,--with-since  1.19.0     Descripton for W\"};\n        final Options options = new Options()\n                .addOption(Option.builder(\"W\").longOpt(\"with-since\").since(\"1.19.0\").desc(\"Descripton for W\").build())\n                .addOption(Option.builder(\"n\").longOpt(\"no-since\").desc(\"Description for n\").build());\n        final HelpFormatter formatter = HelpFormatter.builder().setShowSince(true).get();\n\n        final StringBuffer sb = new StringBuffer();\n        formatter.renderOptions(sb, 50, options, 2, 5);\n        assertArrayEquals(expected, sb.toString().split(System.lineSeparator()));\n        // check internal exception handling for coverage\n        final HelpFormatter spy = spy(formatter);\n        when(spy.appendOptions(sb, 50, options, 2, 5)).thenThrow(IOException.class);\n        assertThrows(UncheckedIOException.class, () -> spy.renderOptions(sb, 50, options, 2, 5));\n    }", "signature": "@Test\n    public void testRenderSince()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRenderWrappedTextMultiLine() {\n        // multi line text\n        final int width = 16;\n        final int padding = 0;\n        //@formatter:off\n        final String expected = \"aaaa aaaa aaaa\" + EOL +\n                                \"aaaaaa\" + EOL +\n                                \"aaaaa\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, expected);\n        assertEquals(expected, sb.toString(), \"multi line text\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRenderWrappedTextMultiLine", "params": [], "body": "                                                 {\n        // multi line text\n        final int width = 16;\n        final int padding = 0;\n        //@formatter:off\n        final String expected = \"aaaa aaaa aaaa\" + EOL +\n                                \"aaaaaa\" + EOL +\n                                \"aaaaa\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, expected);\n        assertEquals(expected, sb.toString(), \"multi line text\");\n    }", "signature": "@Test\n    public void testRenderWrappedTextMultiLine()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRenderWrappedTextMultiLinePadded() {\n        // multi-line padded text\n        final int width = 16;\n        final int padding = 4;\n        //@formatter:off\n        final String text = \"aaaa aaaa aaaa\" + EOL +\n                      \"aaaaaa\" + EOL +\n                      \"aaaaa\";\n        final String expected = \"aaaa aaaa aaaa\" + EOL +\n                          \"    aaaaaa\" + EOL +\n                          \"    aaaaa\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"multi-line padded text\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRenderWrappedTextMultiLinePadded", "params": [], "body": "                                                       {\n        // multi-line padded text\n        final int width = 16;\n        final int padding = 4;\n        //@formatter:off\n        final String text = \"aaaa aaaa aaaa\" + EOL +\n                      \"aaaaaa\" + EOL +\n                      \"aaaaa\";\n        final String expected = \"aaaa aaaa aaaa\" + EOL +\n                          \"    aaaaaa\" + EOL +\n                          \"    aaaaa\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"multi-line padded text\");\n    }", "signature": "@Test\n    public void testRenderWrappedTextMultiLinePadded()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRenderWrappedTextSingleLine() throws IOException {\n        // single line text\n        final int width = 12;\n        final int padding = 0;\n        final String text = \"This is a test.\";\n        final String expected = \"This is a\" + EOL + \"test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line text\");\n        // check internal exception handling for coverage\n        final HelpFormatter spy = spy(new HelpFormatter());\n        when(spy.appendWrappedText(sb, width, padding, text)).thenThrow(IOException.class);\n        assertThrows(UncheckedIOException.class, () -> spy.renderWrappedText(sb, width, padding, text));\n\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRenderWrappedTextSingleLine", "params": [], "body": "                                                                     {\n        // single line text\n        final int width = 12;\n        final int padding = 0;\n        final String text = \"This is a test.\";\n        final String expected = \"This is a\" + EOL + \"test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line text\");\n        // check internal exception handling for coverage\n        final HelpFormatter spy = spy(new HelpFormatter());\n        when(spy.appendWrappedText(sb, width, padding, text)).thenThrow(IOException.class);\n        assertThrows(UncheckedIOException.class, () -> spy.renderWrappedText(sb, width, padding, text));\n\n    }", "signature": "@Test\n    public void testRenderWrappedTextSingleLine()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRenderWrappedTextSingleLinePadded() {\n        // single line padded text\n        final int width = 12;\n        final int padding = 4;\n        final String text = \"This is a test.\";\n        final String expected = \"This is a\" + EOL + \"    test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line padded text\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRenderWrappedTextSingleLinePadded", "params": [], "body": "                                                        {\n        // single line padded text\n        final int width = 12;\n        final int padding = 4;\n        final String text = \"This is a test.\";\n        final String expected = \"This is a\" + EOL + \"    test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line padded text\");\n    }", "signature": "@Test\n    public void testRenderWrappedTextSingleLinePadded()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRenderWrappedTextSingleLinePadded2() {\n        // single line padded text 2\n        final int width = 53;\n        final int padding = 24;\n        //@formatter:off\n        final String text = \"  -p,--period <PERIOD>  PERIOD is time duration of form \" +\n                            \"DATE[-DATE] where DATE has form YYYY[MM[DD]]\";\n        final String expected = \"  -p,--period <PERIOD>  PERIOD is time duration of\" + EOL +\n                                \"                        form DATE[-DATE] where DATE\" + EOL +\n                                \"                        has form YYYY[MM[DD]]\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line padded text 2\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRenderWrappedTextSingleLinePadded2", "params": [], "body": "                                                         {\n        // single line padded text 2\n        final int width = 53;\n        final int padding = 24;\n        //@formatter:off\n        final String text = \"  -p,--period <PERIOD>  PERIOD is time duration of form \" +\n                            \"DATE[-DATE] where DATE has form YYYY[MM[DD]]\";\n        final String expected = \"  -p,--period <PERIOD>  PERIOD is time duration of\" + EOL +\n                                \"                        form DATE[-DATE] where DATE\" + EOL +\n                                \"                        has form YYYY[MM[DD]]\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line padded text 2\");\n    }", "signature": "@Test\n    public void testRenderWrappedTextSingleLinePadded2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRenderWrappedTextWordCut() {\n        final int width = 7;\n        final int padding = 0;\n        final String text = \"Thisisatest.\";\n        final String expected = \"Thisisa\" + EOL + \"test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"cut and wrap\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRenderWrappedTextWordCut", "params": [], "body": "                                               {\n        final int width = 7;\n        final int padding = 0;\n        final String text = \"Thisisatest.\";\n        final String expected = \"Thisisa\" + EOL + \"test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"cut and wrap\");\n    }", "signature": "@Test\n    public void testRenderWrappedTextWordCut()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRtrim() {\n        final HelpFormatter formatter = new HelpFormatter();\n\n        assertNull(formatter.rtrim(null));\n        assertEquals(\"\", formatter.rtrim(\"\"));\n        assertEquals(\"  foo\", formatter.rtrim(\"  foo  \"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRtrim", "params": [], "body": "                            {\n        final HelpFormatter formatter = new HelpFormatter();\n\n        assertNull(formatter.rtrim(null));\n        assertEquals(\"\", formatter.rtrim(\"\"));\n        assertEquals(\"  foo\", formatter.rtrim(\"  foo  \"));\n    }", "signature": "@Test\n    public void testRtrim()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUsageWithLongOptSeparator() {\n        final Options options = new Options();\n        options.addOption(\"f\", true, \"the file\");\n        options.addOption(Option.builder(\"s\").longOpt(\"size\").desc(\"the size\").hasArg().argName(\"SIZE\").build());\n        options.addOption(Option.builder().longOpt(\"age\").desc(\"the age\").hasArg().build());\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.setLongOptSeparator(\"=\");\n\n        final StringWriter out = new StringWriter();\n\n        formatter.printUsage(new PrintWriter(out), 80, \"create\", options);\n\n        assertEquals(\"usage: create [--age=<arg>] [-f <arg>] [-s <SIZE>]\", out.toString().trim());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUsageWithLongOptSeparator", "params": [], "body": "                                                {\n        final Options options = new Options();\n        options.addOption(\"f\", true, \"the file\");\n        options.addOption(Option.builder(\"s\").longOpt(\"size\").desc(\"the size\").hasArg().argName(\"SIZE\").build());\n        options.addOption(Option.builder().longOpt(\"age\").desc(\"the age\").hasArg().build());\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.setLongOptSeparator(\"=\");\n\n        final StringWriter out = new StringWriter();\n\n        formatter.printUsage(new PrintWriter(out), 80, \"create\", options);\n\n        assertEquals(\"usage: create [--age=<arg>] [-f <arg>] [-s <SIZE>]\", out.toString().trim());\n    }", "signature": "@Test\n    public void testUsageWithLongOptSeparator()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/Option_addValueTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Option_addValueTest {\n    private Option option;\n\n    @BeforeEach\n    public void setUp() {\n        option = new Option(\"f\", null);\n    }\n\n    @Test\n    public void testAddValue() {\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value1\"));\n    }\n\n    @Test\n    public void testAddValueAfterClearValues() {\n        option.clearValues();\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value2\"));\n    }\n\n    @Test\n    public void testAddValueWithAcceptsArg() {\n        option.clearValues();\n        if (option.acceptsArg()) {\n            assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value3\"));\n        }\n    }\n\n    @Test\n    public void testAddValueWithRequiresArg() {\n        option.clearValues();\n        if (option.requiresArg()) {\n            assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value4\"));\n        }\n    }\n}\n", "file_hash": "34900e88cffa005cdad8a882253763192022e2046f62f638f50efd35c5c270aa", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class Option_addValueTest {\n    private Option option;\n\n    @BeforeEach\n    public void setUp() {\n        option = new Option(\"f\", null);\n    }\n\n    @Test\n    public void testAddValue() {\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value1\"));\n    }\n\n    @Test\n    public void testAddValueAfterClearValues() {\n        option.clearValues();\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value2\"));\n    }\n\n    @Test\n    public void testAddValueWithAcceptsArg() {\n        option.clearValues();\n        if (option.acceptsArg()) {\n            assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value3\"));\n        }\n    }\n\n    @Test\n    public void testAddValueWithRequiresArg() {\n        option.clearValues();\n        if (option.requiresArg()) {\n            assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value4\"));\n        }\n    }\n}", "definition": "public class Option_addValueTest", "class_docstring": "", "name": "Option_addValueTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Option option;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "option", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        option = new Option(\"f\", null);\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        option = new Option(\"f\", null);\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddValue() {\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value1\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddValue", "params": [], "body": "                               {\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value1\"));\n    }", "signature": "@Test\n    public void testAddValue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddValueAfterClearValues() {\n        option.clearValues();\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value2\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddValueAfterClearValues", "params": [], "body": "                                               {\n        option.clearValues();\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value2\"));\n    }", "signature": "@Test\n    public void testAddValueAfterClearValues()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddValueWithAcceptsArg() {\n        option.clearValues();\n        if (option.acceptsArg()) {\n            assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value3\"));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddValueWithAcceptsArg", "params": [], "body": "                                             {\n        option.clearValues();\n        if (option.acceptsArg()) {\n            assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value3\"));\n        }\n    }", "signature": "@Test\n    public void testAddValueWithAcceptsArg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddValueWithRequiresArg() {\n        option.clearValues();\n        if (option.requiresArg()) {\n            assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value4\"));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddValueWithRequiresArg", "params": [], "body": "                                              {\n        option.clearValues();\n        if (option.requiresArg()) {\n            assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"value4\"));\n        }\n    }", "signature": "@Test\n    public void testAddValueWithRequiresArg()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/ValueTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ValueTest {\n\n    private static final Option NULL_OPTION = null;\n    private static final String NULL_STRING = null;\n\n    protected static Stream<CommandLineParser> parsers() {\n        return Stream.of(new DefaultParser(), new PosixParser());\n    }\n\n    private final Options opts = new Options();\n\n    private CommandLine cl;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        opts.addOption(\"a\", false, \"toggle -a\");\n        opts.addOption(\"b\", true, \"set -b\");\n        opts.addOption(\"c\", \"c\", false, \"toggle -c\");\n        opts.addOption(\"d\", \"d\", true, \"set -d\");\n\n        opts.addOption(OptionBuilder.hasOptionalArg().create('e'));\n        opts.addOption(OptionBuilder.hasOptionalArg().withLongOpt(\"fish\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs().withLongOpt(\"gravy\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs(2).withLongOpt(\"hide\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        opts.addOption(OptionBuilder.hasOptionalArgs().create('j'));\n        opts.addOption(Option.builder().option(\"v\").hasArg().valueSeparator().build());\n\n        final String[] args = { \"-a\", \"-b\", \"foo\", \"--c\", \"--d\", \"bar\" };\n\n        cl = new PosixParser().parse(opts, args);\n    }\n\n    @Test\n    public void testLongNoArg() {\n        assertTrue(cl.hasOption(\"c\"));\n        assertNull(cl.getOptionValue(\"c\"));\n    }\n\n    @Test\n    public void testLongNoArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"c\")));\n        assertNull(cl.getOptionValue(opts.getOption(\"c\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\", \"face\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"fish\"));\n        assertEquals(\"face\", cmd.getOptionValue(\"fish\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--gravy\", \"gold\", \"garden\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"gravy\"));\n        assertEquals(\"gold\", cmd.getOptionValue(\"gravy\"));\n        assertEquals(\"gold\", cmd.getOptionValues(\"gravy\")[0]);\n        assertEquals(\"garden\", cmd.getOptionValues(\"gravy\")[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--gravy\", \"gold\", \"garden\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"gravy\")));\n        assertEquals(\"gold\", cmd.getOptionValue(opts.getOption(\"gravy\")));\n        assertEquals(\"gold\", cmd.getOptionValues(opts.getOption(\"gravy\"))[0]);\n        assertEquals(\"garden\", cmd.getOptionValues(opts.getOption(\"gravy\"))[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\", \"face\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"fish\")));\n        assertEquals(\"face\", cmd.getOptionValue(opts.getOption(\"fish\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--hide\", \"house\", \"hair\", \"head\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"hide\"));\n        assertEquals(\"house\", cmd.getOptionValue(\"hide\"));\n        assertEquals(\"house\", cmd.getOptionValues(\"hide\")[0]);\n        assertEquals(\"hair\", cmd.getOptionValues(\"hide\")[1]);\n        assertEquals(cmd.getArgs().length, 1);\n        assertEquals(\"head\", cmd.getArgs()[0]);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final CommandLine cmd = parser.parse(opts, new String[] { \"--hide\", \"house\", \"hair\", \"head\" });\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"hide\")));\n        assertEquals(\"house\", cmd.getOptionValue(opts.getOption(\"hide\")));\n        assertEquals(\"house\", cmd.getOptionValues(opts.getOption(\"hide\"))[0]);\n        assertEquals(\"hair\", cmd.getOptionValues(opts.getOption(\"hide\"))[1]);\n        assertEquals(cmd.getArgs().length, 1);\n        assertEquals(\"head\", cmd.getArgs()[0]);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNoValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"fish\"));\n        assertNull(cmd.getOptionValue(\"fish\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNoValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"fish\")));\n        assertNull(cmd.getOptionValue(opts.getOption(\"fish\")));\n    }\n\n    @Test\n    public void testLongWithArg() {\n        assertTrue(cl.hasOption(\"d\"));\n        assertNotNull(cl.getOptionValue(\"d\"));\n        assertEquals(cl.getOptionValue(\"d\"), \"bar\");\n    }\n\n    @Test\n    public void testLongWithArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"d\")));\n        assertNotNull(cl.getOptionValue(opts.getOption(\"d\")));\n        assertEquals(cl.getOptionValue(opts.getOption(\"d\")), \"bar\");\n    }\n\n    @Test\n    public void testShortNoArg() {\n        assertTrue(cl.hasOption(\"a\"));\n        assertNull(cl.getOptionValue(\"a\"));\n    }\n\n    @Test\n    public void testShortNoArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"a\")));\n        assertNull(cl.getOptionValue(opts.getOption(\"a\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgNoValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"e\"));\n        assertNull(cmd.getOptionValue(\"e\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgNoValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"e\")));\n        assertNull(cmd.getOptionValue(opts.getOption(\"e\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\", \"everything\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"e\"));\n        assertEquals(\"everything\", cmd.getOptionValue(\"e\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-j\", \"ink\", \"idea\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"j\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"j\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"j\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"j\")[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-j\", \"ink\", \"idea\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"j\")));\n        assertEquals(\"ink\", cmd.getOptionValue(opts.getOption(\"j\")));\n        assertEquals(\"ink\", cmd.getOptionValues(opts.getOption(\"j\"))[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(opts.getOption(\"j\"))[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\", \"everything\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"e\")));\n        assertEquals(\"everything\", cmd.getOptionValue(opts.getOption(\"e\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalNArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-i\", \"ink\", \"idea\", \"isotope\", \"ice\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"i\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"i\")[1]);\n        assertEquals(cmd.getArgs().length, 2);\n        assertEquals(\"isotope\", cmd.getArgs()[0]);\n        assertEquals(\"ice\", cmd.getArgs()[1]);\n    }\n\n    @Test\n    public void testShortOptionalNArgValuesSeparated() throws Exception {\n        final String[] args = { \"-v=ink\", \"-v=idea\", \"-v=isotope\", \"-v=ice\" };\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"v\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"v\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"v\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"v\")[1]);\n        assertEquals(\"isotope\", cmd.getOptionValues(\"v\")[2]);\n        assertEquals(\"ice\", cmd.getOptionValues(\"v\")[3]);\n    }\n\n    @Test\n    public void testShortOptionalNArgValuesWithOption() throws Exception {\n        final String[] args = { \"-i\", \"ink\", \"idea\", \"isotope\", \"ice\" };\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(opts.getOption(\"i\")));\n        assertEquals(\"ink\", cmd.getOptionValues(opts.getOption(\"i\"))[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(opts.getOption(\"i\"))[1]);\n        assertEquals(cmd.getArgs().length, 2);\n        assertEquals(\"isotope\", cmd.getArgs()[0]);\n        assertEquals(\"ice\", cmd.getArgs()[1]);\n    }\n\n    @Test\n    public void testShortWithArg() {\n        assertTrue(cl.hasOption(\"b\"));\n        assertNotNull(cl.getOptionValue(\"b\"));\n        assertEquals(cl.getOptionValue(\"b\"), \"foo\");\n    }\n\n    @Test\n    public void testShortWithArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"b\")));\n        assertNotNull(cl.getOptionValue(opts.getOption(\"b\")));\n        assertEquals(cl.getOptionValue(opts.getOption(\"b\")), \"foo\");\n    }\n}\n", "file_hash": "e43072137490a0d90adad083c7bd90abf8113d7f64eb634d1f801e38281f623e", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import java.util.stream.Stream;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.provider.MethodSource;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ValueTest {\n\n    private static final Option NULL_OPTION = null;\n    private static final String NULL_STRING = null;\n\n    protected static Stream<CommandLineParser> parsers() {\n        return Stream.of(new DefaultParser(), new PosixParser());\n    }\n\n    private final Options opts = new Options();\n\n    private CommandLine cl;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        opts.addOption(\"a\", false, \"toggle -a\");\n        opts.addOption(\"b\", true, \"set -b\");\n        opts.addOption(\"c\", \"c\", false, \"toggle -c\");\n        opts.addOption(\"d\", \"d\", true, \"set -d\");\n\n        opts.addOption(OptionBuilder.hasOptionalArg().create('e'));\n        opts.addOption(OptionBuilder.hasOptionalArg().withLongOpt(\"fish\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs().withLongOpt(\"gravy\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs(2).withLongOpt(\"hide\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        opts.addOption(OptionBuilder.hasOptionalArgs().create('j'));\n        opts.addOption(Option.builder().option(\"v\").hasArg().valueSeparator().build());\n\n        final String[] args = { \"-a\", \"-b\", \"foo\", \"--c\", \"--d\", \"bar\" };\n\n        cl = new PosixParser().parse(opts, args);\n    }\n\n    @Test\n    public void testLongNoArg() {\n        assertTrue(cl.hasOption(\"c\"));\n        assertNull(cl.getOptionValue(\"c\"));\n    }\n\n    @Test\n    public void testLongNoArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"c\")));\n        assertNull(cl.getOptionValue(opts.getOption(\"c\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\", \"face\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"fish\"));\n        assertEquals(\"face\", cmd.getOptionValue(\"fish\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--gravy\", \"gold\", \"garden\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"gravy\"));\n        assertEquals(\"gold\", cmd.getOptionValue(\"gravy\"));\n        assertEquals(\"gold\", cmd.getOptionValues(\"gravy\")[0]);\n        assertEquals(\"garden\", cmd.getOptionValues(\"gravy\")[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--gravy\", \"gold\", \"garden\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"gravy\")));\n        assertEquals(\"gold\", cmd.getOptionValue(opts.getOption(\"gravy\")));\n        assertEquals(\"gold\", cmd.getOptionValues(opts.getOption(\"gravy\"))[0]);\n        assertEquals(\"garden\", cmd.getOptionValues(opts.getOption(\"gravy\"))[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\", \"face\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"fish\")));\n        assertEquals(\"face\", cmd.getOptionValue(opts.getOption(\"fish\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--hide\", \"house\", \"hair\", \"head\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"hide\"));\n        assertEquals(\"house\", cmd.getOptionValue(\"hide\"));\n        assertEquals(\"house\", cmd.getOptionValues(\"hide\")[0]);\n        assertEquals(\"hair\", cmd.getOptionValues(\"hide\")[1]);\n        assertEquals(cmd.getArgs().length, 1);\n        assertEquals(\"head\", cmd.getArgs()[0]);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final CommandLine cmd = parser.parse(opts, new String[] { \"--hide\", \"house\", \"hair\", \"head\" });\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"hide\")));\n        assertEquals(\"house\", cmd.getOptionValue(opts.getOption(\"hide\")));\n        assertEquals(\"house\", cmd.getOptionValues(opts.getOption(\"hide\"))[0]);\n        assertEquals(\"hair\", cmd.getOptionValues(opts.getOption(\"hide\"))[1]);\n        assertEquals(cmd.getArgs().length, 1);\n        assertEquals(\"head\", cmd.getArgs()[0]);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNoValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"fish\"));\n        assertNull(cmd.getOptionValue(\"fish\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNoValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"fish\")));\n        assertNull(cmd.getOptionValue(opts.getOption(\"fish\")));\n    }\n\n    @Test\n    public void testLongWithArg() {\n        assertTrue(cl.hasOption(\"d\"));\n        assertNotNull(cl.getOptionValue(\"d\"));\n        assertEquals(cl.getOptionValue(\"d\"), \"bar\");\n    }\n\n    @Test\n    public void testLongWithArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"d\")));\n        assertNotNull(cl.getOptionValue(opts.getOption(\"d\")));\n        assertEquals(cl.getOptionValue(opts.getOption(\"d\")), \"bar\");\n    }\n\n    @Test\n    public void testShortNoArg() {\n        assertTrue(cl.hasOption(\"a\"));\n        assertNull(cl.getOptionValue(\"a\"));\n    }\n\n    @Test\n    public void testShortNoArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"a\")));\n        assertNull(cl.getOptionValue(opts.getOption(\"a\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgNoValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"e\"));\n        assertNull(cmd.getOptionValue(\"e\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgNoValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"e\")));\n        assertNull(cmd.getOptionValue(opts.getOption(\"e\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\", \"everything\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"e\"));\n        assertEquals(\"everything\", cmd.getOptionValue(\"e\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-j\", \"ink\", \"idea\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"j\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"j\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"j\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"j\")[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-j\", \"ink\", \"idea\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"j\")));\n        assertEquals(\"ink\", cmd.getOptionValue(opts.getOption(\"j\")));\n        assertEquals(\"ink\", cmd.getOptionValues(opts.getOption(\"j\"))[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(opts.getOption(\"j\"))[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\", \"everything\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"e\")));\n        assertEquals(\"everything\", cmd.getOptionValue(opts.getOption(\"e\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalNArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-i\", \"ink\", \"idea\", \"isotope\", \"ice\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"i\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"i\")[1]);\n        assertEquals(cmd.getArgs().length, 2);\n        assertEquals(\"isotope\", cmd.getArgs()[0]);\n        assertEquals(\"ice\", cmd.getArgs()[1]);\n    }\n\n    @Test\n    public void testShortOptionalNArgValuesSeparated() throws Exception {\n        final String[] args = { \"-v=ink\", \"-v=idea\", \"-v=isotope\", \"-v=ice\" };\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"v\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"v\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"v\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"v\")[1]);\n        assertEquals(\"isotope\", cmd.getOptionValues(\"v\")[2]);\n        assertEquals(\"ice\", cmd.getOptionValues(\"v\")[3]);\n    }\n\n    @Test\n    public void testShortOptionalNArgValuesWithOption() throws Exception {\n        final String[] args = { \"-i\", \"ink\", \"idea\", \"isotope\", \"ice\" };\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(opts.getOption(\"i\")));\n        assertEquals(\"ink\", cmd.getOptionValues(opts.getOption(\"i\"))[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(opts.getOption(\"i\"))[1]);\n        assertEquals(cmd.getArgs().length, 2);\n        assertEquals(\"isotope\", cmd.getArgs()[0]);\n        assertEquals(\"ice\", cmd.getArgs()[1]);\n    }\n\n    @Test\n    public void testShortWithArg() {\n        assertTrue(cl.hasOption(\"b\"));\n        assertNotNull(cl.getOptionValue(\"b\"));\n        assertEquals(cl.getOptionValue(\"b\"), \"foo\");\n    }\n\n    @Test\n    public void testShortWithArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"b\")));\n        assertNotNull(cl.getOptionValue(opts.getOption(\"b\")));\n        assertEquals(cl.getOptionValue(opts.getOption(\"b\")), \"foo\");\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ValueTest", "class_docstring": "", "name": "ValueTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [{"attribute_expression": "private static final Option NULL_OPTION = null;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Option", "name": "NULL_OPTION = null", "syntax_pass": true}, {"attribute_expression": "private static final String NULL_STRING = null;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "NULL_STRING = null", "syntax_pass": true}, {"attribute_expression": "private final Options opts = new Options();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Options", "name": "opts = new Options()", "syntax_pass": true}, {"attribute_expression": "private CommandLine cl;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CommandLine", "name": "cl", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected static Stream<CommandLineParser> parsers() {\n        return Stream.of(new DefaultParser(), new PosixParser());\n    }", "docstring": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "return_type": "Stream<CommandLineParser>", "classes": []}, "name": "parsers", "params": [], "body": "                                                         {\n        return Stream.of(new DefaultParser(), new PosixParser());\n    }", "signature": "protected static Stream<CommandLineParser> parsers()"}, {"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        opts.addOption(\"a\", false, \"toggle -a\");\n        opts.addOption(\"b\", true, \"set -b\");\n        opts.addOption(\"c\", \"c\", false, \"toggle -c\");\n        opts.addOption(\"d\", \"d\", true, \"set -d\");\n\n        opts.addOption(OptionBuilder.hasOptionalArg().create('e'));\n        opts.addOption(OptionBuilder.hasOptionalArg().withLongOpt(\"fish\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs().withLongOpt(\"gravy\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs(2).withLongOpt(\"hide\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        opts.addOption(OptionBuilder.hasOptionalArgs().create('j'));\n        opts.addOption(Option.builder().option(\"v\").hasArg().valueSeparator().build());\n\n        final String[] args = { \"-a\", \"-b\", \"foo\", \"--c\", \"--d\", \"bar\" };\n\n        cl = new PosixParser().parse(opts, args);\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                                         {\n        opts.addOption(\"a\", false, \"toggle -a\");\n        opts.addOption(\"b\", true, \"set -b\");\n        opts.addOption(\"c\", \"c\", false, \"toggle -c\");\n        opts.addOption(\"d\", \"d\", true, \"set -d\");\n\n        opts.addOption(OptionBuilder.hasOptionalArg().create('e'));\n        opts.addOption(OptionBuilder.hasOptionalArg().withLongOpt(\"fish\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs().withLongOpt(\"gravy\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs(2).withLongOpt(\"hide\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        opts.addOption(OptionBuilder.hasOptionalArgs().create('j'));\n        opts.addOption(Option.builder().option(\"v\").hasArg().valueSeparator().build());\n\n        final String[] args = { \"-a\", \"-b\", \"foo\", \"--c\", \"--d\", \"bar\" };\n\n        cl = new PosixParser().parse(opts, args);\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongNoArg() {\n        assertTrue(cl.hasOption(\"c\"));\n        assertNull(cl.getOptionValue(\"c\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongNoArg", "params": [], "body": "                                {\n        assertTrue(cl.hasOption(\"c\"));\n        assertNull(cl.getOptionValue(\"c\"));\n    }", "signature": "@Test\n    public void testLongNoArg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongNoArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"c\")));\n        assertNull(cl.getOptionValue(opts.getOption(\"c\")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongNoArgWithOption", "params": [], "body": "                                          {\n        assertTrue(cl.hasOption(opts.getOption(\"c\")));\n        assertNull(cl.getOptionValue(opts.getOption(\"c\")));\n    }", "signature": "@Test\n    public void testLongNoArgWithOption()"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\", \"face\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"fish\"));\n        assertEquals(\"face\", cmd.getOptionValue(\"fish\"));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionalArgValue", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                          {\n        final String[] args = { \"--fish\", \"face\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"fish\"));\n        assertEquals(\"face\", cmd.getOptionValue(\"fish\"));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValue(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--gravy\", \"gold\", \"garden\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"gravy\"));\n        assertEquals(\"gold\", cmd.getOptionValue(\"gravy\"));\n        assertEquals(\"gold\", cmd.getOptionValues(\"gravy\")[0]);\n        assertEquals(\"garden\", cmd.getOptionValues(\"gravy\")[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionalArgValues", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                           {\n        final String[] args = { \"--gravy\", \"gold\", \"garden\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"gravy\"));\n        assertEquals(\"gold\", cmd.getOptionValue(\"gravy\"));\n        assertEquals(\"gold\", cmd.getOptionValues(\"gravy\")[0]);\n        assertEquals(\"garden\", cmd.getOptionValues(\"gravy\")[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValues(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--gravy\", \"gold\", \"garden\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"gravy\")));\n        assertEquals(\"gold\", cmd.getOptionValue(opts.getOption(\"gravy\")));\n        assertEquals(\"gold\", cmd.getOptionValues(opts.getOption(\"gravy\"))[0]);\n        assertEquals(\"garden\", cmd.getOptionValues(opts.getOption(\"gravy\"))[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionalArgValuesWithOption", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                                     {\n        final String[] args = { \"--gravy\", \"gold\", \"garden\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"gravy\")));\n        assertEquals(\"gold\", cmd.getOptionValue(opts.getOption(\"gravy\")));\n        assertEquals(\"gold\", cmd.getOptionValues(opts.getOption(\"gravy\"))[0]);\n        assertEquals(\"garden\", cmd.getOptionValues(opts.getOption(\"gravy\"))[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValuesWithOption(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\", \"face\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"fish\")));\n        assertEquals(\"face\", cmd.getOptionValue(opts.getOption(\"fish\")));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionalArgValueWithOption", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                                    {\n        final String[] args = { \"--fish\", \"face\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"fish\")));\n        assertEquals(\"face\", cmd.getOptionValue(opts.getOption(\"fish\")));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValueWithOption(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--hide\", \"house\", \"hair\", \"head\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"hide\"));\n        assertEquals(\"house\", cmd.getOptionValue(\"hide\"));\n        assertEquals(\"house\", cmd.getOptionValues(\"hide\")[0]);\n        assertEquals(\"hair\", cmd.getOptionValues(\"hide\")[1]);\n        assertEquals(cmd.getArgs().length, 1);\n        assertEquals(\"head\", cmd.getArgs()[0]);\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionalNArgValues", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                            {\n        final String[] args = { \"--hide\", \"house\", \"hair\", \"head\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"hide\"));\n        assertEquals(\"house\", cmd.getOptionValue(\"hide\"));\n        assertEquals(\"house\", cmd.getOptionValues(\"hide\")[0]);\n        assertEquals(\"hair\", cmd.getOptionValues(\"hide\")[1]);\n        assertEquals(cmd.getArgs().length, 1);\n        assertEquals(\"head\", cmd.getArgs()[0]);\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNArgValues(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final CommandLine cmd = parser.parse(opts, new String[] { \"--hide\", \"house\", \"hair\", \"head\" });\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"hide\")));\n        assertEquals(\"house\", cmd.getOptionValue(opts.getOption(\"hide\")));\n        assertEquals(\"house\", cmd.getOptionValues(opts.getOption(\"hide\"))[0]);\n        assertEquals(\"hair\", cmd.getOptionValues(opts.getOption(\"hide\"))[1]);\n        assertEquals(cmd.getArgs().length, 1);\n        assertEquals(\"head\", cmd.getArgs()[0]);\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionalNArgValuesWithOption", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                                      {\n        final CommandLine cmd = parser.parse(opts, new String[] { \"--hide\", \"house\", \"hair\", \"head\" });\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"hide\")));\n        assertEquals(\"house\", cmd.getOptionValue(opts.getOption(\"hide\")));\n        assertEquals(\"house\", cmd.getOptionValues(opts.getOption(\"hide\"))[0]);\n        assertEquals(\"hair\", cmd.getOptionValues(opts.getOption(\"hide\"))[1]);\n        assertEquals(cmd.getArgs().length, 1);\n        assertEquals(\"head\", cmd.getArgs()[0]);\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNArgValuesWithOption(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNoValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"fish\"));\n        assertNull(cmd.getOptionValue(\"fish\"));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionalNoValue", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                         {\n        final String[] args = { \"--fish\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"fish\"));\n        assertNull(cmd.getOptionValue(\"fish\"));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNoValue(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNoValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"fish\")));\n        assertNull(cmd.getOptionValue(opts.getOption(\"fish\")));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionalNoValueWithOption", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                                   {\n        final String[] args = { \"--fish\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"fish\")));\n        assertNull(cmd.getOptionValue(opts.getOption(\"fish\")));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNoValueWithOption(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongWithArg() {\n        assertTrue(cl.hasOption(\"d\"));\n        assertNotNull(cl.getOptionValue(\"d\"));\n        assertEquals(cl.getOptionValue(\"d\"), \"bar\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithArg", "params": [], "body": "                                  {\n        assertTrue(cl.hasOption(\"d\"));\n        assertNotNull(cl.getOptionValue(\"d\"));\n        assertEquals(cl.getOptionValue(\"d\"), \"bar\");\n    }", "signature": "@Test\n    public void testLongWithArg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongWithArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"d\")));\n        assertNotNull(cl.getOptionValue(opts.getOption(\"d\")));\n        assertEquals(cl.getOptionValue(opts.getOption(\"d\")), \"bar\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithArgWithOption", "params": [], "body": "                                            {\n        assertTrue(cl.hasOption(opts.getOption(\"d\")));\n        assertNotNull(cl.getOptionValue(opts.getOption(\"d\")));\n        assertEquals(cl.getOptionValue(opts.getOption(\"d\")), \"bar\");\n    }", "signature": "@Test\n    public void testLongWithArgWithOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortNoArg() {\n        assertTrue(cl.hasOption(\"a\"));\n        assertNull(cl.getOptionValue(\"a\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortNoArg", "params": [], "body": "                                 {\n        assertTrue(cl.hasOption(\"a\"));\n        assertNull(cl.getOptionValue(\"a\"));\n    }", "signature": "@Test\n    public void testShortNoArg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortNoArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"a\")));\n        assertNull(cl.getOptionValue(opts.getOption(\"a\")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortNoArgWithOption", "params": [], "body": "                                           {\n        assertTrue(cl.hasOption(opts.getOption(\"a\")));\n        assertNull(cl.getOptionValue(opts.getOption(\"a\")));\n    }", "signature": "@Test\n    public void testShortNoArgWithOption()"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgNoValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"e\"));\n        assertNull(cmd.getOptionValue(\"e\"));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionalArgNoValue", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                             {\n        final String[] args = { \"-e\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"e\"));\n        assertNull(cmd.getOptionValue(\"e\"));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgNoValue(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgNoValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"e\")));\n        assertNull(cmd.getOptionValue(opts.getOption(\"e\")));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionalArgNoValueWithOption", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                                       {\n        final String[] args = { \"-e\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"e\")));\n        assertNull(cmd.getOptionValue(opts.getOption(\"e\")));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgNoValueWithOption(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\", \"everything\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"e\"));\n        assertEquals(\"everything\", cmd.getOptionValue(\"e\"));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionalArgValue", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                           {\n        final String[] args = { \"-e\", \"everything\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"e\"));\n        assertEquals(\"everything\", cmd.getOptionValue(\"e\"));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValue(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-j\", \"ink\", \"idea\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"j\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"j\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"j\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"j\")[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionalArgValues", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                            {\n        final String[] args = { \"-j\", \"ink\", \"idea\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"j\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"j\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"j\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"j\")[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValues(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-j\", \"ink\", \"idea\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"j\")));\n        assertEquals(\"ink\", cmd.getOptionValue(opts.getOption(\"j\")));\n        assertEquals(\"ink\", cmd.getOptionValues(opts.getOption(\"j\"))[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(opts.getOption(\"j\"))[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionalArgValuesWithOption", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                                      {\n        final String[] args = { \"-j\", \"ink\", \"idea\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"j\")));\n        assertEquals(\"ink\", cmd.getOptionValue(opts.getOption(\"j\")));\n        assertEquals(\"ink\", cmd.getOptionValues(opts.getOption(\"j\"))[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(opts.getOption(\"j\"))[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValuesWithOption(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\", \"everything\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"e\")));\n        assertEquals(\"everything\", cmd.getOptionValue(opts.getOption(\"e\")));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionalArgValueWithOption", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                                     {\n        final String[] args = { \"-e\", \"everything\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"e\")));\n        assertEquals(\"everything\", cmd.getOptionValue(opts.getOption(\"e\")));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValueWithOption(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalNArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-i\", \"ink\", \"idea\", \"isotope\", \"ice\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"i\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"i\")[1]);\n        assertEquals(cmd.getArgs().length, 2);\n        assertEquals(\"isotope\", cmd.getArgs()[0]);\n        assertEquals(\"ice\", cmd.getArgs()[1]);\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"parsers\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionalNArgValues", "params": [{"name": "parser", "type": "CommandLineParser"}], "body": "                                                                                             {\n        final String[] args = { \"-i\", \"ink\", \"idea\", \"isotope\", \"ice\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"i\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"i\")[1]);\n        assertEquals(cmd.getArgs().length, 2);\n        assertEquals(\"isotope\", cmd.getArgs()[0]);\n        assertEquals(\"ice\", cmd.getArgs()[1]);\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalNArgValues(final CommandLineParser parser)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortOptionalNArgValuesSeparated() throws Exception {\n        final String[] args = { \"-v=ink\", \"-v=idea\", \"-v=isotope\", \"-v=ice\" };\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"v\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"v\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"v\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"v\")[1]);\n        assertEquals(\"isotope\", cmd.getOptionValues(\"v\")[2]);\n        assertEquals(\"ice\", cmd.getOptionValues(\"v\")[3]);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionalNArgValuesSeparated", "params": [], "body": "                                                                        {\n        final String[] args = { \"-v=ink\", \"-v=idea\", \"-v=isotope\", \"-v=ice\" };\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"v\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"v\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"v\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"v\")[1]);\n        assertEquals(\"isotope\", cmd.getOptionValues(\"v\")[2]);\n        assertEquals(\"ice\", cmd.getOptionValues(\"v\")[3]);\n    }", "signature": "@Test\n    public void testShortOptionalNArgValuesSeparated()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortOptionalNArgValuesWithOption() throws Exception {\n        final String[] args = { \"-i\", \"ink\", \"idea\", \"isotope\", \"ice\" };\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(opts.getOption(\"i\")));\n        assertEquals(\"ink\", cmd.getOptionValues(opts.getOption(\"i\"))[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(opts.getOption(\"i\"))[1]);\n        assertEquals(cmd.getArgs().length, 2);\n        assertEquals(\"isotope\", cmd.getArgs()[0]);\n        assertEquals(\"ice\", cmd.getArgs()[1]);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionalNArgValuesWithOption", "params": [], "body": "                                                                         {\n        final String[] args = { \"-i\", \"ink\", \"idea\", \"isotope\", \"ice\" };\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(opts.getOption(\"i\")));\n        assertEquals(\"ink\", cmd.getOptionValues(opts.getOption(\"i\"))[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(opts.getOption(\"i\"))[1]);\n        assertEquals(cmd.getArgs().length, 2);\n        assertEquals(\"isotope\", cmd.getArgs()[0]);\n        assertEquals(\"ice\", cmd.getArgs()[1]);\n    }", "signature": "@Test\n    public void testShortOptionalNArgValuesWithOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortWithArg() {\n        assertTrue(cl.hasOption(\"b\"));\n        assertNotNull(cl.getOptionValue(\"b\"));\n        assertEquals(cl.getOptionValue(\"b\"), \"foo\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortWithArg", "params": [], "body": "                                   {\n        assertTrue(cl.hasOption(\"b\"));\n        assertNotNull(cl.getOptionValue(\"b\"));\n        assertEquals(cl.getOptionValue(\"b\"), \"foo\");\n    }", "signature": "@Test\n    public void testShortWithArg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortWithArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"b\")));\n        assertNotNull(cl.getOptionValue(opts.getOption(\"b\")));\n        assertEquals(cl.getOptionValue(opts.getOption(\"b\")), \"foo\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortWithArgWithOption", "params": [], "body": "                                             {\n        assertTrue(cl.hasOption(opts.getOption(\"b\")));\n        assertNotNull(cl.getOptionValue(opts.getOption(\"b\")));\n        assertEquals(cl.getOptionValue(opts.getOption(\"b\")), \"foo\");\n    }", "signature": "@Test\n    public void testShortWithArgWithOption()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/OptionTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotSame;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.junit.jupiter.api.Test;\n\npublic class OptionTest {\n\n    private static final class DefaultOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        private final String defaultValue;\n\n        DefaultOption(final String opt, final String description, final String defaultValue) throws IllegalArgumentException {\n            super(opt, true, description);\n            this.defaultValue = defaultValue;\n        }\n\n        @Override\n        public String getValue() {\n            return super.getValue() != null ? super.getValue() : defaultValue;\n        }\n    }\n\n    private static final class TestOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        TestOption(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n            super(opt, hasArg, description);\n        }\n\n        @Override\n        public boolean addValue(final String value) {\n            processValue(value);\n            return true;\n        }\n    }\n\n    private static void checkOption(final Option option, final String opt, final String description, final String longOpt, final int numArgs,\n            final String argName, final boolean required, final boolean optionalArg, final char valueSeparator, final Class<?> cls, final String deprecatedDesc,\n            final Boolean deprecatedForRemoval, final String deprecatedSince) {\n        assertEquals(opt, option.getOpt());\n        assertEquals(description, option.getDescription());\n        assertEquals(longOpt, option.getLongOpt());\n        assertEquals(numArgs, option.getArgs());\n        assertEquals(argName, option.getArgName());\n        assertEquals(required, option.isRequired());\n\n        assertEquals(optionalArg, option.hasOptionalArg());\n        assertEquals(numArgs > 0, option.hasArg());\n        assertEquals(numArgs > 0, option.acceptsArg());\n        assertEquals(valueSeparator, option.getValueSeparator());\n        assertEquals(cls, option.getType());\n        if (deprecatedDesc != null) {\n            assertEquals(deprecatedDesc, option.getDeprecated().getDescription());\n        }\n        if (deprecatedForRemoval != null) {\n            assertEquals(deprecatedForRemoval, option.getDeprecated().isForRemoval());\n        }\n        if (deprecatedSince != null) {\n            assertEquals(deprecatedSince, option.getDeprecated().getSince());\n        }\n    }\n\n    private Option roundTrip(final Option o) throws IOException, ClassNotFoundException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(o);\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        final ObjectInputStream ois = new ObjectInputStream(bais);\n        return (Option) ois.readObject();\n    }\n\n    @Test\n    public void testAddValue() {\n        final Option option = new Option(\"f\", null);\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"\"));\n        assertThrows(IllegalArgumentException.class, () -> option.processValue(\"\"));\n    }\n\n    @Test\n    public void testBuilderEmpty() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().build());\n    }\n\n    @Test\n    public void testBuilderInsufficientParams1() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().desc(\"desc\").build());\n    }\n\n    @Test\n    public void testBuilderInsufficientParams2() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(null).desc(\"desc\").build());\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName0() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(null).build());\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"\"));\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\" \"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName1() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"invalid?\"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName2() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"invalid@\"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName3() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(\"invalid?\"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName4() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(\"invalid@\"));\n    }\n\n    @Test\n    public void testBuilderMethods() {\n        final char defaultSeparator = (char) 0;\n\n        checkOption(Option.builder(\"a\").desc(\"desc\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").longOpt(\"aaa\").build(), \"a\", \"desc\", \"aaa\", Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(true).build(), \"a\", \"desc\", null, 1, null, false, false, defaultSeparator, String.class, null, null,\n                null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(true).build(), \"a\", \"desc\", null, 1, null, false, false, defaultSeparator, String.class, null, null,\n                null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").numberOfArgs(3).build(), \"a\", \"desc\", null, 3, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").required(true).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, true, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").required(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n\n        checkOption(Option.builder(\"a\").desc(\"desc\").argName(\"arg1\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, \"arg1\", false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").optionalArg(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").optionalArg(true).build(), \"a\", \"desc\", null, 1, null, false, true, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").valueSeparator(':').build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, ':',\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").type(Integer.class).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                Integer.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").type(null).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false,\n                defaultSeparator, Integer.class, null, null, null);\n        // Deprecated\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated().build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false,\n                false, defaultSeparator, Integer.class, \"\", false, \"\");\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated(DeprecatedAttributes.builder().get()).build(), \"a\", \"desc\", null,\n                Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"\", false, \"\");\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated(DeprecatedAttributes.builder().setDescription(\"X\").get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", false, \"\");\n        checkOption(\n                Option.builder().option(\"a\").desc(\"desc\").type(Integer.class)\n                        .deprecated(DeprecatedAttributes.builder().setDescription(\"X\").setForRemoval(true).get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", true, \"\");\n        checkOption(\n                Option.builder().option(\"a\").desc(\"desc\").type(Integer.class)\n                        .deprecated(DeprecatedAttributes.builder().setDescription(\"X\").setForRemoval(true).setSince(\"2.0\").get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", true, \"2.0\");\n    }\n\n    @Test\n    public void testClear() {\n        final TestOption option = new TestOption(\"x\", true, \"\");\n        assertEquals(0, option.getValuesList().size());\n        option.addValue(\"a\");\n        assertEquals(1, option.getValuesList().size());\n        option.clearValues();\n        assertEquals(0, option.getValuesList().size());\n    }\n\n    // See https://issues.apache.org/jira/browse/CLI-21\n    @Test\n    public void testClone() {\n        final TestOption a = new TestOption(\"a\", true, \"\");\n        final TestOption b = (TestOption) a.clone();\n        assertEquals(a, b);\n        assertNotSame(a, b);\n        a.setDescription(\"a\");\n        assertEquals(\"\", b.getDescription());\n        b.setArgs(2);\n        b.addValue(\"b1\");\n        b.addValue(\"b2\");\n        assertEquals(1, a.getArgs());\n        assertEquals(0, a.getValuesList().size());\n        assertEquals(2, b.getValues().length);\n    }\n\n    @Test\n    public void testEquals() {\n        final Option option1a = new Option(\"1\", null);\n        final Option option1b = new Option(\"1\", null);\n        final Option option2 = new Option(\"2\", null);\n        assertEquals(option1a, option1a);\n        assertEquals(option1a, option1b);\n        assertEquals(option1b, option1a);\n        assertNotEquals(option1a, option2);\n        assertNotEquals(option1b, option2);\n        assertNotEquals(option2, option1a);\n        assertNotEquals(option2, \"\");\n    }\n\n    @Test\n    public void testGetValue() {\n        final Option option = new Option(\"f\", null);\n        option.setArgs(Option.UNLIMITED_VALUES);\n\n        assertEquals(\"default\", option.getValue(\"default\"));\n        assertNull(option.getValue(0));\n\n        option.processValue(\"foo\");\n\n        assertEquals(\"foo\", option.getValue());\n        assertEquals(\"foo\", option.getValue(0));\n        assertEquals(\"foo\", option.getValue(\"default\"));\n    }\n\n    @Test\n    public void testHasArgName() {\n        final Option option = new Option(\"f\", null);\n\n        option.setArgName(null);\n        assertFalse(option.hasArgName());\n\n        option.setArgName(\"\");\n        assertFalse(option.hasArgName());\n\n        option.setArgName(\"file\");\n        assertTrue(option.hasArgName());\n    }\n\n    @Test\n    public void testHasArgs() {\n        final Option option = new Option(\"f\", null);\n\n        option.setArgs(0);\n        assertFalse(option.hasArgs());\n\n        option.setArgs(1);\n        assertFalse(option.hasArgs());\n\n        option.setArgs(10);\n        assertTrue(option.hasArgs());\n\n        option.setArgs(Option.UNLIMITED_VALUES);\n        assertTrue(option.hasArgs());\n\n        option.setArgs(Option.UNINITIALIZED);\n        assertFalse(option.hasArgs());\n    }\n\n    @Test\n    public void testHashCode() {\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder(\"test2\").build().hashCode());\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder().longOpt(\"test\").build().hashCode());\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder(\"test\").longOpt(\"long test\").build().hashCode());\n    }\n\n    @Test\n    public void testSerialization() throws IOException, ClassNotFoundException {\n        final Option option = Option.builder(\"o\").type(TypeHandlerTest.Instantiable.class).build();\n        assertEquals(Converter.DEFAULT, option.getConverter());\n        Option roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n        // verify unregistered class converters and verifiers get reset to default.\n        // converters are NOT Serializable, use a serialization proxy if you want that.\n        option.setConverter(Converter.DATE);\n        roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n        // verify registered class converters and verifiers do not get reset to default.\n        // converters are NOT Serializable, use a serialization proxy if you want that.\n        // verify earlier values still set.\n        assertEquals(Converter.DATE, option.getConverter());\n        roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n    }\n\n    @Test\n    public void testSubclass() {\n        final Option option = new DefaultOption(\"f\", \"file\", \"myfile.txt\");\n        final Option clone = (Option) option.clone();\n        assertEquals(\"myfile.txt\", clone.getValue());\n        assertEquals(DefaultOption.class, clone.getClass());\n    }\n\n    @Test\n    public void testTypeClass() {\n        final Option option = new Option(\"f\", null);\n        assertEquals(String.class, option.getType());\n        option.setType(CharSequence.class);\n        assertEquals(CharSequence.class, option.getType());\n    }\n\n    @Test\n    public void testTypeObject() {\n        final Option option = new Option(\"f\", null);\n        assertEquals(String.class, option.getType());\n        @SuppressWarnings(\"cast\")\n        final Object type = CharSequence.class; // Do NOT remove cast\n        option.setType(type);\n        assertEquals(CharSequence.class, option.getType());\n    }\n}\n", "file_hash": "2a80ea1bbb9f8ee1de276276d70fb3270d7653b222c291a7ab208d43ccc47c73", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertNotEquals;", "import static org.junit.jupiter.api.Assertions.assertNotSame;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import java.io.ByteArrayInputStream;", "import java.io.ByteArrayOutputStream;", "import java.io.IOException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class OptionTest {\n\n    private static final class DefaultOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        private final String defaultValue;\n\n        DefaultOption(final String opt, final String description, final String defaultValue) throws IllegalArgumentException {\n            super(opt, true, description);\n            this.defaultValue = defaultValue;\n        }\n\n        @Override\n        public String getValue() {\n            return super.getValue() != null ? super.getValue() : defaultValue;\n        }\n    }\n\n    private static final class TestOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        TestOption(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n            super(opt, hasArg, description);\n        }\n\n        @Override\n        public boolean addValue(final String value) {\n            processValue(value);\n            return true;\n        }\n    }\n\n    private static void checkOption(final Option option, final String opt, final String description, final String longOpt, final int numArgs,\n            final String argName, final boolean required, final boolean optionalArg, final char valueSeparator, final Class<?> cls, final String deprecatedDesc,\n            final Boolean deprecatedForRemoval, final String deprecatedSince) {\n        assertEquals(opt, option.getOpt());\n        assertEquals(description, option.getDescription());\n        assertEquals(longOpt, option.getLongOpt());\n        assertEquals(numArgs, option.getArgs());\n        assertEquals(argName, option.getArgName());\n        assertEquals(required, option.isRequired());\n\n        assertEquals(optionalArg, option.hasOptionalArg());\n        assertEquals(numArgs > 0, option.hasArg());\n        assertEquals(numArgs > 0, option.acceptsArg());\n        assertEquals(valueSeparator, option.getValueSeparator());\n        assertEquals(cls, option.getType());\n        if (deprecatedDesc != null) {\n            assertEquals(deprecatedDesc, option.getDeprecated().getDescription());\n        }\n        if (deprecatedForRemoval != null) {\n            assertEquals(deprecatedForRemoval, option.getDeprecated().isForRemoval());\n        }\n        if (deprecatedSince != null) {\n            assertEquals(deprecatedSince, option.getDeprecated().getSince());\n        }\n    }\n\n    private Option roundTrip(final Option o) throws IOException, ClassNotFoundException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(o);\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        final ObjectInputStream ois = new ObjectInputStream(bais);\n        return (Option) ois.readObject();\n    }\n\n    @Test\n    public void testAddValue() {\n        final Option option = new Option(\"f\", null);\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"\"));\n        assertThrows(IllegalArgumentException.class, () -> option.processValue(\"\"));\n    }\n\n    @Test\n    public void testBuilderEmpty() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().build());\n    }\n\n    @Test\n    public void testBuilderInsufficientParams1() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().desc(\"desc\").build());\n    }\n\n    @Test\n    public void testBuilderInsufficientParams2() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(null).desc(\"desc\").build());\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName0() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(null).build());\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"\"));\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\" \"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName1() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"invalid?\"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName2() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"invalid@\"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName3() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(\"invalid?\"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName4() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(\"invalid@\"));\n    }\n\n    @Test\n    public void testBuilderMethods() {\n        final char defaultSeparator = (char) 0;\n\n        checkOption(Option.builder(\"a\").desc(\"desc\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").longOpt(\"aaa\").build(), \"a\", \"desc\", \"aaa\", Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(true).build(), \"a\", \"desc\", null, 1, null, false, false, defaultSeparator, String.class, null, null,\n                null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(true).build(), \"a\", \"desc\", null, 1, null, false, false, defaultSeparator, String.class, null, null,\n                null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").numberOfArgs(3).build(), \"a\", \"desc\", null, 3, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").required(true).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, true, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").required(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n\n        checkOption(Option.builder(\"a\").desc(\"desc\").argName(\"arg1\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, \"arg1\", false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").optionalArg(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").optionalArg(true).build(), \"a\", \"desc\", null, 1, null, false, true, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").valueSeparator(':').build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, ':',\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").type(Integer.class).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                Integer.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").type(null).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false,\n                defaultSeparator, Integer.class, null, null, null);\n        // Deprecated\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated().build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false,\n                false, defaultSeparator, Integer.class, \"\", false, \"\");\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated(DeprecatedAttributes.builder().get()).build(), \"a\", \"desc\", null,\n                Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"\", false, \"\");\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated(DeprecatedAttributes.builder().setDescription(\"X\").get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", false, \"\");\n        checkOption(\n                Option.builder().option(\"a\").desc(\"desc\").type(Integer.class)\n                        .deprecated(DeprecatedAttributes.builder().setDescription(\"X\").setForRemoval(true).get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", true, \"\");\n        checkOption(\n                Option.builder().option(\"a\").desc(\"desc\").type(Integer.class)\n                        .deprecated(DeprecatedAttributes.builder().setDescription(\"X\").setForRemoval(true).setSince(\"2.0\").get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", true, \"2.0\");\n    }\n\n    @Test\n    public void testClear() {\n        final TestOption option = new TestOption(\"x\", true, \"\");\n        assertEquals(0, option.getValuesList().size());\n        option.addValue(\"a\");\n        assertEquals(1, option.getValuesList().size());\n        option.clearValues();\n        assertEquals(0, option.getValuesList().size());\n    }\n\n    // See https://issues.apache.org/jira/browse/CLI-21\n    @Test\n    public void testClone() {\n        final TestOption a = new TestOption(\"a\", true, \"\");\n        final TestOption b = (TestOption) a.clone();\n        assertEquals(a, b);\n        assertNotSame(a, b);\n        a.setDescription(\"a\");\n        assertEquals(\"\", b.getDescription());\n        b.setArgs(2);\n        b.addValue(\"b1\");\n        b.addValue(\"b2\");\n        assertEquals(1, a.getArgs());\n        assertEquals(0, a.getValuesList().size());\n        assertEquals(2, b.getValues().length);\n    }\n\n    @Test\n    public void testEquals() {\n        final Option option1a = new Option(\"1\", null);\n        final Option option1b = new Option(\"1\", null);\n        final Option option2 = new Option(\"2\", null);\n        assertEquals(option1a, option1a);\n        assertEquals(option1a, option1b);\n        assertEquals(option1b, option1a);\n        assertNotEquals(option1a, option2);\n        assertNotEquals(option1b, option2);\n        assertNotEquals(option2, option1a);\n        assertNotEquals(option2, \"\");\n    }\n\n    @Test\n    public void testGetValue() {\n        final Option option = new Option(\"f\", null);\n        option.setArgs(Option.UNLIMITED_VALUES);\n\n        assertEquals(\"default\", option.getValue(\"default\"));\n        assertNull(option.getValue(0));\n\n        option.processValue(\"foo\");\n\n        assertEquals(\"foo\", option.getValue());\n        assertEquals(\"foo\", option.getValue(0));\n        assertEquals(\"foo\", option.getValue(\"default\"));\n    }\n\n    @Test\n    public void testHasArgName() {\n        final Option option = new Option(\"f\", null);\n\n        option.setArgName(null);\n        assertFalse(option.hasArgName());\n\n        option.setArgName(\"\");\n        assertFalse(option.hasArgName());\n\n        option.setArgName(\"file\");\n        assertTrue(option.hasArgName());\n    }\n\n    @Test\n    public void testHasArgs() {\n        final Option option = new Option(\"f\", null);\n\n        option.setArgs(0);\n        assertFalse(option.hasArgs());\n\n        option.setArgs(1);\n        assertFalse(option.hasArgs());\n\n        option.setArgs(10);\n        assertTrue(option.hasArgs());\n\n        option.setArgs(Option.UNLIMITED_VALUES);\n        assertTrue(option.hasArgs());\n\n        option.setArgs(Option.UNINITIALIZED);\n        assertFalse(option.hasArgs());\n    }\n\n    @Test\n    public void testHashCode() {\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder(\"test2\").build().hashCode());\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder().longOpt(\"test\").build().hashCode());\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder(\"test\").longOpt(\"long test\").build().hashCode());\n    }\n\n    @Test\n    public void testSerialization() throws IOException, ClassNotFoundException {\n        final Option option = Option.builder(\"o\").type(TypeHandlerTest.Instantiable.class).build();\n        assertEquals(Converter.DEFAULT, option.getConverter());\n        Option roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n        // verify unregistered class converters and verifiers get reset to default.\n        // converters are NOT Serializable, use a serialization proxy if you want that.\n        option.setConverter(Converter.DATE);\n        roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n        // verify registered class converters and verifiers do not get reset to default.\n        // converters are NOT Serializable, use a serialization proxy if you want that.\n        // verify earlier values still set.\n        assertEquals(Converter.DATE, option.getConverter());\n        roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n    }\n\n    @Test\n    public void testSubclass() {\n        final Option option = new DefaultOption(\"f\", \"file\", \"myfile.txt\");\n        final Option clone = (Option) option.clone();\n        assertEquals(\"myfile.txt\", clone.getValue());\n        assertEquals(DefaultOption.class, clone.getClass());\n    }\n\n    @Test\n    public void testTypeClass() {\n        final Option option = new Option(\"f\", null);\n        assertEquals(String.class, option.getType());\n        option.setType(CharSequence.class);\n        assertEquals(CharSequence.class, option.getType());\n    }\n\n    @Test\n    public void testTypeObject() {\n        final Option option = new Option(\"f\", null);\n        assertEquals(String.class, option.getType());\n        @SuppressWarnings(\"cast\")\n        final Object type = CharSequence.class; // Do NOT remove cast\n        option.setType(type);\n        assertEquals(CharSequence.class, option.getType());\n    }\n}", "definition": "public class OptionTest", "class_docstring": "", "name": "OptionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": [{"original_string": "    private static final class DefaultOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        private final String defaultValue;\n\n        DefaultOption(final String opt, final String description, final String defaultValue) throws IllegalArgumentException {\n            super(opt, true, description);\n            this.defaultValue = defaultValue;\n        }\n\n        @Override\n        public String getValue() {\n            return super.getValue() != null ? super.getValue() : defaultValue;\n        }\n    }", "definition": "    private static final class DefaultOption extends Option", "class_docstring": "", "name": "DefaultOption", "super_interfaces": [], "superclasses": "Option", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final String defaultValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "defaultValue", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        DefaultOption(final String opt, final String description, final String defaultValue) throws IllegalArgumentException {\n            super(opt, true, description);\n            this.defaultValue = defaultValue;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DefaultOption", "params": [{"name": "opt", "type": "String"}, {"name": "description", "type": "String"}, {"name": "defaultValue", "type": "String"}], "body": "                                                                                                                             {\n            super(opt, true, description);\n            this.defaultValue = defaultValue;\n        }", "signature": "DefaultOption(final String opt, final String description, final String defaultValue)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getValue() {\n            return super.getValue() != null ? super.getValue() : defaultValue;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getValue", "params": [], "body": "                                 {\n            return super.getValue() != null ? super.getValue() : defaultValue;\n        }", "signature": "@Override\n        public String getValue()"}]}, {"original_string": "    private static final class TestOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        TestOption(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n            super(opt, hasArg, description);\n        }\n\n        @Override\n        public boolean addValue(final String value) {\n            processValue(value);\n            return true;\n        }\n    }", "definition": "    private static final class TestOption extends Option", "class_docstring": "", "name": "TestOption", "super_interfaces": [], "superclasses": "Option", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TestOption(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n            super(opt, hasArg, description);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TestOption", "params": [{"name": "opt", "type": "String"}, {"name": "hasArg", "type": "boolean"}, {"name": "description", "type": "String"}], "body": "                                                                                                                     {\n            super(opt, hasArg, description);\n        }", "signature": "TestOption(final String opt, final boolean hasArg, final String description)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean addValue(final String value) {\n            processValue(value);\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "addValue", "params": [{"name": "value", "type": "String"}], "body": "                                                    {\n            processValue(value);\n            return true;\n        }", "signature": "@Override\n        public boolean addValue(final String value)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static void checkOption(final Option option, final String opt, final String description, final String longOpt, final int numArgs,\n            final String argName, final boolean required, final boolean optionalArg, final char valueSeparator, final Class<?> cls, final String deprecatedDesc,\n            final Boolean deprecatedForRemoval, final String deprecatedSince) {\n        assertEquals(opt, option.getOpt());\n        assertEquals(description, option.getDescription());\n        assertEquals(longOpt, option.getLongOpt());\n        assertEquals(numArgs, option.getArgs());\n        assertEquals(argName, option.getArgName());\n        assertEquals(required, option.isRequired());\n\n        assertEquals(optionalArg, option.hasOptionalArg());\n        assertEquals(numArgs > 0, option.hasArg());\n        assertEquals(numArgs > 0, option.acceptsArg());\n        assertEquals(valueSeparator, option.getValueSeparator());\n        assertEquals(cls, option.getType());\n        if (deprecatedDesc != null) {\n            assertEquals(deprecatedDesc, option.getDeprecated().getDescription());\n        }\n        if (deprecatedForRemoval != null) {\n            assertEquals(deprecatedForRemoval, option.getDeprecated().isForRemoval());\n        }\n        if (deprecatedSince != null) {\n            assertEquals(deprecatedSince, option.getDeprecated().getSince());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "checkOption", "params": [{"name": "option", "type": "Option"}, {"name": "opt", "type": "String"}, {"name": "description", "type": "String"}, {"name": "longOpt", "type": "String"}, {"name": "numArgs", "type": "int"}, {"name": "argName", "type": "String"}, {"name": "required", "type": "boolean"}, {"name": "optionalArg", "type": "boolean"}, {"name": "valueSeparator", "type": "char"}, {"name": "cls", "type": "Class<?>"}, {"name": "deprecatedDesc", "type": "String"}, {"name": "deprecatedForRemoval", "type": "Boolean"}, {"name": "deprecatedSince", "type": "String"}], "body": "                                                                              {\n        assertEquals(opt, option.getOpt());\n        assertEquals(description, option.getDescription());\n        assertEquals(longOpt, option.getLongOpt());\n        assertEquals(numArgs, option.getArgs());\n        assertEquals(argName, option.getArgName());\n        assertEquals(required, option.isRequired());\n\n        assertEquals(optionalArg, option.hasOptionalArg());\n        assertEquals(numArgs > 0, option.hasArg());\n        assertEquals(numArgs > 0, option.acceptsArg());\n        assertEquals(valueSeparator, option.getValueSeparator());\n        assertEquals(cls, option.getType());\n        if (deprecatedDesc != null) {\n            assertEquals(deprecatedDesc, option.getDeprecated().getDescription());\n        }\n        if (deprecatedForRemoval != null) {\n            assertEquals(deprecatedForRemoval, option.getDeprecated().isForRemoval());\n        }\n        if (deprecatedSince != null) {\n            assertEquals(deprecatedSince, option.getDeprecated().getSince());\n        }\n    }", "signature": "private static void checkOption(final Option option, final String opt, final String description, final String longOpt, final int numArgs,\n            final String argName, final boolean required, final boolean optionalArg, final char valueSeparator, final Class<?> cls, final String deprecatedDesc,\n            final Boolean deprecatedForRemoval, final String deprecatedSince)"}, {"syntax_pass": true, "original_string": "    private Option roundTrip(final Option o) throws IOException, ClassNotFoundException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(o);\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        final ObjectInputStream ois = new ObjectInputStream(bais);\n        return (Option) ois.readObject();\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Option", "classes": []}, "name": "roundTrip", "params": [{"name": "o", "type": "Option"}], "body": "                                                                                        {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(o);\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        final ObjectInputStream ois = new ObjectInputStream(bais);\n        return (Option) ois.readObject();\n    }", "signature": "private Option roundTrip(final Option o)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddValue() {\n        final Option option = new Option(\"f\", null);\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"\"));\n        assertThrows(IllegalArgumentException.class, () -> option.processValue(\"\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddValue", "params": [], "body": "                               {\n        final Option option = new Option(\"f\", null);\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"\"));\n        assertThrows(IllegalArgumentException.class, () -> option.processValue(\"\"));\n    }", "signature": "@Test\n    public void testAddValue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderEmpty() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().build());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderEmpty", "params": [], "body": "                                   {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().build());\n    }", "signature": "@Test\n    public void testBuilderEmpty()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderInsufficientParams1() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().desc(\"desc\").build());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderInsufficientParams1", "params": [], "body": "                                                 {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().desc(\"desc\").build());\n    }", "signature": "@Test\n    public void testBuilderInsufficientParams1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderInsufficientParams2() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(null).desc(\"desc\").build());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderInsufficientParams2", "params": [], "body": "                                                 {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(null).desc(\"desc\").build());\n    }", "signature": "@Test\n    public void testBuilderInsufficientParams2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderInvalidOptionName0() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(null).build());\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"\"));\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\" \"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderInvalidOptionName0", "params": [], "body": "                                                {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(null).build());\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"\"));\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\" \"));\n    }", "signature": "@Test\n    public void testBuilderInvalidOptionName0()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderInvalidOptionName1() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"invalid?\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderInvalidOptionName1", "params": [], "body": "                                                {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"invalid?\"));\n    }", "signature": "@Test\n    public void testBuilderInvalidOptionName1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderInvalidOptionName2() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"invalid@\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderInvalidOptionName2", "params": [], "body": "                                                {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"invalid@\"));\n    }", "signature": "@Test\n    public void testBuilderInvalidOptionName2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderInvalidOptionName3() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(\"invalid?\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderInvalidOptionName3", "params": [], "body": "                                                {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(\"invalid?\"));\n    }", "signature": "@Test\n    public void testBuilderInvalidOptionName3()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderInvalidOptionName4() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(\"invalid@\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderInvalidOptionName4", "params": [], "body": "                                                {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(\"invalid@\"));\n    }", "signature": "@Test\n    public void testBuilderInvalidOptionName4()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderMethods() {\n        final char defaultSeparator = (char) 0;\n\n        checkOption(Option.builder(\"a\").desc(\"desc\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").longOpt(\"aaa\").build(), \"a\", \"desc\", \"aaa\", Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(true).build(), \"a\", \"desc\", null, 1, null, false, false, defaultSeparator, String.class, null, null,\n                null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(true).build(), \"a\", \"desc\", null, 1, null, false, false, defaultSeparator, String.class, null, null,\n                null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").numberOfArgs(3).build(), \"a\", \"desc\", null, 3, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").required(true).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, true, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").required(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n\n        checkOption(Option.builder(\"a\").desc(\"desc\").argName(\"arg1\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, \"arg1\", false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").optionalArg(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").optionalArg(true).build(), \"a\", \"desc\", null, 1, null, false, true, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").valueSeparator(':').build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, ':',\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").type(Integer.class).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                Integer.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").type(null).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false,\n                defaultSeparator, Integer.class, null, null, null);\n        // Deprecated\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated().build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false,\n                false, defaultSeparator, Integer.class, \"\", false, \"\");\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated(DeprecatedAttributes.builder().get()).build(), \"a\", \"desc\", null,\n                Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"\", false, \"\");\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated(DeprecatedAttributes.builder().setDescription(\"X\").get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", false, \"\");\n        checkOption(\n                Option.builder().option(\"a\").desc(\"desc\").type(Integer.class)\n                        .deprecated(DeprecatedAttributes.builder().setDescription(\"X\").setForRemoval(true).get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", true, \"\");\n        checkOption(\n                Option.builder().option(\"a\").desc(\"desc\").type(Integer.class)\n                        .deprecated(DeprecatedAttributes.builder().setDescription(\"X\").setForRemoval(true).setSince(\"2.0\").get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", true, \"2.0\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderMethods", "params": [], "body": "                                     {\n        final char defaultSeparator = (char) 0;\n\n        checkOption(Option.builder(\"a\").desc(\"desc\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").longOpt(\"aaa\").build(), \"a\", \"desc\", \"aaa\", Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(true).build(), \"a\", \"desc\", null, 1, null, false, false, defaultSeparator, String.class, null, null,\n                null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(true).build(), \"a\", \"desc\", null, 1, null, false, false, defaultSeparator, String.class, null, null,\n                null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").numberOfArgs(3).build(), \"a\", \"desc\", null, 3, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").required(true).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, true, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").required(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n\n        checkOption(Option.builder(\"a\").desc(\"desc\").argName(\"arg1\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, \"arg1\", false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").optionalArg(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").optionalArg(true).build(), \"a\", \"desc\", null, 1, null, false, true, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").valueSeparator(':').build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, ':',\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").type(Integer.class).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                Integer.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").type(null).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false,\n                defaultSeparator, Integer.class, null, null, null);\n        // Deprecated\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated().build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false,\n                false, defaultSeparator, Integer.class, \"\", false, \"\");\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated(DeprecatedAttributes.builder().get()).build(), \"a\", \"desc\", null,\n                Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"\", false, \"\");\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated(DeprecatedAttributes.builder().setDescription(\"X\").get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", false, \"\");\n        checkOption(\n                Option.builder().option(\"a\").desc(\"desc\").type(Integer.class)\n                        .deprecated(DeprecatedAttributes.builder().setDescription(\"X\").setForRemoval(true).get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", true, \"\");\n        checkOption(\n                Option.builder().option(\"a\").desc(\"desc\").type(Integer.class)\n                        .deprecated(DeprecatedAttributes.builder().setDescription(\"X\").setForRemoval(true).setSince(\"2.0\").get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", true, \"2.0\");\n    }", "signature": "@Test\n    public void testBuilderMethods()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testClear() {\n        final TestOption option = new TestOption(\"x\", true, \"\");\n        assertEquals(0, option.getValuesList().size());\n        option.addValue(\"a\");\n        assertEquals(1, option.getValuesList().size());\n        option.clearValues();\n        assertEquals(0, option.getValuesList().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testClear", "params": [], "body": "                            {\n        final TestOption option = new TestOption(\"x\", true, \"\");\n        assertEquals(0, option.getValuesList().size());\n        option.addValue(\"a\");\n        assertEquals(1, option.getValuesList().size());\n        option.clearValues();\n        assertEquals(0, option.getValuesList().size());\n    }", "signature": "@Test\n    public void testClear()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testClone() {\n        final TestOption a = new TestOption(\"a\", true, \"\");\n        final TestOption b = (TestOption) a.clone();\n        assertEquals(a, b);\n        assertNotSame(a, b);\n        a.setDescription(\"a\");\n        assertEquals(\"\", b.getDescription());\n        b.setArgs(2);\n        b.addValue(\"b1\");\n        b.addValue(\"b2\");\n        assertEquals(1, a.getArgs());\n        assertEquals(0, a.getValuesList().size());\n        assertEquals(2, b.getValues().length);\n    }", "docstring": " See https://issues.apache.org/jira/browse/CLI-21", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testClone", "params": [], "body": "                            {\n        final TestOption a = new TestOption(\"a\", true, \"\");\n        final TestOption b = (TestOption) a.clone();\n        assertEquals(a, b);\n        assertNotSame(a, b);\n        a.setDescription(\"a\");\n        assertEquals(\"\", b.getDescription());\n        b.setArgs(2);\n        b.addValue(\"b1\");\n        b.addValue(\"b2\");\n        assertEquals(1, a.getArgs());\n        assertEquals(0, a.getValuesList().size());\n        assertEquals(2, b.getValues().length);\n    }", "signature": "@Test\n    public void testClone()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEquals() {\n        final Option option1a = new Option(\"1\", null);\n        final Option option1b = new Option(\"1\", null);\n        final Option option2 = new Option(\"2\", null);\n        assertEquals(option1a, option1a);\n        assertEquals(option1a, option1b);\n        assertEquals(option1b, option1a);\n        assertNotEquals(option1a, option2);\n        assertNotEquals(option1b, option2);\n        assertNotEquals(option2, option1a);\n        assertNotEquals(option2, \"\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEquals", "params": [], "body": "                             {\n        final Option option1a = new Option(\"1\", null);\n        final Option option1b = new Option(\"1\", null);\n        final Option option2 = new Option(\"2\", null);\n        assertEquals(option1a, option1a);\n        assertEquals(option1a, option1b);\n        assertEquals(option1b, option1a);\n        assertNotEquals(option1a, option2);\n        assertNotEquals(option1b, option2);\n        assertNotEquals(option2, option1a);\n        assertNotEquals(option2, \"\");\n    }", "signature": "@Test\n    public void testEquals()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetValue() {\n        final Option option = new Option(\"f\", null);\n        option.setArgs(Option.UNLIMITED_VALUES);\n\n        assertEquals(\"default\", option.getValue(\"default\"));\n        assertNull(option.getValue(0));\n\n        option.processValue(\"foo\");\n\n        assertEquals(\"foo\", option.getValue());\n        assertEquals(\"foo\", option.getValue(0));\n        assertEquals(\"foo\", option.getValue(\"default\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetValue", "params": [], "body": "                               {\n        final Option option = new Option(\"f\", null);\n        option.setArgs(Option.UNLIMITED_VALUES);\n\n        assertEquals(\"default\", option.getValue(\"default\"));\n        assertNull(option.getValue(0));\n\n        option.processValue(\"foo\");\n\n        assertEquals(\"foo\", option.getValue());\n        assertEquals(\"foo\", option.getValue(0));\n        assertEquals(\"foo\", option.getValue(\"default\"));\n    }", "signature": "@Test\n    public void testGetValue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHasArgName() {\n        final Option option = new Option(\"f\", null);\n\n        option.setArgName(null);\n        assertFalse(option.hasArgName());\n\n        option.setArgName(\"\");\n        assertFalse(option.hasArgName());\n\n        option.setArgName(\"file\");\n        assertTrue(option.hasArgName());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHasArgName", "params": [], "body": "                                 {\n        final Option option = new Option(\"f\", null);\n\n        option.setArgName(null);\n        assertFalse(option.hasArgName());\n\n        option.setArgName(\"\");\n        assertFalse(option.hasArgName());\n\n        option.setArgName(\"file\");\n        assertTrue(option.hasArgName());\n    }", "signature": "@Test\n    public void testHasArgName()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHasArgs() {\n        final Option option = new Option(\"f\", null);\n\n        option.setArgs(0);\n        assertFalse(option.hasArgs());\n\n        option.setArgs(1);\n        assertFalse(option.hasArgs());\n\n        option.setArgs(10);\n        assertTrue(option.hasArgs());\n\n        option.setArgs(Option.UNLIMITED_VALUES);\n        assertTrue(option.hasArgs());\n\n        option.setArgs(Option.UNINITIALIZED);\n        assertFalse(option.hasArgs());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHasArgs", "params": [], "body": "                              {\n        final Option option = new Option(\"f\", null);\n\n        option.setArgs(0);\n        assertFalse(option.hasArgs());\n\n        option.setArgs(1);\n        assertFalse(option.hasArgs());\n\n        option.setArgs(10);\n        assertTrue(option.hasArgs());\n\n        option.setArgs(Option.UNLIMITED_VALUES);\n        assertTrue(option.hasArgs());\n\n        option.setArgs(Option.UNINITIALIZED);\n        assertFalse(option.hasArgs());\n    }", "signature": "@Test\n    public void testHasArgs()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHashCode() {\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder(\"test2\").build().hashCode());\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder().longOpt(\"test\").build().hashCode());\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder(\"test\").longOpt(\"long test\").build().hashCode());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHashCode", "params": [], "body": "                               {\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder(\"test2\").build().hashCode());\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder().longOpt(\"test\").build().hashCode());\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder(\"test\").longOpt(\"long test\").build().hashCode());\n    }", "signature": "@Test\n    public void testHashCode()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSerialization() throws IOException, ClassNotFoundException {\n        final Option option = Option.builder(\"o\").type(TypeHandlerTest.Instantiable.class).build();\n        assertEquals(Converter.DEFAULT, option.getConverter());\n        Option roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n        // verify unregistered class converters and verifiers get reset to default.\n        // converters are NOT Serializable, use a serialization proxy if you want that.\n        option.setConverter(Converter.DATE);\n        roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n        // verify registered class converters and verifiers do not get reset to default.\n        // converters are NOT Serializable, use a serialization proxy if you want that.\n        // verify earlier values still set.\n        assertEquals(Converter.DATE, option.getConverter());\n        roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSerialization", "params": [], "body": "                                                                               {\n        final Option option = Option.builder(\"o\").type(TypeHandlerTest.Instantiable.class).build();\n        assertEquals(Converter.DEFAULT, option.getConverter());\n        Option roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n        // verify unregistered class converters and verifiers get reset to default.\n        // converters are NOT Serializable, use a serialization proxy if you want that.\n        option.setConverter(Converter.DATE);\n        roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n        // verify registered class converters and verifiers do not get reset to default.\n        // converters are NOT Serializable, use a serialization proxy if you want that.\n        // verify earlier values still set.\n        assertEquals(Converter.DATE, option.getConverter());\n        roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n    }", "signature": "@Test\n    public void testSerialization()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSubclass() {\n        final Option option = new DefaultOption(\"f\", \"file\", \"myfile.txt\");\n        final Option clone = (Option) option.clone();\n        assertEquals(\"myfile.txt\", clone.getValue());\n        assertEquals(DefaultOption.class, clone.getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSubclass", "params": [], "body": "                               {\n        final Option option = new DefaultOption(\"f\", \"file\", \"myfile.txt\");\n        final Option clone = (Option) option.clone();\n        assertEquals(\"myfile.txt\", clone.getValue());\n        assertEquals(DefaultOption.class, clone.getClass());\n    }", "signature": "@Test\n    public void testSubclass()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTypeClass() {\n        final Option option = new Option(\"f\", null);\n        assertEquals(String.class, option.getType());\n        option.setType(CharSequence.class);\n        assertEquals(CharSequence.class, option.getType());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTypeClass", "params": [], "body": "                                {\n        final Option option = new Option(\"f\", null);\n        assertEquals(String.class, option.getType());\n        option.setType(CharSequence.class);\n        assertEquals(CharSequence.class, option.getType());\n    }", "signature": "@Test\n    public void testTypeClass()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTypeObject() {\n        final Option option = new Option(\"f\", null);\n        assertEquals(String.class, option.getType());\n        @SuppressWarnings(\"cast\")\n        final Object type = CharSequence.class; // Do NOT remove cast\n        option.setType(type);\n        assertEquals(CharSequence.class, option.getType());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTypeObject", "params": [], "body": "                                 {\n        final Option option = new Option(\"f\", null);\n        assertEquals(String.class, option.getType());\n        @SuppressWarnings(\"cast\")\n        final Object type = CharSequence.class; // Do NOT remove cast\n        option.setType(type);\n        assertEquals(CharSequence.class, option.getType());\n    }", "signature": "@Test\n    public void testTypeObject()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/OptionsTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class OptionsTest {\n\n    private void assertToStrings(final Option option) {\n        // Should never throw.\n        // Should return a String, not null.\n        assertNotNull(option.toString());\n        assertNotNull(option.toDeprecatedString());\n    }\n\n    @Test\n    public void testAddConflictingOptions() {\n        final Options options1 = new Options();\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n        options1.addOptionGroup(group1);\n        options1.addOption(Option.builder(\"x\").build());\n        options1.addOption(Option.builder(\"y\").build());\n        final Options options2 = new Options();\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(Option.builder(\"x\").type(Integer.class).build());\n        group2.addOption(Option.builder(\"b\").type(Integer.class).build());\n        options2.addOptionGroup(group2);\n        options2.addOption(Option.builder(\"c\").build());\n        assertThrows(IllegalArgumentException.class, () -> options1.addOptions(options2));\n    }\n\n    @Test\n    public void testAddNonConflictingOptions() {\n        final Options options1 = new Options();\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n        options1.addOptionGroup(group1);\n        options1.addOption(Option.builder(\"x\").build());\n        options1.addOption(Option.builder(\"y\").build());\n\n        final Options options2 = new Options();\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(Option.builder(\"c\").type(Integer.class).build());\n        group2.addOption(Option.builder(\"d\").type(Integer.class).build());\n        options2.addOptionGroup(group2);\n        options1.addOption(Option.builder(\"e\").build());\n        options1.addOption(Option.builder(\"f\").build());\n\n        final Options underTest = new Options();\n        underTest.addOptions(options1);\n        underTest.addOptions(options2);\n\n        final List<OptionGroup> expected = Arrays.asList(group1, group2);\n        assertTrue(expected.size() == underTest.getOptionGroups().size() && expected.containsAll(underTest.getOptionGroups()));\n        final Set<Option> expectOpt = new HashSet<>(options1.getOptions());\n        expectOpt.addAll(options2.getOptions());\n        assertEquals(8, expectOpt.size());\n        assertTrue(expectOpt.size() == underTest.getOptions().size() && expectOpt.containsAll(underTest.getOptions()));\n    }\n\n    @Test\n    public void testAddOptions() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n\n        options.addOptionGroup(group1);\n\n        options.addOption(Option.builder(\"X\").build());\n        options.addOption(Option.builder(\"y\").build());\n\n        final Options underTest = new Options();\n        underTest.addOptions(options);\n\n        assertEquals(options.getOptionGroups(), underTest.getOptionGroups());\n        assertArrayEquals(options.getOptions().toArray(), underTest.getOptions().toArray());\n    }\n\n    @Test\n    public void testAddOptions2X() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n\n        options.addOptionGroup(group1);\n\n        options.addOption(Option.builder(\"X\").build());\n        options.addOption(Option.builder(\"y\").build());\n\n        assertThrows(IllegalArgumentException.class, () -> options.addOptions(options));\n    }\n\n    @Test\n    public void testDeprecated() {\n        final Options options = new Options();\n        options.addOption(Option.builder().option(\"a\").build());\n        options.addOption(Option.builder().option(\"b\").deprecated().build());\n        options.addOption(Option.builder().option(\"c\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"2.0\").setDescription(\"Use X.\").get()).build());\n        options.addOption(Option.builder().option(\"d\").deprecated().longOpt(\"longD\").hasArgs().build());\n        // toString()\n        assertTrue(options.getOption(\"a\").toString().startsWith(\"[ Option a\"));\n        assertTrue(options.getOption(\"b\").toString().startsWith(\"[ Option b\"));\n        assertTrue(options.getOption(\"c\").toString().startsWith(\"[ Option c\"));\n        // toDeprecatedString()\n        assertFalse(options.getOption(\"a\").toDeprecatedString().startsWith(\"Option a\"));\n        assertEquals(\"Option 'b': Deprecated\", options.getOption(\"b\").toDeprecatedString());\n        assertEquals(\"Option 'c': Deprecated for removal since 2.0: Use X.\", options.getOption(\"c\").toDeprecatedString());\n        assertToStrings(options.getOption(\"a\"));\n        assertToStrings(options.getOption(\"b\"));\n        assertToStrings(options.getOption(\"c\"));\n        assertToStrings(options.getOption(\"d\"));\n    }\n\n    @Test\n    public void testDuplicateLong() {\n        final Options options = new Options();\n        options.addOption(\"a\", \"--a\", false, \"toggle -a\");\n        options.addOption(\"a\", \"--a\", false, \"toggle -a*\");\n        assertEquals(\"toggle -a*\", options.getOption(\"a\").getDescription(), \"last one in wins\");\n        assertToStrings(options.getOption(\"a\"));\n    }\n\n    @Test\n    public void testDuplicateSimple() {\n        final Options options = new Options();\n        options.addOption(\"a\", false, \"toggle -a\");\n        assertToStrings(options.getOption(\"a\"));\n        options.addOption(\"a\", true, \"toggle -a*\");\n        assertEquals(\"toggle -a*\", options.getOption(\"a\").getDescription(), \"last one in wins\");\n        assertToStrings(options.getOption(\"a\"));\n    }\n\n    @Test\n    public void testGetMatchingOpts() {\n        final Options options = new Options();\n        OptionBuilder.withLongOpt(\"version\");\n        options.addOption(OptionBuilder.create());\n        OptionBuilder.withLongOpt(\"verbose\");\n        options.addOption(OptionBuilder.create());\n        assertTrue(options.getMatchingOptions(\"foo\").isEmpty());\n        assertEquals(1, options.getMatchingOptions(\"version\").size());\n        assertEquals(2, options.getMatchingOptions(\"ver\").size());\n        assertToStrings(options.getOption(\"version\"));\n        assertToStrings(options.getOption(\"verbose\"));\n    }\n\n    @Test\n    public void testGetOptionsGroups() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(OptionBuilder.create('a'));\n        group1.addOption(OptionBuilder.create('b'));\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(OptionBuilder.create('x'));\n        group2.addOption(OptionBuilder.create('y'));\n\n        options.addOptionGroup(group1);\n        options.addOptionGroup(group2);\n\n        assertNotNull(options.getOptionGroups());\n        assertEquals(2, options.getOptionGroups().size());\n    }\n\n    @Test\n    public void testHelpOptions() {\n        OptionBuilder.withLongOpt(\"long-only1\");\n        final Option longOnly1 = OptionBuilder.create();\n        OptionBuilder.withLongOpt(\"long-only2\");\n        final Option longOnly2 = OptionBuilder.create();\n        final Option shortOnly1 = OptionBuilder.create(\"1\");\n        final Option shortOnly2 = OptionBuilder.create(\"2\");\n        OptionBuilder.withLongOpt(\"bothA\");\n        final Option bothA = OptionBuilder.create(\"a\");\n        OptionBuilder.withLongOpt(\"bothB\");\n        final Option bothB = OptionBuilder.create(\"b\");\n\n        final Options options = new Options();\n        options.addOption(longOnly1);\n        options.addOption(longOnly2);\n        options.addOption(shortOnly1);\n        options.addOption(shortOnly2);\n        options.addOption(bothA);\n        options.addOption(bothB);\n\n        final Collection<Option> allOptions = new ArrayList<>();\n        allOptions.add(longOnly1);\n        allOptions.add(longOnly2);\n        allOptions.add(shortOnly1);\n        allOptions.add(shortOnly2);\n        allOptions.add(bothA);\n        allOptions.add(bothB);\n\n        final Collection<Option> helpOptions = options.helpOptions();\n\n        assertTrue(helpOptions.containsAll(allOptions), \"Everything in all should be in help\");\n        assertTrue(allOptions.containsAll(helpOptions), \"Everything in help should be in all\");\n    }\n\n    @Test\n    public void testLong() {\n        final Options options = new Options();\n\n        options.addOption(\"a\", \"--a\", false, \"toggle -a\");\n        options.addOption(\"b\", \"--b\", true, \"set -b\");\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }\n\n    @Test\n    public void testMissingOptionException() throws ParseException {\n        final Options options = new Options();\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"f\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required option: f\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testMissingOptionsException() throws ParseException {\n        final Options options = new Options();\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"f\"));\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"x\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required options: f, x\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testSimple() {\n        final Options options = new Options();\n\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"b\", true, \"toggle -b\");\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }\n\n    @Test\n    public void testToString() {\n        final Options options = new Options();\n        options.addOption(\"f\", \"foo\", true, \"Foo\");\n        options.addOption(\"b\", \"bar\", false, \"Bar\");\n\n        final String s = options.toString();\n        assertNotNull(s, \"null string returned\");\n        assertTrue(s.toLowerCase().contains(\"foo\"), \"foo option missing\");\n        assertTrue(s.toLowerCase().contains(\"bar\"), \"bar option missing\");\n    }\n}\n", "file_hash": "59c85ed6d7181cf07a78480cfef3af6cde7520547fecd738a4d202935c39515f", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertArrayEquals;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import static org.junit.jupiter.api.Assertions.fail;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.HashSet;", "import java.util.List;", "import java.util.Set;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class OptionsTest {\n\n    private void assertToStrings(final Option option) {\n        // Should never throw.\n        // Should return a String, not null.\n        assertNotNull(option.toString());\n        assertNotNull(option.toDeprecatedString());\n    }\n\n    @Test\n    public void testAddConflictingOptions() {\n        final Options options1 = new Options();\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n        options1.addOptionGroup(group1);\n        options1.addOption(Option.builder(\"x\").build());\n        options1.addOption(Option.builder(\"y\").build());\n        final Options options2 = new Options();\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(Option.builder(\"x\").type(Integer.class).build());\n        group2.addOption(Option.builder(\"b\").type(Integer.class).build());\n        options2.addOptionGroup(group2);\n        options2.addOption(Option.builder(\"c\").build());\n        assertThrows(IllegalArgumentException.class, () -> options1.addOptions(options2));\n    }\n\n    @Test\n    public void testAddNonConflictingOptions() {\n        final Options options1 = new Options();\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n        options1.addOptionGroup(group1);\n        options1.addOption(Option.builder(\"x\").build());\n        options1.addOption(Option.builder(\"y\").build());\n\n        final Options options2 = new Options();\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(Option.builder(\"c\").type(Integer.class).build());\n        group2.addOption(Option.builder(\"d\").type(Integer.class).build());\n        options2.addOptionGroup(group2);\n        options1.addOption(Option.builder(\"e\").build());\n        options1.addOption(Option.builder(\"f\").build());\n\n        final Options underTest = new Options();\n        underTest.addOptions(options1);\n        underTest.addOptions(options2);\n\n        final List<OptionGroup> expected = Arrays.asList(group1, group2);\n        assertTrue(expected.size() == underTest.getOptionGroups().size() && expected.containsAll(underTest.getOptionGroups()));\n        final Set<Option> expectOpt = new HashSet<>(options1.getOptions());\n        expectOpt.addAll(options2.getOptions());\n        assertEquals(8, expectOpt.size());\n        assertTrue(expectOpt.size() == underTest.getOptions().size() && expectOpt.containsAll(underTest.getOptions()));\n    }\n\n    @Test\n    public void testAddOptions() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n\n        options.addOptionGroup(group1);\n\n        options.addOption(Option.builder(\"X\").build());\n        options.addOption(Option.builder(\"y\").build());\n\n        final Options underTest = new Options();\n        underTest.addOptions(options);\n\n        assertEquals(options.getOptionGroups(), underTest.getOptionGroups());\n        assertArrayEquals(options.getOptions().toArray(), underTest.getOptions().toArray());\n    }\n\n    @Test\n    public void testAddOptions2X() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n\n        options.addOptionGroup(group1);\n\n        options.addOption(Option.builder(\"X\").build());\n        options.addOption(Option.builder(\"y\").build());\n\n        assertThrows(IllegalArgumentException.class, () -> options.addOptions(options));\n    }\n\n    @Test\n    public void testDeprecated() {\n        final Options options = new Options();\n        options.addOption(Option.builder().option(\"a\").build());\n        options.addOption(Option.builder().option(\"b\").deprecated().build());\n        options.addOption(Option.builder().option(\"c\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"2.0\").setDescription(\"Use X.\").get()).build());\n        options.addOption(Option.builder().option(\"d\").deprecated().longOpt(\"longD\").hasArgs().build());\n        // toString()\n        assertTrue(options.getOption(\"a\").toString().startsWith(\"[ Option a\"));\n        assertTrue(options.getOption(\"b\").toString().startsWith(\"[ Option b\"));\n        assertTrue(options.getOption(\"c\").toString().startsWith(\"[ Option c\"));\n        // toDeprecatedString()\n        assertFalse(options.getOption(\"a\").toDeprecatedString().startsWith(\"Option a\"));\n        assertEquals(\"Option 'b': Deprecated\", options.getOption(\"b\").toDeprecatedString());\n        assertEquals(\"Option 'c': Deprecated for removal since 2.0: Use X.\", options.getOption(\"c\").toDeprecatedString());\n        assertToStrings(options.getOption(\"a\"));\n        assertToStrings(options.getOption(\"b\"));\n        assertToStrings(options.getOption(\"c\"));\n        assertToStrings(options.getOption(\"d\"));\n    }\n\n    @Test\n    public void testDuplicateLong() {\n        final Options options = new Options();\n        options.addOption(\"a\", \"--a\", false, \"toggle -a\");\n        options.addOption(\"a\", \"--a\", false, \"toggle -a*\");\n        assertEquals(\"toggle -a*\", options.getOption(\"a\").getDescription(), \"last one in wins\");\n        assertToStrings(options.getOption(\"a\"));\n    }\n\n    @Test\n    public void testDuplicateSimple() {\n        final Options options = new Options();\n        options.addOption(\"a\", false, \"toggle -a\");\n        assertToStrings(options.getOption(\"a\"));\n        options.addOption(\"a\", true, \"toggle -a*\");\n        assertEquals(\"toggle -a*\", options.getOption(\"a\").getDescription(), \"last one in wins\");\n        assertToStrings(options.getOption(\"a\"));\n    }\n\n    @Test\n    public void testGetMatchingOpts() {\n        final Options options = new Options();\n        OptionBuilder.withLongOpt(\"version\");\n        options.addOption(OptionBuilder.create());\n        OptionBuilder.withLongOpt(\"verbose\");\n        options.addOption(OptionBuilder.create());\n        assertTrue(options.getMatchingOptions(\"foo\").isEmpty());\n        assertEquals(1, options.getMatchingOptions(\"version\").size());\n        assertEquals(2, options.getMatchingOptions(\"ver\").size());\n        assertToStrings(options.getOption(\"version\"));\n        assertToStrings(options.getOption(\"verbose\"));\n    }\n\n    @Test\n    public void testGetOptionsGroups() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(OptionBuilder.create('a'));\n        group1.addOption(OptionBuilder.create('b'));\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(OptionBuilder.create('x'));\n        group2.addOption(OptionBuilder.create('y'));\n\n        options.addOptionGroup(group1);\n        options.addOptionGroup(group2);\n\n        assertNotNull(options.getOptionGroups());\n        assertEquals(2, options.getOptionGroups().size());\n    }\n\n    @Test\n    public void testHelpOptions() {\n        OptionBuilder.withLongOpt(\"long-only1\");\n        final Option longOnly1 = OptionBuilder.create();\n        OptionBuilder.withLongOpt(\"long-only2\");\n        final Option longOnly2 = OptionBuilder.create();\n        final Option shortOnly1 = OptionBuilder.create(\"1\");\n        final Option shortOnly2 = OptionBuilder.create(\"2\");\n        OptionBuilder.withLongOpt(\"bothA\");\n        final Option bothA = OptionBuilder.create(\"a\");\n        OptionBuilder.withLongOpt(\"bothB\");\n        final Option bothB = OptionBuilder.create(\"b\");\n\n        final Options options = new Options();\n        options.addOption(longOnly1);\n        options.addOption(longOnly2);\n        options.addOption(shortOnly1);\n        options.addOption(shortOnly2);\n        options.addOption(bothA);\n        options.addOption(bothB);\n\n        final Collection<Option> allOptions = new ArrayList<>();\n        allOptions.add(longOnly1);\n        allOptions.add(longOnly2);\n        allOptions.add(shortOnly1);\n        allOptions.add(shortOnly2);\n        allOptions.add(bothA);\n        allOptions.add(bothB);\n\n        final Collection<Option> helpOptions = options.helpOptions();\n\n        assertTrue(helpOptions.containsAll(allOptions), \"Everything in all should be in help\");\n        assertTrue(allOptions.containsAll(helpOptions), \"Everything in help should be in all\");\n    }\n\n    @Test\n    public void testLong() {\n        final Options options = new Options();\n\n        options.addOption(\"a\", \"--a\", false, \"toggle -a\");\n        options.addOption(\"b\", \"--b\", true, \"set -b\");\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }\n\n    @Test\n    public void testMissingOptionException() throws ParseException {\n        final Options options = new Options();\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"f\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required option: f\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testMissingOptionsException() throws ParseException {\n        final Options options = new Options();\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"f\"));\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"x\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required options: f, x\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testSimple() {\n        final Options options = new Options();\n\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"b\", true, \"toggle -b\");\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }\n\n    @Test\n    public void testToString() {\n        final Options options = new Options();\n        options.addOption(\"f\", \"foo\", true, \"Foo\");\n        options.addOption(\"b\", \"bar\", false, \"Bar\");\n\n        final String s = options.toString();\n        assertNotNull(s, \"null string returned\");\n        assertTrue(s.toLowerCase().contains(\"foo\"), \"foo option missing\");\n        assertTrue(s.toLowerCase().contains(\"bar\"), \"bar option missing\");\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class OptionsTest", "class_docstring": "", "name": "OptionsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private void assertToStrings(final Option option) {\n        // Should never throw.\n        // Should return a String, not null.\n        assertNotNull(option.toString());\n        assertNotNull(option.toDeprecatedString());\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertToStrings", "params": [{"name": "option", "type": "Option"}], "body": "                                                      {\n        // Should never throw.\n        // Should return a String, not null.\n        assertNotNull(option.toString());\n        assertNotNull(option.toDeprecatedString());\n    }", "signature": "private void assertToStrings(final Option option)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddConflictingOptions() {\n        final Options options1 = new Options();\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n        options1.addOptionGroup(group1);\n        options1.addOption(Option.builder(\"x\").build());\n        options1.addOption(Option.builder(\"y\").build());\n        final Options options2 = new Options();\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(Option.builder(\"x\").type(Integer.class).build());\n        group2.addOption(Option.builder(\"b\").type(Integer.class).build());\n        options2.addOptionGroup(group2);\n        options2.addOption(Option.builder(\"c\").build());\n        assertThrows(IllegalArgumentException.class, () -> options1.addOptions(options2));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddConflictingOptions", "params": [], "body": "                                            {\n        final Options options1 = new Options();\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n        options1.addOptionGroup(group1);\n        options1.addOption(Option.builder(\"x\").build());\n        options1.addOption(Option.builder(\"y\").build());\n        final Options options2 = new Options();\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(Option.builder(\"x\").type(Integer.class).build());\n        group2.addOption(Option.builder(\"b\").type(Integer.class).build());\n        options2.addOptionGroup(group2);\n        options2.addOption(Option.builder(\"c\").build());\n        assertThrows(IllegalArgumentException.class, () -> options1.addOptions(options2));\n    }", "signature": "@Test\n    public void testAddConflictingOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddNonConflictingOptions() {\n        final Options options1 = new Options();\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n        options1.addOptionGroup(group1);\n        options1.addOption(Option.builder(\"x\").build());\n        options1.addOption(Option.builder(\"y\").build());\n\n        final Options options2 = new Options();\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(Option.builder(\"c\").type(Integer.class).build());\n        group2.addOption(Option.builder(\"d\").type(Integer.class).build());\n        options2.addOptionGroup(group2);\n        options1.addOption(Option.builder(\"e\").build());\n        options1.addOption(Option.builder(\"f\").build());\n\n        final Options underTest = new Options();\n        underTest.addOptions(options1);\n        underTest.addOptions(options2);\n\n        final List<OptionGroup> expected = Arrays.asList(group1, group2);\n        assertTrue(expected.size() == underTest.getOptionGroups().size() && expected.containsAll(underTest.getOptionGroups()));\n        final Set<Option> expectOpt = new HashSet<>(options1.getOptions());\n        expectOpt.addAll(options2.getOptions());\n        assertEquals(8, expectOpt.size());\n        assertTrue(expectOpt.size() == underTest.getOptions().size() && expectOpt.containsAll(underTest.getOptions()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddNonConflictingOptions", "params": [], "body": "                                               {\n        final Options options1 = new Options();\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n        options1.addOptionGroup(group1);\n        options1.addOption(Option.builder(\"x\").build());\n        options1.addOption(Option.builder(\"y\").build());\n\n        final Options options2 = new Options();\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(Option.builder(\"c\").type(Integer.class).build());\n        group2.addOption(Option.builder(\"d\").type(Integer.class).build());\n        options2.addOptionGroup(group2);\n        options1.addOption(Option.builder(\"e\").build());\n        options1.addOption(Option.builder(\"f\").build());\n\n        final Options underTest = new Options();\n        underTest.addOptions(options1);\n        underTest.addOptions(options2);\n\n        final List<OptionGroup> expected = Arrays.asList(group1, group2);\n        assertTrue(expected.size() == underTest.getOptionGroups().size() && expected.containsAll(underTest.getOptionGroups()));\n        final Set<Option> expectOpt = new HashSet<>(options1.getOptions());\n        expectOpt.addAll(options2.getOptions());\n        assertEquals(8, expectOpt.size());\n        assertTrue(expectOpt.size() == underTest.getOptions().size() && expectOpt.containsAll(underTest.getOptions()));\n    }", "signature": "@Test\n    public void testAddNonConflictingOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptions() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n\n        options.addOptionGroup(group1);\n\n        options.addOption(Option.builder(\"X\").build());\n        options.addOption(Option.builder(\"y\").build());\n\n        final Options underTest = new Options();\n        underTest.addOptions(options);\n\n        assertEquals(options.getOptionGroups(), underTest.getOptionGroups());\n        assertArrayEquals(options.getOptions().toArray(), underTest.getOptions().toArray());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptions", "params": [], "body": "                                 {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n\n        options.addOptionGroup(group1);\n\n        options.addOption(Option.builder(\"X\").build());\n        options.addOption(Option.builder(\"y\").build());\n\n        final Options underTest = new Options();\n        underTest.addOptions(options);\n\n        assertEquals(options.getOptionGroups(), underTest.getOptionGroups());\n        assertArrayEquals(options.getOptions().toArray(), underTest.getOptions().toArray());\n    }", "signature": "@Test\n    public void testAddOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddOptions2X() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n\n        options.addOptionGroup(group1);\n\n        options.addOption(Option.builder(\"X\").build());\n        options.addOption(Option.builder(\"y\").build());\n\n        assertThrows(IllegalArgumentException.class, () -> options.addOptions(options));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddOptions2X", "params": [], "body": "                                   {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n\n        options.addOptionGroup(group1);\n\n        options.addOption(Option.builder(\"X\").build());\n        options.addOption(Option.builder(\"y\").build());\n\n        assertThrows(IllegalArgumentException.class, () -> options.addOptions(options));\n    }", "signature": "@Test\n    public void testAddOptions2X()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDeprecated() {\n        final Options options = new Options();\n        options.addOption(Option.builder().option(\"a\").build());\n        options.addOption(Option.builder().option(\"b\").deprecated().build());\n        options.addOption(Option.builder().option(\"c\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"2.0\").setDescription(\"Use X.\").get()).build());\n        options.addOption(Option.builder().option(\"d\").deprecated().longOpt(\"longD\").hasArgs().build());\n        // toString()\n        assertTrue(options.getOption(\"a\").toString().startsWith(\"[ Option a\"));\n        assertTrue(options.getOption(\"b\").toString().startsWith(\"[ Option b\"));\n        assertTrue(options.getOption(\"c\").toString().startsWith(\"[ Option c\"));\n        // toDeprecatedString()\n        assertFalse(options.getOption(\"a\").toDeprecatedString().startsWith(\"Option a\"));\n        assertEquals(\"Option 'b': Deprecated\", options.getOption(\"b\").toDeprecatedString());\n        assertEquals(\"Option 'c': Deprecated for removal since 2.0: Use X.\", options.getOption(\"c\").toDeprecatedString());\n        assertToStrings(options.getOption(\"a\"));\n        assertToStrings(options.getOption(\"b\"));\n        assertToStrings(options.getOption(\"c\"));\n        assertToStrings(options.getOption(\"d\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeprecated", "params": [], "body": "                                 {\n        final Options options = new Options();\n        options.addOption(Option.builder().option(\"a\").build());\n        options.addOption(Option.builder().option(\"b\").deprecated().build());\n        options.addOption(Option.builder().option(\"c\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"2.0\").setDescription(\"Use X.\").get()).build());\n        options.addOption(Option.builder().option(\"d\").deprecated().longOpt(\"longD\").hasArgs().build());\n        // toString()\n        assertTrue(options.getOption(\"a\").toString().startsWith(\"[ Option a\"));\n        assertTrue(options.getOption(\"b\").toString().startsWith(\"[ Option b\"));\n        assertTrue(options.getOption(\"c\").toString().startsWith(\"[ Option c\"));\n        // toDeprecatedString()\n        assertFalse(options.getOption(\"a\").toDeprecatedString().startsWith(\"Option a\"));\n        assertEquals(\"Option 'b': Deprecated\", options.getOption(\"b\").toDeprecatedString());\n        assertEquals(\"Option 'c': Deprecated for removal since 2.0: Use X.\", options.getOption(\"c\").toDeprecatedString());\n        assertToStrings(options.getOption(\"a\"));\n        assertToStrings(options.getOption(\"b\"));\n        assertToStrings(options.getOption(\"c\"));\n        assertToStrings(options.getOption(\"d\"));\n    }", "signature": "@Test\n    public void testDeprecated()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDuplicateLong() {\n        final Options options = new Options();\n        options.addOption(\"a\", \"--a\", false, \"toggle -a\");\n        options.addOption(\"a\", \"--a\", false, \"toggle -a*\");\n        assertEquals(\"toggle -a*\", options.getOption(\"a\").getDescription(), \"last one in wins\");\n        assertToStrings(options.getOption(\"a\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDuplicateLong", "params": [], "body": "                                    {\n        final Options options = new Options();\n        options.addOption(\"a\", \"--a\", false, \"toggle -a\");\n        options.addOption(\"a\", \"--a\", false, \"toggle -a*\");\n        assertEquals(\"toggle -a*\", options.getOption(\"a\").getDescription(), \"last one in wins\");\n        assertToStrings(options.getOption(\"a\"));\n    }", "signature": "@Test\n    public void testDuplicateLong()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDuplicateSimple() {\n        final Options options = new Options();\n        options.addOption(\"a\", false, \"toggle -a\");\n        assertToStrings(options.getOption(\"a\"));\n        options.addOption(\"a\", true, \"toggle -a*\");\n        assertEquals(\"toggle -a*\", options.getOption(\"a\").getDescription(), \"last one in wins\");\n        assertToStrings(options.getOption(\"a\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDuplicateSimple", "params": [], "body": "                                      {\n        final Options options = new Options();\n        options.addOption(\"a\", false, \"toggle -a\");\n        assertToStrings(options.getOption(\"a\"));\n        options.addOption(\"a\", true, \"toggle -a*\");\n        assertEquals(\"toggle -a*\", options.getOption(\"a\").getDescription(), \"last one in wins\");\n        assertToStrings(options.getOption(\"a\"));\n    }", "signature": "@Test\n    public void testDuplicateSimple()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetMatchingOpts() {\n        final Options options = new Options();\n        OptionBuilder.withLongOpt(\"version\");\n        options.addOption(OptionBuilder.create());\n        OptionBuilder.withLongOpt(\"verbose\");\n        options.addOption(OptionBuilder.create());\n        assertTrue(options.getMatchingOptions(\"foo\").isEmpty());\n        assertEquals(1, options.getMatchingOptions(\"version\").size());\n        assertEquals(2, options.getMatchingOptions(\"ver\").size());\n        assertToStrings(options.getOption(\"version\"));\n        assertToStrings(options.getOption(\"verbose\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetMatchingOpts", "params": [], "body": "                                      {\n        final Options options = new Options();\n        OptionBuilder.withLongOpt(\"version\");\n        options.addOption(OptionBuilder.create());\n        OptionBuilder.withLongOpt(\"verbose\");\n        options.addOption(OptionBuilder.create());\n        assertTrue(options.getMatchingOptions(\"foo\").isEmpty());\n        assertEquals(1, options.getMatchingOptions(\"version\").size());\n        assertEquals(2, options.getMatchingOptions(\"ver\").size());\n        assertToStrings(options.getOption(\"version\"));\n        assertToStrings(options.getOption(\"verbose\"));\n    }", "signature": "@Test\n    public void testGetMatchingOpts()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetOptionsGroups() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(OptionBuilder.create('a'));\n        group1.addOption(OptionBuilder.create('b'));\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(OptionBuilder.create('x'));\n        group2.addOption(OptionBuilder.create('y'));\n\n        options.addOptionGroup(group1);\n        options.addOptionGroup(group2);\n\n        assertNotNull(options.getOptionGroups());\n        assertEquals(2, options.getOptionGroups().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetOptionsGroups", "params": [], "body": "                                       {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(OptionBuilder.create('a'));\n        group1.addOption(OptionBuilder.create('b'));\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(OptionBuilder.create('x'));\n        group2.addOption(OptionBuilder.create('y'));\n\n        options.addOptionGroup(group1);\n        options.addOptionGroup(group2);\n\n        assertNotNull(options.getOptionGroups());\n        assertEquals(2, options.getOptionGroups().size());\n    }", "signature": "@Test\n    public void testGetOptionsGroups()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHelpOptions() {\n        OptionBuilder.withLongOpt(\"long-only1\");\n        final Option longOnly1 = OptionBuilder.create();\n        OptionBuilder.withLongOpt(\"long-only2\");\n        final Option longOnly2 = OptionBuilder.create();\n        final Option shortOnly1 = OptionBuilder.create(\"1\");\n        final Option shortOnly2 = OptionBuilder.create(\"2\");\n        OptionBuilder.withLongOpt(\"bothA\");\n        final Option bothA = OptionBuilder.create(\"a\");\n        OptionBuilder.withLongOpt(\"bothB\");\n        final Option bothB = OptionBuilder.create(\"b\");\n\n        final Options options = new Options();\n        options.addOption(longOnly1);\n        options.addOption(longOnly2);\n        options.addOption(shortOnly1);\n        options.addOption(shortOnly2);\n        options.addOption(bothA);\n        options.addOption(bothB);\n\n        final Collection<Option> allOptions = new ArrayList<>();\n        allOptions.add(longOnly1);\n        allOptions.add(longOnly2);\n        allOptions.add(shortOnly1);\n        allOptions.add(shortOnly2);\n        allOptions.add(bothA);\n        allOptions.add(bothB);\n\n        final Collection<Option> helpOptions = options.helpOptions();\n\n        assertTrue(helpOptions.containsAll(allOptions), \"Everything in all should be in help\");\n        assertTrue(allOptions.containsAll(helpOptions), \"Everything in help should be in all\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHelpOptions", "params": [], "body": "                                  {\n        OptionBuilder.withLongOpt(\"long-only1\");\n        final Option longOnly1 = OptionBuilder.create();\n        OptionBuilder.withLongOpt(\"long-only2\");\n        final Option longOnly2 = OptionBuilder.create();\n        final Option shortOnly1 = OptionBuilder.create(\"1\");\n        final Option shortOnly2 = OptionBuilder.create(\"2\");\n        OptionBuilder.withLongOpt(\"bothA\");\n        final Option bothA = OptionBuilder.create(\"a\");\n        OptionBuilder.withLongOpt(\"bothB\");\n        final Option bothB = OptionBuilder.create(\"b\");\n\n        final Options options = new Options();\n        options.addOption(longOnly1);\n        options.addOption(longOnly2);\n        options.addOption(shortOnly1);\n        options.addOption(shortOnly2);\n        options.addOption(bothA);\n        options.addOption(bothB);\n\n        final Collection<Option> allOptions = new ArrayList<>();\n        allOptions.add(longOnly1);\n        allOptions.add(longOnly2);\n        allOptions.add(shortOnly1);\n        allOptions.add(shortOnly2);\n        allOptions.add(bothA);\n        allOptions.add(bothB);\n\n        final Collection<Option> helpOptions = options.helpOptions();\n\n        assertTrue(helpOptions.containsAll(allOptions), \"Everything in all should be in help\");\n        assertTrue(allOptions.containsAll(helpOptions), \"Everything in help should be in all\");\n    }", "signature": "@Test\n    public void testHelpOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLong() {\n        final Options options = new Options();\n\n        options.addOption(\"a\", \"--a\", false, \"toggle -a\");\n        options.addOption(\"b\", \"--b\", true, \"set -b\");\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLong", "params": [], "body": "                           {\n        final Options options = new Options();\n\n        options.addOption(\"a\", \"--a\", false, \"toggle -a\");\n        options.addOption(\"b\", \"--b\", true, \"set -b\");\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }", "signature": "@Test\n    public void testLong()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMissingOptionException() throws ParseException {\n        final Options options = new Options();\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"f\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required option: f\", e.getMessage());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMissingOptionException", "params": [], "body": "                                                                   {\n        final Options options = new Options();\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"f\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required option: f\", e.getMessage());\n        }\n    }", "signature": "@Test\n    public void testMissingOptionException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMissingOptionsException() throws ParseException {\n        final Options options = new Options();\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"f\"));\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"x\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required options: f, x\", e.getMessage());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMissingOptionsException", "params": [], "body": "                                                                    {\n        final Options options = new Options();\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"f\"));\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"x\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required options: f, x\", e.getMessage());\n        }\n    }", "signature": "@Test\n    public void testMissingOptionsException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSimple() {\n        final Options options = new Options();\n\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"b\", true, \"toggle -b\");\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSimple", "params": [], "body": "                             {\n        final Options options = new Options();\n\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"b\", true, \"toggle -b\");\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }", "signature": "@Test\n    public void testSimple()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToString() {\n        final Options options = new Options();\n        options.addOption(\"f\", \"foo\", true, \"Foo\");\n        options.addOption(\"b\", \"bar\", false, \"Bar\");\n\n        final String s = options.toString();\n        assertNotNull(s, \"null string returned\");\n        assertTrue(s.toLowerCase().contains(\"foo\"), \"foo option missing\");\n        assertTrue(s.toLowerCase().contains(\"bar\"), \"bar option missing\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToString", "params": [], "body": "                               {\n        final Options options = new Options();\n        options.addOption(\"f\", \"foo\", true, \"Foo\");\n        options.addOption(\"b\", \"bar\", false, \"Bar\");\n\n        final String s = options.toString();\n        assertNotNull(s, \"null string returned\");\n        assertTrue(s.toLowerCase().contains(\"foo\"), \"foo option missing\");\n        assertTrue(s.toLowerCase().contains(\"bar\"), \"bar option missing\");\n    }", "signature": "@Test\n    public void testToString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/UnrecognizedOptionExceptionTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link UnrecognizedOptionException}.\n */\npublic class UnrecognizedOptionExceptionTest {\n\n    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new UnrecognizedOptionException(\"a\").getMessage());\n        assertEquals(\"a\", new UnrecognizedOptionException(\"a\", \"b\").getMessage());\n        assertEquals(\"b\", new UnrecognizedOptionException(\"a\", \"b\").getOption());\n    }\n}\n", "file_hash": "8f3b2fc1a92d68baf961c0323ef81c1a70ec9b14bba65e6e62ba1d1bda7680bc", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class UnrecognizedOptionExceptionTest {\n\n    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new UnrecognizedOptionException(\"a\").getMessage());\n        assertEquals(\"a\", new UnrecognizedOptionException(\"a\", \"b\").getMessage());\n        assertEquals(\"b\", new UnrecognizedOptionException(\"a\", \"b\").getOption());\n    }\n}", "definition": "public class UnrecognizedOptionExceptionTest", "class_docstring": "\nTests {@link UnrecognizedOptionException}.\n", "name": "UnrecognizedOptionExceptionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new UnrecognizedOptionException(\"a\").getMessage());\n        assertEquals(\"a\", new UnrecognizedOptionException(\"a\", \"b\").getMessage());\n        assertEquals(\"b\", new UnrecognizedOptionException(\"a\", \"b\").getOption());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testConstructor", "params": [], "body": "                                  {\n        assertEquals(\"a\", new UnrecognizedOptionException(\"a\").getMessage());\n        assertEquals(\"a\", new UnrecognizedOptionException(\"a\", \"b\").getMessage());\n        assertEquals(\"b\", new UnrecognizedOptionException(\"a\", \"b\").getOption());\n    }", "signature": "@Test\n    public void testConstructor()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/PatternOptionBuilder_parsePatternTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PatternOptionBuilder_parsePatternTest {\n\n    @Test\n    public void testParsePattern_SingleOption() {\n        Options options = PatternOptionBuilder.parsePattern(\"a\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertFalse(option.hasArg());\n    }\n\n    @Test\n    public void testParsePattern_OptionWithValueCode() {\n        Options options = PatternOptionBuilder.parsePattern(\"a@\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertTrue(option.hasArg());\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, option.getType());\n    }\n\n    @Test\n    public void testParsePattern_OptionWithRequiredFlag() {\n        Options options = PatternOptionBuilder.parsePattern(\"a!\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertFalse(option.hasArg());\n        assertTrue(option.isRequired());\n    }\n\n    @Test\n    public void testParsePattern_MultipleOptions() {\n        Options options = PatternOptionBuilder.parsePattern(\"ab@c!\");\n        assertEquals(3, options.getOptions().size());\n\n        Option optionA = options.getOption(\"a\");\n        assertEquals(\"a\", optionA.getOpt());\n        assertFalse(optionA.hasArg());\n\n        Option optionB = options.getOption(\"b\");\n        assertEquals(\"b\", optionB.getOpt());\n        assertTrue(optionB.hasArg());\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, optionB.getType());\n\n        Option optionC = options.getOption(\"c\");\n        assertEquals(\"c\", optionC.getOpt());\n        assertFalse(optionC.hasArg());\n        assertTrue(optionC.isRequired());\n    }\n}\n", "file_hash": "7983e5466ea724e26c82c1cdbe28bae41d8432da23e20b6efa3991f013e698e8", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class PatternOptionBuilder_parsePatternTest {\n\n    @Test\n    public void testParsePattern_SingleOption() {\n        Options options = PatternOptionBuilder.parsePattern(\"a\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertFalse(option.hasArg());\n    }\n\n    @Test\n    public void testParsePattern_OptionWithValueCode() {\n        Options options = PatternOptionBuilder.parsePattern(\"a@\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertTrue(option.hasArg());\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, option.getType());\n    }\n\n    @Test\n    public void testParsePattern_OptionWithRequiredFlag() {\n        Options options = PatternOptionBuilder.parsePattern(\"a!\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertFalse(option.hasArg());\n        assertTrue(option.isRequired());\n    }\n\n    @Test\n    public void testParsePattern_MultipleOptions() {\n        Options options = PatternOptionBuilder.parsePattern(\"ab@c!\");\n        assertEquals(3, options.getOptions().size());\n\n        Option optionA = options.getOption(\"a\");\n        assertEquals(\"a\", optionA.getOpt());\n        assertFalse(optionA.hasArg());\n\n        Option optionB = options.getOption(\"b\");\n        assertEquals(\"b\", optionB.getOpt());\n        assertTrue(optionB.hasArg());\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, optionB.getType());\n\n        Option optionC = options.getOption(\"c\");\n        assertEquals(\"c\", optionC.getOpt());\n        assertFalse(optionC.hasArg());\n        assertTrue(optionC.isRequired());\n    }\n}", "definition": "public class PatternOptionBuilder_parsePatternTest", "class_docstring": "", "name": "PatternOptionBuilder_parsePatternTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testParsePattern_SingleOption() {\n        Options options = PatternOptionBuilder.parsePattern(\"a\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertFalse(option.hasArg());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testParsePattern_SingleOption", "params": [], "body": "                                                {\n        Options options = PatternOptionBuilder.parsePattern(\"a\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertFalse(option.hasArg());\n    }", "signature": "@Test\n    public void testParsePattern_SingleOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testParsePattern_OptionWithValueCode() {\n        Options options = PatternOptionBuilder.parsePattern(\"a@\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertTrue(option.hasArg());\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, option.getType());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testParsePattern_OptionWithValueCode", "params": [], "body": "                                                       {\n        Options options = PatternOptionBuilder.parsePattern(\"a@\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertTrue(option.hasArg());\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, option.getType());\n    }", "signature": "@Test\n    public void testParsePattern_OptionWithValueCode()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testParsePattern_OptionWithRequiredFlag() {\n        Options options = PatternOptionBuilder.parsePattern(\"a!\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertFalse(option.hasArg());\n        assertTrue(option.isRequired());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testParsePattern_OptionWithRequiredFlag", "params": [], "body": "                                                          {\n        Options options = PatternOptionBuilder.parsePattern(\"a!\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOption(\"a\");\n        assertEquals(\"a\", option.getOpt());\n        assertFalse(option.hasArg());\n        assertTrue(option.isRequired());\n    }", "signature": "@Test\n    public void testParsePattern_OptionWithRequiredFlag()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testParsePattern_MultipleOptions() {\n        Options options = PatternOptionBuilder.parsePattern(\"ab@c!\");\n        assertEquals(3, options.getOptions().size());\n\n        Option optionA = options.getOption(\"a\");\n        assertEquals(\"a\", optionA.getOpt());\n        assertFalse(optionA.hasArg());\n\n        Option optionB = options.getOption(\"b\");\n        assertEquals(\"b\", optionB.getOpt());\n        assertTrue(optionB.hasArg());\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, optionB.getType());\n\n        Option optionC = options.getOption(\"c\");\n        assertEquals(\"c\", optionC.getOpt());\n        assertFalse(optionC.hasArg());\n        assertTrue(optionC.isRequired());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testParsePattern_MultipleOptions", "params": [], "body": "                                                   {\n        Options options = PatternOptionBuilder.parsePattern(\"ab@c!\");\n        assertEquals(3, options.getOptions().size());\n\n        Option optionA = options.getOption(\"a\");\n        assertEquals(\"a\", optionA.getOpt());\n        assertFalse(optionA.hasArg());\n\n        Option optionB = options.getOption(\"b\");\n        assertEquals(\"b\", optionB.getOpt());\n        assertTrue(optionB.hasArg());\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, optionB.getType());\n\n        Option optionC = options.getOption(\"c\");\n        assertEquals(\"c\", optionC.getOpt());\n        assertFalse(optionC.hasArg());\n        assertTrue(optionC.isRequired());\n    }", "signature": "@Test\n    public void testParsePattern_MultipleOptions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/AlreadySelectedExceptionTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link AlreadySelectedException}.\n */\npublic class AlreadySelectedExceptionTest {\n\n    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new AlreadySelectedException(\"a\").getMessage());\n        assertNull(new AlreadySelectedException(\"a\").getOption());\n        final Option option = new Option(\"a\", \"d\");\n        final OptionGroup group = new OptionGroup();\n        assertNotNull(new AlreadySelectedException(group, option).getMessage());\n        assertEquals(option, new AlreadySelectedException(group, option).getOption());\n        assertEquals(group, new AlreadySelectedException(group, option).getOptionGroup());\n    }\n}\n", "file_hash": "ec091b52ef7aa03a29da7aa1d2d25d22368b60ad5ac6ea7109fc6b56f2c6c22a", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class AlreadySelectedExceptionTest {\n\n    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new AlreadySelectedException(\"a\").getMessage());\n        assertNull(new AlreadySelectedException(\"a\").getOption());\n        final Option option = new Option(\"a\", \"d\");\n        final OptionGroup group = new OptionGroup();\n        assertNotNull(new AlreadySelectedException(group, option).getMessage());\n        assertEquals(option, new AlreadySelectedException(group, option).getOption());\n        assertEquals(group, new AlreadySelectedException(group, option).getOptionGroup());\n    }\n}", "definition": "public class AlreadySelectedExceptionTest", "class_docstring": "\nTests {@link AlreadySelectedException}.\n", "name": "AlreadySelectedExceptionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new AlreadySelectedException(\"a\").getMessage());\n        assertNull(new AlreadySelectedException(\"a\").getOption());\n        final Option option = new Option(\"a\", \"d\");\n        final OptionGroup group = new OptionGroup();\n        assertNotNull(new AlreadySelectedException(group, option).getMessage());\n        assertEquals(option, new AlreadySelectedException(group, option).getOption());\n        assertEquals(group, new AlreadySelectedException(group, option).getOptionGroup());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testConstructor", "params": [], "body": "                                  {\n        assertEquals(\"a\", new AlreadySelectedException(\"a\").getMessage());\n        assertNull(new AlreadySelectedException(\"a\").getOption());\n        final Option option = new Option(\"a\", \"d\");\n        final OptionGroup group = new OptionGroup();\n        assertNotNull(new AlreadySelectedException(group, option).getMessage());\n        assertEquals(option, new AlreadySelectedException(group, option).getOption());\n        assertEquals(group, new AlreadySelectedException(group, option).getOptionGroup());\n    }", "signature": "@Test\n    public void testConstructor()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/ConverterTests.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.net.URL;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests for standard Converters.\n */\npublic class ConverterTests {\n\n    // A class without a default constructor.\n    public class AClassWithoutADefaultConstructor {\n        public AClassWithoutADefaultConstructor(final int i) {\n        }\n    }\n\n    private static Stream<Arguments> numberTestParameters() {\n        final List<Arguments> lst = new ArrayList<>();\n\n        lst.add(Arguments.of(\"123\", Long.valueOf(\"123\")));\n        lst.add(Arguments.of(\"12.3\", Double.valueOf(\"12.3\")));\n        lst.add(Arguments.of(\"-123\", Long.valueOf(\"-123\")));\n        lst.add(Arguments.of(\"-12.3\", Double.valueOf(\"-12.3\")));\n        lst.add(Arguments.of(\".3\", Double.valueOf(\"0.3\")));\n        lst.add(Arguments.of(\"-.3\", Double.valueOf(\"-0.3\")));\n        lst.add(Arguments.of(\"0x5F\", null));\n        lst.add(Arguments.of(\"2,3\", null));\n        lst.add(Arguments.of(\"1.2.3\", null));\n\n        return lst.stream();\n    }\n\n    @Test\n    public void classTests() throws Exception {\n\n        assertNotNull(Converter.CLASS.apply(this.getClass().getName()), this.getClass().getName());\n        assertNotNull(Converter.CLASS.apply(this.getClass().getCanonicalName()), this.getClass().getCanonicalName());\n        assertThrows(ClassNotFoundException.class, () -> Converter.CLASS.apply(this.getClass().getSimpleName()),\n                this.getClass().getSimpleName());\n        assertNotNull(Converter.CLASS.apply(this.getClass().getTypeName()), this.getClass().getTypeName());\n\n        assertThrows(ClassNotFoundException.class, () -> Converter.CLASS.apply(\"foo.bar\"));\n        assertNotNull(Converter.CLASS.apply(AClassWithoutADefaultConstructor.class.getName()));\n    }\n\n    @Test\n    public void dateTests() throws Exception {\n        assertThrows(java.text.ParseException.class, () -> Converter.DATE.apply(\"whatever\"));\n\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the\n         * machine on which the test is running.  To avoid this problem, convert the time into a string\n         * and then unparse that using the converter.  This produces strings that always match the correct\n         * time zone.\n         */\n        final Date expected = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n        final String formatted = dateFormat.format(expected);\n        assertEquals(expected, Converter.DATE.apply(formatted));\n\n        assertThrows(java.text.ParseException.class, () -> Converter.DATE.apply(\"Jun 06 17:48:57 EDT 2002\"));\n    }\n\n    @Test\n    public void fileTests() throws Exception {\n        final URL url = this.getClass().getClassLoader().getResource(\"./org/apache/commons/cli/existing-readable.file\");\n        final String fileName = url.toString().substring(\"file:\".length());\n        assertNotNull(Converter.FILE.apply(fileName));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"numberTestParameters\")\n    public void numberTests(final String str, final Number expected) throws Exception {\n        if (expected != null) {\n            assertEquals(expected, Converter.NUMBER.apply(str));\n        } else {\n            assertThrows(NumberFormatException.class, () -> Converter.NUMBER.apply(str));\n        }\n    }\n\n    @Test\n    public void objectTests() throws Exception {\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getName()), this.getClass().getName());\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getCanonicalName()), this.getClass().getCanonicalName());\n        assertThrows(ClassNotFoundException.class, () -> Converter.OBJECT.apply(this.getClass().getSimpleName()),\n                this.getClass().getSimpleName());\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getTypeName()), this.getClass().getTypeName());\n\n        assertThrows(ClassNotFoundException.class, () -> Converter.OBJECT.apply(\"foo.bar\"));\n        assertThrows(NoSuchMethodException.class, () -> Converter.OBJECT.apply(AClassWithoutADefaultConstructor.class.getName()));\n    }\n\n    @Test\n    public void urlTests() throws Exception {\n        assertEquals(new URL(\"http://apache.org\"), Converter.URL.apply(\"http://apache.org\"));\n        assertThrows(java.net.MalformedURLException.class, () -> Converter.URL.apply(\"foo.bar\"));\n    }\n}\n", "file_hash": "f22adbf6cafb78a87c7f6e7abe5517e42eb4691aa4f5092df6853f9347980665", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import java.net.URL;", "import java.text.DateFormat;", "import java.text.SimpleDateFormat;", "import java.util.ArrayList;", "import java.util.Date;", "import java.util.List;", "import java.util.stream.Stream;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.provider.Arguments;", "import org.junit.jupiter.params.provider.MethodSource;"], "methods": [], "classes": [{"original_string": "public class ConverterTests {\n\n    // A class without a default constructor.\n    public class AClassWithoutADefaultConstructor {\n        public AClassWithoutADefaultConstructor(final int i) {\n        }\n    }\n\n    private static Stream<Arguments> numberTestParameters() {\n        final List<Arguments> lst = new ArrayList<>();\n\n        lst.add(Arguments.of(\"123\", Long.valueOf(\"123\")));\n        lst.add(Arguments.of(\"12.3\", Double.valueOf(\"12.3\")));\n        lst.add(Arguments.of(\"-123\", Long.valueOf(\"-123\")));\n        lst.add(Arguments.of(\"-12.3\", Double.valueOf(\"-12.3\")));\n        lst.add(Arguments.of(\".3\", Double.valueOf(\"0.3\")));\n        lst.add(Arguments.of(\"-.3\", Double.valueOf(\"-0.3\")));\n        lst.add(Arguments.of(\"0x5F\", null));\n        lst.add(Arguments.of(\"2,3\", null));\n        lst.add(Arguments.of(\"1.2.3\", null));\n\n        return lst.stream();\n    }\n\n    @Test\n    public void classTests() throws Exception {\n\n        assertNotNull(Converter.CLASS.apply(this.getClass().getName()), this.getClass().getName());\n        assertNotNull(Converter.CLASS.apply(this.getClass().getCanonicalName()), this.getClass().getCanonicalName());\n        assertThrows(ClassNotFoundException.class, () -> Converter.CLASS.apply(this.getClass().getSimpleName()),\n                this.getClass().getSimpleName());\n        assertNotNull(Converter.CLASS.apply(this.getClass().getTypeName()), this.getClass().getTypeName());\n\n        assertThrows(ClassNotFoundException.class, () -> Converter.CLASS.apply(\"foo.bar\"));\n        assertNotNull(Converter.CLASS.apply(AClassWithoutADefaultConstructor.class.getName()));\n    }\n\n    @Test\n    public void dateTests() throws Exception {\n        assertThrows(java.text.ParseException.class, () -> Converter.DATE.apply(\"whatever\"));\n\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the\n         * machine on which the test is running.  To avoid this problem, convert the time into a string\n         * and then unparse that using the converter.  This produces strings that always match the correct\n         * time zone.\n         */\n        final Date expected = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n        final String formatted = dateFormat.format(expected);\n        assertEquals(expected, Converter.DATE.apply(formatted));\n\n        assertThrows(java.text.ParseException.class, () -> Converter.DATE.apply(\"Jun 06 17:48:57 EDT 2002\"));\n    }\n\n    @Test\n    public void fileTests() throws Exception {\n        final URL url = this.getClass().getClassLoader().getResource(\"./org/apache/commons/cli/existing-readable.file\");\n        final String fileName = url.toString().substring(\"file:\".length());\n        assertNotNull(Converter.FILE.apply(fileName));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"numberTestParameters\")\n    public void numberTests(final String str, final Number expected) throws Exception {\n        if (expected != null) {\n            assertEquals(expected, Converter.NUMBER.apply(str));\n        } else {\n            assertThrows(NumberFormatException.class, () -> Converter.NUMBER.apply(str));\n        }\n    }\n\n    @Test\n    public void objectTests() throws Exception {\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getName()), this.getClass().getName());\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getCanonicalName()), this.getClass().getCanonicalName());\n        assertThrows(ClassNotFoundException.class, () -> Converter.OBJECT.apply(this.getClass().getSimpleName()),\n                this.getClass().getSimpleName());\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getTypeName()), this.getClass().getTypeName());\n\n        assertThrows(ClassNotFoundException.class, () -> Converter.OBJECT.apply(\"foo.bar\"));\n        assertThrows(NoSuchMethodException.class, () -> Converter.OBJECT.apply(AClassWithoutADefaultConstructor.class.getName()));\n    }\n\n    @Test\n    public void urlTests() throws Exception {\n        assertEquals(new URL(\"http://apache.org\"), Converter.URL.apply(\"http://apache.org\"));\n        assertThrows(java.net.MalformedURLException.class, () -> Converter.URL.apply(\"foo.bar\"));\n    }\n}", "definition": "public class ConverterTests", "class_docstring": "\nTests for standard Converters.\n", "name": "ConverterTests", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": [{"original_string": "    public class AClassWithoutADefaultConstructor {\n        public AClassWithoutADefaultConstructor(final int i) {\n        }\n    }", "definition": "    public class AClassWithoutADefaultConstructor", "class_docstring": " A class without a default constructor.", "name": "AClassWithoutADefaultConstructor", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AClassWithoutADefaultConstructor(final int i) {\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AClassWithoutADefaultConstructor", "params": [{"name": "i", "type": "int"}], "body": "                                                             {\n        }", "signature": "public AClassWithoutADefaultConstructor(final int i)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static Stream<Arguments> numberTestParameters() {\n        final List<Arguments> lst = new ArrayList<>();\n\n        lst.add(Arguments.of(\"123\", Long.valueOf(\"123\")));\n        lst.add(Arguments.of(\"12.3\", Double.valueOf(\"12.3\")));\n        lst.add(Arguments.of(\"-123\", Long.valueOf(\"-123\")));\n        lst.add(Arguments.of(\"-12.3\", Double.valueOf(\"-12.3\")));\n        lst.add(Arguments.of(\".3\", Double.valueOf(\"0.3\")));\n        lst.add(Arguments.of(\"-.3\", Double.valueOf(\"-0.3\")));\n        lst.add(Arguments.of(\"0x5F\", null));\n        lst.add(Arguments.of(\"2,3\", null));\n        lst.add(Arguments.of(\"1.2.3\", null));\n\n        return lst.stream();\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Stream<Arguments>", "classes": []}, "name": "numberTestParameters", "params": [], "body": "                                                            {\n        final List<Arguments> lst = new ArrayList<>();\n\n        lst.add(Arguments.of(\"123\", Long.valueOf(\"123\")));\n        lst.add(Arguments.of(\"12.3\", Double.valueOf(\"12.3\")));\n        lst.add(Arguments.of(\"-123\", Long.valueOf(\"-123\")));\n        lst.add(Arguments.of(\"-12.3\", Double.valueOf(\"-12.3\")));\n        lst.add(Arguments.of(\".3\", Double.valueOf(\"0.3\")));\n        lst.add(Arguments.of(\"-.3\", Double.valueOf(\"-0.3\")));\n        lst.add(Arguments.of(\"0x5F\", null));\n        lst.add(Arguments.of(\"2,3\", null));\n        lst.add(Arguments.of(\"1.2.3\", null));\n\n        return lst.stream();\n    }", "signature": "private static Stream<Arguments> numberTestParameters()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void classTests() throws Exception {\n\n        assertNotNull(Converter.CLASS.apply(this.getClass().getName()), this.getClass().getName());\n        assertNotNull(Converter.CLASS.apply(this.getClass().getCanonicalName()), this.getClass().getCanonicalName());\n        assertThrows(ClassNotFoundException.class, () -> Converter.CLASS.apply(this.getClass().getSimpleName()),\n                this.getClass().getSimpleName());\n        assertNotNull(Converter.CLASS.apply(this.getClass().getTypeName()), this.getClass().getTypeName());\n\n        assertThrows(ClassNotFoundException.class, () -> Converter.CLASS.apply(\"foo.bar\"));\n        assertNotNull(Converter.CLASS.apply(AClassWithoutADefaultConstructor.class.getName()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "classTests", "params": [], "body": "                                              {\n\n        assertNotNull(Converter.CLASS.apply(this.getClass().getName()), this.getClass().getName());\n        assertNotNull(Converter.CLASS.apply(this.getClass().getCanonicalName()), this.getClass().getCanonicalName());\n        assertThrows(ClassNotFoundException.class, () -> Converter.CLASS.apply(this.getClass().getSimpleName()),\n                this.getClass().getSimpleName());\n        assertNotNull(Converter.CLASS.apply(this.getClass().getTypeName()), this.getClass().getTypeName());\n\n        assertThrows(ClassNotFoundException.class, () -> Converter.CLASS.apply(\"foo.bar\"));\n        assertNotNull(Converter.CLASS.apply(AClassWithoutADefaultConstructor.class.getName()));\n    }", "signature": "@Test\n    public void classTests()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void dateTests() throws Exception {\n        assertThrows(java.text.ParseException.class, () -> Converter.DATE.apply(\"whatever\"));\n\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the\n         * machine on which the test is running.  To avoid this problem, convert the time into a string\n         * and then unparse that using the converter.  This produces strings that always match the correct\n         * time zone.\n         */\n        final Date expected = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n        final String formatted = dateFormat.format(expected);\n        assertEquals(expected, Converter.DATE.apply(formatted));\n\n        assertThrows(java.text.ParseException.class, () -> Converter.DATE.apply(\"Jun 06 17:48:57 EDT 2002\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "dateTests", "params": [], "body": "                                             {\n        assertThrows(java.text.ParseException.class, () -> Converter.DATE.apply(\"whatever\"));\n\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the\n         * machine on which the test is running.  To avoid this problem, convert the time into a string\n         * and then unparse that using the converter.  This produces strings that always match the correct\n         * time zone.\n         */\n        final Date expected = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n        final String formatted = dateFormat.format(expected);\n        assertEquals(expected, Converter.DATE.apply(formatted));\n\n        assertThrows(java.text.ParseException.class, () -> Converter.DATE.apply(\"Jun 06 17:48:57 EDT 2002\"));\n    }", "signature": "@Test\n    public void dateTests()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void fileTests() throws Exception {\n        final URL url = this.getClass().getClassLoader().getResource(\"./org/apache/commons/cli/existing-readable.file\");\n        final String fileName = url.toString().substring(\"file:\".length());\n        assertNotNull(Converter.FILE.apply(fileName));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "fileTests", "params": [], "body": "                                             {\n        final URL url = this.getClass().getClassLoader().getResource(\"./org/apache/commons/cli/existing-readable.file\");\n        final String fileName = url.toString().substring(\"file:\".length());\n        assertNotNull(Converter.FILE.apply(fileName));\n    }", "signature": "@Test\n    public void fileTests()"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"numberTestParameters\")\n    public void numberTests(final String str, final Number expected) throws Exception {\n        if (expected != null) {\n            assertEquals(expected, Converter.NUMBER.apply(str));\n        } else {\n            assertThrows(NumberFormatException.class, () -> Converter.NUMBER.apply(str));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"numberTestParameters\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"numberTestParameters\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "numberTests", "params": [{"name": "str", "type": "String"}, {"name": "expected", "type": "Number"}], "body": "                                                                                      {\n        if (expected != null) {\n            assertEquals(expected, Converter.NUMBER.apply(str));\n        } else {\n            assertThrows(NumberFormatException.class, () -> Converter.NUMBER.apply(str));\n        }\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"numberTestParameters\")\n    public void numberTests(final String str, final Number expected)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void objectTests() throws Exception {\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getName()), this.getClass().getName());\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getCanonicalName()), this.getClass().getCanonicalName());\n        assertThrows(ClassNotFoundException.class, () -> Converter.OBJECT.apply(this.getClass().getSimpleName()),\n                this.getClass().getSimpleName());\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getTypeName()), this.getClass().getTypeName());\n\n        assertThrows(ClassNotFoundException.class, () -> Converter.OBJECT.apply(\"foo.bar\"));\n        assertThrows(NoSuchMethodException.class, () -> Converter.OBJECT.apply(AClassWithoutADefaultConstructor.class.getName()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "objectTests", "params": [], "body": "                                               {\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getName()), this.getClass().getName());\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getCanonicalName()), this.getClass().getCanonicalName());\n        assertThrows(ClassNotFoundException.class, () -> Converter.OBJECT.apply(this.getClass().getSimpleName()),\n                this.getClass().getSimpleName());\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getTypeName()), this.getClass().getTypeName());\n\n        assertThrows(ClassNotFoundException.class, () -> Converter.OBJECT.apply(\"foo.bar\"));\n        assertThrows(NoSuchMethodException.class, () -> Converter.OBJECT.apply(AClassWithoutADefaultConstructor.class.getName()));\n    }", "signature": "@Test\n    public void objectTests()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void urlTests() throws Exception {\n        assertEquals(new URL(\"http://apache.org\"), Converter.URL.apply(\"http://apache.org\"));\n        assertThrows(java.net.MalformedURLException.class, () -> Converter.URL.apply(\"foo.bar\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "urlTests", "params": [], "body": "                                            {\n        assertEquals(new URL(\"http://apache.org\"), Converter.URL.apply(\"http://apache.org\"));\n        assertThrows(java.net.MalformedURLException.class, () -> Converter.URL.apply(\"foo.bar\"));\n    }", "signature": "@Test\n    public void urlTests()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/Option_cloneTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class Option_cloneTest {\n\n    private Option option;\n\n    @BeforeEach\n    public void setUp() {\n        option = Option.builder(\"f\").hasArg().numberOfArgs(2).build();\n    }\n\n    @Test\n    public void testCloneWithValues() {\n        option.processValue(\"value1\");\n        option.processValue(\"value2\");\n\n        Option clonedOption = (Option) option.clone();\n\n        assertNotSame(option, clonedOption);\n        assertEquals(option.getValues().length, clonedOption.getValues().length);\n        assertEquals(option.getValues()[0], clonedOption.getValues()[0]);\n        assertEquals(option.getValues()[1], clonedOption.getValues()[1]);\n    }\n\n    @Test\n    public void testCloneWithoutValues() {\n        Option clonedOption = (Option) option.clone();\n\n        assertNotSame(option, clonedOption);\n        assertNull(clonedOption.getValues());\n    }\n\n    @Test\n    public void testCloneAndClearValues() {\n        option.processValue(\"value1\");\n        option.processValue(\"value2\");\n\n        Option clonedOption = (Option) option.clone();\n        clonedOption.clearValues();\n\n        assertNotSame(option, clonedOption);\n        assertNull(clonedOption.getValues());\n    }\n\n    @Test\n    public void testCloneAndProcessValue() {\n        option.processValue(\"value1\");\n\n        Option clonedOption = (Option) option.clone();\n        clonedOption.processValue(\"value2\");\n\n        assertNotSame(option, clonedOption);\n        assertEquals(1, option.getValues().length);\n        assertEquals(2, clonedOption.getValues().length);\n    }\n}\n", "file_hash": "87f5317079c8fbf53f4f82bafa898724a3334d5e6c14d90b8fcfe8f380899d45", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.*;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class Option_cloneTest {\n\n    private Option option;\n\n    @BeforeEach\n    public void setUp() {\n        option = Option.builder(\"f\").hasArg().numberOfArgs(2).build();\n    }\n\n    @Test\n    public void testCloneWithValues() {\n        option.processValue(\"value1\");\n        option.processValue(\"value2\");\n\n        Option clonedOption = (Option) option.clone();\n\n        assertNotSame(option, clonedOption);\n        assertEquals(option.getValues().length, clonedOption.getValues().length);\n        assertEquals(option.getValues()[0], clonedOption.getValues()[0]);\n        assertEquals(option.getValues()[1], clonedOption.getValues()[1]);\n    }\n\n    @Test\n    public void testCloneWithoutValues() {\n        Option clonedOption = (Option) option.clone();\n\n        assertNotSame(option, clonedOption);\n        assertNull(clonedOption.getValues());\n    }\n\n    @Test\n    public void testCloneAndClearValues() {\n        option.processValue(\"value1\");\n        option.processValue(\"value2\");\n\n        Option clonedOption = (Option) option.clone();\n        clonedOption.clearValues();\n\n        assertNotSame(option, clonedOption);\n        assertNull(clonedOption.getValues());\n    }\n\n    @Test\n    public void testCloneAndProcessValue() {\n        option.processValue(\"value1\");\n\n        Option clonedOption = (Option) option.clone();\n        clonedOption.processValue(\"value2\");\n\n        assertNotSame(option, clonedOption);\n        assertEquals(1, option.getValues().length);\n        assertEquals(2, clonedOption.getValues().length);\n    }\n}", "definition": "public class Option_cloneTest", "class_docstring": "", "name": "Option_cloneTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Option option;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "option", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        option = Option.builder(\"f\").hasArg().numberOfArgs(2).build();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        option = Option.builder(\"f\").hasArg().numberOfArgs(2).build();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloneWithValues() {\n        option.processValue(\"value1\");\n        option.processValue(\"value2\");\n\n        Option clonedOption = (Option) option.clone();\n\n        assertNotSame(option, clonedOption);\n        assertEquals(option.getValues().length, clonedOption.getValues().length);\n        assertEquals(option.getValues()[0], clonedOption.getValues()[0]);\n        assertEquals(option.getValues()[1], clonedOption.getValues()[1]);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloneWithValues", "params": [], "body": "                                      {\n        option.processValue(\"value1\");\n        option.processValue(\"value2\");\n\n        Option clonedOption = (Option) option.clone();\n\n        assertNotSame(option, clonedOption);\n        assertEquals(option.getValues().length, clonedOption.getValues().length);\n        assertEquals(option.getValues()[0], clonedOption.getValues()[0]);\n        assertEquals(option.getValues()[1], clonedOption.getValues()[1]);\n    }", "signature": "@Test\n    public void testCloneWithValues()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloneWithoutValues() {\n        Option clonedOption = (Option) option.clone();\n\n        assertNotSame(option, clonedOption);\n        assertNull(clonedOption.getValues());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloneWithoutValues", "params": [], "body": "                                         {\n        Option clonedOption = (Option) option.clone();\n\n        assertNotSame(option, clonedOption);\n        assertNull(clonedOption.getValues());\n    }", "signature": "@Test\n    public void testCloneWithoutValues()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloneAndClearValues() {\n        option.processValue(\"value1\");\n        option.processValue(\"value2\");\n\n        Option clonedOption = (Option) option.clone();\n        clonedOption.clearValues();\n\n        assertNotSame(option, clonedOption);\n        assertNull(clonedOption.getValues());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloneAndClearValues", "params": [], "body": "                                          {\n        option.processValue(\"value1\");\n        option.processValue(\"value2\");\n\n        Option clonedOption = (Option) option.clone();\n        clonedOption.clearValues();\n\n        assertNotSame(option, clonedOption);\n        assertNull(clonedOption.getValues());\n    }", "signature": "@Test\n    public void testCloneAndClearValues()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloneAndProcessValue() {\n        option.processValue(\"value1\");\n\n        Option clonedOption = (Option) option.clone();\n        clonedOption.processValue(\"value2\");\n\n        assertNotSame(option, clonedOption);\n        assertEquals(1, option.getValues().length);\n        assertEquals(2, clonedOption.getValues().length);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloneAndProcessValue", "params": [], "body": "                                           {\n        option.processValue(\"value1\");\n\n        Option clonedOption = (Option) option.clone();\n        clonedOption.processValue(\"value2\");\n\n        assertNotSame(option, clonedOption);\n        assertEquals(1, option.getValues().length);\n        assertEquals(2, clonedOption.getValues().length);\n    }", "signature": "@Test\n    public void testCloneAndProcessValue()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/ParseExceptionTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ParseException}.\n */\npublic class ParseExceptionTest {\n\n    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new ParseException(\"a\").getMessage());\n        final Throwable t = new IOException();\n        assertEquals(t, new ParseException(t).getCause());\n        assertEquals(t, ParseException.wrap(t).getCause());\n        final ParseException pe = new ParseException(\"A\");\n        assertEquals(pe, ParseException.wrap(pe));\n    }\n}\n", "file_hash": "e34ec3b530d740a96e3b40332e4d495ffa5e062bd3428e74e7f9fe0b2f104065", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import java.io.IOException;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class ParseExceptionTest {\n\n    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new ParseException(\"a\").getMessage());\n        final Throwable t = new IOException();\n        assertEquals(t, new ParseException(t).getCause());\n        assertEquals(t, ParseException.wrap(t).getCause());\n        final ParseException pe = new ParseException(\"A\");\n        assertEquals(pe, ParseException.wrap(pe));\n    }\n}", "definition": "public class ParseExceptionTest", "class_docstring": "\nTests {@link ParseException}.\n", "name": "ParseExceptionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new ParseException(\"a\").getMessage());\n        final Throwable t = new IOException();\n        assertEquals(t, new ParseException(t).getCause());\n        assertEquals(t, ParseException.wrap(t).getCause());\n        final ParseException pe = new ParseException(\"A\");\n        assertEquals(pe, ParseException.wrap(pe));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testConstructor", "params": [], "body": "                                  {\n        assertEquals(\"a\", new ParseException(\"a\").getMessage());\n        final Throwable t = new IOException();\n        assertEquals(t, new ParseException(t).getCause());\n        assertEquals(t, ParseException.wrap(t).getCause());\n        final ParseException pe = new ParseException(\"A\");\n        assertEquals(pe, ParseException.wrap(pe));\n    }", "signature": "@Test\n    public void testConstructor()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/OptionBuilderTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport org.junit.jupiter.api.Test;\n\n@SuppressWarnings(\"deprecation\") // OptionBuilder is marked deprecated\npublic class OptionBuilderTest {\n    @Test\n    public void testBaseOptionCharOpt() {\n        final Option base = OptionBuilder.withDescription(\"option description\").create('o');\n\n        assertEquals(\"o\", base.getOpt());\n        assertEquals(\"option description\", base.getDescription());\n        assertFalse(base.hasArg());\n    }\n\n    @Test\n    public void testBaseOptionStringOpt() {\n        final Option base = OptionBuilder.withDescription(\"option description\").create(\"o\");\n\n        assertEquals(\"o\", base.getOpt());\n        assertEquals(\"option description\", base.getDescription());\n        assertFalse(base.hasArg());\n    }\n\n    @Test\n    public void testBuilderIsResettedAlways() {\n        try {\n            OptionBuilder.withDescription(\"JUnit\").create('\"');\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n        assertNull(OptionBuilder.create('x').getDescription(), \"we inherited a description\");\n\n        try {\n            OptionBuilder.withDescription(\"JUnit\").create();\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n        assertNull(OptionBuilder.create('x').getDescription(), \"we inherited a description\");\n    }\n\n    @Test\n    public void testCompleteOption() {\n        //@formatter:off\n        final Option simple = OptionBuilder.withLongOpt(\"simple option\")\n                                     .hasArg()\n                                     .isRequired()\n                                     .hasArgs()\n                                     .withType(Float.class)\n                                     .withDescription(\"this is a simple option\")\n                                     .create('s');\n        //@formatter:on\n\n        assertEquals(\"s\", simple.getOpt());\n        assertEquals(\"simple option\", simple.getLongOpt());\n        assertEquals(\"this is a simple option\", simple.getDescription());\n        assertEquals(simple.getType(), Float.class);\n        assertTrue(simple.hasArg());\n        assertTrue(simple.isRequired());\n        assertTrue(simple.hasArgs());\n    }\n\n    @Test\n    public void testCreateIncompleteOption() {\n        try {\n            OptionBuilder.hasArg().create();\n            fail(\"Incomplete option should be rejected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n\n            // implicitly reset the builder\n            OptionBuilder.create(\"opt\");\n        }\n    }\n\n    @Test\n    public void testIllegalOptions() {\n        // bad single character option\n        try {\n            OptionBuilder.withDescription(\"option description\").create('\"');\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException exp) {\n            // success\n        }\n\n        // bad character in option string\n        try {\n            OptionBuilder.create(\"opt`\");\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException exp) {\n            // success\n        }\n\n        // valid option\n        try {\n            OptionBuilder.create(\"opt\");\n            // success\n        } catch (final IllegalArgumentException exp) {\n            fail(\"IllegalArgumentException caught\");\n        }\n    }\n\n    @Test\n    public void testOptionArgNumbers() {\n        //@formatter:off\n        final Option opt = OptionBuilder.withDescription(\"option description\")\n                                  .hasArgs(2)\n                                  .create('o');\n        //@formatter:on\n        assertEquals(2, opt.getArgs());\n    }\n\n    @Test\n    public void testSpecialOptChars() throws Exception {\n        // '?'\n        final Option opt1 = OptionBuilder.withDescription(\"help options\").create('?');\n        assertEquals(\"?\", opt1.getOpt());\n\n        // '@'\n        final Option opt2 = OptionBuilder.withDescription(\"read from stdin\").create('@');\n        assertEquals(\"@\", opt2.getOpt());\n\n        // ' '\n        try {\n            OptionBuilder.create(' ');\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException e) {\n            // success\n        }\n    }\n\n    @Test\n    public void testTwoCompleteOptions() {\n        //@formatter:off\n        Option simple = OptionBuilder.withLongOpt(\"simple option\")\n                                     .hasArg()\n                                     .isRequired()\n                                     .hasArgs()\n                                     .withType(Float.class)\n                                     .withDescription(\"this is a simple option\")\n                                     .create('s');\n        //@formatter:on\n\n        assertEquals(\"s\", simple.getOpt());\n        assertEquals(\"simple option\", simple.getLongOpt());\n        assertEquals(\"this is a simple option\", simple.getDescription());\n        assertEquals(simple.getType(), Float.class);\n        assertTrue(simple.hasArg());\n        assertTrue(simple.isRequired());\n        assertTrue(simple.hasArgs());\n\n        //@formatter:off\n        simple = OptionBuilder.withLongOpt(\"dimple option\")\n                              .hasArg()\n                              .withDescription(\"this is a dimple option\")\n                              .create('d');\n        //@formatter:on\n\n        assertEquals(\"d\", simple.getOpt());\n        assertEquals(\"dimple option\", simple.getLongOpt());\n        assertEquals(\"this is a dimple option\", simple.getDescription());\n        assertEquals(String.class, simple.getType());\n        assertTrue(simple.hasArg());\n        assertFalse(simple.isRequired());\n        assertFalse(simple.hasArgs());\n    }\n}\n", "file_hash": "f0186f35c32ea955f14d6d97001d5d9d6dd0eec672845a96d93175b90a9cf90d", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import static org.junit.jupiter.api.Assertions.fail;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // OptionBuilder is marked deprecated\npublic class OptionBuilderTest {\n    @Test\n    public void testBaseOptionCharOpt() {\n        final Option base = OptionBuilder.withDescription(\"option description\").create('o');\n\n        assertEquals(\"o\", base.getOpt());\n        assertEquals(\"option description\", base.getDescription());\n        assertFalse(base.hasArg());\n    }\n\n    @Test\n    public void testBaseOptionStringOpt() {\n        final Option base = OptionBuilder.withDescription(\"option description\").create(\"o\");\n\n        assertEquals(\"o\", base.getOpt());\n        assertEquals(\"option description\", base.getDescription());\n        assertFalse(base.hasArg());\n    }\n\n    @Test\n    public void testBuilderIsResettedAlways() {\n        try {\n            OptionBuilder.withDescription(\"JUnit\").create('\"');\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n        assertNull(OptionBuilder.create('x').getDescription(), \"we inherited a description\");\n\n        try {\n            OptionBuilder.withDescription(\"JUnit\").create();\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n        assertNull(OptionBuilder.create('x').getDescription(), \"we inherited a description\");\n    }\n\n    @Test\n    public void testCompleteOption() {\n        //@formatter:off\n        final Option simple = OptionBuilder.withLongOpt(\"simple option\")\n                                     .hasArg()\n                                     .isRequired()\n                                     .hasArgs()\n                                     .withType(Float.class)\n                                     .withDescription(\"this is a simple option\")\n                                     .create('s');\n        //@formatter:on\n\n        assertEquals(\"s\", simple.getOpt());\n        assertEquals(\"simple option\", simple.getLongOpt());\n        assertEquals(\"this is a simple option\", simple.getDescription());\n        assertEquals(simple.getType(), Float.class);\n        assertTrue(simple.hasArg());\n        assertTrue(simple.isRequired());\n        assertTrue(simple.hasArgs());\n    }\n\n    @Test\n    public void testCreateIncompleteOption() {\n        try {\n            OptionBuilder.hasArg().create();\n            fail(\"Incomplete option should be rejected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n\n            // implicitly reset the builder\n            OptionBuilder.create(\"opt\");\n        }\n    }\n\n    @Test\n    public void testIllegalOptions() {\n        // bad single character option\n        try {\n            OptionBuilder.withDescription(\"option description\").create('\"');\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException exp) {\n            // success\n        }\n\n        // bad character in option string\n        try {\n            OptionBuilder.create(\"opt`\");\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException exp) {\n            // success\n        }\n\n        // valid option\n        try {\n            OptionBuilder.create(\"opt\");\n            // success\n        } catch (final IllegalArgumentException exp) {\n            fail(\"IllegalArgumentException caught\");\n        }\n    }\n\n    @Test\n    public void testOptionArgNumbers() {\n        //@formatter:off\n        final Option opt = OptionBuilder.withDescription(\"option description\")\n                                  .hasArgs(2)\n                                  .create('o');\n        //@formatter:on\n        assertEquals(2, opt.getArgs());\n    }\n\n    @Test\n    public void testSpecialOptChars() throws Exception {\n        // '?'\n        final Option opt1 = OptionBuilder.withDescription(\"help options\").create('?');\n        assertEquals(\"?\", opt1.getOpt());\n\n        // '@'\n        final Option opt2 = OptionBuilder.withDescription(\"read from stdin\").create('@');\n        assertEquals(\"@\", opt2.getOpt());\n\n        // ' '\n        try {\n            OptionBuilder.create(' ');\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException e) {\n            // success\n        }\n    }\n\n    @Test\n    public void testTwoCompleteOptions() {\n        //@formatter:off\n        Option simple = OptionBuilder.withLongOpt(\"simple option\")\n                                     .hasArg()\n                                     .isRequired()\n                                     .hasArgs()\n                                     .withType(Float.class)\n                                     .withDescription(\"this is a simple option\")\n                                     .create('s');\n        //@formatter:on\n\n        assertEquals(\"s\", simple.getOpt());\n        assertEquals(\"simple option\", simple.getLongOpt());\n        assertEquals(\"this is a simple option\", simple.getDescription());\n        assertEquals(simple.getType(), Float.class);\n        assertTrue(simple.hasArg());\n        assertTrue(simple.isRequired());\n        assertTrue(simple.hasArgs());\n\n        //@formatter:off\n        simple = OptionBuilder.withLongOpt(\"dimple option\")\n                              .hasArg()\n                              .withDescription(\"this is a dimple option\")\n                              .create('d');\n        //@formatter:on\n\n        assertEquals(\"d\", simple.getOpt());\n        assertEquals(\"dimple option\", simple.getLongOpt());\n        assertEquals(\"this is a dimple option\", simple.getDescription());\n        assertEquals(String.class, simple.getType());\n        assertTrue(simple.hasArg());\n        assertFalse(simple.isRequired());\n        assertFalse(simple.hasArgs());\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // OptionBuilder is marked deprecated\npublic class OptionBuilderTest", "class_docstring": "", "name": "OptionBuilderTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // OptionBuilder is marked deprecated\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// OptionBuilder is marked deprecated"], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testBaseOptionCharOpt() {\n        final Option base = OptionBuilder.withDescription(\"option description\").create('o');\n\n        assertEquals(\"o\", base.getOpt());\n        assertEquals(\"option description\", base.getDescription());\n        assertFalse(base.hasArg());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBaseOptionCharOpt", "params": [], "body": "                                        {\n        final Option base = OptionBuilder.withDescription(\"option description\").create('o');\n\n        assertEquals(\"o\", base.getOpt());\n        assertEquals(\"option description\", base.getDescription());\n        assertFalse(base.hasArg());\n    }", "signature": "@Test\n    public void testBaseOptionCharOpt()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBaseOptionStringOpt() {\n        final Option base = OptionBuilder.withDescription(\"option description\").create(\"o\");\n\n        assertEquals(\"o\", base.getOpt());\n        assertEquals(\"option description\", base.getDescription());\n        assertFalse(base.hasArg());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBaseOptionStringOpt", "params": [], "body": "                                          {\n        final Option base = OptionBuilder.withDescription(\"option description\").create(\"o\");\n\n        assertEquals(\"o\", base.getOpt());\n        assertEquals(\"option description\", base.getDescription());\n        assertFalse(base.hasArg());\n    }", "signature": "@Test\n    public void testBaseOptionStringOpt()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBuilderIsResettedAlways() {\n        try {\n            OptionBuilder.withDescription(\"JUnit\").create('\"');\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n        assertNull(OptionBuilder.create('x').getDescription(), \"we inherited a description\");\n\n        try {\n            OptionBuilder.withDescription(\"JUnit\").create();\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n        assertNull(OptionBuilder.create('x').getDescription(), \"we inherited a description\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilderIsResettedAlways", "params": [], "body": "                                              {\n        try {\n            OptionBuilder.withDescription(\"JUnit\").create('\"');\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n        assertNull(OptionBuilder.create('x').getDescription(), \"we inherited a description\");\n\n        try {\n            OptionBuilder.withDescription(\"JUnit\").create();\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n        assertNull(OptionBuilder.create('x').getDescription(), \"we inherited a description\");\n    }", "signature": "@Test\n    public void testBuilderIsResettedAlways()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCompleteOption() {\n        //@formatter:off\n        final Option simple = OptionBuilder.withLongOpt(\"simple option\")\n                                     .hasArg()\n                                     .isRequired()\n                                     .hasArgs()\n                                     .withType(Float.class)\n                                     .withDescription(\"this is a simple option\")\n                                     .create('s');\n        //@formatter:on\n\n        assertEquals(\"s\", simple.getOpt());\n        assertEquals(\"simple option\", simple.getLongOpt());\n        assertEquals(\"this is a simple option\", simple.getDescription());\n        assertEquals(simple.getType(), Float.class);\n        assertTrue(simple.hasArg());\n        assertTrue(simple.isRequired());\n        assertTrue(simple.hasArgs());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCompleteOption", "params": [], "body": "                                     {\n        //@formatter:off\n        final Option simple = OptionBuilder.withLongOpt(\"simple option\")\n                                     .hasArg()\n                                     .isRequired()\n                                     .hasArgs()\n                                     .withType(Float.class)\n                                     .withDescription(\"this is a simple option\")\n                                     .create('s');\n        //@formatter:on\n\n        assertEquals(\"s\", simple.getOpt());\n        assertEquals(\"simple option\", simple.getLongOpt());\n        assertEquals(\"this is a simple option\", simple.getDescription());\n        assertEquals(simple.getType(), Float.class);\n        assertTrue(simple.hasArg());\n        assertTrue(simple.isRequired());\n        assertTrue(simple.hasArgs());\n    }", "signature": "@Test\n    public void testCompleteOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCreateIncompleteOption() {\n        try {\n            OptionBuilder.hasArg().create();\n            fail(\"Incomplete option should be rejected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n\n            // implicitly reset the builder\n            OptionBuilder.create(\"opt\");\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateIncompleteOption", "params": [], "body": "                                             {\n        try {\n            OptionBuilder.hasArg().create();\n            fail(\"Incomplete option should be rejected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n\n            // implicitly reset the builder\n            OptionBuilder.create(\"opt\");\n        }\n    }", "signature": "@Test\n    public void testCreateIncompleteOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testIllegalOptions() {\n        // bad single character option\n        try {\n            OptionBuilder.withDescription(\"option description\").create('\"');\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException exp) {\n            // success\n        }\n\n        // bad character in option string\n        try {\n            OptionBuilder.create(\"opt`\");\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException exp) {\n            // success\n        }\n\n        // valid option\n        try {\n            OptionBuilder.create(\"opt\");\n            // success\n        } catch (final IllegalArgumentException exp) {\n            fail(\"IllegalArgumentException caught\");\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIllegalOptions", "params": [], "body": "                                     {\n        // bad single character option\n        try {\n            OptionBuilder.withDescription(\"option description\").create('\"');\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException exp) {\n            // success\n        }\n\n        // bad character in option string\n        try {\n            OptionBuilder.create(\"opt`\");\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException exp) {\n            // success\n        }\n\n        // valid option\n        try {\n            OptionBuilder.create(\"opt\");\n            // success\n        } catch (final IllegalArgumentException exp) {\n            fail(\"IllegalArgumentException caught\");\n        }\n    }", "signature": "@Test\n    public void testIllegalOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionArgNumbers() {\n        //@formatter:off\n        final Option opt = OptionBuilder.withDescription(\"option description\")\n                                  .hasArgs(2)\n                                  .create('o');\n        //@formatter:on\n        assertEquals(2, opt.getArgs());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionArgNumbers", "params": [], "body": "                                       {\n        //@formatter:off\n        final Option opt = OptionBuilder.withDescription(\"option description\")\n                                  .hasArgs(2)\n                                  .create('o');\n        //@formatter:on\n        assertEquals(2, opt.getArgs());\n    }", "signature": "@Test\n    public void testOptionArgNumbers()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSpecialOptChars() throws Exception {\n        // '?'\n        final Option opt1 = OptionBuilder.withDescription(\"help options\").create('?');\n        assertEquals(\"?\", opt1.getOpt());\n\n        // '@'\n        final Option opt2 = OptionBuilder.withDescription(\"read from stdin\").create('@');\n        assertEquals(\"@\", opt2.getOpt());\n\n        // ' '\n        try {\n            OptionBuilder.create(' ');\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException e) {\n            // success\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSpecialOptChars", "params": [], "body": "                                                       {\n        // '?'\n        final Option opt1 = OptionBuilder.withDescription(\"help options\").create('?');\n        assertEquals(\"?\", opt1.getOpt());\n\n        // '@'\n        final Option opt2 = OptionBuilder.withDescription(\"read from stdin\").create('@');\n        assertEquals(\"@\", opt2.getOpt());\n\n        // ' '\n        try {\n            OptionBuilder.create(' ');\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException e) {\n            // success\n        }\n    }", "signature": "@Test\n    public void testSpecialOptChars()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTwoCompleteOptions() {\n        //@formatter:off\n        Option simple = OptionBuilder.withLongOpt(\"simple option\")\n                                     .hasArg()\n                                     .isRequired()\n                                     .hasArgs()\n                                     .withType(Float.class)\n                                     .withDescription(\"this is a simple option\")\n                                     .create('s');\n        //@formatter:on\n\n        assertEquals(\"s\", simple.getOpt());\n        assertEquals(\"simple option\", simple.getLongOpt());\n        assertEquals(\"this is a simple option\", simple.getDescription());\n        assertEquals(simple.getType(), Float.class);\n        assertTrue(simple.hasArg());\n        assertTrue(simple.isRequired());\n        assertTrue(simple.hasArgs());\n\n        //@formatter:off\n        simple = OptionBuilder.withLongOpt(\"dimple option\")\n                              .hasArg()\n                              .withDescription(\"this is a dimple option\")\n                              .create('d');\n        //@formatter:on\n\n        assertEquals(\"d\", simple.getOpt());\n        assertEquals(\"dimple option\", simple.getLongOpt());\n        assertEquals(\"this is a dimple option\", simple.getDescription());\n        assertEquals(String.class, simple.getType());\n        assertTrue(simple.hasArg());\n        assertFalse(simple.isRequired());\n        assertFalse(simple.hasArgs());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTwoCompleteOptions", "params": [], "body": "                                         {\n        //@formatter:off\n        Option simple = OptionBuilder.withLongOpt(\"simple option\")\n                                     .hasArg()\n                                     .isRequired()\n                                     .hasArgs()\n                                     .withType(Float.class)\n                                     .withDescription(\"this is a simple option\")\n                                     .create('s');\n        //@formatter:on\n\n        assertEquals(\"s\", simple.getOpt());\n        assertEquals(\"simple option\", simple.getLongOpt());\n        assertEquals(\"this is a simple option\", simple.getDescription());\n        assertEquals(simple.getType(), Float.class);\n        assertTrue(simple.hasArg());\n        assertTrue(simple.isRequired());\n        assertTrue(simple.hasArgs());\n\n        //@formatter:off\n        simple = OptionBuilder.withLongOpt(\"dimple option\")\n                              .hasArg()\n                              .withDescription(\"this is a dimple option\")\n                              .create('d');\n        //@formatter:on\n\n        assertEquals(\"d\", simple.getOpt());\n        assertEquals(\"dimple option\", simple.getLongOpt());\n        assertEquals(\"this is a dimple option\", simple.getDescription());\n        assertEquals(String.class, simple.getType());\n        assertTrue(simple.hasArg());\n        assertFalse(simple.isRequired());\n        assertFalse(simple.hasArgs());\n    }", "signature": "@Test\n    public void testTwoCompleteOptions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/AbstractParserTestCase.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Properties;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Abstract test case testing common parser features.\n *\n * TODO Needs a rework using JUnit parameterized tests.\n */\npublic abstract class AbstractParserTestCase {\n\n    protected CommandLineParser parser;\n\n    protected Options options;\n\n    @SuppressWarnings(\"deprecation\")\n    private CommandLine parse(final CommandLineParser parser, final Options options, final String[] args, final Properties properties) throws ParseException {\n        if (parser instanceof Parser) {\n            return ((Parser) parser).parse(options, args, properties);\n        }\n        if (parser instanceof DefaultParser) {\n            return ((DefaultParser) parser).parse(options, args, properties);\n        }\n        throw new UnsupportedOperationException(\"Default options not supported by this parser\");\n    }\n\n    @BeforeEach\n    public void setUp() {\n        //@formatter:off\n        options = new Options()\n            .addOption(\"a\", \"enable-a\", false, \"turn [a] on or off\")\n            .addOption(\"b\", \"bfile\", true, \"set the value of [b]\")\n            .addOption(\"c\", \"copt\", false, \"turn [c] on or off\");\n        //@formatter:on\n    }\n\n    public void testAmbiguousArgParsing() throws Exception {\n        final String[] args = { \"-=-\" };\n        final Options options = new Options();\n\n        assertThrows(UnrecognizedOptionException.class, () -> parser.parse(options, args));\n    }\n\n    @Test\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n        final String[] args = { \"-b\", \"-foobar\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasOptionalArg().create('f'));\n        options.addOption(OptionBuilder.withLongOpt(\"bar\").hasOptionalArg().create('b'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"b\"));\n        assertTrue(cl.hasOption(\"f\"));\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n        final String[] args = { \"-b\", \"-foobar\" };\n\n        final Options options = new Options();\n        options.addOption(Option.builder().longOpt(\"foo\").option(\"f\").optionalArg(true).build());\n        options.addOption(Option.builder().longOpt(\"bar\").option(\"b\").optionalArg(false).build());\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"b\"));\n        assertTrue(cl.hasOption(\"f\"));\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption1() throws Exception {\n        final String[] args = { \"--ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"--ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption2() throws Exception {\n        final String[] args = { \"-ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"-ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption3() throws Exception {\n        final String[] args = { \"--ver=1\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"--ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption4() throws Exception {\n        final String[] args = { \"-ver=1\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"-ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testArgumentStartingWithHyphen() throws Exception {\n        final String[] args = { \"-b\", \"-foo\" };\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-foo\", cl.getOptionValue(\"b\"));\n    }\n\n    @Test\n    public void testBursting() throws Exception {\n        final String[] args = { \"-acbtoast\", \"foo\", \"bar\" };\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }\n\n    @Test\n    public void testDoubleDash1() throws Exception {\n        final String[] args = { \"--copt\", \"--\", \"-b\", \"toast\" };\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertFalse(cl.hasOption(\"b\"), \"Confirm -b is not set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm 2 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testDoubleDash2() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArg().create('n'));\n        options.addOption(OptionBuilder.create('m'));\n\n        try {\n            parser.parse(options, new String[] { \"-n\", \"--\", \"-m\" });\n            fail(\"MissingArgumentException not thrown for option -n\");\n        } catch (final MissingArgumentException e) {\n            assertNotNull(e.getOption(), \"option null\");\n            assertEquals(\"n\", e.getOption().getOpt());\n        }\n    }\n\n    @Test\n    public void testLongOptionQuoteHandling() throws Exception {\n        final String[] args = { \"--bfile\", \"\\\"quoted string\\\"\" };\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n        final String[] args = { \"--bfile=\\\"quoted string\\\"\" };\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testLongWithEqualDoubleDash() throws Exception {\n        final String[] args = { \"--foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testLongWithEqualSingleDash() throws Exception {\n        final String[] args = { \"-foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testLongWithoutEqualDoubleDash() throws Exception {\n        final String[] args = { \"--foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args, true);\n        assertFalse(cl.hasOption(\"foo\")); // foo isn't expected to be recognized with a double dash\n    }\n\n    @Test\n    public void testLongWithoutEqualSingleDash() throws Exception {\n        final String[] args = { \"-foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testLongWithUnexpectedArgument1() throws Exception {\n        final String[] args = { \"--foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, args);\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"--foo=bar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }\n\n    @Test\n    public void testLongWithUnexpectedArgument2() throws Exception {\n        final String[] args = { \"-foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, args);\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-foobar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }\n\n    @Test\n    public void testMissingArg() throws Exception {\n        final String[] args = { \"-b\" };\n        boolean caught = false;\n        try {\n            parser.parse(options, args);\n        } catch (final MissingArgumentException e) {\n            caught = true;\n            assertEquals(\"b\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testMissingArgWithBursting() throws Exception {\n        final String[] args = { \"-acb\" };\n        boolean caught = false;\n        try {\n            parser.parse(options, args);\n        } catch (final MissingArgumentException e) {\n            caught = true;\n            assertEquals(\"b\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testMissingRequiredGroup() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.create(\"a\"));\n        group.addOption(OptionBuilder.create(\"b\"));\n        group.setRequired(true);\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n        options.addOption(OptionBuilder.isRequired().create(\"c\"));\n\n        try {\n            parser.parse(options, new String[] { \"-c\" });\n            fail(\"MissingOptionException not thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(1, e.getMissingOptions().size());\n            assertTrue(e.getMissingOptions().get(0) instanceof OptionGroup);\n        } catch (final ParseException e) {\n            fail(\"Expected to catch MissingOptionException\");\n        }\n    }\n\n    @Test\n    public void testMissingRequiredOption() {\n        final String[] args = { \"-a\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n\n        try {\n            parser.parse(options, args);\n            fail(\"exception should have been thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required option: b\", e.getMessage(), \"Incorrect exception message\");\n            assertTrue(e.getMissingOptions().contains(\"b\"));\n        } catch (final ParseException e) {\n            fail(\"expected to catch MissingOptionException\");\n        }\n    }\n\n    @Test\n    public void testMissingRequiredOptions() {\n        final String[] args = { \"-a\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n        options.addOption(OptionBuilder.withLongOpt(\"cfile\").hasArg().isRequired().create('c'));\n\n        try {\n            parser.parse(options, args);\n            fail(\"exception should have been thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required options: b, c\", e.getMessage(), \"Incorrect exception message\");\n            assertTrue(e.getMissingOptions().contains(\"b\"));\n            assertTrue(e.getMissingOptions().contains(\"c\"));\n        } catch (final ParseException e) {\n            fail(\"expected to catch MissingOptionException\");\n        }\n    }\n\n    @Test\n    public void testMultiple() throws Exception {\n        final String[] args = { \"-c\", \"foobar\", \"-b\", \"toast\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testMultipleWithLong() throws Exception {\n        final String[] args = { \"--copt\", \"foobar\", \"--bfile\", \"toast\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testMultipleWithNull() throws Exception {\n        final String[] args = { null, \"-c\", null, \"foobar\", null, \"-b\", null, \"toast\", null };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testNegativeArgument() throws Exception {\n        final String[] args = { \"-b\", \"-1\" };\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-1\", cl.getOptionValue(\"b\"));\n    }\n\n    @Test\n    public void testNegativeOption() throws Exception {\n        final String[] args = { \"-b\", \"-1\" };\n\n        options.addOption(\"1\", false, null);\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-1\", cl.getOptionValue(\"b\"));\n    }\n\n    @Test\n    public void testOptionalArgsOptionBuilder() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        final Properties properties = new Properties();\n\n        CommandLine cmd = parse(parser, options, new String[] { \"-i\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertNull(cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\", \"rock\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n        assertArrayEquals(new String[] { \"rock\" }, cmd.getArgs());\n    }\n\n    @Test\n    public void testOptionalArgsOptionDotBuilder() throws Exception {\n        final Options options = new Options();\n        options.addOption(Option.builder(\"i\").numberOfArgs(2).optionalArg(true).build());\n        final Properties properties = new Properties();\n\n        CommandLine cmd = parse(parser, options, new String[] { \"-i\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertNull(cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\", \"rock\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n        assertArrayEquals(new String[] { \"rock\" }, cmd.getArgs());\n\n        options.addOption(Option.builder(\"j\").numberOfArgs(3).optionalArg(true).build());\n        cmd = parse(parser, options, new String[] { \"-j\" }, properties);\n    }\n\n    @Test\n    public void testOptionAndRequiredOption() throws Exception {\n        final String[] args = { \"-a\", \"-b\", \"file\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"file\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO of extra args\");\n    }\n\n    @Test\n    public void testOptionGroup() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        assertFalse(group.isSelected());\n        group.addOption(OptionBuilder.create(\"a\"));\n        group.addOption(OptionBuilder.create(\"b\"));\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        parser.parse(options, new String[] { \"-b\" });\n\n        assertTrue(group.isSelected());\n        assertEquals(\"b\", group.getSelected(), \"selected option\");\n    }\n\n    @Test\n    public void testOptionGroupLong() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.withLongOpt(\"foo\").create());\n        group.addOption(OptionBuilder.withLongOpt(\"bar\").create());\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final CommandLine cl = parser.parse(options, new String[] { \"--bar\" });\n\n        assertTrue(cl.hasOption(\"bar\"));\n        assertTrue(group.isSelected());\n        assertEquals(\"bar\", group.getSelected(), \"selected option\");\n    }\n\n    @Test\n    public void testPartialLongOptionSingleDash() throws Exception {\n        final String[] args = { \"-ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.hasArg().create('v'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n        assertFalse(cl.hasOption(\"v\"), \"Confirm -v is not set\");\n    }\n\n    @Test\n    public void testPropertiesOption1() throws Exception {\n        final String[] args = { \"-Jsource=1.5\", \"-J\", \"target\", \"1.5\", \"foo\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator().hasArgs(2).create('J'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        final List<String> values = Arrays.asList(cl.getOptionValues(\"J\"));\n        assertNotNull(values, \"null values\");\n        assertEquals(4, values.size(), \"number of values\");\n        assertEquals(\"source\", values.get(0), \"value 1\");\n        assertEquals(\"1.5\", values.get(1), \"value 2\");\n        assertEquals(\"target\", values.get(2), \"value 3\");\n        assertEquals(\"1.5\", values.get(3), \"value 4\");\n\n        final List<?> argsleft = cl.getArgList();\n        assertEquals(1, argsleft.size(), \"Should be 1 arg left\");\n        assertEquals(\"foo\", argsleft.get(0), \"Expecting foo\");\n    }\n\n    @Test\n    public void testPropertiesOption2() throws Exception {\n        final String[] args = { \"-Dparam1\", \"-Dparam2=value2\", \"-D\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator().hasOptionalArgs(2).create('D'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(\"D\");\n        assertNotNull(props, \"null properties\");\n        assertEquals(2, props.size(), \"number of properties in \" + props);\n        assertEquals(\"true\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n\n        final List<?> argsleft = cl.getArgList();\n        assertEquals(0, argsleft.size(), \"Should be no arg left\");\n    }\n\n    @Test\n    public void testPropertyOptionFlags() throws Exception {\n        final Options options = new Options();\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"c\", \"c\", false, \"toggle -c\");\n        options.addOption(OptionBuilder.hasOptionalArg().create('e'));\n\n        Properties properties = new Properties();\n        properties.setProperty(\"a\", \"true\");\n        properties.setProperty(\"c\", \"yes\");\n        properties.setProperty(\"e\", \"1\");\n\n        CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"a\"));\n        assertTrue(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"false\");\n        properties.setProperty(\"c\", \"no\");\n        properties.setProperty(\"e\", \"0\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\")); // this option accepts an argument\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"TRUE\");\n        properties.setProperty(\"c\", \"nO\");\n        properties.setProperty(\"e\", \"TrUe\");\n\n        cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"just a string\");\n        properties.setProperty(\"e\", \"\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"0\");\n        properties.setProperty(\"c\", \"1\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertTrue(cmd.hasOption(\"c\"));\n    }\n\n    @Test\n    public void testPropertyOptionGroup() throws Exception {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(\"a\", null));\n        group1.addOption(new Option(\"b\", null));\n        options.addOptionGroup(group1);\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"x\", null));\n        group2.addOption(new Option(\"y\", null));\n        options.addOptionGroup(group2);\n\n        final String[] args = { \"-a\" };\n\n        final Properties properties = new Properties();\n        properties.put(\"b\", \"true\");\n        properties.put(\"x\", \"true\");\n\n        final CommandLine cmd = parse(parser, options, args, properties);\n\n        assertTrue(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"b\"));\n        assertTrue(cmd.hasOption(\"x\"));\n        assertFalse(cmd.hasOption(\"y\"));\n    }\n\n    @Test\n    public void testPropertyOptionMultipleValues() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArgs().withValueSeparator(',').create('k'));\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"k\", \"one,two\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"k\"));\n        final String[] values = { \"one\", \"two\" };\n        assertArrayEquals(values, cmd.getOptionValues('k'));\n    }\n\n    @Test\n    public void testPropertyOptionRequired() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"f\", \"true\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"f\"));\n    }\n\n    @Test\n    public void testPropertyOptionSingularValue() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).withLongOpt(\"hide\").create());\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"hide\", \"seek\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"hide\"));\n        assertEquals(\"seek\", cmd.getOptionValue(\"hide\"));\n        assertFalse(cmd.hasOption(\"fake\"));\n    }\n\n    @Test\n    public void testPropertyOptionUnexpected() throws Exception {\n        final Options options = new Options();\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"f\", \"true\");\n\n        try {\n            parse(parser, options, null, properties);\n            fail(\"UnrecognizedOptionException expected\");\n        } catch (final UnrecognizedOptionException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testPropertyOverrideValues() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        options.addOption(OptionBuilder.hasOptionalArgs().create('j'));\n\n        final String[] args = { \"-j\", \"found\", \"-i\", \"ink\" };\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"j\", \"seek\");\n\n        final CommandLine cmd = parse(parser, options, args, properties);\n        assertTrue(cmd.hasOption(\"j\"));\n        assertEquals(\"found\", cmd.getOptionValue(\"j\"));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"i\"));\n        assertFalse(cmd.hasOption(\"fake\"));\n    }\n\n    @Test\n    public void testReuseOptionsTwice() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create('v'));\n        // first parsing\n        parser.parse(options, new String[] { \"-v\" });\n        try {\n            // second parsing, with the same Options instance and an invalid command line\n            parser.parse(options, new String[0]);\n            fail(\"MissingOptionException not thrown\");\n        } catch (final MissingOptionException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-b\\\"quoted string\\\"\" });\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b\\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testShortOptionQuoteHandling() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-b\", \"\\\"quoted string\\\"\" });\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testShortWithEqual() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, new String[] { \"-f=bar\" });\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testShortWithoutEqual() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, new String[] { \"-fbar\" });\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testShortWithUnexpectedArgument() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, new String[] { \"-f=bar\" });\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-f=bar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }\n\n    @Test\n    public void testSimpleLong() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"--enable-a\", \"--bfile\", \"toast\", \"foo\", \"bar\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(\"toast\", cl.getOptionValue(\"bfile\"), \"Confirm arg of --bfile\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }\n\n    @Test\n    public void testSimpleShort() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-a\", \"-b\", \"toast\", \"foo\", \"bar\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }\n\n    @Test\n    public void testSingleDash() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"--copt\", \"-b\", \"-\", \"-a\", \"-\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"-\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm 1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"-\", cl.getArgList().get(0), \"Confirm value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testStopAtExpectedArg() throws Exception {\n        final String[] args = { \"-b\", \"foo\" };\n        final CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption('b'), \"Confirm -b is set\");\n        assertEquals(\"foo\", cl.getOptionValue('b'), \"Confirm -b is set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopAtNonOptionLong() throws Exception {\n        final String[] args = { \"--zop==1\", \"-abtoast\", \"--b=bar\" };\n        final CommandLine cl = parser.parse(options, args, true);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is not set\");\n        assertFalse(cl.hasOption(\"b\"), \"Confirm -b is not set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopAtNonOptionShort() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-z\", \"-a\", \"-btoast\" }, true);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is not set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopAtUnexpectedArg() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-c\", \"foober\", \"-b\", \"toast\" }, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopBursting() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-azc\" }, true);\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertTrue(cl.getArgList().contains(\"zc\"));\n    }\n\n    @Test\n    public void testStopBursting2() throws Exception {\n        CommandLine cl = parser.parse(options, new String[] { \"-c\", \"foobar\", \"-btoast\" }, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm  2 extra args: \" + cl.getArgList().size());\n        cl = parser.parse(options, cl.getArgs());\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption1() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"--ver\" });\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption2() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"-ver\" });\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption3() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"--ver=1\" });\n        assertTrue(cl.hasOption(\"verbose\"), \"Confirm --verbose is set\");\n        assertEquals(\"1\", cl.getOptionValue(\"verbose\"));\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption4() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"-ver=1\" });\n        assertTrue(cl.hasOption(\"verbose\"), \"Confirm --verbose is set\");\n        assertEquals(\"1\", cl.getOptionValue(\"verbose\"));\n    }\n\n    @Test\n    public void testUnlimitedArgs() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArgs().create(\"e\"));\n        options.addOption(OptionBuilder.hasArgs().create(\"f\"));\n        final CommandLine cl = parser.parse(options, new String[] { \"-e\", \"one\", \"two\", \"-f\", \"alpha\" });\n        assertTrue(cl.hasOption(\"e\"), \"Confirm -e is set\");\n        assertEquals(2, cl.getOptionValues(\"e\").length, \"number of arg for -e\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertEquals(1, cl.getOptionValues(\"f\").length, \"number of arg for -f\");\n    }\n\n    @Test\n    public void testUnrecognizedOption() throws Exception {\n        try {\n            parser.parse(options, new String[] { \"-a\", \"-d\", \"-b\", \"toast\", \"foo\", \"bar\" });\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-d\", e.getOption());\n        }\n    }\n\n    @Test\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n        try {\n            parser.parse(options, new String[] { \"-adbtoast\", \"foo\", \"bar\" });\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-adbtoast\", e.getOption());\n        }\n    }\n\n    @Test\n    public void testWithRequiredOption() throws Exception {\n        final String[] args = { \"-b\", \"file\" };\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is NOT set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"file\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO of extra args\");\n    }\n}\n", "file_hash": "9883e07f8af2b32f92040d5a86ac3dc184c658bc97e936c12aa8e3c7a1272740", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertArrayEquals;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import static org.junit.jupiter.api.Assertions.fail;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Properties;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public abstract class AbstractParserTestCase {\n\n    protected CommandLineParser parser;\n\n    protected Options options;\n\n    @SuppressWarnings(\"deprecation\")\n    private CommandLine parse(final CommandLineParser parser, final Options options, final String[] args, final Properties properties) throws ParseException {\n        if (parser instanceof Parser) {\n            return ((Parser) parser).parse(options, args, properties);\n        }\n        if (parser instanceof DefaultParser) {\n            return ((DefaultParser) parser).parse(options, args, properties);\n        }\n        throw new UnsupportedOperationException(\"Default options not supported by this parser\");\n    }\n\n    @BeforeEach\n    public void setUp() {\n        //@formatter:off\n        options = new Options()\n            .addOption(\"a\", \"enable-a\", false, \"turn [a] on or off\")\n            .addOption(\"b\", \"bfile\", true, \"set the value of [b]\")\n            .addOption(\"c\", \"copt\", false, \"turn [c] on or off\");\n        //@formatter:on\n    }\n\n    public void testAmbiguousArgParsing() throws Exception {\n        final String[] args = { \"-=-\" };\n        final Options options = new Options();\n\n        assertThrows(UnrecognizedOptionException.class, () -> parser.parse(options, args));\n    }\n\n    @Test\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n        final String[] args = { \"-b\", \"-foobar\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasOptionalArg().create('f'));\n        options.addOption(OptionBuilder.withLongOpt(\"bar\").hasOptionalArg().create('b'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"b\"));\n        assertTrue(cl.hasOption(\"f\"));\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n        final String[] args = { \"-b\", \"-foobar\" };\n\n        final Options options = new Options();\n        options.addOption(Option.builder().longOpt(\"foo\").option(\"f\").optionalArg(true).build());\n        options.addOption(Option.builder().longOpt(\"bar\").option(\"b\").optionalArg(false).build());\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"b\"));\n        assertTrue(cl.hasOption(\"f\"));\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption1() throws Exception {\n        final String[] args = { \"--ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"--ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption2() throws Exception {\n        final String[] args = { \"-ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"-ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption3() throws Exception {\n        final String[] args = { \"--ver=1\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"--ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption4() throws Exception {\n        final String[] args = { \"-ver=1\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"-ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testArgumentStartingWithHyphen() throws Exception {\n        final String[] args = { \"-b\", \"-foo\" };\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-foo\", cl.getOptionValue(\"b\"));\n    }\n\n    @Test\n    public void testBursting() throws Exception {\n        final String[] args = { \"-acbtoast\", \"foo\", \"bar\" };\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }\n\n    @Test\n    public void testDoubleDash1() throws Exception {\n        final String[] args = { \"--copt\", \"--\", \"-b\", \"toast\" };\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertFalse(cl.hasOption(\"b\"), \"Confirm -b is not set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm 2 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testDoubleDash2() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArg().create('n'));\n        options.addOption(OptionBuilder.create('m'));\n\n        try {\n            parser.parse(options, new String[] { \"-n\", \"--\", \"-m\" });\n            fail(\"MissingArgumentException not thrown for option -n\");\n        } catch (final MissingArgumentException e) {\n            assertNotNull(e.getOption(), \"option null\");\n            assertEquals(\"n\", e.getOption().getOpt());\n        }\n    }\n\n    @Test\n    public void testLongOptionQuoteHandling() throws Exception {\n        final String[] args = { \"--bfile\", \"\\\"quoted string\\\"\" };\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n        final String[] args = { \"--bfile=\\\"quoted string\\\"\" };\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testLongWithEqualDoubleDash() throws Exception {\n        final String[] args = { \"--foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testLongWithEqualSingleDash() throws Exception {\n        final String[] args = { \"-foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testLongWithoutEqualDoubleDash() throws Exception {\n        final String[] args = { \"--foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args, true);\n        assertFalse(cl.hasOption(\"foo\")); // foo isn't expected to be recognized with a double dash\n    }\n\n    @Test\n    public void testLongWithoutEqualSingleDash() throws Exception {\n        final String[] args = { \"-foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testLongWithUnexpectedArgument1() throws Exception {\n        final String[] args = { \"--foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, args);\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"--foo=bar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }\n\n    @Test\n    public void testLongWithUnexpectedArgument2() throws Exception {\n        final String[] args = { \"-foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, args);\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-foobar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }\n\n    @Test\n    public void testMissingArg() throws Exception {\n        final String[] args = { \"-b\" };\n        boolean caught = false;\n        try {\n            parser.parse(options, args);\n        } catch (final MissingArgumentException e) {\n            caught = true;\n            assertEquals(\"b\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testMissingArgWithBursting() throws Exception {\n        final String[] args = { \"-acb\" };\n        boolean caught = false;\n        try {\n            parser.parse(options, args);\n        } catch (final MissingArgumentException e) {\n            caught = true;\n            assertEquals(\"b\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testMissingRequiredGroup() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.create(\"a\"));\n        group.addOption(OptionBuilder.create(\"b\"));\n        group.setRequired(true);\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n        options.addOption(OptionBuilder.isRequired().create(\"c\"));\n\n        try {\n            parser.parse(options, new String[] { \"-c\" });\n            fail(\"MissingOptionException not thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(1, e.getMissingOptions().size());\n            assertTrue(e.getMissingOptions().get(0) instanceof OptionGroup);\n        } catch (final ParseException e) {\n            fail(\"Expected to catch MissingOptionException\");\n        }\n    }\n\n    @Test\n    public void testMissingRequiredOption() {\n        final String[] args = { \"-a\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n\n        try {\n            parser.parse(options, args);\n            fail(\"exception should have been thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required option: b\", e.getMessage(), \"Incorrect exception message\");\n            assertTrue(e.getMissingOptions().contains(\"b\"));\n        } catch (final ParseException e) {\n            fail(\"expected to catch MissingOptionException\");\n        }\n    }\n\n    @Test\n    public void testMissingRequiredOptions() {\n        final String[] args = { \"-a\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n        options.addOption(OptionBuilder.withLongOpt(\"cfile\").hasArg().isRequired().create('c'));\n\n        try {\n            parser.parse(options, args);\n            fail(\"exception should have been thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required options: b, c\", e.getMessage(), \"Incorrect exception message\");\n            assertTrue(e.getMissingOptions().contains(\"b\"));\n            assertTrue(e.getMissingOptions().contains(\"c\"));\n        } catch (final ParseException e) {\n            fail(\"expected to catch MissingOptionException\");\n        }\n    }\n\n    @Test\n    public void testMultiple() throws Exception {\n        final String[] args = { \"-c\", \"foobar\", \"-b\", \"toast\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testMultipleWithLong() throws Exception {\n        final String[] args = { \"--copt\", \"foobar\", \"--bfile\", \"toast\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testMultipleWithNull() throws Exception {\n        final String[] args = { null, \"-c\", null, \"foobar\", null, \"-b\", null, \"toast\", null };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testNegativeArgument() throws Exception {\n        final String[] args = { \"-b\", \"-1\" };\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-1\", cl.getOptionValue(\"b\"));\n    }\n\n    @Test\n    public void testNegativeOption() throws Exception {\n        final String[] args = { \"-b\", \"-1\" };\n\n        options.addOption(\"1\", false, null);\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-1\", cl.getOptionValue(\"b\"));\n    }\n\n    @Test\n    public void testOptionalArgsOptionBuilder() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        final Properties properties = new Properties();\n\n        CommandLine cmd = parse(parser, options, new String[] { \"-i\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertNull(cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\", \"rock\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n        assertArrayEquals(new String[] { \"rock\" }, cmd.getArgs());\n    }\n\n    @Test\n    public void testOptionalArgsOptionDotBuilder() throws Exception {\n        final Options options = new Options();\n        options.addOption(Option.builder(\"i\").numberOfArgs(2).optionalArg(true).build());\n        final Properties properties = new Properties();\n\n        CommandLine cmd = parse(parser, options, new String[] { \"-i\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertNull(cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\", \"rock\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n        assertArrayEquals(new String[] { \"rock\" }, cmd.getArgs());\n\n        options.addOption(Option.builder(\"j\").numberOfArgs(3).optionalArg(true).build());\n        cmd = parse(parser, options, new String[] { \"-j\" }, properties);\n    }\n\n    @Test\n    public void testOptionAndRequiredOption() throws Exception {\n        final String[] args = { \"-a\", \"-b\", \"file\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"file\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO of extra args\");\n    }\n\n    @Test\n    public void testOptionGroup() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        assertFalse(group.isSelected());\n        group.addOption(OptionBuilder.create(\"a\"));\n        group.addOption(OptionBuilder.create(\"b\"));\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        parser.parse(options, new String[] { \"-b\" });\n\n        assertTrue(group.isSelected());\n        assertEquals(\"b\", group.getSelected(), \"selected option\");\n    }\n\n    @Test\n    public void testOptionGroupLong() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.withLongOpt(\"foo\").create());\n        group.addOption(OptionBuilder.withLongOpt(\"bar\").create());\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final CommandLine cl = parser.parse(options, new String[] { \"--bar\" });\n\n        assertTrue(cl.hasOption(\"bar\"));\n        assertTrue(group.isSelected());\n        assertEquals(\"bar\", group.getSelected(), \"selected option\");\n    }\n\n    @Test\n    public void testPartialLongOptionSingleDash() throws Exception {\n        final String[] args = { \"-ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.hasArg().create('v'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n        assertFalse(cl.hasOption(\"v\"), \"Confirm -v is not set\");\n    }\n\n    @Test\n    public void testPropertiesOption1() throws Exception {\n        final String[] args = { \"-Jsource=1.5\", \"-J\", \"target\", \"1.5\", \"foo\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator().hasArgs(2).create('J'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        final List<String> values = Arrays.asList(cl.getOptionValues(\"J\"));\n        assertNotNull(values, \"null values\");\n        assertEquals(4, values.size(), \"number of values\");\n        assertEquals(\"source\", values.get(0), \"value 1\");\n        assertEquals(\"1.5\", values.get(1), \"value 2\");\n        assertEquals(\"target\", values.get(2), \"value 3\");\n        assertEquals(\"1.5\", values.get(3), \"value 4\");\n\n        final List<?> argsleft = cl.getArgList();\n        assertEquals(1, argsleft.size(), \"Should be 1 arg left\");\n        assertEquals(\"foo\", argsleft.get(0), \"Expecting foo\");\n    }\n\n    @Test\n    public void testPropertiesOption2() throws Exception {\n        final String[] args = { \"-Dparam1\", \"-Dparam2=value2\", \"-D\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator().hasOptionalArgs(2).create('D'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(\"D\");\n        assertNotNull(props, \"null properties\");\n        assertEquals(2, props.size(), \"number of properties in \" + props);\n        assertEquals(\"true\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n\n        final List<?> argsleft = cl.getArgList();\n        assertEquals(0, argsleft.size(), \"Should be no arg left\");\n    }\n\n    @Test\n    public void testPropertyOptionFlags() throws Exception {\n        final Options options = new Options();\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"c\", \"c\", false, \"toggle -c\");\n        options.addOption(OptionBuilder.hasOptionalArg().create('e'));\n\n        Properties properties = new Properties();\n        properties.setProperty(\"a\", \"true\");\n        properties.setProperty(\"c\", \"yes\");\n        properties.setProperty(\"e\", \"1\");\n\n        CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"a\"));\n        assertTrue(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"false\");\n        properties.setProperty(\"c\", \"no\");\n        properties.setProperty(\"e\", \"0\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\")); // this option accepts an argument\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"TRUE\");\n        properties.setProperty(\"c\", \"nO\");\n        properties.setProperty(\"e\", \"TrUe\");\n\n        cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"just a string\");\n        properties.setProperty(\"e\", \"\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"0\");\n        properties.setProperty(\"c\", \"1\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertTrue(cmd.hasOption(\"c\"));\n    }\n\n    @Test\n    public void testPropertyOptionGroup() throws Exception {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(\"a\", null));\n        group1.addOption(new Option(\"b\", null));\n        options.addOptionGroup(group1);\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"x\", null));\n        group2.addOption(new Option(\"y\", null));\n        options.addOptionGroup(group2);\n\n        final String[] args = { \"-a\" };\n\n        final Properties properties = new Properties();\n        properties.put(\"b\", \"true\");\n        properties.put(\"x\", \"true\");\n\n        final CommandLine cmd = parse(parser, options, args, properties);\n\n        assertTrue(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"b\"));\n        assertTrue(cmd.hasOption(\"x\"));\n        assertFalse(cmd.hasOption(\"y\"));\n    }\n\n    @Test\n    public void testPropertyOptionMultipleValues() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArgs().withValueSeparator(',').create('k'));\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"k\", \"one,two\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"k\"));\n        final String[] values = { \"one\", \"two\" };\n        assertArrayEquals(values, cmd.getOptionValues('k'));\n    }\n\n    @Test\n    public void testPropertyOptionRequired() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"f\", \"true\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"f\"));\n    }\n\n    @Test\n    public void testPropertyOptionSingularValue() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).withLongOpt(\"hide\").create());\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"hide\", \"seek\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"hide\"));\n        assertEquals(\"seek\", cmd.getOptionValue(\"hide\"));\n        assertFalse(cmd.hasOption(\"fake\"));\n    }\n\n    @Test\n    public void testPropertyOptionUnexpected() throws Exception {\n        final Options options = new Options();\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"f\", \"true\");\n\n        try {\n            parse(parser, options, null, properties);\n            fail(\"UnrecognizedOptionException expected\");\n        } catch (final UnrecognizedOptionException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testPropertyOverrideValues() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        options.addOption(OptionBuilder.hasOptionalArgs().create('j'));\n\n        final String[] args = { \"-j\", \"found\", \"-i\", \"ink\" };\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"j\", \"seek\");\n\n        final CommandLine cmd = parse(parser, options, args, properties);\n        assertTrue(cmd.hasOption(\"j\"));\n        assertEquals(\"found\", cmd.getOptionValue(\"j\"));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"i\"));\n        assertFalse(cmd.hasOption(\"fake\"));\n    }\n\n    @Test\n    public void testReuseOptionsTwice() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create('v'));\n        // first parsing\n        parser.parse(options, new String[] { \"-v\" });\n        try {\n            // second parsing, with the same Options instance and an invalid command line\n            parser.parse(options, new String[0]);\n            fail(\"MissingOptionException not thrown\");\n        } catch (final MissingOptionException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-b\\\"quoted string\\\"\" });\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b\\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testShortOptionQuoteHandling() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-b\", \"\\\"quoted string\\\"\" });\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testShortWithEqual() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, new String[] { \"-f=bar\" });\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testShortWithoutEqual() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, new String[] { \"-fbar\" });\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testShortWithUnexpectedArgument() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, new String[] { \"-f=bar\" });\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-f=bar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }\n\n    @Test\n    public void testSimpleLong() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"--enable-a\", \"--bfile\", \"toast\", \"foo\", \"bar\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(\"toast\", cl.getOptionValue(\"bfile\"), \"Confirm arg of --bfile\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }\n\n    @Test\n    public void testSimpleShort() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-a\", \"-b\", \"toast\", \"foo\", \"bar\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }\n\n    @Test\n    public void testSingleDash() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"--copt\", \"-b\", \"-\", \"-a\", \"-\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"-\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm 1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"-\", cl.getArgList().get(0), \"Confirm value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testStopAtExpectedArg() throws Exception {\n        final String[] args = { \"-b\", \"foo\" };\n        final CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption('b'), \"Confirm -b is set\");\n        assertEquals(\"foo\", cl.getOptionValue('b'), \"Confirm -b is set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopAtNonOptionLong() throws Exception {\n        final String[] args = { \"--zop==1\", \"-abtoast\", \"--b=bar\" };\n        final CommandLine cl = parser.parse(options, args, true);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is not set\");\n        assertFalse(cl.hasOption(\"b\"), \"Confirm -b is not set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopAtNonOptionShort() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-z\", \"-a\", \"-btoast\" }, true);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is not set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopAtUnexpectedArg() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-c\", \"foober\", \"-b\", \"toast\" }, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopBursting() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-azc\" }, true);\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertTrue(cl.getArgList().contains(\"zc\"));\n    }\n\n    @Test\n    public void testStopBursting2() throws Exception {\n        CommandLine cl = parser.parse(options, new String[] { \"-c\", \"foobar\", \"-btoast\" }, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm  2 extra args: \" + cl.getArgList().size());\n        cl = parser.parse(options, cl.getArgs());\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption1() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"--ver\" });\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption2() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"-ver\" });\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption3() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"--ver=1\" });\n        assertTrue(cl.hasOption(\"verbose\"), \"Confirm --verbose is set\");\n        assertEquals(\"1\", cl.getOptionValue(\"verbose\"));\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption4() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"-ver=1\" });\n        assertTrue(cl.hasOption(\"verbose\"), \"Confirm --verbose is set\");\n        assertEquals(\"1\", cl.getOptionValue(\"verbose\"));\n    }\n\n    @Test\n    public void testUnlimitedArgs() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArgs().create(\"e\"));\n        options.addOption(OptionBuilder.hasArgs().create(\"f\"));\n        final CommandLine cl = parser.parse(options, new String[] { \"-e\", \"one\", \"two\", \"-f\", \"alpha\" });\n        assertTrue(cl.hasOption(\"e\"), \"Confirm -e is set\");\n        assertEquals(2, cl.getOptionValues(\"e\").length, \"number of arg for -e\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertEquals(1, cl.getOptionValues(\"f\").length, \"number of arg for -f\");\n    }\n\n    @Test\n    public void testUnrecognizedOption() throws Exception {\n        try {\n            parser.parse(options, new String[] { \"-a\", \"-d\", \"-b\", \"toast\", \"foo\", \"bar\" });\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-d\", e.getOption());\n        }\n    }\n\n    @Test\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n        try {\n            parser.parse(options, new String[] { \"-adbtoast\", \"foo\", \"bar\" });\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-adbtoast\", e.getOption());\n        }\n    }\n\n    @Test\n    public void testWithRequiredOption() throws Exception {\n        final String[] args = { \"-b\", \"file\" };\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is NOT set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"file\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO of extra args\");\n    }\n}", "definition": "public abstract class AbstractParserTestCase", "class_docstring": "\nAbstract test case testing common parser features.\n\nTODO Needs a rework using JUnit parameterized tests.\n", "name": "AbstractParserTestCase", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "fields": [{"attribute_expression": "protected CommandLineParser parser;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "CommandLineParser", "name": "parser", "syntax_pass": true}, {"attribute_expression": "protected Options options;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @SuppressWarnings(\"deprecation\")\n    private CommandLine parse(final CommandLineParser parser, final Options options, final String[] args, final Properties properties) throws ParseException {\n        if (parser instanceof Parser) {\n            return ((Parser) parser).parse(options, args, properties);\n        }\n        if (parser instanceof DefaultParser) {\n            return ((DefaultParser) parser).parse(options, args, properties);\n        }\n        throw new UnsupportedOperationException(\"Default options not supported by this parser\");\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\")\n    private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "private"], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "parse", "params": [{"name": "parser", "type": "CommandLineParser"}, {"name": "options", "type": "Options"}, {"name": "args", "type": "String[]"}, {"name": "properties", "type": "Properties"}], "body": "                                                                                                                                                             {\n        if (parser instanceof Parser) {\n            return ((Parser) parser).parse(options, args, properties);\n        }\n        if (parser instanceof DefaultParser) {\n            return ((DefaultParser) parser).parse(options, args, properties);\n        }\n        throw new UnsupportedOperationException(\"Default options not supported by this parser\");\n    }", "signature": "@SuppressWarnings(\"deprecation\")\n    private CommandLine parse(final CommandLineParser parser, final Options options, final String[] args, final Properties properties)"}, {"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        //@formatter:off\n        options = new Options()\n            .addOption(\"a\", \"enable-a\", false, \"turn [a] on or off\")\n            .addOption(\"b\", \"bfile\", true, \"set the value of [b]\")\n            .addOption(\"c\", \"copt\", false, \"turn [c] on or off\");\n        //@formatter:on\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        //@formatter:off\n        options = new Options()\n            .addOption(\"a\", \"enable-a\", false, \"turn [a] on or off\")\n            .addOption(\"b\", \"bfile\", true, \"set the value of [b]\")\n            .addOption(\"c\", \"copt\", false, \"turn [c] on or off\");\n        //@formatter:on\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    public void testAmbiguousArgParsing() throws Exception {\n        final String[] args = { \"-=-\" };\n        final Options options = new Options();\n\n        assertThrows(UnrecognizedOptionException.class, () -> parser.parse(options, args));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousArgParsing", "params": [], "body": "                                                           {\n        final String[] args = { \"-=-\" };\n        final Options options = new Options();\n\n        assertThrows(UnrecognizedOptionException.class, () -> parser.parse(options, args));\n    }", "signature": "public void testAmbiguousArgParsing()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n        final String[] args = { \"-b\", \"-foobar\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasOptionalArg().create('f'));\n        options.addOption(OptionBuilder.withLongOpt(\"bar\").hasOptionalArg().create('b'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"b\"));\n        assertTrue(cl.hasOption(\"f\"));\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousLongWithoutEqualSingleDash", "params": [], "body": "                                                                           {\n        final String[] args = { \"-b\", \"-foobar\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasOptionalArg().create('f'));\n        options.addOption(OptionBuilder.withLongOpt(\"bar\").hasOptionalArg().create('b'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"b\"));\n        assertTrue(cl.hasOption(\"f\"));\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "signature": "@Test\n    public void testAmbiguousLongWithoutEqualSingleDash()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n        final String[] args = { \"-b\", \"-foobar\" };\n\n        final Options options = new Options();\n        options.addOption(Option.builder().longOpt(\"foo\").option(\"f\").optionalArg(true).build());\n        options.addOption(Option.builder().longOpt(\"bar\").option(\"b\").optionalArg(false).build());\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"b\"));\n        assertTrue(cl.hasOption(\"f\"));\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousLongWithoutEqualSingleDash2", "params": [], "body": "                                                                            {\n        final String[] args = { \"-b\", \"-foobar\" };\n\n        final Options options = new Options();\n        options.addOption(Option.builder().longOpt(\"foo\").option(\"f\").optionalArg(true).build());\n        options.addOption(Option.builder().longOpt(\"bar\").option(\"b\").optionalArg(false).build());\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"b\"));\n        assertTrue(cl.hasOption(\"f\"));\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "signature": "@Test\n    public void testAmbiguousLongWithoutEqualSingleDash2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAmbiguousPartialLongOption1() throws Exception {\n        final String[] args = { \"--ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"--ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption1", "params": [], "body": "                                                                   {\n        final String[] args = { \"--ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"--ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "signature": "@Test\n    public void testAmbiguousPartialLongOption1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAmbiguousPartialLongOption2() throws Exception {\n        final String[] args = { \"-ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"-ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption2", "params": [], "body": "                                                                   {\n        final String[] args = { \"-ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"-ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "signature": "@Test\n    public void testAmbiguousPartialLongOption2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAmbiguousPartialLongOption3() throws Exception {\n        final String[] args = { \"--ver=1\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"--ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption3", "params": [], "body": "                                                                   {\n        final String[] args = { \"--ver=1\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"--ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "signature": "@Test\n    public void testAmbiguousPartialLongOption3()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAmbiguousPartialLongOption4() throws Exception {\n        final String[] args = { \"-ver=1\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"-ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiguousPartialLongOption4", "params": [], "body": "                                                                   {\n        final String[] args = { \"-ver=1\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"-ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "signature": "@Test\n    public void testAmbiguousPartialLongOption4()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testArgumentStartingWithHyphen() throws Exception {\n        final String[] args = { \"-b\", \"-foo\" };\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-foo\", cl.getOptionValue(\"b\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testArgumentStartingWithHyphen", "params": [], "body": "                                                                  {\n        final String[] args = { \"-b\", \"-foo\" };\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-foo\", cl.getOptionValue(\"b\"));\n    }", "signature": "@Test\n    public void testArgumentStartingWithHyphen()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBursting() throws Exception {\n        final String[] args = { \"-acbtoast\", \"foo\", \"bar\" };\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBursting", "params": [], "body": "                                                {\n        final String[] args = { \"-acbtoast\", \"foo\", \"bar\" };\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }", "signature": "@Test\n    public void testBursting()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDoubleDash1() throws Exception {\n        final String[] args = { \"--copt\", \"--\", \"-b\", \"toast\" };\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertFalse(cl.hasOption(\"b\"), \"Confirm -b is not set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm 2 extra args: \" + cl.getArgList().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoubleDash1", "params": [], "body": "                                                   {\n        final String[] args = { \"--copt\", \"--\", \"-b\", \"toast\" };\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertFalse(cl.hasOption(\"b\"), \"Confirm -b is not set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm 2 extra args: \" + cl.getArgList().size());\n    }", "signature": "@Test\n    public void testDoubleDash1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testDoubleDash2() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArg().create('n'));\n        options.addOption(OptionBuilder.create('m'));\n\n        try {\n            parser.parse(options, new String[] { \"-n\", \"--\", \"-m\" });\n            fail(\"MissingArgumentException not thrown for option -n\");\n        } catch (final MissingArgumentException e) {\n            assertNotNull(e.getOption(), \"option null\");\n            assertEquals(\"n\", e.getOption().getOpt());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDoubleDash2", "params": [], "body": "                                                   {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArg().create('n'));\n        options.addOption(OptionBuilder.create('m'));\n\n        try {\n            parser.parse(options, new String[] { \"-n\", \"--\", \"-m\" });\n            fail(\"MissingArgumentException not thrown for option -n\");\n        } catch (final MissingArgumentException e) {\n            assertNotNull(e.getOption(), \"option null\");\n            assertEquals(\"n\", e.getOption().getOpt());\n        }\n    }", "signature": "@Test\n    public void testDoubleDash2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongOptionQuoteHandling() throws Exception {\n        final String[] args = { \"--bfile\", \"\\\"quoted string\\\"\" };\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" strips quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionQuoteHandling", "params": [], "body": "                                                               {\n        final String[] args = { \"--bfile\", \"\\\"quoted string\\\"\" };\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" strips quotes\");\n    }", "signature": "@Test\n    public void testLongOptionQuoteHandling()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n        final String[] args = { \"--bfile=\\\"quoted string\\\"\" };\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongOptionWithEqualsQuoteHandling", "params": [], "body": "                                                                         {\n        final String[] args = { \"--bfile=\\\"quoted string\\\"\" };\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }", "signature": "@Test\n    public void testLongOptionWithEqualsQuoteHandling()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongWithEqualDoubleDash() throws Exception {\n        final String[] args = { \"--foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithEqualDoubleDash", "params": [], "body": "                                                               {\n        final String[] args = { \"--foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "signature": "@Test\n    public void testLongWithEqualDoubleDash()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongWithEqualSingleDash() throws Exception {\n        final String[] args = { \"-foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithEqualSingleDash", "params": [], "body": "                                                               {\n        final String[] args = { \"-foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "signature": "@Test\n    public void testLongWithEqualSingleDash()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongWithoutEqualDoubleDash() throws Exception {\n        final String[] args = { \"--foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args, true);\n        assertFalse(cl.hasOption(\"foo\")); // foo isn't expected to be recognized with a double dash\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithoutEqualDoubleDash", "params": [], "body": "                                                                  {\n        final String[] args = { \"--foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args, true);\n        assertFalse(cl.hasOption(\"foo\")); // foo isn't expected to be recognized with a double dash\n    }", "signature": "@Test\n    public void testLongWithoutEqualDoubleDash()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongWithoutEqualSingleDash() throws Exception {\n        final String[] args = { \"-foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithoutEqualSingleDash", "params": [], "body": "                                                                  {\n        final String[] args = { \"-foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "signature": "@Test\n    public void testLongWithoutEqualSingleDash()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongWithUnexpectedArgument1() throws Exception {\n        final String[] args = { \"--foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, args);\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"--foo=bar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithUnexpectedArgument1", "params": [], "body": "                                                                   {\n        final String[] args = { \"--foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, args);\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"--foo=bar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }", "signature": "@Test\n    public void testLongWithUnexpectedArgument1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongWithUnexpectedArgument2() throws Exception {\n        final String[] args = { \"-foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, args);\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-foobar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongWithUnexpectedArgument2", "params": [], "body": "                                                                   {\n        final String[] args = { \"-foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, args);\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-foobar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }", "signature": "@Test\n    public void testLongWithUnexpectedArgument2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMissingArg() throws Exception {\n        final String[] args = { \"-b\" };\n        boolean caught = false;\n        try {\n            parser.parse(options, args);\n        } catch (final MissingArgumentException e) {\n            caught = true;\n            assertEquals(\"b\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMissingArg", "params": [], "body": "                                                  {\n        final String[] args = { \"-b\" };\n        boolean caught = false;\n        try {\n            parser.parse(options, args);\n        } catch (final MissingArgumentException e) {\n            caught = true;\n            assertEquals(\"b\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "signature": "@Test\n    public void testMissingArg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMissingArgWithBursting() throws Exception {\n        final String[] args = { \"-acb\" };\n        boolean caught = false;\n        try {\n            parser.parse(options, args);\n        } catch (final MissingArgumentException e) {\n            caught = true;\n            assertEquals(\"b\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMissingArgWithBursting", "params": [], "body": "                                                              {\n        final String[] args = { \"-acb\" };\n        boolean caught = false;\n        try {\n            parser.parse(options, args);\n        } catch (final MissingArgumentException e) {\n            caught = true;\n            assertEquals(\"b\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }", "signature": "@Test\n    public void testMissingArgWithBursting()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMissingRequiredGroup() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.create(\"a\"));\n        group.addOption(OptionBuilder.create(\"b\"));\n        group.setRequired(true);\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n        options.addOption(OptionBuilder.isRequired().create(\"c\"));\n\n        try {\n            parser.parse(options, new String[] { \"-c\" });\n            fail(\"MissingOptionException not thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(1, e.getMissingOptions().size());\n            assertTrue(e.getMissingOptions().get(0) instanceof OptionGroup);\n        } catch (final ParseException e) {\n            fail(\"Expected to catch MissingOptionException\");\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMissingRequiredGroup", "params": [], "body": "                                                            {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.create(\"a\"));\n        group.addOption(OptionBuilder.create(\"b\"));\n        group.setRequired(true);\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n        options.addOption(OptionBuilder.isRequired().create(\"c\"));\n\n        try {\n            parser.parse(options, new String[] { \"-c\" });\n            fail(\"MissingOptionException not thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(1, e.getMissingOptions().size());\n            assertTrue(e.getMissingOptions().get(0) instanceof OptionGroup);\n        } catch (final ParseException e) {\n            fail(\"Expected to catch MissingOptionException\");\n        }\n    }", "signature": "@Test\n    public void testMissingRequiredGroup()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMissingRequiredOption() {\n        final String[] args = { \"-a\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n\n        try {\n            parser.parse(options, args);\n            fail(\"exception should have been thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required option: b\", e.getMessage(), \"Incorrect exception message\");\n            assertTrue(e.getMissingOptions().contains(\"b\"));\n        } catch (final ParseException e) {\n            fail(\"expected to catch MissingOptionException\");\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMissingRequiredOption", "params": [], "body": "                                            {\n        final String[] args = { \"-a\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n\n        try {\n            parser.parse(options, args);\n            fail(\"exception should have been thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required option: b\", e.getMessage(), \"Incorrect exception message\");\n            assertTrue(e.getMissingOptions().contains(\"b\"));\n        } catch (final ParseException e) {\n            fail(\"expected to catch MissingOptionException\");\n        }\n    }", "signature": "@Test\n    public void testMissingRequiredOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMissingRequiredOptions() {\n        final String[] args = { \"-a\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n        options.addOption(OptionBuilder.withLongOpt(\"cfile\").hasArg().isRequired().create('c'));\n\n        try {\n            parser.parse(options, args);\n            fail(\"exception should have been thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required options: b, c\", e.getMessage(), \"Incorrect exception message\");\n            assertTrue(e.getMissingOptions().contains(\"b\"));\n            assertTrue(e.getMissingOptions().contains(\"c\"));\n        } catch (final ParseException e) {\n            fail(\"expected to catch MissingOptionException\");\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMissingRequiredOptions", "params": [], "body": "                                             {\n        final String[] args = { \"-a\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n        options.addOption(OptionBuilder.withLongOpt(\"cfile\").hasArg().isRequired().create('c'));\n\n        try {\n            parser.parse(options, args);\n            fail(\"exception should have been thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required options: b, c\", e.getMessage(), \"Incorrect exception message\");\n            assertTrue(e.getMissingOptions().contains(\"b\"));\n            assertTrue(e.getMissingOptions().contains(\"c\"));\n        } catch (final ParseException e) {\n            fail(\"expected to catch MissingOptionException\");\n        }\n    }", "signature": "@Test\n    public void testMissingRequiredOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMultiple() throws Exception {\n        final String[] args = { \"-c\", \"foobar\", \"-b\", \"toast\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMultiple", "params": [], "body": "                                                {\n        final String[] args = { \"-c\", \"foobar\", \"-b\", \"toast\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }", "signature": "@Test\n    public void testMultiple()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMultipleWithLong() throws Exception {\n        final String[] args = { \"--copt\", \"foobar\", \"--bfile\", \"toast\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMultipleWithLong", "params": [], "body": "                                                        {\n        final String[] args = { \"--copt\", \"foobar\", \"--bfile\", \"toast\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }", "signature": "@Test\n    public void testMultipleWithLong()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMultipleWithNull() throws Exception {\n        final String[] args = { null, \"-c\", null, \"foobar\", null, \"-b\", null, \"toast\", null };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMultipleWithNull", "params": [], "body": "                                                        {\n        final String[] args = { null, \"-c\", null, \"foobar\", null, \"-b\", null, \"toast\", null };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }", "signature": "@Test\n    public void testMultipleWithNull()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNegativeArgument() throws Exception {\n        final String[] args = { \"-b\", \"-1\" };\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-1\", cl.getOptionValue(\"b\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNegativeArgument", "params": [], "body": "                                                        {\n        final String[] args = { \"-b\", \"-1\" };\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-1\", cl.getOptionValue(\"b\"));\n    }", "signature": "@Test\n    public void testNegativeArgument()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNegativeOption() throws Exception {\n        final String[] args = { \"-b\", \"-1\" };\n\n        options.addOption(\"1\", false, null);\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-1\", cl.getOptionValue(\"b\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNegativeOption", "params": [], "body": "                                                      {\n        final String[] args = { \"-b\", \"-1\" };\n\n        options.addOption(\"1\", false, null);\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-1\", cl.getOptionValue(\"b\"));\n    }", "signature": "@Test\n    public void testNegativeOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionalArgsOptionBuilder() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        final Properties properties = new Properties();\n\n        CommandLine cmd = parse(parser, options, new String[] { \"-i\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertNull(cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\", \"rock\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n        assertArrayEquals(new String[] { \"rock\" }, cmd.getArgs());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionalArgsOptionBuilder", "params": [], "body": "                                                                 {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        final Properties properties = new Properties();\n\n        CommandLine cmd = parse(parser, options, new String[] { \"-i\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertNull(cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\", \"rock\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n        assertArrayEquals(new String[] { \"rock\" }, cmd.getArgs());\n    }", "signature": "@Test\n    public void testOptionalArgsOptionBuilder()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionalArgsOptionDotBuilder() throws Exception {\n        final Options options = new Options();\n        options.addOption(Option.builder(\"i\").numberOfArgs(2).optionalArg(true).build());\n        final Properties properties = new Properties();\n\n        CommandLine cmd = parse(parser, options, new String[] { \"-i\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertNull(cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\", \"rock\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n        assertArrayEquals(new String[] { \"rock\" }, cmd.getArgs());\n\n        options.addOption(Option.builder(\"j\").numberOfArgs(3).optionalArg(true).build());\n        cmd = parse(parser, options, new String[] { \"-j\" }, properties);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionalArgsOptionDotBuilder", "params": [], "body": "                                                                    {\n        final Options options = new Options();\n        options.addOption(Option.builder(\"i\").numberOfArgs(2).optionalArg(true).build());\n        final Properties properties = new Properties();\n\n        CommandLine cmd = parse(parser, options, new String[] { \"-i\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertNull(cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\", \"rock\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n        assertArrayEquals(new String[] { \"rock\" }, cmd.getArgs());\n\n        options.addOption(Option.builder(\"j\").numberOfArgs(3).optionalArg(true).build());\n        cmd = parse(parser, options, new String[] { \"-j\" }, properties);\n    }", "signature": "@Test\n    public void testOptionalArgsOptionDotBuilder()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionAndRequiredOption() throws Exception {\n        final String[] args = { \"-a\", \"-b\", \"file\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"file\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO of extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionAndRequiredOption", "params": [], "body": "                                                               {\n        final String[] args = { \"-a\", \"-b\", \"file\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"file\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO of extra args\");\n    }", "signature": "@Test\n    public void testOptionAndRequiredOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionGroup() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        assertFalse(group.isSelected());\n        group.addOption(OptionBuilder.create(\"a\"));\n        group.addOption(OptionBuilder.create(\"b\"));\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        parser.parse(options, new String[] { \"-b\" });\n\n        assertTrue(group.isSelected());\n        assertEquals(\"b\", group.getSelected(), \"selected option\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionGroup", "params": [], "body": "                                                   {\n        final OptionGroup group = new OptionGroup();\n        assertFalse(group.isSelected());\n        group.addOption(OptionBuilder.create(\"a\"));\n        group.addOption(OptionBuilder.create(\"b\"));\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        parser.parse(options, new String[] { \"-b\" });\n\n        assertTrue(group.isSelected());\n        assertEquals(\"b\", group.getSelected(), \"selected option\");\n    }", "signature": "@Test\n    public void testOptionGroup()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionGroupLong() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.withLongOpt(\"foo\").create());\n        group.addOption(OptionBuilder.withLongOpt(\"bar\").create());\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final CommandLine cl = parser.parse(options, new String[] { \"--bar\" });\n\n        assertTrue(cl.hasOption(\"bar\"));\n        assertTrue(group.isSelected());\n        assertEquals(\"bar\", group.getSelected(), \"selected option\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionGroupLong", "params": [], "body": "                                                       {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.withLongOpt(\"foo\").create());\n        group.addOption(OptionBuilder.withLongOpt(\"bar\").create());\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final CommandLine cl = parser.parse(options, new String[] { \"--bar\" });\n\n        assertTrue(cl.hasOption(\"bar\"));\n        assertTrue(group.isSelected());\n        assertEquals(\"bar\", group.getSelected(), \"selected option\");\n    }", "signature": "@Test\n    public void testOptionGroupLong()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPartialLongOptionSingleDash() throws Exception {\n        final String[] args = { \"-ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.hasArg().create('v'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n        assertFalse(cl.hasOption(\"v\"), \"Confirm -v is not set\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPartialLongOptionSingleDash", "params": [], "body": "                                                                   {\n        final String[] args = { \"-ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.hasArg().create('v'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n        assertFalse(cl.hasOption(\"v\"), \"Confirm -v is not set\");\n    }", "signature": "@Test\n    public void testPartialLongOptionSingleDash()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPropertiesOption1() throws Exception {\n        final String[] args = { \"-Jsource=1.5\", \"-J\", \"target\", \"1.5\", \"foo\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator().hasArgs(2).create('J'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        final List<String> values = Arrays.asList(cl.getOptionValues(\"J\"));\n        assertNotNull(values, \"null values\");\n        assertEquals(4, values.size(), \"number of values\");\n        assertEquals(\"source\", values.get(0), \"value 1\");\n        assertEquals(\"1.5\", values.get(1), \"value 2\");\n        assertEquals(\"target\", values.get(2), \"value 3\");\n        assertEquals(\"1.5\", values.get(3), \"value 4\");\n\n        final List<?> argsleft = cl.getArgList();\n        assertEquals(1, argsleft.size(), \"Should be 1 arg left\");\n        assertEquals(\"foo\", argsleft.get(0), \"Expecting foo\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertiesOption1", "params": [], "body": "                                                         {\n        final String[] args = { \"-Jsource=1.5\", \"-J\", \"target\", \"1.5\", \"foo\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator().hasArgs(2).create('J'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        final List<String> values = Arrays.asList(cl.getOptionValues(\"J\"));\n        assertNotNull(values, \"null values\");\n        assertEquals(4, values.size(), \"number of values\");\n        assertEquals(\"source\", values.get(0), \"value 1\");\n        assertEquals(\"1.5\", values.get(1), \"value 2\");\n        assertEquals(\"target\", values.get(2), \"value 3\");\n        assertEquals(\"1.5\", values.get(3), \"value 4\");\n\n        final List<?> argsleft = cl.getArgList();\n        assertEquals(1, argsleft.size(), \"Should be 1 arg left\");\n        assertEquals(\"foo\", argsleft.get(0), \"Expecting foo\");\n    }", "signature": "@Test\n    public void testPropertiesOption1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPropertiesOption2() throws Exception {\n        final String[] args = { \"-Dparam1\", \"-Dparam2=value2\", \"-D\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator().hasOptionalArgs(2).create('D'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(\"D\");\n        assertNotNull(props, \"null properties\");\n        assertEquals(2, props.size(), \"number of properties in \" + props);\n        assertEquals(\"true\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n\n        final List<?> argsleft = cl.getArgList();\n        assertEquals(0, argsleft.size(), \"Should be no arg left\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertiesOption2", "params": [], "body": "                                                         {\n        final String[] args = { \"-Dparam1\", \"-Dparam2=value2\", \"-D\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator().hasOptionalArgs(2).create('D'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(\"D\");\n        assertNotNull(props, \"null properties\");\n        assertEquals(2, props.size(), \"number of properties in \" + props);\n        assertEquals(\"true\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n\n        final List<?> argsleft = cl.getArgList();\n        assertEquals(0, argsleft.size(), \"Should be no arg left\");\n    }", "signature": "@Test\n    public void testPropertiesOption2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPropertyOptionFlags() throws Exception {\n        final Options options = new Options();\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"c\", \"c\", false, \"toggle -c\");\n        options.addOption(OptionBuilder.hasOptionalArg().create('e'));\n\n        Properties properties = new Properties();\n        properties.setProperty(\"a\", \"true\");\n        properties.setProperty(\"c\", \"yes\");\n        properties.setProperty(\"e\", \"1\");\n\n        CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"a\"));\n        assertTrue(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"false\");\n        properties.setProperty(\"c\", \"no\");\n        properties.setProperty(\"e\", \"0\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\")); // this option accepts an argument\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"TRUE\");\n        properties.setProperty(\"c\", \"nO\");\n        properties.setProperty(\"e\", \"TrUe\");\n\n        cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"just a string\");\n        properties.setProperty(\"e\", \"\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"0\");\n        properties.setProperty(\"c\", \"1\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertTrue(cmd.hasOption(\"c\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertyOptionFlags", "params": [], "body": "                                                           {\n        final Options options = new Options();\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"c\", \"c\", false, \"toggle -c\");\n        options.addOption(OptionBuilder.hasOptionalArg().create('e'));\n\n        Properties properties = new Properties();\n        properties.setProperty(\"a\", \"true\");\n        properties.setProperty(\"c\", \"yes\");\n        properties.setProperty(\"e\", \"1\");\n\n        CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"a\"));\n        assertTrue(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"false\");\n        properties.setProperty(\"c\", \"no\");\n        properties.setProperty(\"e\", \"0\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\")); // this option accepts an argument\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"TRUE\");\n        properties.setProperty(\"c\", \"nO\");\n        properties.setProperty(\"e\", \"TrUe\");\n\n        cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"just a string\");\n        properties.setProperty(\"e\", \"\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"0\");\n        properties.setProperty(\"c\", \"1\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertTrue(cmd.hasOption(\"c\"));\n    }", "signature": "@Test\n    public void testPropertyOptionFlags()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPropertyOptionGroup() throws Exception {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(\"a\", null));\n        group1.addOption(new Option(\"b\", null));\n        options.addOptionGroup(group1);\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"x\", null));\n        group2.addOption(new Option(\"y\", null));\n        options.addOptionGroup(group2);\n\n        final String[] args = { \"-a\" };\n\n        final Properties properties = new Properties();\n        properties.put(\"b\", \"true\");\n        properties.put(\"x\", \"true\");\n\n        final CommandLine cmd = parse(parser, options, args, properties);\n\n        assertTrue(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"b\"));\n        assertTrue(cmd.hasOption(\"x\"));\n        assertFalse(cmd.hasOption(\"y\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertyOptionGroup", "params": [], "body": "                                                           {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(\"a\", null));\n        group1.addOption(new Option(\"b\", null));\n        options.addOptionGroup(group1);\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"x\", null));\n        group2.addOption(new Option(\"y\", null));\n        options.addOptionGroup(group2);\n\n        final String[] args = { \"-a\" };\n\n        final Properties properties = new Properties();\n        properties.put(\"b\", \"true\");\n        properties.put(\"x\", \"true\");\n\n        final CommandLine cmd = parse(parser, options, args, properties);\n\n        assertTrue(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"b\"));\n        assertTrue(cmd.hasOption(\"x\"));\n        assertFalse(cmd.hasOption(\"y\"));\n    }", "signature": "@Test\n    public void testPropertyOptionGroup()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPropertyOptionMultipleValues() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArgs().withValueSeparator(',').create('k'));\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"k\", \"one,two\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"k\"));\n        final String[] values = { \"one\", \"two\" };\n        assertArrayEquals(values, cmd.getOptionValues('k'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertyOptionMultipleValues", "params": [], "body": "                                                                    {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArgs().withValueSeparator(',').create('k'));\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"k\", \"one,two\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"k\"));\n        final String[] values = { \"one\", \"two\" };\n        assertArrayEquals(values, cmd.getOptionValues('k'));\n    }", "signature": "@Test\n    public void testPropertyOptionMultipleValues()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPropertyOptionRequired() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"f\", \"true\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"f\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertyOptionRequired", "params": [], "body": "                                                              {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"f\", \"true\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"f\"));\n    }", "signature": "@Test\n    public void testPropertyOptionRequired()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPropertyOptionSingularValue() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).withLongOpt(\"hide\").create());\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"hide\", \"seek\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"hide\"));\n        assertEquals(\"seek\", cmd.getOptionValue(\"hide\"));\n        assertFalse(cmd.hasOption(\"fake\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertyOptionSingularValue", "params": [], "body": "                                                                   {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).withLongOpt(\"hide\").create());\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"hide\", \"seek\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"hide\"));\n        assertEquals(\"seek\", cmd.getOptionValue(\"hide\"));\n        assertFalse(cmd.hasOption(\"fake\"));\n    }", "signature": "@Test\n    public void testPropertyOptionSingularValue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPropertyOptionUnexpected() throws Exception {\n        final Options options = new Options();\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"f\", \"true\");\n\n        try {\n            parse(parser, options, null, properties);\n            fail(\"UnrecognizedOptionException expected\");\n        } catch (final UnrecognizedOptionException e) {\n            // expected\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertyOptionUnexpected", "params": [], "body": "                                                                {\n        final Options options = new Options();\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"f\", \"true\");\n\n        try {\n            parse(parser, options, null, properties);\n            fail(\"UnrecognizedOptionException expected\");\n        } catch (final UnrecognizedOptionException e) {\n            // expected\n        }\n    }", "signature": "@Test\n    public void testPropertyOptionUnexpected()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPropertyOverrideValues() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        options.addOption(OptionBuilder.hasOptionalArgs().create('j'));\n\n        final String[] args = { \"-j\", \"found\", \"-i\", \"ink\" };\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"j\", \"seek\");\n\n        final CommandLine cmd = parse(parser, options, args, properties);\n        assertTrue(cmd.hasOption(\"j\"));\n        assertEquals(\"found\", cmd.getOptionValue(\"j\"));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"i\"));\n        assertFalse(cmd.hasOption(\"fake\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertyOverrideValues", "params": [], "body": "                                                              {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        options.addOption(OptionBuilder.hasOptionalArgs().create('j'));\n\n        final String[] args = { \"-j\", \"found\", \"-i\", \"ink\" };\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"j\", \"seek\");\n\n        final CommandLine cmd = parse(parser, options, args, properties);\n        assertTrue(cmd.hasOption(\"j\"));\n        assertEquals(\"found\", cmd.getOptionValue(\"j\"));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"i\"));\n        assertFalse(cmd.hasOption(\"fake\"));\n    }", "signature": "@Test\n    public void testPropertyOverrideValues()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testReuseOptionsTwice() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create('v'));\n        // first parsing\n        parser.parse(options, new String[] { \"-v\" });\n        try {\n            // second parsing, with the same Options instance and an invalid command line\n            parser.parse(options, new String[0]);\n            fail(\"MissingOptionException not thrown\");\n        } catch (final MissingOptionException e) {\n            // expected\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testReuseOptionsTwice", "params": [], "body": "                                                         {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create('v'));\n        // first parsing\n        parser.parse(options, new String[] { \"-v\" });\n        try {\n            // second parsing, with the same Options instance and an invalid command line\n            parser.parse(options, new String[0]);\n            fail(\"MissingOptionException not thrown\");\n        } catch (final MissingOptionException e) {\n            // expected\n        }\n    }", "signature": "@Test\n    public void testReuseOptionsTwice()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-b\\\"quoted string\\\"\" });\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b\\\"arg\\\" strips quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionConcatenatedQuoteHandling", "params": [], "body": "                                                                            {\n        final CommandLine cl = parser.parse(options, new String[] { \"-b\\\"quoted string\\\"\" });\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b\\\"arg\\\" strips quotes\");\n    }", "signature": "@Test\n    public void testShortOptionConcatenatedQuoteHandling()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortOptionQuoteHandling() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-b\", \"\\\"quoted string\\\"\" });\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" strips quotes\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortOptionQuoteHandling", "params": [], "body": "                                                                {\n        final CommandLine cl = parser.parse(options, new String[] { \"-b\", \"\\\"quoted string\\\"\" });\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" strips quotes\");\n    }", "signature": "@Test\n    public void testShortOptionQuoteHandling()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortWithEqual() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, new String[] { \"-f=bar\" });\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortWithEqual", "params": [], "body": "                                                      {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, new String[] { \"-f=bar\" });\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "signature": "@Test\n    public void testShortWithEqual()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortWithoutEqual() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, new String[] { \"-fbar\" });\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortWithoutEqual", "params": [], "body": "                                                         {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, new String[] { \"-fbar\" });\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }", "signature": "@Test\n    public void testShortWithoutEqual()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortWithUnexpectedArgument() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, new String[] { \"-f=bar\" });\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-f=bar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortWithUnexpectedArgument", "params": [], "body": "                                                                   {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, new String[] { \"-f=bar\" });\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-f=bar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }", "signature": "@Test\n    public void testShortWithUnexpectedArgument()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSimpleLong() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"--enable-a\", \"--bfile\", \"toast\", \"foo\", \"bar\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(\"toast\", cl.getOptionValue(\"bfile\"), \"Confirm arg of --bfile\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSimpleLong", "params": [], "body": "                                                  {\n        final CommandLine cl = parser.parse(options, new String[] { \"--enable-a\", \"--bfile\", \"toast\", \"foo\", \"bar\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(\"toast\", cl.getOptionValue(\"bfile\"), \"Confirm arg of --bfile\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }", "signature": "@Test\n    public void testSimpleLong()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSimpleShort() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-a\", \"-b\", \"toast\", \"foo\", \"bar\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSimpleShort", "params": [], "body": "                                                   {\n        final CommandLine cl = parser.parse(options, new String[] { \"-a\", \"-b\", \"toast\", \"foo\", \"bar\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }", "signature": "@Test\n    public void testSimpleShort()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSingleDash() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"--copt\", \"-b\", \"-\", \"-a\", \"-\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"-\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm 1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"-\", cl.getArgList().get(0), \"Confirm value of extra arg: \" + cl.getArgList().get(0));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSingleDash", "params": [], "body": "                                                  {\n        final CommandLine cl = parser.parse(options, new String[] { \"--copt\", \"-b\", \"-\", \"-a\", \"-\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"-\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm 1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"-\", cl.getArgList().get(0), \"Confirm value of extra arg: \" + cl.getArgList().get(0));\n    }", "signature": "@Test\n    public void testSingleDash()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStopAtExpectedArg() throws Exception {\n        final String[] args = { \"-b\", \"foo\" };\n        final CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption('b'), \"Confirm -b is set\");\n        assertEquals(\"foo\", cl.getOptionValue('b'), \"Confirm -b is set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args: \" + cl.getArgList().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStopAtExpectedArg", "params": [], "body": "                                                         {\n        final String[] args = { \"-b\", \"foo\" };\n        final CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption('b'), \"Confirm -b is set\");\n        assertEquals(\"foo\", cl.getOptionValue('b'), \"Confirm -b is set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args: \" + cl.getArgList().size());\n    }", "signature": "@Test\n    public void testStopAtExpectedArg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStopAtNonOptionLong() throws Exception {\n        final String[] args = { \"--zop==1\", \"-abtoast\", \"--b=bar\" };\n        final CommandLine cl = parser.parse(options, args, true);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is not set\");\n        assertFalse(cl.hasOption(\"b\"), \"Confirm -b is not set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStopAtNonOptionLong", "params": [], "body": "                                                           {\n        final String[] args = { \"--zop==1\", \"-abtoast\", \"--b=bar\" };\n        final CommandLine cl = parser.parse(options, args, true);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is not set\");\n        assertFalse(cl.hasOption(\"b\"), \"Confirm -b is not set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }", "signature": "@Test\n    public void testStopAtNonOptionLong()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStopAtNonOptionShort() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-z\", \"-a\", \"-btoast\" }, true);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is not set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStopAtNonOptionShort", "params": [], "body": "                                                            {\n        final CommandLine cl = parser.parse(options, new String[] { \"-z\", \"-a\", \"-btoast\" }, true);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is not set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }", "signature": "@Test\n    public void testStopAtNonOptionShort()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStopAtUnexpectedArg() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-c\", \"foober\", \"-b\", \"toast\" }, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStopAtUnexpectedArg", "params": [], "body": "                                                           {\n        final CommandLine cl = parser.parse(options, new String[] { \"-c\", \"foober\", \"-b\", \"toast\" }, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }", "signature": "@Test\n    public void testStopAtUnexpectedArg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStopBursting() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-azc\" }, true);\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertTrue(cl.getArgList().contains(\"zc\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStopBursting", "params": [], "body": "                                                    {\n        final CommandLine cl = parser.parse(options, new String[] { \"-azc\" }, true);\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertTrue(cl.getArgList().contains(\"zc\"));\n    }", "signature": "@Test\n    public void testStopBursting()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStopBursting2() throws Exception {\n        CommandLine cl = parser.parse(options, new String[] { \"-c\", \"foobar\", \"-btoast\" }, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm  2 extra args: \" + cl.getArgList().size());\n        cl = parser.parse(options, cl.getArgs());\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStopBursting2", "params": [], "body": "                                                     {\n        CommandLine cl = parser.parse(options, new String[] { \"-c\", \"foobar\", \"-btoast\" }, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm  2 extra args: \" + cl.getArgList().size());\n        cl = parser.parse(options, cl.getArgs());\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }", "signature": "@Test\n    public void testStopBursting2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnambiguousPartialLongOption1() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"--ver\" });\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption1", "params": [], "body": "                                                                     {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"--ver\" });\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n    }", "signature": "@Test\n    public void testUnambiguousPartialLongOption1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnambiguousPartialLongOption2() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"-ver\" });\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption2", "params": [], "body": "                                                                     {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"-ver\" });\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n    }", "signature": "@Test\n    public void testUnambiguousPartialLongOption2()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnambiguousPartialLongOption3() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"--ver=1\" });\n        assertTrue(cl.hasOption(\"verbose\"), \"Confirm --verbose is set\");\n        assertEquals(\"1\", cl.getOptionValue(\"verbose\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption3", "params": [], "body": "                                                                     {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"--ver=1\" });\n        assertTrue(cl.hasOption(\"verbose\"), \"Confirm --verbose is set\");\n        assertEquals(\"1\", cl.getOptionValue(\"verbose\"));\n    }", "signature": "@Test\n    public void testUnambiguousPartialLongOption3()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnambiguousPartialLongOption4() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"-ver=1\" });\n        assertTrue(cl.hasOption(\"verbose\"), \"Confirm --verbose is set\");\n        assertEquals(\"1\", cl.getOptionValue(\"verbose\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnambiguousPartialLongOption4", "params": [], "body": "                                                                     {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"-ver=1\" });\n        assertTrue(cl.hasOption(\"verbose\"), \"Confirm --verbose is set\");\n        assertEquals(\"1\", cl.getOptionValue(\"verbose\"));\n    }", "signature": "@Test\n    public void testUnambiguousPartialLongOption4()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnlimitedArgs() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArgs().create(\"e\"));\n        options.addOption(OptionBuilder.hasArgs().create(\"f\"));\n        final CommandLine cl = parser.parse(options, new String[] { \"-e\", \"one\", \"two\", \"-f\", \"alpha\" });\n        assertTrue(cl.hasOption(\"e\"), \"Confirm -e is set\");\n        assertEquals(2, cl.getOptionValues(\"e\").length, \"number of arg for -e\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertEquals(1, cl.getOptionValues(\"f\").length, \"number of arg for -f\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnlimitedArgs", "params": [], "body": "                                                     {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArgs().create(\"e\"));\n        options.addOption(OptionBuilder.hasArgs().create(\"f\"));\n        final CommandLine cl = parser.parse(options, new String[] { \"-e\", \"one\", \"two\", \"-f\", \"alpha\" });\n        assertTrue(cl.hasOption(\"e\"), \"Confirm -e is set\");\n        assertEquals(2, cl.getOptionValues(\"e\").length, \"number of arg for -e\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertEquals(1, cl.getOptionValues(\"f\").length, \"number of arg for -f\");\n    }", "signature": "@Test\n    public void testUnlimitedArgs()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnrecognizedOption() throws Exception {\n        try {\n            parser.parse(options, new String[] { \"-a\", \"-d\", \"-b\", \"toast\", \"foo\", \"bar\" });\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-d\", e.getOption());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnrecognizedOption", "params": [], "body": "                                                          {\n        try {\n            parser.parse(options, new String[] { \"-a\", \"-d\", \"-b\", \"toast\", \"foo\", \"bar\" });\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-d\", e.getOption());\n        }\n    }", "signature": "@Test\n    public void testUnrecognizedOption()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n        try {\n            parser.parse(options, new String[] { \"-adbtoast\", \"foo\", \"bar\" });\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-adbtoast\", e.getOption());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUnrecognizedOptionWithBursting", "params": [], "body": "                                                                      {\n        try {\n            parser.parse(options, new String[] { \"-adbtoast\", \"foo\", \"bar\" });\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-adbtoast\", e.getOption());\n        }\n    }", "signature": "@Test\n    public void testUnrecognizedOptionWithBursting()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testWithRequiredOption() throws Exception {\n        final String[] args = { \"-b\", \"file\" };\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is NOT set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"file\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO of extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWithRequiredOption", "params": [], "body": "                                                          {\n        final String[] args = { \"-b\", \"file\" };\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is NOT set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"file\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO of extra args\");\n    }", "signature": "@Test\n    public void testWithRequiredOption()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/OptionBuilder_hasOptionalArgTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class OptionBuilder_hasOptionalArgTest {\n\n    @Test\n    public void testHasOptionalArg() {\n        // Given\n        OptionBuilder.hasOptionalArg();\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n    }\n\n    @Test\n    public void testHasOptionalArgWithArgName() {\n        // Given\n        OptionBuilder.hasOptionalArg().withArgName(\"value\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"value\", option.getArgName());\n    }\n\n    @Test\n    public void testHasOptionalArgWithDescription() {\n        // Given\n        OptionBuilder.hasOptionalArg().withDescription(\"optional arg option\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"optional arg option\", option.getDescription());\n    }\n\n    @Test\n    public void testHasOptionalArgWithLongOpt() {\n        // Given\n        OptionBuilder.hasOptionalArg().withLongOpt(\"longOpt\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"longOpt\", option.getLongOpt());\n    }\n\n    @Test\n    public void testHasOptionalArgWithRequired() {\n        // Given\n        OptionBuilder.hasOptionalArg().isRequired();\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertTrue(option.isRequired());\n    }\n}\n", "file_hash": "8b00af01268e3a54f9b21f0e29e0e0a78b12359e458d4d032360c5d2bce16649", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.*;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class OptionBuilder_hasOptionalArgTest {\n\n    @Test\n    public void testHasOptionalArg() {\n        // Given\n        OptionBuilder.hasOptionalArg();\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n    }\n\n    @Test\n    public void testHasOptionalArgWithArgName() {\n        // Given\n        OptionBuilder.hasOptionalArg().withArgName(\"value\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"value\", option.getArgName());\n    }\n\n    @Test\n    public void testHasOptionalArgWithDescription() {\n        // Given\n        OptionBuilder.hasOptionalArg().withDescription(\"optional arg option\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"optional arg option\", option.getDescription());\n    }\n\n    @Test\n    public void testHasOptionalArgWithLongOpt() {\n        // Given\n        OptionBuilder.hasOptionalArg().withLongOpt(\"longOpt\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"longOpt\", option.getLongOpt());\n    }\n\n    @Test\n    public void testHasOptionalArgWithRequired() {\n        // Given\n        OptionBuilder.hasOptionalArg().isRequired();\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertTrue(option.isRequired());\n    }\n}", "definition": "public class OptionBuilder_hasOptionalArgTest", "class_docstring": "", "name": "OptionBuilder_hasOptionalArgTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testHasOptionalArg() {\n        // Given\n        OptionBuilder.hasOptionalArg();\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHasOptionalArg", "params": [], "body": "                                     {\n        // Given\n        OptionBuilder.hasOptionalArg();\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n    }", "signature": "@Test\n    public void testHasOptionalArg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHasOptionalArgWithArgName() {\n        // Given\n        OptionBuilder.hasOptionalArg().withArgName(\"value\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"value\", option.getArgName());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHasOptionalArgWithArgName", "params": [], "body": "                                                {\n        // Given\n        OptionBuilder.hasOptionalArg().withArgName(\"value\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"value\", option.getArgName());\n    }", "signature": "@Test\n    public void testHasOptionalArgWithArgName()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHasOptionalArgWithDescription() {\n        // Given\n        OptionBuilder.hasOptionalArg().withDescription(\"optional arg option\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"optional arg option\", option.getDescription());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHasOptionalArgWithDescription", "params": [], "body": "                                                    {\n        // Given\n        OptionBuilder.hasOptionalArg().withDescription(\"optional arg option\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"optional arg option\", option.getDescription());\n    }", "signature": "@Test\n    public void testHasOptionalArgWithDescription()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHasOptionalArgWithLongOpt() {\n        // Given\n        OptionBuilder.hasOptionalArg().withLongOpt(\"longOpt\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"longOpt\", option.getLongOpt());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHasOptionalArgWithLongOpt", "params": [], "body": "                                                {\n        // Given\n        OptionBuilder.hasOptionalArg().withLongOpt(\"longOpt\");\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertEquals(\"longOpt\", option.getLongOpt());\n    }", "signature": "@Test\n    public void testHasOptionalArgWithLongOpt()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHasOptionalArgWithRequired() {\n        // Given\n        OptionBuilder.hasOptionalArg().isRequired();\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertTrue(option.isRequired());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHasOptionalArgWithRequired", "params": [], "body": "                                                 {\n        // Given\n        OptionBuilder.hasOptionalArg().isRequired();\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n        assertTrue(option.isRequired());\n    }", "signature": "@Test\n    public void testHasOptionalArgWithRequired()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/DeprecatedAttributes_toStringTest.java", "original_string": "\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class DeprecatedAttributes_toStringTest {\n\n    @Test\n    public void testToStringDefault() {\n        final DeprecatedAttributes defaultValue = DeprecatedAttributes.builder().get();\n        assertEquals(\"Deprecated\", defaultValue.toString());\n    }\n\n    @Test\n    public void testToStringForRemoval() {\n        final DeprecatedAttributes forRemovalValue = DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .get();\n        assertEquals(\"Deprecated for removal\", forRemovalValue.toString());\n    }\n\n    @Test\n    public void testToStringSince() {\n        final DeprecatedAttributes sinceValue = DeprecatedAttributes.builder()\n                .setSince(\"1.0\")\n                .get();\n        assertEquals(\"Deprecated since 1.0\", sinceValue.toString());\n    }\n\n    @Test\n    public void testToStringDescription() {\n        final DeprecatedAttributes descriptionValue = DeprecatedAttributes.builder()\n                .setDescription(\"This option is deprecated\")\n                .get();\n        assertEquals(\"Deprecated: This option is deprecated\", descriptionValue.toString());\n    }\n\n    @Test\n    public void testToStringAllFields() {\n        final DeprecatedAttributes allFieldsValue = DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .setSince(\"1.0\")\n                .setDescription(\"This option is deprecated\")\n                .get();\n        assertEquals(\"Deprecated for removal since 1.0: This option is deprecated\", allFieldsValue.toString());\n    }\n}\n", "file_hash": "fd5cb978426315e7fdd95653289d01fc59f327d3bf87db91735623b87da9bdc2", "file_docstring": "", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class DeprecatedAttributes_toStringTest {\n\n    @Test\n    public void testToStringDefault() {\n        final DeprecatedAttributes defaultValue = DeprecatedAttributes.builder().get();\n        assertEquals(\"Deprecated\", defaultValue.toString());\n    }\n\n    @Test\n    public void testToStringForRemoval() {\n        final DeprecatedAttributes forRemovalValue = DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .get();\n        assertEquals(\"Deprecated for removal\", forRemovalValue.toString());\n    }\n\n    @Test\n    public void testToStringSince() {\n        final DeprecatedAttributes sinceValue = DeprecatedAttributes.builder()\n                .setSince(\"1.0\")\n                .get();\n        assertEquals(\"Deprecated since 1.0\", sinceValue.toString());\n    }\n\n    @Test\n    public void testToStringDescription() {\n        final DeprecatedAttributes descriptionValue = DeprecatedAttributes.builder()\n                .setDescription(\"This option is deprecated\")\n                .get();\n        assertEquals(\"Deprecated: This option is deprecated\", descriptionValue.toString());\n    }\n\n    @Test\n    public void testToStringAllFields() {\n        final DeprecatedAttributes allFieldsValue = DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .setSince(\"1.0\")\n                .setDescription(\"This option is deprecated\")\n                .get();\n        assertEquals(\"Deprecated for removal since 1.0: This option is deprecated\", allFieldsValue.toString());\n    }\n}", "definition": "public class DeprecatedAttributes_toStringTest", "class_docstring": "", "name": "DeprecatedAttributes_toStringTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testToStringDefault() {\n        final DeprecatedAttributes defaultValue = DeprecatedAttributes.builder().get();\n        assertEquals(\"Deprecated\", defaultValue.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringDefault", "params": [], "body": "                                      {\n        final DeprecatedAttributes defaultValue = DeprecatedAttributes.builder().get();\n        assertEquals(\"Deprecated\", defaultValue.toString());\n    }", "signature": "@Test\n    public void testToStringDefault()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringForRemoval() {\n        final DeprecatedAttributes forRemovalValue = DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .get();\n        assertEquals(\"Deprecated for removal\", forRemovalValue.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringForRemoval", "params": [], "body": "                                         {\n        final DeprecatedAttributes forRemovalValue = DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .get();\n        assertEquals(\"Deprecated for removal\", forRemovalValue.toString());\n    }", "signature": "@Test\n    public void testToStringForRemoval()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringSince() {\n        final DeprecatedAttributes sinceValue = DeprecatedAttributes.builder()\n                .setSince(\"1.0\")\n                .get();\n        assertEquals(\"Deprecated since 1.0\", sinceValue.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringSince", "params": [], "body": "                                    {\n        final DeprecatedAttributes sinceValue = DeprecatedAttributes.builder()\n                .setSince(\"1.0\")\n                .get();\n        assertEquals(\"Deprecated since 1.0\", sinceValue.toString());\n    }", "signature": "@Test\n    public void testToStringSince()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringDescription() {\n        final DeprecatedAttributes descriptionValue = DeprecatedAttributes.builder()\n                .setDescription(\"This option is deprecated\")\n                .get();\n        assertEquals(\"Deprecated: This option is deprecated\", descriptionValue.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringDescription", "params": [], "body": "                                          {\n        final DeprecatedAttributes descriptionValue = DeprecatedAttributes.builder()\n                .setDescription(\"This option is deprecated\")\n                .get();\n        assertEquals(\"Deprecated: This option is deprecated\", descriptionValue.toString());\n    }", "signature": "@Test\n    public void testToStringDescription()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringAllFields() {\n        final DeprecatedAttributes allFieldsValue = DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .setSince(\"1.0\")\n                .setDescription(\"This option is deprecated\")\n                .get();\n        assertEquals(\"Deprecated for removal since 1.0: This option is deprecated\", allFieldsValue.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringAllFields", "params": [], "body": "                                        {\n        final DeprecatedAttributes allFieldsValue = DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .setSince(\"1.0\")\n                .setDescription(\"This option is deprecated\")\n                .get();\n        assertEquals(\"Deprecated for removal since 1.0: This option is deprecated\", allFieldsValue.toString());\n    }", "signature": "@Test\n    public void testToStringAllFields()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/ValuesTest.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ValuesTest {\n    private CommandLine cmd;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        final Options options = new Options();\n\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"b\", true, \"set -b\");\n        options.addOption(\"c\", \"c\", false, \"toggle -c\");\n        options.addOption(\"d\", \"d\", true, \"set -d\");\n\n        options.addOption(OptionBuilder.withLongOpt(\"e\").hasArgs().withDescription(\"set -e \").create('e'));\n        options.addOption(\"f\", \"f\", false, \"jk\");\n        options.addOption(OptionBuilder.withLongOpt(\"g\").hasArgs(2).withDescription(\"set -g\").create('g'));\n        options.addOption(OptionBuilder.withLongOpt(\"h\").hasArg().withDescription(\"set -h\").create('h'));\n        options.addOption(OptionBuilder.withLongOpt(\"i\").withDescription(\"set -i\").create('i'));\n        options.addOption(OptionBuilder.withLongOpt(\"j\").hasArgs().withDescription(\"set -j\").withValueSeparator('=').create('j'));\n        options.addOption(OptionBuilder.withLongOpt(\"k\").hasArgs().withDescription(\"set -k\").withValueSeparator('=').create('k'));\n        options.addOption(OptionBuilder.withLongOpt(\"m\").hasArgs().withDescription(\"set -m\").withValueSeparator().create('m'));\n\n        //@formatter:off\n        final String[] args = {\n            \"-a\",\n            \"-b\", \"foo\",\n            \"--c\",\n            \"--d\", \"bar\",\n            \"-e\", \"one\", \"two\",\n            \"-f\",\n            \"arg1\", \"arg2\",\n            \"-g\", \"val1\", \"val2\", \"arg3\",\n            \"-h\", \"val1\", \"-i\",\n            \"-h\", \"val2\",\n            \"-jkey=value\",\n            \"-j\", \"key=value\",\n            \"-kkey1=value1\",\n            \"-kkey2=value2\",\n            \"-mkey=value\"\n        };\n        //@formatter:on\n\n        final CommandLineParser parser = new PosixParser();\n\n        cmd = parser.parse(options, args);\n    }\n\n    @Test\n    public void testCharSeparator() {\n        // tests the char methods of CommandLine that delegate to the String methods\n        assertTrue(cmd.hasOption(\"j\"), \"Option j is not set\");\n        assertTrue(cmd.hasOption('j'), \"Option j is not set\");\n        assertArrayEquals(new String[] {\"key\", \"value\", \"key\", \"value\"}, cmd.getOptionValues(\"j\"));\n        assertArrayEquals(new String[] {\"key\", \"value\", \"key\", \"value\"}, cmd.getOptionValues('j'));\n\n        assertTrue(cmd.hasOption(\"k\"), \"Option k is not set\");\n        assertTrue(cmd.hasOption('k'), \"Option k is not set\");\n        assertArrayEquals(new String[] {\"key1\", \"value1\", \"key2\", \"value2\"}, cmd.getOptionValues(\"k\"));\n        assertArrayEquals(new String[] {\"key1\", \"value1\", \"key2\", \"value2\"}, cmd.getOptionValues('k'));\n\n        assertTrue(cmd.hasOption(\"m\"), \"Option m is not set\");\n        assertTrue(cmd.hasOption('m'), \"Option m is not set\");\n        assertArrayEquals(new String[] {\"key\", \"value\"}, cmd.getOptionValues(\"m\"));\n        assertArrayEquals(new String[] {\"key\", \"value\"}, cmd.getOptionValues('m'));\n    }\n\n    @Test\n    public void testComplexValues() {\n        assertTrue(cmd.hasOption(\"i\"), \"Option i is not set\");\n        assertTrue(cmd.hasOption(\"h\"), \"Option h is not set\");\n        assertArrayEquals(new String[] {\"val1\", \"val2\"}, cmd.getOptionValues(\"h\"));\n    }\n\n    @Test\n    public void testExtraArgs() {\n        assertArrayEquals(new String[] {\"arg1\", \"arg2\", \"arg3\"}, cmd.getArgs(), \"Extra args\");\n    }\n\n    @Test\n    public void testMultipleArgValues() {\n        assertTrue(cmd.hasOption(\"e\"), \"Option e is not set\");\n        assertArrayEquals(new String[] {\"one\", \"two\"}, cmd.getOptionValues(\"e\"));\n    }\n\n    @Test\n    public void testShortArgs() {\n        assertTrue(cmd.hasOption(\"a\"), \"Option a is not set\");\n        assertTrue(cmd.hasOption(\"c\"), \"Option c is not set\");\n\n        assertNull(cmd.getOptionValues(\"a\"));\n        assertNull(cmd.getOptionValues(\"c\"));\n    }\n\n    @Test\n    public void testShortArgsWithValue() {\n        assertTrue(cmd.hasOption(\"b\"), \"Option b is not set\");\n        assertEquals(\"foo\", cmd.getOptionValue(\"b\"));\n        assertEquals(1, cmd.getOptionValues(\"b\").length);\n\n        assertTrue(cmd.hasOption(\"b\"), \"Option b is not set\");\n        assertEquals(\"bar\", cmd.getOptionValue(\"d\"));\n        assertEquals(1, cmd.getOptionValues(\"d\").length);\n    }\n\n    @Test\n    public void testTwoArgValues() {\n        assertTrue(cmd.hasOption(\"g\"), \"Option g is not set\");\n        assertArrayEquals(new String[] {\"val1\", \"val2\"}, cmd.getOptionValues(\"g\"));\n    }\n\n    /**\n     * jkeyes - commented out this test as the new architecture breaks this type of functionality. I have left the test here\n     * in case I get a brainwave on how to resolve this.\n     */\n    /*\n     * public void testGetValue() { // the 'm' option assertTrue(_option.getValues().length == 2); assertEquals(\n     * _option.getValue(), \"key\"); assertEquals(_option.getValue(0), \"key\"); assertEquals(_option.getValue(1),\n     * \"value\");\n     *\n     * try { assertEquals(_option.getValue(2), \"key\"); fail(\"IndexOutOfBounds not caught\"); } catch (\n     * IndexOutOfBoundsException exp) {\n     *\n     * }\n     *\n     * try { assertEquals(_option.getValue(-1), \"key\"); fail(\"IndexOutOfBounds not caught\"); } catch (\n     * IndexOutOfBoundsException exp) {\n     *\n     * } }\n     */\n}\n", "file_hash": "c5eb08f44ae41cbc3ae2e22ee319dcae889405fb9d8e50accd43cd1a5bb4080f", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.junit.jupiter.api.Assertions.assertArrayEquals;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ValuesTest {\n    private CommandLine cmd;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        final Options options = new Options();\n\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"b\", true, \"set -b\");\n        options.addOption(\"c\", \"c\", false, \"toggle -c\");\n        options.addOption(\"d\", \"d\", true, \"set -d\");\n\n        options.addOption(OptionBuilder.withLongOpt(\"e\").hasArgs().withDescription(\"set -e \").create('e'));\n        options.addOption(\"f\", \"f\", false, \"jk\");\n        options.addOption(OptionBuilder.withLongOpt(\"g\").hasArgs(2).withDescription(\"set -g\").create('g'));\n        options.addOption(OptionBuilder.withLongOpt(\"h\").hasArg().withDescription(\"set -h\").create('h'));\n        options.addOption(OptionBuilder.withLongOpt(\"i\").withDescription(\"set -i\").create('i'));\n        options.addOption(OptionBuilder.withLongOpt(\"j\").hasArgs().withDescription(\"set -j\").withValueSeparator('=').create('j'));\n        options.addOption(OptionBuilder.withLongOpt(\"k\").hasArgs().withDescription(\"set -k\").withValueSeparator('=').create('k'));\n        options.addOption(OptionBuilder.withLongOpt(\"m\").hasArgs().withDescription(\"set -m\").withValueSeparator().create('m'));\n\n        //@formatter:off\n        final String[] args = {\n            \"-a\",\n            \"-b\", \"foo\",\n            \"--c\",\n            \"--d\", \"bar\",\n            \"-e\", \"one\", \"two\",\n            \"-f\",\n            \"arg1\", \"arg2\",\n            \"-g\", \"val1\", \"val2\", \"arg3\",\n            \"-h\", \"val1\", \"-i\",\n            \"-h\", \"val2\",\n            \"-jkey=value\",\n            \"-j\", \"key=value\",\n            \"-kkey1=value1\",\n            \"-kkey2=value2\",\n            \"-mkey=value\"\n        };\n        //@formatter:on\n\n        final CommandLineParser parser = new PosixParser();\n\n        cmd = parser.parse(options, args);\n    }\n\n    @Test\n    public void testCharSeparator() {\n        // tests the char methods of CommandLine that delegate to the String methods\n        assertTrue(cmd.hasOption(\"j\"), \"Option j is not set\");\n        assertTrue(cmd.hasOption('j'), \"Option j is not set\");\n        assertArrayEquals(new String[] {\"key\", \"value\", \"key\", \"value\"}, cmd.getOptionValues(\"j\"));\n        assertArrayEquals(new String[] {\"key\", \"value\", \"key\", \"value\"}, cmd.getOptionValues('j'));\n\n        assertTrue(cmd.hasOption(\"k\"), \"Option k is not set\");\n        assertTrue(cmd.hasOption('k'), \"Option k is not set\");\n        assertArrayEquals(new String[] {\"key1\", \"value1\", \"key2\", \"value2\"}, cmd.getOptionValues(\"k\"));\n        assertArrayEquals(new String[] {\"key1\", \"value1\", \"key2\", \"value2\"}, cmd.getOptionValues('k'));\n\n        assertTrue(cmd.hasOption(\"m\"), \"Option m is not set\");\n        assertTrue(cmd.hasOption('m'), \"Option m is not set\");\n        assertArrayEquals(new String[] {\"key\", \"value\"}, cmd.getOptionValues(\"m\"));\n        assertArrayEquals(new String[] {\"key\", \"value\"}, cmd.getOptionValues('m'));\n    }\n\n    @Test\n    public void testComplexValues() {\n        assertTrue(cmd.hasOption(\"i\"), \"Option i is not set\");\n        assertTrue(cmd.hasOption(\"h\"), \"Option h is not set\");\n        assertArrayEquals(new String[] {\"val1\", \"val2\"}, cmd.getOptionValues(\"h\"));\n    }\n\n    @Test\n    public void testExtraArgs() {\n        assertArrayEquals(new String[] {\"arg1\", \"arg2\", \"arg3\"}, cmd.getArgs(), \"Extra args\");\n    }\n\n    @Test\n    public void testMultipleArgValues() {\n        assertTrue(cmd.hasOption(\"e\"), \"Option e is not set\");\n        assertArrayEquals(new String[] {\"one\", \"two\"}, cmd.getOptionValues(\"e\"));\n    }\n\n    @Test\n    public void testShortArgs() {\n        assertTrue(cmd.hasOption(\"a\"), \"Option a is not set\");\n        assertTrue(cmd.hasOption(\"c\"), \"Option c is not set\");\n\n        assertNull(cmd.getOptionValues(\"a\"));\n        assertNull(cmd.getOptionValues(\"c\"));\n    }\n\n    @Test\n    public void testShortArgsWithValue() {\n        assertTrue(cmd.hasOption(\"b\"), \"Option b is not set\");\n        assertEquals(\"foo\", cmd.getOptionValue(\"b\"));\n        assertEquals(1, cmd.getOptionValues(\"b\").length);\n\n        assertTrue(cmd.hasOption(\"b\"), \"Option b is not set\");\n        assertEquals(\"bar\", cmd.getOptionValue(\"d\"));\n        assertEquals(1, cmd.getOptionValues(\"d\").length);\n    }\n\n    @Test\n    public void testTwoArgValues() {\n        assertTrue(cmd.hasOption(\"g\"), \"Option g is not set\");\n        assertArrayEquals(new String[] {\"val1\", \"val2\"}, cmd.getOptionValues(\"g\"));\n    }\n\n    /**\n     * jkeyes - commented out this test as the new architecture breaks this type of functionality. I have left the test here\n     * in case I get a brainwave on how to resolve this.\n     */\n    /*\n     * public void testGetValue() { // the 'm' option assertTrue(_option.getValues().length == 2); assertEquals(\n     * _option.getValue(), \"key\"); assertEquals(_option.getValue(0), \"key\"); assertEquals(_option.getValue(1),\n     * \"value\");\n     *\n     * try { assertEquals(_option.getValue(2), \"key\"); fail(\"IndexOutOfBounds not caught\"); } catch (\n     * IndexOutOfBoundsException exp) {\n     *\n     * }\n     *\n     * try { assertEquals(_option.getValue(-1), \"key\"); fail(\"IndexOutOfBounds not caught\"); } catch (\n     * IndexOutOfBoundsException exp) {\n     *\n     * } }\n     */\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ValuesTest", "class_docstring": "", "name": "ValuesTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [{"attribute_expression": "private CommandLine cmd;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CommandLine", "name": "cmd", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        final Options options = new Options();\n\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"b\", true, \"set -b\");\n        options.addOption(\"c\", \"c\", false, \"toggle -c\");\n        options.addOption(\"d\", \"d\", true, \"set -d\");\n\n        options.addOption(OptionBuilder.withLongOpt(\"e\").hasArgs().withDescription(\"set -e \").create('e'));\n        options.addOption(\"f\", \"f\", false, \"jk\");\n        options.addOption(OptionBuilder.withLongOpt(\"g\").hasArgs(2).withDescription(\"set -g\").create('g'));\n        options.addOption(OptionBuilder.withLongOpt(\"h\").hasArg().withDescription(\"set -h\").create('h'));\n        options.addOption(OptionBuilder.withLongOpt(\"i\").withDescription(\"set -i\").create('i'));\n        options.addOption(OptionBuilder.withLongOpt(\"j\").hasArgs().withDescription(\"set -j\").withValueSeparator('=').create('j'));\n        options.addOption(OptionBuilder.withLongOpt(\"k\").hasArgs().withDescription(\"set -k\").withValueSeparator('=').create('k'));\n        options.addOption(OptionBuilder.withLongOpt(\"m\").hasArgs().withDescription(\"set -m\").withValueSeparator().create('m'));\n\n        //@formatter:off\n        final String[] args = {\n            \"-a\",\n            \"-b\", \"foo\",\n            \"--c\",\n            \"--d\", \"bar\",\n            \"-e\", \"one\", \"two\",\n            \"-f\",\n            \"arg1\", \"arg2\",\n            \"-g\", \"val1\", \"val2\", \"arg3\",\n            \"-h\", \"val1\", \"-i\",\n            \"-h\", \"val2\",\n            \"-jkey=value\",\n            \"-j\", \"key=value\",\n            \"-kkey1=value1\",\n            \"-kkey2=value2\",\n            \"-mkey=value\"\n        };\n        //@formatter:on\n\n        final CommandLineParser parser = new PosixParser();\n\n        cmd = parser.parse(options, args);\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                                         {\n        final Options options = new Options();\n\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"b\", true, \"set -b\");\n        options.addOption(\"c\", \"c\", false, \"toggle -c\");\n        options.addOption(\"d\", \"d\", true, \"set -d\");\n\n        options.addOption(OptionBuilder.withLongOpt(\"e\").hasArgs().withDescription(\"set -e \").create('e'));\n        options.addOption(\"f\", \"f\", false, \"jk\");\n        options.addOption(OptionBuilder.withLongOpt(\"g\").hasArgs(2).withDescription(\"set -g\").create('g'));\n        options.addOption(OptionBuilder.withLongOpt(\"h\").hasArg().withDescription(\"set -h\").create('h'));\n        options.addOption(OptionBuilder.withLongOpt(\"i\").withDescription(\"set -i\").create('i'));\n        options.addOption(OptionBuilder.withLongOpt(\"j\").hasArgs().withDescription(\"set -j\").withValueSeparator('=').create('j'));\n        options.addOption(OptionBuilder.withLongOpt(\"k\").hasArgs().withDescription(\"set -k\").withValueSeparator('=').create('k'));\n        options.addOption(OptionBuilder.withLongOpt(\"m\").hasArgs().withDescription(\"set -m\").withValueSeparator().create('m'));\n\n        //@formatter:off\n        final String[] args = {\n            \"-a\",\n            \"-b\", \"foo\",\n            \"--c\",\n            \"--d\", \"bar\",\n            \"-e\", \"one\", \"two\",\n            \"-f\",\n            \"arg1\", \"arg2\",\n            \"-g\", \"val1\", \"val2\", \"arg3\",\n            \"-h\", \"val1\", \"-i\",\n            \"-h\", \"val2\",\n            \"-jkey=value\",\n            \"-j\", \"key=value\",\n            \"-kkey1=value1\",\n            \"-kkey2=value2\",\n            \"-mkey=value\"\n        };\n        //@formatter:on\n\n        final CommandLineParser parser = new PosixParser();\n\n        cmd = parser.parse(options, args);\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCharSeparator() {\n        // tests the char methods of CommandLine that delegate to the String methods\n        assertTrue(cmd.hasOption(\"j\"), \"Option j is not set\");\n        assertTrue(cmd.hasOption('j'), \"Option j is not set\");\n        assertArrayEquals(new String[] {\"key\", \"value\", \"key\", \"value\"}, cmd.getOptionValues(\"j\"));\n        assertArrayEquals(new String[] {\"key\", \"value\", \"key\", \"value\"}, cmd.getOptionValues('j'));\n\n        assertTrue(cmd.hasOption(\"k\"), \"Option k is not set\");\n        assertTrue(cmd.hasOption('k'), \"Option k is not set\");\n        assertArrayEquals(new String[] {\"key1\", \"value1\", \"key2\", \"value2\"}, cmd.getOptionValues(\"k\"));\n        assertArrayEquals(new String[] {\"key1\", \"value1\", \"key2\", \"value2\"}, cmd.getOptionValues('k'));\n\n        assertTrue(cmd.hasOption(\"m\"), \"Option m is not set\");\n        assertTrue(cmd.hasOption('m'), \"Option m is not set\");\n        assertArrayEquals(new String[] {\"key\", \"value\"}, cmd.getOptionValues(\"m\"));\n        assertArrayEquals(new String[] {\"key\", \"value\"}, cmd.getOptionValues('m'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCharSeparator", "params": [], "body": "                                    {\n        // tests the char methods of CommandLine that delegate to the String methods\n        assertTrue(cmd.hasOption(\"j\"), \"Option j is not set\");\n        assertTrue(cmd.hasOption('j'), \"Option j is not set\");\n        assertArrayEquals(new String[] {\"key\", \"value\", \"key\", \"value\"}, cmd.getOptionValues(\"j\"));\n        assertArrayEquals(new String[] {\"key\", \"value\", \"key\", \"value\"}, cmd.getOptionValues('j'));\n\n        assertTrue(cmd.hasOption(\"k\"), \"Option k is not set\");\n        assertTrue(cmd.hasOption('k'), \"Option k is not set\");\n        assertArrayEquals(new String[] {\"key1\", \"value1\", \"key2\", \"value2\"}, cmd.getOptionValues(\"k\"));\n        assertArrayEquals(new String[] {\"key1\", \"value1\", \"key2\", \"value2\"}, cmd.getOptionValues('k'));\n\n        assertTrue(cmd.hasOption(\"m\"), \"Option m is not set\");\n        assertTrue(cmd.hasOption('m'), \"Option m is not set\");\n        assertArrayEquals(new String[] {\"key\", \"value\"}, cmd.getOptionValues(\"m\"));\n        assertArrayEquals(new String[] {\"key\", \"value\"}, cmd.getOptionValues('m'));\n    }", "signature": "@Test\n    public void testCharSeparator()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testComplexValues() {\n        assertTrue(cmd.hasOption(\"i\"), \"Option i is not set\");\n        assertTrue(cmd.hasOption(\"h\"), \"Option h is not set\");\n        assertArrayEquals(new String[] {\"val1\", \"val2\"}, cmd.getOptionValues(\"h\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testComplexValues", "params": [], "body": "                                    {\n        assertTrue(cmd.hasOption(\"i\"), \"Option i is not set\");\n        assertTrue(cmd.hasOption(\"h\"), \"Option h is not set\");\n        assertArrayEquals(new String[] {\"val1\", \"val2\"}, cmd.getOptionValues(\"h\"));\n    }", "signature": "@Test\n    public void testComplexValues()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExtraArgs() {\n        assertArrayEquals(new String[] {\"arg1\", \"arg2\", \"arg3\"}, cmd.getArgs(), \"Extra args\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExtraArgs", "params": [], "body": "                                {\n        assertArrayEquals(new String[] {\"arg1\", \"arg2\", \"arg3\"}, cmd.getArgs(), \"Extra args\");\n    }", "signature": "@Test\n    public void testExtraArgs()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMultipleArgValues() {\n        assertTrue(cmd.hasOption(\"e\"), \"Option e is not set\");\n        assertArrayEquals(new String[] {\"one\", \"two\"}, cmd.getOptionValues(\"e\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMultipleArgValues", "params": [], "body": "                                        {\n        assertTrue(cmd.hasOption(\"e\"), \"Option e is not set\");\n        assertArrayEquals(new String[] {\"one\", \"two\"}, cmd.getOptionValues(\"e\"));\n    }", "signature": "@Test\n    public void testMultipleArgValues()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortArgs() {\n        assertTrue(cmd.hasOption(\"a\"), \"Option a is not set\");\n        assertTrue(cmd.hasOption(\"c\"), \"Option c is not set\");\n\n        assertNull(cmd.getOptionValues(\"a\"));\n        assertNull(cmd.getOptionValues(\"c\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortArgs", "params": [], "body": "                                {\n        assertTrue(cmd.hasOption(\"a\"), \"Option a is not set\");\n        assertTrue(cmd.hasOption(\"c\"), \"Option c is not set\");\n\n        assertNull(cmd.getOptionValues(\"a\"));\n        assertNull(cmd.getOptionValues(\"c\"));\n    }", "signature": "@Test\n    public void testShortArgs()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShortArgsWithValue() {\n        assertTrue(cmd.hasOption(\"b\"), \"Option b is not set\");\n        assertEquals(\"foo\", cmd.getOptionValue(\"b\"));\n        assertEquals(1, cmd.getOptionValues(\"b\").length);\n\n        assertTrue(cmd.hasOption(\"b\"), \"Option b is not set\");\n        assertEquals(\"bar\", cmd.getOptionValue(\"d\"));\n        assertEquals(1, cmd.getOptionValues(\"d\").length);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShortArgsWithValue", "params": [], "body": "                                         {\n        assertTrue(cmd.hasOption(\"b\"), \"Option b is not set\");\n        assertEquals(\"foo\", cmd.getOptionValue(\"b\"));\n        assertEquals(1, cmd.getOptionValues(\"b\").length);\n\n        assertTrue(cmd.hasOption(\"b\"), \"Option b is not set\");\n        assertEquals(\"bar\", cmd.getOptionValue(\"d\"));\n        assertEquals(1, cmd.getOptionValues(\"d\").length);\n    }", "signature": "@Test\n    public void testShortArgsWithValue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTwoArgValues() {\n        assertTrue(cmd.hasOption(\"g\"), \"Option g is not set\");\n        assertArrayEquals(new String[] {\"val1\", \"val2\"}, cmd.getOptionValues(\"g\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTwoArgValues", "params": [], "body": "                                   {\n        assertTrue(cmd.hasOption(\"g\"), \"Option g is not set\");\n        assertArrayEquals(new String[] {\"val1\", \"val2\"}, cmd.getOptionValues(\"g\"));\n    }", "signature": "@Test\n    public void testTwoArgValues()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugCLI148Test.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli.bug;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.OptionBuilder;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.PosixParser;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * https://issues.apache.org/jira/browse/CLI-148\n */\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI148Test {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        options = new Options();\n        options.addOption(OptionBuilder.hasArg().create('t'));\n        options.addOption(OptionBuilder.hasArg().create('s'));\n    }\n\n    @Test\n    public void testWorkaround1() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-t-something\"};\n\n        final CommandLine commandLine = parser.parse(options, args);\n        assertEquals(\"-something\", commandLine.getOptionValue('t'));\n    }\n\n    @Test\n    public void testWorkaround2() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-t\", \"\\\"-something\\\"\"};\n\n        final CommandLine commandLine = parser.parse(options, args);\n        assertEquals(\"-something\", commandLine.getOptionValue('t'));\n    }\n}\n", "file_hash": "7ff770a6714c442f8159a4078e7d971c51477969ca1d226185388d7e07124769", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import org.apache.commons.cli.CommandLine;", "import org.apache.commons.cli.CommandLineParser;", "import org.apache.commons.cli.OptionBuilder;", "import org.apache.commons.cli.Options;", "import org.apache.commons.cli.PosixParser;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI148Test {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        options = new Options();\n        options.addOption(OptionBuilder.hasArg().create('t'));\n        options.addOption(OptionBuilder.hasArg().create('s'));\n    }\n\n    @Test\n    public void testWorkaround1() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-t-something\"};\n\n        final CommandLine commandLine = parser.parse(options, args);\n        assertEquals(\"-something\", commandLine.getOptionValue('t'));\n    }\n\n    @Test\n    public void testWorkaround2() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-t\", \"\\\"-something\\\"\"};\n\n        final CommandLine commandLine = parser.parse(options, args);\n        assertEquals(\"-something\", commandLine.getOptionValue('t'));\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI148Test", "class_docstring": "\nhttps://issues.apache.org/jira/browse/CLI-148\n", "name": "BugCLI148Test", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        options = new Options();\n        options.addOption(OptionBuilder.hasArg().create('t'));\n        options.addOption(OptionBuilder.hasArg().create('s'));\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                                         {\n        options = new Options();\n        options.addOption(OptionBuilder.hasArg().create('t'));\n        options.addOption(OptionBuilder.hasArg().create('s'));\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testWorkaround1() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-t-something\"};\n\n        final CommandLine commandLine = parser.parse(options, args);\n        assertEquals(\"-something\", commandLine.getOptionValue('t'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWorkaround1", "params": [], "body": "                                                   {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-t-something\"};\n\n        final CommandLine commandLine = parser.parse(options, args);\n        assertEquals(\"-something\", commandLine.getOptionValue('t'));\n    }", "signature": "@Test\n    public void testWorkaround1()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testWorkaround2() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-t\", \"\\\"-something\\\"\"};\n\n        final CommandLine commandLine = parser.parse(options, args);\n        assertEquals(\"-something\", commandLine.getOptionValue('t'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWorkaround2", "params": [], "body": "                                                   {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-t\", \"\\\"-something\\\"\"};\n\n        final CommandLine commandLine = parser.parse(options, args);\n        assertEquals(\"-something\", commandLine.getOptionValue('t'));\n    }", "signature": "@Test\n    public void testWorkaround2()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugCLI13Test.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli.bug;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.OptionBuilder;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.commons.cli.PosixParser;\nimport org.junit.jupiter.api.Test;\n\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI13Test {\n\n    @Test\n    public void testCLI13() throws ParseException {\n        final String debugOpt = \"debug\";\n        @SuppressWarnings(\"static-access\")\n        //@formatter:off\n        final Option debug = OptionBuilder\n            .withArgName(debugOpt)\n            .withDescription(\"turn on debugging\")\n            .withLongOpt(debugOpt)\n            .hasArg()\n            .create('d');\n        //@formatter:on\n        final Options options = new Options();\n        options.addOption(debug);\n        final CommandLine commandLine = new PosixParser().parse(options, new String[] {\"-d\", \"true\"});\n\n        assertEquals(\"true\", commandLine.getOptionValue(debugOpt));\n        assertEquals(\"true\", commandLine.getOptionValue('d'));\n        assertTrue(commandLine.hasOption('d'));\n        assertTrue(commandLine.hasOption(debugOpt));\n    }\n}\n", "file_hash": "0f2f2856268302bbba6b697bab6ed41dbd4c6dbc1d7f332598226bb0e93b4874", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import org.apache.commons.cli.CommandLine;", "import org.apache.commons.cli.Option;", "import org.apache.commons.cli.OptionBuilder;", "import org.apache.commons.cli.Options;", "import org.apache.commons.cli.ParseException;", "import org.apache.commons.cli.PosixParser;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI13Test {\n\n    @Test\n    public void testCLI13() throws ParseException {\n        final String debugOpt = \"debug\";\n        @SuppressWarnings(\"static-access\")\n        //@formatter:off\n        final Option debug = OptionBuilder\n            .withArgName(debugOpt)\n            .withDescription(\"turn on debugging\")\n            .withLongOpt(debugOpt)\n            .hasArg()\n            .create('d');\n        //@formatter:on\n        final Options options = new Options();\n        options.addOption(debug);\n        final CommandLine commandLine = new PosixParser().parse(options, new String[] {\"-d\", \"true\"});\n\n        assertEquals(\"true\", commandLine.getOptionValue(debugOpt));\n        assertEquals(\"true\", commandLine.getOptionValue('d'));\n        assertTrue(commandLine.hasOption('d'));\n        assertTrue(commandLine.hasOption(debugOpt));\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI13Test", "class_docstring": "", "name": "BugCLI13Test", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testCLI13() throws ParseException {\n        final String debugOpt = \"debug\";\n        @SuppressWarnings(\"static-access\")\n        //@formatter:off\n        final Option debug = OptionBuilder\n            .withArgName(debugOpt)\n            .withDescription(\"turn on debugging\")\n            .withLongOpt(debugOpt)\n            .hasArg()\n            .create('d');\n        //@formatter:on\n        final Options options = new Options();\n        options.addOption(debug);\n        final CommandLine commandLine = new PosixParser().parse(options, new String[] {\"-d\", \"true\"});\n\n        assertEquals(\"true\", commandLine.getOptionValue(debugOpt));\n        assertEquals(\"true\", commandLine.getOptionValue('d'));\n        assertTrue(commandLine.hasOption('d'));\n        assertTrue(commandLine.hasOption(debugOpt));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCLI13", "params": [], "body": "                                                  {\n        final String debugOpt = \"debug\";\n        @SuppressWarnings(\"static-access\")\n        //@formatter:off\n        final Option debug = OptionBuilder\n            .withArgName(debugOpt)\n            .withDescription(\"turn on debugging\")\n            .withLongOpt(debugOpt)\n            .hasArg()\n            .create('d');\n        //@formatter:on\n        final Options options = new Options();\n        options.addOption(debug);\n        final CommandLine commandLine = new PosixParser().parse(options, new String[] {\"-d\", \"true\"});\n\n        assertEquals(\"true\", commandLine.getOptionValue(debugOpt));\n        assertEquals(\"true\", commandLine.getOptionValue('d'));\n        assertTrue(commandLine.hasOption('d'));\n        assertTrue(commandLine.hasOption(debugOpt));\n    }", "signature": "@Test\n    public void testCLI13()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugCLI266Test.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli.bug;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.OptionGroup;\nimport org.apache.commons.cli.Options;\nimport org.junit.jupiter.api.Test;\n\npublic class BugCLI266Test {\n\n    private final List<String> insertedOrder = Arrays.asList(\"h\", \"d\", \"f\", \"x\", \"s\", \"p\", \"t\", \"w\", \"o\");\n    private final List<String> sortOrder = Arrays.asList(\"d\", \"f\", \"h\", \"o\", \"p\", \"s\", \"t\", \"w\", \"x\");\n\n    private void buildOptionsGroup(final Options options) {\n        final OptionGroup firstGroup = new OptionGroup();\n        final OptionGroup secondGroup = new OptionGroup();\n        firstGroup.setRequired(true);\n        secondGroup.setRequired(true);\n\n        //@formatter:off\n        firstGroup.addOption(Option.builder(\"d\")\n                .longOpt(\"db\")\n                .hasArg()\n                .argName(\"table-name\")\n                .build());\n        firstGroup.addOption(Option.builder(\"f\")\n                .longOpt(\"flat-file\")\n                .hasArg()\n                .argName(\"input.csv\")\n                .build());\n        //@formatter:on\n        options.addOptionGroup(firstGroup);\n        //@formatter:off\n        secondGroup.addOption(Option.builder(\"x\")\n                .hasArg()\n                .argName(\"arg1\")\n                .build());\n        secondGroup.addOption(Option.builder(\"s\")\n                .build());\n        secondGroup.addOption(Option.builder(\"p\")\n                .hasArg()\n                .argName(\"arg1\")\n                .build());\n        //@formatter:on\n        options.addOptionGroup(secondGroup);\n    }\n\n    private Options getOptions() {\n        final Options options = new Options();\n        //@formatter:off\n        final Option help = Option.builder(\"h\")\n                .longOpt(\"help\")\n                .desc(\"Prints this help message\")\n                .build();\n        //@formatter:on\n        options.addOption(help);\n\n        buildOptionsGroup(options);\n\n        //@formatter:off\n        final Option t = Option.builder(\"t\")\n                .required()\n                .hasArg()\n                .argName(\"file\")\n                .build();\n        final Option w = Option.builder(\"w\")\n                .required()\n                .hasArg()\n                .argName(\"word\")\n                .build();\n        final Option o = Option.builder(\"o\")\n                .hasArg()\n                .argName(\"directory\")\n                .build();\n        //@formatter:on\n        options.addOption(t);\n        options.addOption(w);\n        options.addOption(o);\n        return options;\n    }\n\n    @Test\n    public void testOptionComparatorDefaultOrder() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final List<Option> options = new ArrayList<>(getOptions().getOptions());\n        Collections.sort(options, formatter.getOptionComparator());\n        int i = 0;\n        for (final Option o : options) {\n            assertEquals(o.getOpt(), sortOrder.get(i));\n            i++;\n        }\n    }\n\n    @Test\n    public void testOptionComparatorInsertedOrder() {\n        final Collection<Option> options = getOptions().getOptions();\n        int i = 0;\n        for (final Option o : options) {\n            assertEquals(o.getOpt(), insertedOrder.get(i));\n            i++;\n        }\n    }\n}\n", "file_hash": "70d81435822df001c8d50fcf78851e9871a977ed3ba288828edb8717a2bf8465", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.List;", "import org.apache.commons.cli.HelpFormatter;", "import org.apache.commons.cli.Option;", "import org.apache.commons.cli.OptionGroup;", "import org.apache.commons.cli.Options;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class BugCLI266Test {\n\n    private final List<String> insertedOrder = Arrays.asList(\"h\", \"d\", \"f\", \"x\", \"s\", \"p\", \"t\", \"w\", \"o\");\n    private final List<String> sortOrder = Arrays.asList(\"d\", \"f\", \"h\", \"o\", \"p\", \"s\", \"t\", \"w\", \"x\");\n\n    private void buildOptionsGroup(final Options options) {\n        final OptionGroup firstGroup = new OptionGroup();\n        final OptionGroup secondGroup = new OptionGroup();\n        firstGroup.setRequired(true);\n        secondGroup.setRequired(true);\n\n        //@formatter:off\n        firstGroup.addOption(Option.builder(\"d\")\n                .longOpt(\"db\")\n                .hasArg()\n                .argName(\"table-name\")\n                .build());\n        firstGroup.addOption(Option.builder(\"f\")\n                .longOpt(\"flat-file\")\n                .hasArg()\n                .argName(\"input.csv\")\n                .build());\n        //@formatter:on\n        options.addOptionGroup(firstGroup);\n        //@formatter:off\n        secondGroup.addOption(Option.builder(\"x\")\n                .hasArg()\n                .argName(\"arg1\")\n                .build());\n        secondGroup.addOption(Option.builder(\"s\")\n                .build());\n        secondGroup.addOption(Option.builder(\"p\")\n                .hasArg()\n                .argName(\"arg1\")\n                .build());\n        //@formatter:on\n        options.addOptionGroup(secondGroup);\n    }\n\n    private Options getOptions() {\n        final Options options = new Options();\n        //@formatter:off\n        final Option help = Option.builder(\"h\")\n                .longOpt(\"help\")\n                .desc(\"Prints this help message\")\n                .build();\n        //@formatter:on\n        options.addOption(help);\n\n        buildOptionsGroup(options);\n\n        //@formatter:off\n        final Option t = Option.builder(\"t\")\n                .required()\n                .hasArg()\n                .argName(\"file\")\n                .build();\n        final Option w = Option.builder(\"w\")\n                .required()\n                .hasArg()\n                .argName(\"word\")\n                .build();\n        final Option o = Option.builder(\"o\")\n                .hasArg()\n                .argName(\"directory\")\n                .build();\n        //@formatter:on\n        options.addOption(t);\n        options.addOption(w);\n        options.addOption(o);\n        return options;\n    }\n\n    @Test\n    public void testOptionComparatorDefaultOrder() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final List<Option> options = new ArrayList<>(getOptions().getOptions());\n        Collections.sort(options, formatter.getOptionComparator());\n        int i = 0;\n        for (final Option o : options) {\n            assertEquals(o.getOpt(), sortOrder.get(i));\n            i++;\n        }\n    }\n\n    @Test\n    public void testOptionComparatorInsertedOrder() {\n        final Collection<Option> options = getOptions().getOptions();\n        int i = 0;\n        for (final Option o : options) {\n            assertEquals(o.getOpt(), insertedOrder.get(i));\n            i++;\n        }\n    }\n}", "definition": "public class BugCLI266Test", "class_docstring": "", "name": "BugCLI266Test", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final List<String> insertedOrder = Arrays.asList(\"h\", \"d\", \"f\", \"x\", \"s\", \"p\", \"t\", \"w\", \"o\");", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "insertedOrder = Arrays.asList(\"h\", \"d\", \"f\", \"x\", \"s\", \"p\", \"t\", \"w\", \"o\")", "syntax_pass": true}, {"attribute_expression": "private final List<String> sortOrder = Arrays.asList(\"d\", \"f\", \"h\", \"o\", \"p\", \"s\", \"t\", \"w\", \"x\");", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "sortOrder = Arrays.asList(\"d\", \"f\", \"h\", \"o\", \"p\", \"s\", \"t\", \"w\", \"x\")", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private void buildOptionsGroup(final Options options) {\n        final OptionGroup firstGroup = new OptionGroup();\n        final OptionGroup secondGroup = new OptionGroup();\n        firstGroup.setRequired(true);\n        secondGroup.setRequired(true);\n\n        //@formatter:off\n        firstGroup.addOption(Option.builder(\"d\")\n                .longOpt(\"db\")\n                .hasArg()\n                .argName(\"table-name\")\n                .build());\n        firstGroup.addOption(Option.builder(\"f\")\n                .longOpt(\"flat-file\")\n                .hasArg()\n                .argName(\"input.csv\")\n                .build());\n        //@formatter:on\n        options.addOptionGroup(firstGroup);\n        //@formatter:off\n        secondGroup.addOption(Option.builder(\"x\")\n                .hasArg()\n                .argName(\"arg1\")\n                .build());\n        secondGroup.addOption(Option.builder(\"s\")\n                .build());\n        secondGroup.addOption(Option.builder(\"p\")\n                .hasArg()\n                .argName(\"arg1\")\n                .build());\n        //@formatter:on\n        options.addOptionGroup(secondGroup);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "buildOptionsGroup", "params": [{"name": "options", "type": "Options"}], "body": "                                                          {\n        final OptionGroup firstGroup = new OptionGroup();\n        final OptionGroup secondGroup = new OptionGroup();\n        firstGroup.setRequired(true);\n        secondGroup.setRequired(true);\n\n        //@formatter:off\n        firstGroup.addOption(Option.builder(\"d\")\n                .longOpt(\"db\")\n                .hasArg()\n                .argName(\"table-name\")\n                .build());\n        firstGroup.addOption(Option.builder(\"f\")\n                .longOpt(\"flat-file\")\n                .hasArg()\n                .argName(\"input.csv\")\n                .build());\n        //@formatter:on\n        options.addOptionGroup(firstGroup);\n        //@formatter:off\n        secondGroup.addOption(Option.builder(\"x\")\n                .hasArg()\n                .argName(\"arg1\")\n                .build());\n        secondGroup.addOption(Option.builder(\"s\")\n                .build());\n        secondGroup.addOption(Option.builder(\"p\")\n                .hasArg()\n                .argName(\"arg1\")\n                .build());\n        //@formatter:on\n        options.addOptionGroup(secondGroup);\n    }", "signature": "private void buildOptionsGroup(final Options options)"}, {"syntax_pass": true, "original_string": "    private Options getOptions() {\n        final Options options = new Options();\n        //@formatter:off\n        final Option help = Option.builder(\"h\")\n                .longOpt(\"help\")\n                .desc(\"Prints this help message\")\n                .build();\n        //@formatter:on\n        options.addOption(help);\n\n        buildOptionsGroup(options);\n\n        //@formatter:off\n        final Option t = Option.builder(\"t\")\n                .required()\n                .hasArg()\n                .argName(\"file\")\n                .build();\n        final Option w = Option.builder(\"w\")\n                .required()\n                .hasArg()\n                .argName(\"word\")\n                .build();\n        final Option o = Option.builder(\"o\")\n                .hasArg()\n                .argName(\"directory\")\n                .build();\n        //@formatter:on\n        options.addOption(t);\n        options.addOption(w);\n        options.addOption(o);\n        return options;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Options", "classes": []}, "name": "getOptions", "params": [], "body": "                                 {\n        final Options options = new Options();\n        //@formatter:off\n        final Option help = Option.builder(\"h\")\n                .longOpt(\"help\")\n                .desc(\"Prints this help message\")\n                .build();\n        //@formatter:on\n        options.addOption(help);\n\n        buildOptionsGroup(options);\n\n        //@formatter:off\n        final Option t = Option.builder(\"t\")\n                .required()\n                .hasArg()\n                .argName(\"file\")\n                .build();\n        final Option w = Option.builder(\"w\")\n                .required()\n                .hasArg()\n                .argName(\"word\")\n                .build();\n        final Option o = Option.builder(\"o\")\n                .hasArg()\n                .argName(\"directory\")\n                .build();\n        //@formatter:on\n        options.addOption(t);\n        options.addOption(w);\n        options.addOption(o);\n        return options;\n    }", "signature": "private Options getOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionComparatorDefaultOrder() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final List<Option> options = new ArrayList<>(getOptions().getOptions());\n        Collections.sort(options, formatter.getOptionComparator());\n        int i = 0;\n        for (final Option o : options) {\n            assertEquals(o.getOpt(), sortOrder.get(i));\n            i++;\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionComparatorDefaultOrder", "params": [], "body": "                                                   {\n        final HelpFormatter formatter = new HelpFormatter();\n        final List<Option> options = new ArrayList<>(getOptions().getOptions());\n        Collections.sort(options, formatter.getOptionComparator());\n        int i = 0;\n        for (final Option o : options) {\n            assertEquals(o.getOpt(), sortOrder.get(i));\n            i++;\n        }\n    }", "signature": "@Test\n    public void testOptionComparatorDefaultOrder()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testOptionComparatorInsertedOrder() {\n        final Collection<Option> options = getOptions().getOptions();\n        int i = 0;\n        for (final Option o : options) {\n            assertEquals(o.getOpt(), insertedOrder.get(i));\n            i++;\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOptionComparatorInsertedOrder", "params": [], "body": "                                                    {\n        final Collection<Option> options = getOptions().getOptions();\n        int i = 0;\n        for (final Option o : options) {\n            assertEquals(o.getOpt(), insertedOrder.get(i));\n            i++;\n        }\n    }", "signature": "@Test\n    public void testOptionComparatorInsertedOrder()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugsTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli.bug;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.GnuParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.MissingArgumentException;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.OptionBuilder;\nimport org.apache.commons.cli.OptionGroup;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.commons.cli.Parser;\nimport org.apache.commons.cli.PosixParser;\nimport org.junit.jupiter.api.Test;\n\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugsTest {\n    @Test\n    public void test11456() throws Exception {\n        // POSIX\n        Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArg().create('a'));\n        options.addOption(OptionBuilder.hasArg().create('b'));\n        String[] args = {\"-a\", \"-bvalue\"};\n\n        CommandLineParser parser = new PosixParser();\n\n        CommandLine cmd = parser.parse(options, args);\n        assertEquals(cmd.getOptionValue('b'), \"value\");\n\n        // GNU\n        options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArg().create('a'));\n        options.addOption(OptionBuilder.hasArg().create('b'));\n        args = new String[] {\"-a\", \"-b\", \"value\"};\n\n        parser = new GnuParser();\n\n        cmd = parser.parse(options, args);\n        assertEquals(cmd.getOptionValue('b'), \"value\");\n    }\n\n    @Test\n    public void test11457() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n        final String[] args = {\"--verbose\"};\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine cmd = parser.parse(options, args);\n        assertTrue(cmd.hasOption(\"verbose\"));\n    }\n\n    @Test\n    public void test11458() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator('=').hasArgs().create('D'));\n        options.addOption(OptionBuilder.withValueSeparator(':').hasArgs().create('p'));\n        final String[] args = {\"-DJAVA_HOME=/opt/java\", \"-pfile1:file2:file3\"};\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine cmd = parser.parse(options, args);\n\n        String[] values = cmd.getOptionValues('D');\n\n        assertEquals(values[0], \"JAVA_HOME\");\n        assertEquals(values[1], \"/opt/java\");\n\n        values = cmd.getOptionValues('p');\n\n        assertEquals(values[0], \"file1\");\n        assertEquals(values[1], \"file2\");\n        assertEquals(values[2], \"file3\");\n\n        final Iterator<Option> iter = cmd.iterator();\n        while (iter.hasNext()) {\n            final Option opt = iter.next();\n            switch (opt.getId()) {\n            case 'D':\n                assertEquals(opt.getValue(0), \"JAVA_HOME\");\n                assertEquals(opt.getValue(1), \"/opt/java\");\n                break;\n            case 'p':\n                assertEquals(opt.getValue(0), \"file1\");\n                assertEquals(opt.getValue(1), \"file2\");\n                assertEquals(opt.getValue(2), \"file3\");\n                break;\n            default:\n                fail(\"-D option not found\");\n            }\n        }\n    }\n\n    @Test\n    public void test11680() throws Exception {\n        final Options options = new Options();\n        final Option optionF = options.addOption(\"f\", true, \"foobar\").getOption(\"f\");\n        final Option optionM = options.addOption(\"m\", true, \"missing\").getOption(\"m\");\n        final String[] args = { \"-f\", \"foo\" };\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine cmd = parser.parse(options, args);\n        // 1.7.0 API:\n        cmd.getOptionValue(optionF, () -> \"default f\");\n        cmd.getOptionValue(optionM, () -> \"default m\");\n        // 1.7.0 API:\n        cmd.getOptionValue('f', () -> \"default f\");\n        cmd.getOptionValue('m', () -> \"default m\");\n        // 1.5.0 API:\n        cmd.getOptionValue(optionF, \"default f\");\n        cmd.getOptionValue(optionM, \"default m\");\n        // Original API:\n        cmd.getOptionValue(\"f\", \"default f\");\n        cmd.getOptionValue(\"m\", \"default m\");\n        //\n        assertNull(cmd.getOptionValue((String) null, (String) null));\n        assertEquals(\"default\", cmd.getOptionValue((String) null, \"default\"));\n    }\n\n    @Test\n    public void test12210() throws Exception {\n        // create the main options object which will handle the first parameter\n        final Options mainOptions = new Options();\n        // There can be 2 main exclusive options: -exec|-rep\n\n        // Therefore, place them in an option group\n\n        String[] argv = {\"-exec\", \"-exec_opt1\", \"-exec_opt2\"};\n        final OptionGroup grp = new OptionGroup();\n\n        grp.addOption(new Option(\"exec\", false, \"description for this option\"));\n\n        grp.addOption(new Option(\"rep\", false, \"description for this option\"));\n\n        mainOptions.addOptionGroup(grp);\n\n        // for the exec option, there are 2 options...\n        final Options execOptions = new Options();\n        execOptions.addOption(\"exec_opt1\", false, \" desc\");\n        execOptions.addOption(\"exec_opt2\", false, \" desc\");\n\n        // similarly, for rep there are 2 options...\n        final Options repOptions = new Options();\n        repOptions.addOption(\"repopto\", false, \"desc\");\n        repOptions.addOption(\"repoptt\", false, \"desc\");\n\n        // create the parser\n        final GnuParser parser = new GnuParser();\n\n        // finally, parse the arguments:\n\n        // first parse the main options to see what the user has specified\n        // We set stopAtNonOption to true so it does not touch the remaining\n        // options\n        CommandLine cmd = parser.parse(mainOptions, argv, true);\n        // get the remaining options...\n        argv = cmd.getArgs();\n\n        if (cmd.hasOption(\"exec\")) {\n            cmd = parser.parse(execOptions, argv, false);\n            // process the exec_op1 and exec_opt2...\n            assertTrue(cmd.hasOption(\"exec_opt1\"));\n            assertTrue(cmd.hasOption(\"exec_opt2\"));\n        } else if (cmd.hasOption(\"rep\")) {\n            cmd = parser.parse(repOptions, argv, false);\n            // process the rep_op1 and rep_opt2...\n        } else {\n            fail(\"exec option not found\");\n        }\n    }\n\n    @Test\n    public void test13425() throws Exception {\n        final Options options = new Options();\n        //@formatter:off\n        final Option oldpass = OptionBuilder.withLongOpt(\"old-password\")\n            .withDescription(\"Use this option to specify the old password\")\n            .hasArg()\n            .create('o');\n        final Option newpass = OptionBuilder.withLongOpt(\"new-password\")\n            .withDescription(\"Use this option to specify the new password\")\n            .hasArg()\n            .create('n');\n        //@formatter:on\n\n        final String[] args = {\"-o\", \"-n\", \"newpassword\"};\n\n        options.addOption(oldpass);\n        options.addOption(newpass);\n\n        final Parser parser = new PosixParser();\n\n        try {\n            parser.parse(options, args);\n            fail(\"MissingArgumentException not caught.\");\n        } catch (final MissingArgumentException expected) {\n        }\n    }\n\n    @Test\n    public void test13666() throws Exception {\n        final Options options = new Options();\n        final Option dirOption = OptionBuilder.withDescription(\"dir\").hasArg().create('d');\n        options.addOption(dirOption);\n        final PrintStream oldSystemOut = System.out;\n        try {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final String eol = System.lineSeparator();\n            System.setOut(new PrintStream(baos));\n            final HelpFormatter formatter = new HelpFormatter();\n            formatter.printHelp(\"dir\", options);\n            assertEquals(\"usage: dir\" + eol + \" -d <arg>   dir\" + eol, baos.toString());\n        } finally {\n            System.setOut(oldSystemOut);\n        }\n    }\n\n    @Test\n    public void test13666_Builder() throws Exception {\n        final Options options = new Options();\n        final Option dirOption = OptionBuilder.withDescription(\"dir\").hasArg().create('d');\n        options.addOption(dirOption);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final String eol = System.lineSeparator();\n        final HelpFormatter formatter = HelpFormatter.builder().setPrintWriter(new PrintWriter(baos)).get();\n        formatter.printHelp(\"dir\", options);\n        assertEquals(\"usage: dir\" + eol + \" -d <arg>   dir\" + eol, baos.toString());\n    }\n\n    @Test\n    public void test13935() throws Exception {\n        final OptionGroup directions = new OptionGroup();\n\n        final Option left = new Option(\"l\", \"left\", false, \"go left\");\n        final Option right = new Option(\"r\", \"right\", false, \"go right\");\n        final Option straight = new Option(\"s\", \"straight\", false, \"go straight\");\n        final Option forward = new Option(\"f\", \"forward\", false, \"go forward\");\n        forward.setRequired(true);\n\n        directions.addOption(left);\n        directions.addOption(right);\n        directions.setRequired(true);\n\n        final Options opts = new Options();\n        opts.addOptionGroup(directions);\n        opts.addOption(straight);\n\n        final CommandLineParser parser = new PosixParser();\n\n        String[] args = {};\n        try {\n            parser.parse(opts, args);\n            fail(\"Expected ParseException\");\n        } catch (final ParseException expected) {\n        }\n\n        args = new String[] {\"-s\"};\n        try {\n            parser.parse(opts, args);\n            fail(\"Expected ParseException\");\n        } catch (final ParseException expected) {\n        }\n\n        args = new String[] {\"-s\", \"-l\"};\n        CommandLine line = parser.parse(opts, args);\n        assertNotNull(line);\n\n        opts.addOption(forward);\n        args = new String[] {\"-s\", \"-l\", \"-f\"};\n        line = parser.parse(opts, args);\n        assertNotNull(line);\n    }\n\n    @Test\n    public void test14786() throws Exception {\n        final Option o = OptionBuilder.isRequired().withDescription(\"test\").create(\"test\");\n        final Options opts = new Options();\n        opts.addOption(o);\n        opts.addOption(o);\n\n        final CommandLineParser parser = new GnuParser();\n\n        final String[] args = {\"-test\"};\n\n        final CommandLine line = parser.parse(opts, args);\n        assertTrue(line.hasOption(\"test\"));\n    }\n\n    @Test\n    public void test15046() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] cliArgs = {\"-z\", \"c\"};\n\n        final Options options = new Options();\n        options.addOption(new Option(\"z\", \"timezone\", true, \"affected option\"));\n\n        parser.parse(options, cliArgs);\n\n        // now add conflicting option\n        options.addOption(\"c\", \"conflict\", true, \"conflict option\");\n        final CommandLine line = parser.parse(options, cliArgs);\n        assertEquals(line.getOptionValue('z'), \"c\");\n        assertFalse(line.hasOption(\"c\"));\n    }\n\n    @Test\n    public void test15648() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-m\", \"\\\"Two Words\\\"\"};\n        final Option m = OptionBuilder.hasArgs().create(\"m\");\n        final Options options = new Options();\n        options.addOption(m);\n        final CommandLine line = parser.parse(options, args);\n        assertEquals(\"Two Words\", line.getOptionValue(\"m\"));\n    }\n\n    @Test\n    public void test31148() throws ParseException {\n        final Option multiArgOption = new Option(\"o\", \"option with multiple args\");\n        multiArgOption.setArgs(1);\n\n        final Options options = new Options();\n        options.addOption(multiArgOption);\n\n        final Parser parser = new PosixParser();\n        final String[] args = {};\n        final Properties props = new Properties();\n        props.setProperty(\"o\", \"ovalue\");\n        final CommandLine cl = parser.parse(options, args, props);\n\n        assertTrue(cl.hasOption('o'));\n        assertEquals(\"ovalue\", cl.getOptionValue('o'));\n    }\n\n}\n", "file_hash": "7394905f1694e9615436ca612fdf5e5324c19b2013cadbf5b9cf2f5838f69050", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import static org.junit.jupiter.api.Assertions.fail;", "import java.io.ByteArrayOutputStream;", "import java.io.PrintStream;", "import java.io.PrintWriter;", "import java.util.Iterator;", "import java.util.Properties;", "import org.apache.commons.cli.CommandLine;", "import org.apache.commons.cli.CommandLineParser;", "import org.apache.commons.cli.GnuParser;", "import org.apache.commons.cli.HelpFormatter;", "import org.apache.commons.cli.MissingArgumentException;", "import org.apache.commons.cli.Option;", "import org.apache.commons.cli.OptionBuilder;", "import org.apache.commons.cli.OptionGroup;", "import org.apache.commons.cli.Options;", "import org.apache.commons.cli.ParseException;", "import org.apache.commons.cli.Parser;", "import org.apache.commons.cli.PosixParser;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugsTest {\n    @Test\n    public void test11456() throws Exception {\n        // POSIX\n        Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArg().create('a'));\n        options.addOption(OptionBuilder.hasArg().create('b'));\n        String[] args = {\"-a\", \"-bvalue\"};\n\n        CommandLineParser parser = new PosixParser();\n\n        CommandLine cmd = parser.parse(options, args);\n        assertEquals(cmd.getOptionValue('b'), \"value\");\n\n        // GNU\n        options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArg().create('a'));\n        options.addOption(OptionBuilder.hasArg().create('b'));\n        args = new String[] {\"-a\", \"-b\", \"value\"};\n\n        parser = new GnuParser();\n\n        cmd = parser.parse(options, args);\n        assertEquals(cmd.getOptionValue('b'), \"value\");\n    }\n\n    @Test\n    public void test11457() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n        final String[] args = {\"--verbose\"};\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine cmd = parser.parse(options, args);\n        assertTrue(cmd.hasOption(\"verbose\"));\n    }\n\n    @Test\n    public void test11458() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator('=').hasArgs().create('D'));\n        options.addOption(OptionBuilder.withValueSeparator(':').hasArgs().create('p'));\n        final String[] args = {\"-DJAVA_HOME=/opt/java\", \"-pfile1:file2:file3\"};\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine cmd = parser.parse(options, args);\n\n        String[] values = cmd.getOptionValues('D');\n\n        assertEquals(values[0], \"JAVA_HOME\");\n        assertEquals(values[1], \"/opt/java\");\n\n        values = cmd.getOptionValues('p');\n\n        assertEquals(values[0], \"file1\");\n        assertEquals(values[1], \"file2\");\n        assertEquals(values[2], \"file3\");\n\n        final Iterator<Option> iter = cmd.iterator();\n        while (iter.hasNext()) {\n            final Option opt = iter.next();\n            switch (opt.getId()) {\n            case 'D':\n                assertEquals(opt.getValue(0), \"JAVA_HOME\");\n                assertEquals(opt.getValue(1), \"/opt/java\");\n                break;\n            case 'p':\n                assertEquals(opt.getValue(0), \"file1\");\n                assertEquals(opt.getValue(1), \"file2\");\n                assertEquals(opt.getValue(2), \"file3\");\n                break;\n            default:\n                fail(\"-D option not found\");\n            }\n        }\n    }\n\n    @Test\n    public void test11680() throws Exception {\n        final Options options = new Options();\n        final Option optionF = options.addOption(\"f\", true, \"foobar\").getOption(\"f\");\n        final Option optionM = options.addOption(\"m\", true, \"missing\").getOption(\"m\");\n        final String[] args = { \"-f\", \"foo\" };\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine cmd = parser.parse(options, args);\n        // 1.7.0 API:\n        cmd.getOptionValue(optionF, () -> \"default f\");\n        cmd.getOptionValue(optionM, () -> \"default m\");\n        // 1.7.0 API:\n        cmd.getOptionValue('f', () -> \"default f\");\n        cmd.getOptionValue('m', () -> \"default m\");\n        // 1.5.0 API:\n        cmd.getOptionValue(optionF, \"default f\");\n        cmd.getOptionValue(optionM, \"default m\");\n        // Original API:\n        cmd.getOptionValue(\"f\", \"default f\");\n        cmd.getOptionValue(\"m\", \"default m\");\n        //\n        assertNull(cmd.getOptionValue((String) null, (String) null));\n        assertEquals(\"default\", cmd.getOptionValue((String) null, \"default\"));\n    }\n\n    @Test\n    public void test12210() throws Exception {\n        // create the main options object which will handle the first parameter\n        final Options mainOptions = new Options();\n        // There can be 2 main exclusive options: -exec|-rep\n\n        // Therefore, place them in an option group\n\n        String[] argv = {\"-exec\", \"-exec_opt1\", \"-exec_opt2\"};\n        final OptionGroup grp = new OptionGroup();\n\n        grp.addOption(new Option(\"exec\", false, \"description for this option\"));\n\n        grp.addOption(new Option(\"rep\", false, \"description for this option\"));\n\n        mainOptions.addOptionGroup(grp);\n\n        // for the exec option, there are 2 options...\n        final Options execOptions = new Options();\n        execOptions.addOption(\"exec_opt1\", false, \" desc\");\n        execOptions.addOption(\"exec_opt2\", false, \" desc\");\n\n        // similarly, for rep there are 2 options...\n        final Options repOptions = new Options();\n        repOptions.addOption(\"repopto\", false, \"desc\");\n        repOptions.addOption(\"repoptt\", false, \"desc\");\n\n        // create the parser\n        final GnuParser parser = new GnuParser();\n\n        // finally, parse the arguments:\n\n        // first parse the main options to see what the user has specified\n        // We set stopAtNonOption to true so it does not touch the remaining\n        // options\n        CommandLine cmd = parser.parse(mainOptions, argv, true);\n        // get the remaining options...\n        argv = cmd.getArgs();\n\n        if (cmd.hasOption(\"exec\")) {\n            cmd = parser.parse(execOptions, argv, false);\n            // process the exec_op1 and exec_opt2...\n            assertTrue(cmd.hasOption(\"exec_opt1\"));\n            assertTrue(cmd.hasOption(\"exec_opt2\"));\n        } else if (cmd.hasOption(\"rep\")) {\n            cmd = parser.parse(repOptions, argv, false);\n            // process the rep_op1 and rep_opt2...\n        } else {\n            fail(\"exec option not found\");\n        }\n    }\n\n    @Test\n    public void test13425() throws Exception {\n        final Options options = new Options();\n        //@formatter:off\n        final Option oldpass = OptionBuilder.withLongOpt(\"old-password\")\n            .withDescription(\"Use this option to specify the old password\")\n            .hasArg()\n            .create('o');\n        final Option newpass = OptionBuilder.withLongOpt(\"new-password\")\n            .withDescription(\"Use this option to specify the new password\")\n            .hasArg()\n            .create('n');\n        //@formatter:on\n\n        final String[] args = {\"-o\", \"-n\", \"newpassword\"};\n\n        options.addOption(oldpass);\n        options.addOption(newpass);\n\n        final Parser parser = new PosixParser();\n\n        try {\n            parser.parse(options, args);\n            fail(\"MissingArgumentException not caught.\");\n        } catch (final MissingArgumentException expected) {\n        }\n    }\n\n    @Test\n    public void test13666() throws Exception {\n        final Options options = new Options();\n        final Option dirOption = OptionBuilder.withDescription(\"dir\").hasArg().create('d');\n        options.addOption(dirOption);\n        final PrintStream oldSystemOut = System.out;\n        try {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final String eol = System.lineSeparator();\n            System.setOut(new PrintStream(baos));\n            final HelpFormatter formatter = new HelpFormatter();\n            formatter.printHelp(\"dir\", options);\n            assertEquals(\"usage: dir\" + eol + \" -d <arg>   dir\" + eol, baos.toString());\n        } finally {\n            System.setOut(oldSystemOut);\n        }\n    }\n\n    @Test\n    public void test13666_Builder() throws Exception {\n        final Options options = new Options();\n        final Option dirOption = OptionBuilder.withDescription(\"dir\").hasArg().create('d');\n        options.addOption(dirOption);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final String eol = System.lineSeparator();\n        final HelpFormatter formatter = HelpFormatter.builder().setPrintWriter(new PrintWriter(baos)).get();\n        formatter.printHelp(\"dir\", options);\n        assertEquals(\"usage: dir\" + eol + \" -d <arg>   dir\" + eol, baos.toString());\n    }\n\n    @Test\n    public void test13935() throws Exception {\n        final OptionGroup directions = new OptionGroup();\n\n        final Option left = new Option(\"l\", \"left\", false, \"go left\");\n        final Option right = new Option(\"r\", \"right\", false, \"go right\");\n        final Option straight = new Option(\"s\", \"straight\", false, \"go straight\");\n        final Option forward = new Option(\"f\", \"forward\", false, \"go forward\");\n        forward.setRequired(true);\n\n        directions.addOption(left);\n        directions.addOption(right);\n        directions.setRequired(true);\n\n        final Options opts = new Options();\n        opts.addOptionGroup(directions);\n        opts.addOption(straight);\n\n        final CommandLineParser parser = new PosixParser();\n\n        String[] args = {};\n        try {\n            parser.parse(opts, args);\n            fail(\"Expected ParseException\");\n        } catch (final ParseException expected) {\n        }\n\n        args = new String[] {\"-s\"};\n        try {\n            parser.parse(opts, args);\n            fail(\"Expected ParseException\");\n        } catch (final ParseException expected) {\n        }\n\n        args = new String[] {\"-s\", \"-l\"};\n        CommandLine line = parser.parse(opts, args);\n        assertNotNull(line);\n\n        opts.addOption(forward);\n        args = new String[] {\"-s\", \"-l\", \"-f\"};\n        line = parser.parse(opts, args);\n        assertNotNull(line);\n    }\n\n    @Test\n    public void test14786() throws Exception {\n        final Option o = OptionBuilder.isRequired().withDescription(\"test\").create(\"test\");\n        final Options opts = new Options();\n        opts.addOption(o);\n        opts.addOption(o);\n\n        final CommandLineParser parser = new GnuParser();\n\n        final String[] args = {\"-test\"};\n\n        final CommandLine line = parser.parse(opts, args);\n        assertTrue(line.hasOption(\"test\"));\n    }\n\n    @Test\n    public void test15046() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] cliArgs = {\"-z\", \"c\"};\n\n        final Options options = new Options();\n        options.addOption(new Option(\"z\", \"timezone\", true, \"affected option\"));\n\n        parser.parse(options, cliArgs);\n\n        // now add conflicting option\n        options.addOption(\"c\", \"conflict\", true, \"conflict option\");\n        final CommandLine line = parser.parse(options, cliArgs);\n        assertEquals(line.getOptionValue('z'), \"c\");\n        assertFalse(line.hasOption(\"c\"));\n    }\n\n    @Test\n    public void test15648() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-m\", \"\\\"Two Words\\\"\"};\n        final Option m = OptionBuilder.hasArgs().create(\"m\");\n        final Options options = new Options();\n        options.addOption(m);\n        final CommandLine line = parser.parse(options, args);\n        assertEquals(\"Two Words\", line.getOptionValue(\"m\"));\n    }\n\n    @Test\n    public void test31148() throws ParseException {\n        final Option multiArgOption = new Option(\"o\", \"option with multiple args\");\n        multiArgOption.setArgs(1);\n\n        final Options options = new Options();\n        options.addOption(multiArgOption);\n\n        final Parser parser = new PosixParser();\n        final String[] args = {};\n        final Properties props = new Properties();\n        props.setProperty(\"o\", \"ovalue\");\n        final CommandLine cl = parser.parse(options, args, props);\n\n        assertTrue(cl.hasOption('o'));\n        assertEquals(\"ovalue\", cl.getOptionValue('o'));\n    }\n\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugsTest", "class_docstring": "", "name": "BugsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void test11456() throws Exception {\n        // POSIX\n        Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArg().create('a'));\n        options.addOption(OptionBuilder.hasArg().create('b'));\n        String[] args = {\"-a\", \"-bvalue\"};\n\n        CommandLineParser parser = new PosixParser();\n\n        CommandLine cmd = parser.parse(options, args);\n        assertEquals(cmd.getOptionValue('b'), \"value\");\n\n        // GNU\n        options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArg().create('a'));\n        options.addOption(OptionBuilder.hasArg().create('b'));\n        args = new String[] {\"-a\", \"-b\", \"value\"};\n\n        parser = new GnuParser();\n\n        cmd = parser.parse(options, args);\n        assertEquals(cmd.getOptionValue('b'), \"value\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test11456", "params": [], "body": "                                             {\n        // POSIX\n        Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArg().create('a'));\n        options.addOption(OptionBuilder.hasArg().create('b'));\n        String[] args = {\"-a\", \"-bvalue\"};\n\n        CommandLineParser parser = new PosixParser();\n\n        CommandLine cmd = parser.parse(options, args);\n        assertEquals(cmd.getOptionValue('b'), \"value\");\n\n        // GNU\n        options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArg().create('a'));\n        options.addOption(OptionBuilder.hasArg().create('b'));\n        args = new String[] {\"-a\", \"-b\", \"value\"};\n\n        parser = new GnuParser();\n\n        cmd = parser.parse(options, args);\n        assertEquals(cmd.getOptionValue('b'), \"value\");\n    }", "signature": "@Test\n    public void test11456()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test11457() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n        final String[] args = {\"--verbose\"};\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine cmd = parser.parse(options, args);\n        assertTrue(cmd.hasOption(\"verbose\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test11457", "params": [], "body": "                                             {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n        final String[] args = {\"--verbose\"};\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine cmd = parser.parse(options, args);\n        assertTrue(cmd.hasOption(\"verbose\"));\n    }", "signature": "@Test\n    public void test11457()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test11458() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator('=').hasArgs().create('D'));\n        options.addOption(OptionBuilder.withValueSeparator(':').hasArgs().create('p'));\n        final String[] args = {\"-DJAVA_HOME=/opt/java\", \"-pfile1:file2:file3\"};\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine cmd = parser.parse(options, args);\n\n        String[] values = cmd.getOptionValues('D');\n\n        assertEquals(values[0], \"JAVA_HOME\");\n        assertEquals(values[1], \"/opt/java\");\n\n        values = cmd.getOptionValues('p');\n\n        assertEquals(values[0], \"file1\");\n        assertEquals(values[1], \"file2\");\n        assertEquals(values[2], \"file3\");\n\n        final Iterator<Option> iter = cmd.iterator();\n        while (iter.hasNext()) {\n            final Option opt = iter.next();\n            switch (opt.getId()) {\n            case 'D':\n                assertEquals(opt.getValue(0), \"JAVA_HOME\");\n                assertEquals(opt.getValue(1), \"/opt/java\");\n                break;\n            case 'p':\n                assertEquals(opt.getValue(0), \"file1\");\n                assertEquals(opt.getValue(1), \"file2\");\n                assertEquals(opt.getValue(2), \"file3\");\n                break;\n            default:\n                fail(\"-D option not found\");\n            }\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test11458", "params": [], "body": "                                             {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator('=').hasArgs().create('D'));\n        options.addOption(OptionBuilder.withValueSeparator(':').hasArgs().create('p'));\n        final String[] args = {\"-DJAVA_HOME=/opt/java\", \"-pfile1:file2:file3\"};\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine cmd = parser.parse(options, args);\n\n        String[] values = cmd.getOptionValues('D');\n\n        assertEquals(values[0], \"JAVA_HOME\");\n        assertEquals(values[1], \"/opt/java\");\n\n        values = cmd.getOptionValues('p');\n\n        assertEquals(values[0], \"file1\");\n        assertEquals(values[1], \"file2\");\n        assertEquals(values[2], \"file3\");\n\n        final Iterator<Option> iter = cmd.iterator();\n        while (iter.hasNext()) {\n            final Option opt = iter.next();\n            switch (opt.getId()) {\n            case 'D':\n                assertEquals(opt.getValue(0), \"JAVA_HOME\");\n                assertEquals(opt.getValue(1), \"/opt/java\");\n                break;\n            case 'p':\n                assertEquals(opt.getValue(0), \"file1\");\n                assertEquals(opt.getValue(1), \"file2\");\n                assertEquals(opt.getValue(2), \"file3\");\n                break;\n            default:\n                fail(\"-D option not found\");\n            }\n        }\n    }", "signature": "@Test\n    public void test11458()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test11680() throws Exception {\n        final Options options = new Options();\n        final Option optionF = options.addOption(\"f\", true, \"foobar\").getOption(\"f\");\n        final Option optionM = options.addOption(\"m\", true, \"missing\").getOption(\"m\");\n        final String[] args = { \"-f\", \"foo\" };\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine cmd = parser.parse(options, args);\n        // 1.7.0 API:\n        cmd.getOptionValue(optionF, () -> \"default f\");\n        cmd.getOptionValue(optionM, () -> \"default m\");\n        // 1.7.0 API:\n        cmd.getOptionValue('f', () -> \"default f\");\n        cmd.getOptionValue('m', () -> \"default m\");\n        // 1.5.0 API:\n        cmd.getOptionValue(optionF, \"default f\");\n        cmd.getOptionValue(optionM, \"default m\");\n        // Original API:\n        cmd.getOptionValue(\"f\", \"default f\");\n        cmd.getOptionValue(\"m\", \"default m\");\n        //\n        assertNull(cmd.getOptionValue((String) null, (String) null));\n        assertEquals(\"default\", cmd.getOptionValue((String) null, \"default\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test11680", "params": [], "body": "                                             {\n        final Options options = new Options();\n        final Option optionF = options.addOption(\"f\", true, \"foobar\").getOption(\"f\");\n        final Option optionM = options.addOption(\"m\", true, \"missing\").getOption(\"m\");\n        final String[] args = { \"-f\", \"foo\" };\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine cmd = parser.parse(options, args);\n        // 1.7.0 API:\n        cmd.getOptionValue(optionF, () -> \"default f\");\n        cmd.getOptionValue(optionM, () -> \"default m\");\n        // 1.7.0 API:\n        cmd.getOptionValue('f', () -> \"default f\");\n        cmd.getOptionValue('m', () -> \"default m\");\n        // 1.5.0 API:\n        cmd.getOptionValue(optionF, \"default f\");\n        cmd.getOptionValue(optionM, \"default m\");\n        // Original API:\n        cmd.getOptionValue(\"f\", \"default f\");\n        cmd.getOptionValue(\"m\", \"default m\");\n        //\n        assertNull(cmd.getOptionValue((String) null, (String) null));\n        assertEquals(\"default\", cmd.getOptionValue((String) null, \"default\"));\n    }", "signature": "@Test\n    public void test11680()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test12210() throws Exception {\n        // create the main options object which will handle the first parameter\n        final Options mainOptions = new Options();\n        // There can be 2 main exclusive options: -exec|-rep\n\n        // Therefore, place them in an option group\n\n        String[] argv = {\"-exec\", \"-exec_opt1\", \"-exec_opt2\"};\n        final OptionGroup grp = new OptionGroup();\n\n        grp.addOption(new Option(\"exec\", false, \"description for this option\"));\n\n        grp.addOption(new Option(\"rep\", false, \"description for this option\"));\n\n        mainOptions.addOptionGroup(grp);\n\n        // for the exec option, there are 2 options...\n        final Options execOptions = new Options();\n        execOptions.addOption(\"exec_opt1\", false, \" desc\");\n        execOptions.addOption(\"exec_opt2\", false, \" desc\");\n\n        // similarly, for rep there are 2 options...\n        final Options repOptions = new Options();\n        repOptions.addOption(\"repopto\", false, \"desc\");\n        repOptions.addOption(\"repoptt\", false, \"desc\");\n\n        // create the parser\n        final GnuParser parser = new GnuParser();\n\n        // finally, parse the arguments:\n\n        // first parse the main options to see what the user has specified\n        // We set stopAtNonOption to true so it does not touch the remaining\n        // options\n        CommandLine cmd = parser.parse(mainOptions, argv, true);\n        // get the remaining options...\n        argv = cmd.getArgs();\n\n        if (cmd.hasOption(\"exec\")) {\n            cmd = parser.parse(execOptions, argv, false);\n            // process the exec_op1 and exec_opt2...\n            assertTrue(cmd.hasOption(\"exec_opt1\"));\n            assertTrue(cmd.hasOption(\"exec_opt2\"));\n        } else if (cmd.hasOption(\"rep\")) {\n            cmd = parser.parse(repOptions, argv, false);\n            // process the rep_op1 and rep_opt2...\n        } else {\n            fail(\"exec option not found\");\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test12210", "params": [], "body": "                                             {\n        // create the main options object which will handle the first parameter\n        final Options mainOptions = new Options();\n        // There can be 2 main exclusive options: -exec|-rep\n\n        // Therefore, place them in an option group\n\n        String[] argv = {\"-exec\", \"-exec_opt1\", \"-exec_opt2\"};\n        final OptionGroup grp = new OptionGroup();\n\n        grp.addOption(new Option(\"exec\", false, \"description for this option\"));\n\n        grp.addOption(new Option(\"rep\", false, \"description for this option\"));\n\n        mainOptions.addOptionGroup(grp);\n\n        // for the exec option, there are 2 options...\n        final Options execOptions = new Options();\n        execOptions.addOption(\"exec_opt1\", false, \" desc\");\n        execOptions.addOption(\"exec_opt2\", false, \" desc\");\n\n        // similarly, for rep there are 2 options...\n        final Options repOptions = new Options();\n        repOptions.addOption(\"repopto\", false, \"desc\");\n        repOptions.addOption(\"repoptt\", false, \"desc\");\n\n        // create the parser\n        final GnuParser parser = new GnuParser();\n\n        // finally, parse the arguments:\n\n        // first parse the main options to see what the user has specified\n        // We set stopAtNonOption to true so it does not touch the remaining\n        // options\n        CommandLine cmd = parser.parse(mainOptions, argv, true);\n        // get the remaining options...\n        argv = cmd.getArgs();\n\n        if (cmd.hasOption(\"exec\")) {\n            cmd = parser.parse(execOptions, argv, false);\n            // process the exec_op1 and exec_opt2...\n            assertTrue(cmd.hasOption(\"exec_opt1\"));\n            assertTrue(cmd.hasOption(\"exec_opt2\"));\n        } else if (cmd.hasOption(\"rep\")) {\n            cmd = parser.parse(repOptions, argv, false);\n            // process the rep_op1 and rep_opt2...\n        } else {\n            fail(\"exec option not found\");\n        }\n    }", "signature": "@Test\n    public void test12210()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test13425() throws Exception {\n        final Options options = new Options();\n        //@formatter:off\n        final Option oldpass = OptionBuilder.withLongOpt(\"old-password\")\n            .withDescription(\"Use this option to specify the old password\")\n            .hasArg()\n            .create('o');\n        final Option newpass = OptionBuilder.withLongOpt(\"new-password\")\n            .withDescription(\"Use this option to specify the new password\")\n            .hasArg()\n            .create('n');\n        //@formatter:on\n\n        final String[] args = {\"-o\", \"-n\", \"newpassword\"};\n\n        options.addOption(oldpass);\n        options.addOption(newpass);\n\n        final Parser parser = new PosixParser();\n\n        try {\n            parser.parse(options, args);\n            fail(\"MissingArgumentException not caught.\");\n        } catch (final MissingArgumentException expected) {\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test13425", "params": [], "body": "                                             {\n        final Options options = new Options();\n        //@formatter:off\n        final Option oldpass = OptionBuilder.withLongOpt(\"old-password\")\n            .withDescription(\"Use this option to specify the old password\")\n            .hasArg()\n            .create('o');\n        final Option newpass = OptionBuilder.withLongOpt(\"new-password\")\n            .withDescription(\"Use this option to specify the new password\")\n            .hasArg()\n            .create('n');\n        //@formatter:on\n\n        final String[] args = {\"-o\", \"-n\", \"newpassword\"};\n\n        options.addOption(oldpass);\n        options.addOption(newpass);\n\n        final Parser parser = new PosixParser();\n\n        try {\n            parser.parse(options, args);\n            fail(\"MissingArgumentException not caught.\");\n        } catch (final MissingArgumentException expected) {\n        }\n    }", "signature": "@Test\n    public void test13425()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test13666() throws Exception {\n        final Options options = new Options();\n        final Option dirOption = OptionBuilder.withDescription(\"dir\").hasArg().create('d');\n        options.addOption(dirOption);\n        final PrintStream oldSystemOut = System.out;\n        try {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final String eol = System.lineSeparator();\n            System.setOut(new PrintStream(baos));\n            final HelpFormatter formatter = new HelpFormatter();\n            formatter.printHelp(\"dir\", options);\n            assertEquals(\"usage: dir\" + eol + \" -d <arg>   dir\" + eol, baos.toString());\n        } finally {\n            System.setOut(oldSystemOut);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test13666", "params": [], "body": "                                             {\n        final Options options = new Options();\n        final Option dirOption = OptionBuilder.withDescription(\"dir\").hasArg().create('d');\n        options.addOption(dirOption);\n        final PrintStream oldSystemOut = System.out;\n        try {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final String eol = System.lineSeparator();\n            System.setOut(new PrintStream(baos));\n            final HelpFormatter formatter = new HelpFormatter();\n            formatter.printHelp(\"dir\", options);\n            assertEquals(\"usage: dir\" + eol + \" -d <arg>   dir\" + eol, baos.toString());\n        } finally {\n            System.setOut(oldSystemOut);\n        }\n    }", "signature": "@Test\n    public void test13666()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test13666_Builder() throws Exception {\n        final Options options = new Options();\n        final Option dirOption = OptionBuilder.withDescription(\"dir\").hasArg().create('d');\n        options.addOption(dirOption);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final String eol = System.lineSeparator();\n        final HelpFormatter formatter = HelpFormatter.builder().setPrintWriter(new PrintWriter(baos)).get();\n        formatter.printHelp(\"dir\", options);\n        assertEquals(\"usage: dir\" + eol + \" -d <arg>   dir\" + eol, baos.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test13666_Builder", "params": [], "body": "                                                     {\n        final Options options = new Options();\n        final Option dirOption = OptionBuilder.withDescription(\"dir\").hasArg().create('d');\n        options.addOption(dirOption);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final String eol = System.lineSeparator();\n        final HelpFormatter formatter = HelpFormatter.builder().setPrintWriter(new PrintWriter(baos)).get();\n        formatter.printHelp(\"dir\", options);\n        assertEquals(\"usage: dir\" + eol + \" -d <arg>   dir\" + eol, baos.toString());\n    }", "signature": "@Test\n    public void test13666_Builder()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test13935() throws Exception {\n        final OptionGroup directions = new OptionGroup();\n\n        final Option left = new Option(\"l\", \"left\", false, \"go left\");\n        final Option right = new Option(\"r\", \"right\", false, \"go right\");\n        final Option straight = new Option(\"s\", \"straight\", false, \"go straight\");\n        final Option forward = new Option(\"f\", \"forward\", false, \"go forward\");\n        forward.setRequired(true);\n\n        directions.addOption(left);\n        directions.addOption(right);\n        directions.setRequired(true);\n\n        final Options opts = new Options();\n        opts.addOptionGroup(directions);\n        opts.addOption(straight);\n\n        final CommandLineParser parser = new PosixParser();\n\n        String[] args = {};\n        try {\n            parser.parse(opts, args);\n            fail(\"Expected ParseException\");\n        } catch (final ParseException expected) {\n        }\n\n        args = new String[] {\"-s\"};\n        try {\n            parser.parse(opts, args);\n            fail(\"Expected ParseException\");\n        } catch (final ParseException expected) {\n        }\n\n        args = new String[] {\"-s\", \"-l\"};\n        CommandLine line = parser.parse(opts, args);\n        assertNotNull(line);\n\n        opts.addOption(forward);\n        args = new String[] {\"-s\", \"-l\", \"-f\"};\n        line = parser.parse(opts, args);\n        assertNotNull(line);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test13935", "params": [], "body": "                                             {\n        final OptionGroup directions = new OptionGroup();\n\n        final Option left = new Option(\"l\", \"left\", false, \"go left\");\n        final Option right = new Option(\"r\", \"right\", false, \"go right\");\n        final Option straight = new Option(\"s\", \"straight\", false, \"go straight\");\n        final Option forward = new Option(\"f\", \"forward\", false, \"go forward\");\n        forward.setRequired(true);\n\n        directions.addOption(left);\n        directions.addOption(right);\n        directions.setRequired(true);\n\n        final Options opts = new Options();\n        opts.addOptionGroup(directions);\n        opts.addOption(straight);\n\n        final CommandLineParser parser = new PosixParser();\n\n        String[] args = {};\n        try {\n            parser.parse(opts, args);\n            fail(\"Expected ParseException\");\n        } catch (final ParseException expected) {\n        }\n\n        args = new String[] {\"-s\"};\n        try {\n            parser.parse(opts, args);\n            fail(\"Expected ParseException\");\n        } catch (final ParseException expected) {\n        }\n\n        args = new String[] {\"-s\", \"-l\"};\n        CommandLine line = parser.parse(opts, args);\n        assertNotNull(line);\n\n        opts.addOption(forward);\n        args = new String[] {\"-s\", \"-l\", \"-f\"};\n        line = parser.parse(opts, args);\n        assertNotNull(line);\n    }", "signature": "@Test\n    public void test13935()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test14786() throws Exception {\n        final Option o = OptionBuilder.isRequired().withDescription(\"test\").create(\"test\");\n        final Options opts = new Options();\n        opts.addOption(o);\n        opts.addOption(o);\n\n        final CommandLineParser parser = new GnuParser();\n\n        final String[] args = {\"-test\"};\n\n        final CommandLine line = parser.parse(opts, args);\n        assertTrue(line.hasOption(\"test\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test14786", "params": [], "body": "                                             {\n        final Option o = OptionBuilder.isRequired().withDescription(\"test\").create(\"test\");\n        final Options opts = new Options();\n        opts.addOption(o);\n        opts.addOption(o);\n\n        final CommandLineParser parser = new GnuParser();\n\n        final String[] args = {\"-test\"};\n\n        final CommandLine line = parser.parse(opts, args);\n        assertTrue(line.hasOption(\"test\"));\n    }", "signature": "@Test\n    public void test14786()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test15046() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] cliArgs = {\"-z\", \"c\"};\n\n        final Options options = new Options();\n        options.addOption(new Option(\"z\", \"timezone\", true, \"affected option\"));\n\n        parser.parse(options, cliArgs);\n\n        // now add conflicting option\n        options.addOption(\"c\", \"conflict\", true, \"conflict option\");\n        final CommandLine line = parser.parse(options, cliArgs);\n        assertEquals(line.getOptionValue('z'), \"c\");\n        assertFalse(line.hasOption(\"c\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test15046", "params": [], "body": "                                             {\n        final CommandLineParser parser = new PosixParser();\n        final String[] cliArgs = {\"-z\", \"c\"};\n\n        final Options options = new Options();\n        options.addOption(new Option(\"z\", \"timezone\", true, \"affected option\"));\n\n        parser.parse(options, cliArgs);\n\n        // now add conflicting option\n        options.addOption(\"c\", \"conflict\", true, \"conflict option\");\n        final CommandLine line = parser.parse(options, cliArgs);\n        assertEquals(line.getOptionValue('z'), \"c\");\n        assertFalse(line.hasOption(\"c\"));\n    }", "signature": "@Test\n    public void test15046()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test15648() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-m\", \"\\\"Two Words\\\"\"};\n        final Option m = OptionBuilder.hasArgs().create(\"m\");\n        final Options options = new Options();\n        options.addOption(m);\n        final CommandLine line = parser.parse(options, args);\n        assertEquals(\"Two Words\", line.getOptionValue(\"m\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test15648", "params": [], "body": "                                             {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-m\", \"\\\"Two Words\\\"\"};\n        final Option m = OptionBuilder.hasArgs().create(\"m\");\n        final Options options = new Options();\n        options.addOption(m);\n        final CommandLine line = parser.parse(options, args);\n        assertEquals(\"Two Words\", line.getOptionValue(\"m\"));\n    }", "signature": "@Test\n    public void test15648()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void test31148() throws ParseException {\n        final Option multiArgOption = new Option(\"o\", \"option with multiple args\");\n        multiArgOption.setArgs(1);\n\n        final Options options = new Options();\n        options.addOption(multiArgOption);\n\n        final Parser parser = new PosixParser();\n        final String[] args = {};\n        final Properties props = new Properties();\n        props.setProperty(\"o\", \"ovalue\");\n        final CommandLine cl = parser.parse(options, args, props);\n\n        assertTrue(cl.hasOption('o'));\n        assertEquals(\"ovalue\", cl.getOptionValue('o'));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "test31148", "params": [], "body": "                                                  {\n        final Option multiArgOption = new Option(\"o\", \"option with multiple args\");\n        multiArgOption.setArgs(1);\n\n        final Options options = new Options();\n        options.addOption(multiArgOption);\n\n        final Parser parser = new PosixParser();\n        final String[] args = {};\n        final Properties props = new Properties();\n        props.setProperty(\"o\", \"ovalue\");\n        final CommandLine cl = parser.parse(options, args, props);\n\n        assertTrue(cl.hasOption('o'));\n        assertEquals(\"ovalue\", cl.getOptionValue('o'));\n    }", "signature": "@Test\n    public void test31148()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugCLI71Test.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli.bug;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.MissingArgumentException;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.PosixParser;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI71Test {\n    private Options options;\n    private CommandLineParser parser;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n\n        final Option algorithm = new Option(\"a\", \"algo\", true, \"the algorithm which it to perform executing\");\n        algorithm.setArgName(\"algorithm name\");\n        options.addOption(algorithm);\n\n        final Option key = new Option(\"k\", \"key\", true, \"the key the setted algorithm uses to process\");\n        algorithm.setArgName(\"value\");\n        options.addOption(key);\n\n        parser = new PosixParser();\n    }\n\n    @Test\n    public void testBasic() throws Exception {\n        final String[] args = {\"-a\", \"Caesar\", \"-k\", \"A\"};\n        final CommandLine line = parser.parse(options, args);\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"A\", line.getOptionValue(\"k\"));\n    }\n\n    @Test\n    public void testGetsDefaultIfOptional() throws Exception {\n        final String[] args = {\"-k\", \"-a\", \"Caesar\"};\n        options.getOption(\"k\").setOptionalArg(true);\n        final CommandLine line = parser.parse(options, args);\n\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"a\", line.getOptionValue('k', \"a\"));\n    }\n\n    @Test\n    public void testLackOfError() throws Exception {\n        final String[] args = {\"-k\", \"-a\", \"Caesar\"};\n        try {\n            parser.parse(options, args);\n            fail(\"MissingArgumentException expected\");\n        } catch (final MissingArgumentException e) {\n            assertEquals(\"k\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n    }\n\n    @Test\n    public void testMistakenArgument() throws Exception {\n        String[] args = {\"-a\", \"Caesar\", \"-k\", \"A\"};\n        CommandLine line = parser.parse(options, args);\n        args = new String[] {\"-a\", \"Caesar\", \"-k\", \"a\"};\n        line = parser.parse(options, args);\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"a\", line.getOptionValue(\"k\"));\n    }\n\n}\n", "file_hash": "6fbd58e656ed6431f6eaf679e94d22fdb31bc6c57d553508f86dd80803ecfe0b", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.fail;", "import org.apache.commons.cli.CommandLine;", "import org.apache.commons.cli.CommandLineParser;", "import org.apache.commons.cli.MissingArgumentException;", "import org.apache.commons.cli.Option;", "import org.apache.commons.cli.Options;", "import org.apache.commons.cli.PosixParser;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI71Test {\n    private Options options;\n    private CommandLineParser parser;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n\n        final Option algorithm = new Option(\"a\", \"algo\", true, \"the algorithm which it to perform executing\");\n        algorithm.setArgName(\"algorithm name\");\n        options.addOption(algorithm);\n\n        final Option key = new Option(\"k\", \"key\", true, \"the key the setted algorithm uses to process\");\n        algorithm.setArgName(\"value\");\n        options.addOption(key);\n\n        parser = new PosixParser();\n    }\n\n    @Test\n    public void testBasic() throws Exception {\n        final String[] args = {\"-a\", \"Caesar\", \"-k\", \"A\"};\n        final CommandLine line = parser.parse(options, args);\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"A\", line.getOptionValue(\"k\"));\n    }\n\n    @Test\n    public void testGetsDefaultIfOptional() throws Exception {\n        final String[] args = {\"-k\", \"-a\", \"Caesar\"};\n        options.getOption(\"k\").setOptionalArg(true);\n        final CommandLine line = parser.parse(options, args);\n\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"a\", line.getOptionValue('k', \"a\"));\n    }\n\n    @Test\n    public void testLackOfError() throws Exception {\n        final String[] args = {\"-k\", \"-a\", \"Caesar\"};\n        try {\n            parser.parse(options, args);\n            fail(\"MissingArgumentException expected\");\n        } catch (final MissingArgumentException e) {\n            assertEquals(\"k\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n    }\n\n    @Test\n    public void testMistakenArgument() throws Exception {\n        String[] args = {\"-a\", \"Caesar\", \"-k\", \"A\"};\n        CommandLine line = parser.parse(options, args);\n        args = new String[] {\"-a\", \"Caesar\", \"-k\", \"a\"};\n        line = parser.parse(options, args);\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"a\", line.getOptionValue(\"k\"));\n    }\n\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI71Test", "class_docstring": "", "name": "BugCLI71Test", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}, {"attribute_expression": "private CommandLineParser parser;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CommandLineParser", "name": "parser", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        options = new Options();\n\n        final Option algorithm = new Option(\"a\", \"algo\", true, \"the algorithm which it to perform executing\");\n        algorithm.setArgName(\"algorithm name\");\n        options.addOption(algorithm);\n\n        final Option key = new Option(\"k\", \"key\", true, \"the key the setted algorithm uses to process\");\n        algorithm.setArgName(\"value\");\n        options.addOption(key);\n\n        parser = new PosixParser();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        options = new Options();\n\n        final Option algorithm = new Option(\"a\", \"algo\", true, \"the algorithm which it to perform executing\");\n        algorithm.setArgName(\"algorithm name\");\n        options.addOption(algorithm);\n\n        final Option key = new Option(\"k\", \"key\", true, \"the key the setted algorithm uses to process\");\n        algorithm.setArgName(\"value\");\n        options.addOption(key);\n\n        parser = new PosixParser();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBasic() throws Exception {\n        final String[] args = {\"-a\", \"Caesar\", \"-k\", \"A\"};\n        final CommandLine line = parser.parse(options, args);\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"A\", line.getOptionValue(\"k\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBasic", "params": [], "body": "                                             {\n        final String[] args = {\"-a\", \"Caesar\", \"-k\", \"A\"};\n        final CommandLine line = parser.parse(options, args);\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"A\", line.getOptionValue(\"k\"));\n    }", "signature": "@Test\n    public void testBasic()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetsDefaultIfOptional() throws Exception {\n        final String[] args = {\"-k\", \"-a\", \"Caesar\"};\n        options.getOption(\"k\").setOptionalArg(true);\n        final CommandLine line = parser.parse(options, args);\n\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"a\", line.getOptionValue('k', \"a\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetsDefaultIfOptional", "params": [], "body": "                                                             {\n        final String[] args = {\"-k\", \"-a\", \"Caesar\"};\n        options.getOption(\"k\").setOptionalArg(true);\n        final CommandLine line = parser.parse(options, args);\n\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"a\", line.getOptionValue('k', \"a\"));\n    }", "signature": "@Test\n    public void testGetsDefaultIfOptional()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLackOfError() throws Exception {\n        final String[] args = {\"-k\", \"-a\", \"Caesar\"};\n        try {\n            parser.parse(options, args);\n            fail(\"MissingArgumentException expected\");\n        } catch (final MissingArgumentException e) {\n            assertEquals(\"k\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLackOfError", "params": [], "body": "                                                   {\n        final String[] args = {\"-k\", \"-a\", \"Caesar\"};\n        try {\n            parser.parse(options, args);\n            fail(\"MissingArgumentException expected\");\n        } catch (final MissingArgumentException e) {\n            assertEquals(\"k\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n    }", "signature": "@Test\n    public void testLackOfError()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMistakenArgument() throws Exception {\n        String[] args = {\"-a\", \"Caesar\", \"-k\", \"A\"};\n        CommandLine line = parser.parse(options, args);\n        args = new String[] {\"-a\", \"Caesar\", \"-k\", \"a\"};\n        line = parser.parse(options, args);\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"a\", line.getOptionValue(\"k\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMistakenArgument", "params": [], "body": "                                                        {\n        String[] args = {\"-a\", \"Caesar\", \"-k\", \"A\"};\n        CommandLine line = parser.parse(options, args);\n        args = new String[] {\"-a\", \"Caesar\", \"-k\", \"a\"};\n        line = parser.parse(options, args);\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"a\", line.getOptionValue(\"k\"));\n    }", "signature": "@Test\n    public void testMistakenArgument()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugCLI325Test.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli.bug;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.junit.jupiter.api.Test;\n\npublic class BugCLI325Test {\n\n    @Test\n    public void testCli325() throws ParseException {\n        // @formatter:off\n        final Option option = Option.builder(\"x\")\n                .hasArgs()\n                .valueSeparator()\n                .desc(\"Multiple arg option with value separator.\")\n                .build();\n        // @formatter:on\n        final String[] args = {\"-x\", \"A=a\", \"B=b\"};\n        final CommandLine cmdLine = DefaultParser.builder().build().parse(new Options().addOption(option), args);\n        final Properties props = cmdLine.getOptionProperties(option);\n        assertEquals(2, props.size());\n        assertEquals(\"a\", props.get(\"A\"));\n        assertEquals(\"b\", props.get(\"B\"));\n    }\n}\n", "file_hash": "eb6014eaf2053dd106e7e6e5d6cf18e0780abf330def1c5a6b62339e537ee4a2", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import java.util.Properties;", "import org.apache.commons.cli.CommandLine;", "import org.apache.commons.cli.DefaultParser;", "import org.apache.commons.cli.Option;", "import org.apache.commons.cli.Options;", "import org.apache.commons.cli.ParseException;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class BugCLI325Test {\n\n    @Test\n    public void testCli325() throws ParseException {\n        // @formatter:off\n        final Option option = Option.builder(\"x\")\n                .hasArgs()\n                .valueSeparator()\n                .desc(\"Multiple arg option with value separator.\")\n                .build();\n        // @formatter:on\n        final String[] args = {\"-x\", \"A=a\", \"B=b\"};\n        final CommandLine cmdLine = DefaultParser.builder().build().parse(new Options().addOption(option), args);\n        final Properties props = cmdLine.getOptionProperties(option);\n        assertEquals(2, props.size());\n        assertEquals(\"a\", props.get(\"A\"));\n        assertEquals(\"b\", props.get(\"B\"));\n    }\n}", "definition": "public class BugCLI325Test", "class_docstring": "", "name": "BugCLI325Test", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testCli325() throws ParseException {\n        // @formatter:off\n        final Option option = Option.builder(\"x\")\n                .hasArgs()\n                .valueSeparator()\n                .desc(\"Multiple arg option with value separator.\")\n                .build();\n        // @formatter:on\n        final String[] args = {\"-x\", \"A=a\", \"B=b\"};\n        final CommandLine cmdLine = DefaultParser.builder().build().parse(new Options().addOption(option), args);\n        final Properties props = cmdLine.getOptionProperties(option);\n        assertEquals(2, props.size());\n        assertEquals(\"a\", props.get(\"A\"));\n        assertEquals(\"b\", props.get(\"B\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCli325", "params": [], "body": "                                                   {\n        // @formatter:off\n        final Option option = Option.builder(\"x\")\n                .hasArgs()\n                .valueSeparator()\n                .desc(\"Multiple arg option with value separator.\")\n                .build();\n        // @formatter:on\n        final String[] args = {\"-x\", \"A=a\", \"B=b\"};\n        final CommandLine cmdLine = DefaultParser.builder().build().parse(new Options().addOption(option), args);\n        final Properties props = cmdLine.getOptionProperties(option);\n        assertEquals(2, props.size());\n        assertEquals(\"a\", props.get(\"A\"));\n        assertEquals(\"b\", props.get(\"B\"));\n    }", "signature": "@Test\n    public void testCli325()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugCLI265Test.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli.bug;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test for CLI-265.\n * <p>\n * The issue is that a short option with an optional value will use whatever comes next as value.\n */\npublic class BugCLI265Test {\n\n    private DefaultParser parser;\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        parser = new DefaultParser();\n\n        final Option optionT1 = Option.builder(\"t1\").hasArg().numberOfArgs(1).optionalArg(true).argName(\"t1_path\").build();\n        final Option optionA = Option.builder(\"a\").hasArg(false).build();\n        final Option optionB = Option.builder(\"b\").hasArg(false).build();\n        final Option optionLast = Option.builder(\"last\").hasArg(false).build();\n\n        options = new Options().addOption(optionT1).addOption(optionA).addOption(optionB).addOption(optionLast);\n    }\n\n    @Test\n    public void testShouldParseConcatenatedShortOptions() throws Exception {\n        final String[] concatenatedShortOptions = {\"-t1\", \"-ab\"};\n\n        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNull(commandLine.getOptionValue(\"t1\"));\n        assertTrue(commandLine.hasOption(\"a\"));\n        assertTrue(commandLine.hasOption(\"b\"));\n        assertFalse(commandLine.hasOption(\"last\"));\n    }\n\n    @Test\n    public void testShouldParseShortOptionWithoutValue() throws Exception {\n        final String[] twoShortOptions = {\"-t1\", \"-last\"};\n\n        final CommandLine commandLine = parser.parse(options, twoShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNotEquals(commandLine.getOptionValue(\"t1\"), \"Second option has been used as value for first option\", \"-last\");\n        assertTrue(commandLine.hasOption(\"last\"), \"Second option has not been detected\");\n    }\n\n    @Test\n    public void testShouldParseShortOptionWithValue() throws Exception {\n        final String[] shortOptionWithValue = {\"-t1\", \"path/to/my/db\"};\n\n        final CommandLine commandLine = parser.parse(options, shortOptionWithValue);\n\n        assertEquals(\"path/to/my/db\", commandLine.getOptionValue(\"t1\"));\n        assertFalse(commandLine.hasOption(\"last\"));\n    }\n}\n", "file_hash": "d0dabbe188915c5609d8f85d70b58ce68eb56bda4bb5af403b3d9165886d2663", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertNotEquals;", "import static org.junit.jupiter.api.Assertions.assertNull;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import org.apache.commons.cli.CommandLine;", "import org.apache.commons.cli.DefaultParser;", "import org.apache.commons.cli.Option;", "import org.apache.commons.cli.Options;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class BugCLI265Test {\n\n    private DefaultParser parser;\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        parser = new DefaultParser();\n\n        final Option optionT1 = Option.builder(\"t1\").hasArg().numberOfArgs(1).optionalArg(true).argName(\"t1_path\").build();\n        final Option optionA = Option.builder(\"a\").hasArg(false).build();\n        final Option optionB = Option.builder(\"b\").hasArg(false).build();\n        final Option optionLast = Option.builder(\"last\").hasArg(false).build();\n\n        options = new Options().addOption(optionT1).addOption(optionA).addOption(optionB).addOption(optionLast);\n    }\n\n    @Test\n    public void testShouldParseConcatenatedShortOptions() throws Exception {\n        final String[] concatenatedShortOptions = {\"-t1\", \"-ab\"};\n\n        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNull(commandLine.getOptionValue(\"t1\"));\n        assertTrue(commandLine.hasOption(\"a\"));\n        assertTrue(commandLine.hasOption(\"b\"));\n        assertFalse(commandLine.hasOption(\"last\"));\n    }\n\n    @Test\n    public void testShouldParseShortOptionWithoutValue() throws Exception {\n        final String[] twoShortOptions = {\"-t1\", \"-last\"};\n\n        final CommandLine commandLine = parser.parse(options, twoShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNotEquals(commandLine.getOptionValue(\"t1\"), \"Second option has been used as value for first option\", \"-last\");\n        assertTrue(commandLine.hasOption(\"last\"), \"Second option has not been detected\");\n    }\n\n    @Test\n    public void testShouldParseShortOptionWithValue() throws Exception {\n        final String[] shortOptionWithValue = {\"-t1\", \"path/to/my/db\"};\n\n        final CommandLine commandLine = parser.parse(options, shortOptionWithValue);\n\n        assertEquals(\"path/to/my/db\", commandLine.getOptionValue(\"t1\"));\n        assertFalse(commandLine.hasOption(\"last\"));\n    }\n}", "definition": "public class BugCLI265Test", "class_docstring": "\nTest for CLI-265.\n<p>\nThe issue is that a short option with an optional value will use whatever comes next as value.\n", "name": "BugCLI265Test", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private DefaultParser parser;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DefaultParser", "name": "parser", "syntax_pass": true}, {"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        parser = new DefaultParser();\n\n        final Option optionT1 = Option.builder(\"t1\").hasArg().numberOfArgs(1).optionalArg(true).argName(\"t1_path\").build();\n        final Option optionA = Option.builder(\"a\").hasArg(false).build();\n        final Option optionB = Option.builder(\"b\").hasArg(false).build();\n        final Option optionLast = Option.builder(\"last\").hasArg(false).build();\n\n        options = new Options().addOption(optionT1).addOption(optionA).addOption(optionB).addOption(optionLast);\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        parser = new DefaultParser();\n\n        final Option optionT1 = Option.builder(\"t1\").hasArg().numberOfArgs(1).optionalArg(true).argName(\"t1_path\").build();\n        final Option optionA = Option.builder(\"a\").hasArg(false).build();\n        final Option optionB = Option.builder(\"b\").hasArg(false).build();\n        final Option optionLast = Option.builder(\"last\").hasArg(false).build();\n\n        options = new Options().addOption(optionT1).addOption(optionA).addOption(optionB).addOption(optionLast);\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShouldParseConcatenatedShortOptions() throws Exception {\n        final String[] concatenatedShortOptions = {\"-t1\", \"-ab\"};\n\n        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNull(commandLine.getOptionValue(\"t1\"));\n        assertTrue(commandLine.hasOption(\"a\"));\n        assertTrue(commandLine.hasOption(\"b\"));\n        assertFalse(commandLine.hasOption(\"last\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShouldParseConcatenatedShortOptions", "params": [], "body": "                                                                           {\n        final String[] concatenatedShortOptions = {\"-t1\", \"-ab\"};\n\n        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNull(commandLine.getOptionValue(\"t1\"));\n        assertTrue(commandLine.hasOption(\"a\"));\n        assertTrue(commandLine.hasOption(\"b\"));\n        assertFalse(commandLine.hasOption(\"last\"));\n    }", "signature": "@Test\n    public void testShouldParseConcatenatedShortOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShouldParseShortOptionWithoutValue() throws Exception {\n        final String[] twoShortOptions = {\"-t1\", \"-last\"};\n\n        final CommandLine commandLine = parser.parse(options, twoShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNotEquals(commandLine.getOptionValue(\"t1\"), \"Second option has been used as value for first option\", \"-last\");\n        assertTrue(commandLine.hasOption(\"last\"), \"Second option has not been detected\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShouldParseShortOptionWithoutValue", "params": [], "body": "                                                                          {\n        final String[] twoShortOptions = {\"-t1\", \"-last\"};\n\n        final CommandLine commandLine = parser.parse(options, twoShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNotEquals(commandLine.getOptionValue(\"t1\"), \"Second option has been used as value for first option\", \"-last\");\n        assertTrue(commandLine.hasOption(\"last\"), \"Second option has not been detected\");\n    }", "signature": "@Test\n    public void testShouldParseShortOptionWithoutValue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testShouldParseShortOptionWithValue() throws Exception {\n        final String[] shortOptionWithValue = {\"-t1\", \"path/to/my/db\"};\n\n        final CommandLine commandLine = parser.parse(options, shortOptionWithValue);\n\n        assertEquals(\"path/to/my/db\", commandLine.getOptionValue(\"t1\"));\n        assertFalse(commandLine.hasOption(\"last\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testShouldParseShortOptionWithValue", "params": [], "body": "                                                                       {\n        final String[] shortOptionWithValue = {\"-t1\", \"path/to/my/db\"};\n\n        final CommandLine commandLine = parser.parse(options, shortOptionWithValue);\n\n        assertEquals(\"path/to/my/db\", commandLine.getOptionValue(\"t1\"));\n        assertFalse(commandLine.hasOption(\"last\"));\n    }", "signature": "@Test\n    public void testShouldParseShortOptionWithValue()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugCLI133Test.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli.bug;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.commons.cli.PosixParser;\nimport org.junit.jupiter.api.Test;\n\n@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI133Test {\n    @Test\n    public void testOrder() throws ParseException {\n        final Option optionA = new Option(\"a\", \"first\");\n        final Options opts = new Options();\n        opts.addOption(optionA);\n        final PosixParser posixParser = new PosixParser();\n        final CommandLine line = posixParser.parse(opts, null);\n        assertFalse(line.hasOption((String) null));\n    }\n}\n", "file_hash": "333e453d65c9de3c3b72bdcc9048633f9296c95ad6072b95ef413e3e0a55ed32", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import org.apache.commons.cli.CommandLine;", "import org.apache.commons.cli.Option;", "import org.apache.commons.cli.Options;", "import org.apache.commons.cli.ParseException;", "import org.apache.commons.cli.PosixParser;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI133Test {\n    @Test\n    public void testOrder() throws ParseException {\n        final Option optionA = new Option(\"a\", \"first\");\n        final Options opts = new Options();\n        opts.addOption(optionA);\n        final PosixParser posixParser = new PosixParser();\n        final CommandLine line = posixParser.parse(opts, null);\n        assertFalse(line.hasOption((String) null));\n    }\n}", "definition": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI133Test", "class_docstring": "", "name": "BugCLI133Test", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// tests some deprecated classes"], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testOrder() throws ParseException {\n        final Option optionA = new Option(\"a\", \"first\");\n        final Options opts = new Options();\n        opts.addOption(optionA);\n        final PosixParser posixParser = new PosixParser();\n        final CommandLine line = posixParser.parse(opts, null);\n        assertFalse(line.hasOption((String) null));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOrder", "params": [], "body": "                                                  {\n        final Option optionA = new Option(\"a\", \"first\");\n        final Options opts = new Options();\n        opts.addOption(optionA);\n        final PosixParser posixParser = new PosixParser();\n        final CommandLine line = posixParser.parse(opts, null);\n        assertFalse(line.hasOption((String) null));\n    }", "signature": "@Test\n    public void testOrder()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugCLI162Test.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli.bug;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.sql.ParameterMetaData;\nimport java.sql.Types;\n\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.OptionGroup;\nimport org.apache.commons.cli.Options;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class BugCLI162Test {\n    /** Constant for the line separator. */\n    private static final String CR = System.lineSeparator();\n\n    // Constants used for options\n    private static final String OPT = \"-\";\n\n    private static final String OPT_COLUMN_NAMES = \"l\";\n\n    private static final String OPT_CONNECTION = \"c\";\n\n    private static final String OPT_DESCRIPTION = \"e\";\n\n    private static final String OPT_DRIVER = \"d\";\n\n    private static final String OPT_DRIVER_INFO = \"n\";\n\n    private static final String OPT_FILE_BINDING = \"b\";\n\n    private static final String OPT_FILE_JDBC = \"j\";\n\n    private static final String OPT_FILE_SFMD = \"f\";\n\n    private static final String OPT_HELP = \"h\";\n\n    private static final String OPT_HELP_LONG = \"help\";\n\n    private static final String OPT_INTERACTIVE = \"i\";\n\n    private static final String OPT_JDBC_TO_SFMD = \"2\";\n\n    private static final String OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\";\n\n    private static final String OPT_METADATA = \"m\";\n\n    private static final String OPT_PARAM_MODES_INT = \"o\";\n\n    private static final String OPT_PARAM_MODES_NAME = \"O\";\n\n    private static final String OPT_PARAM_NAMES = \"a\";\n\n    private static final String OPT_PARAM_TYPES_INT = \"y\";\n\n    private static final String OPT_PARAM_TYPES_NAME = \"Y\";\n\n    private static final String OPT_PASSWORD = \"p\";\n\n    private static final String OPT_PASSWORD_L = \"password\";\n\n    private static final String OPT_SQL = \"s\";\n\n    private static final String OPT_SQL_L = \"sql\";\n\n    private static final String OPT_STACK_TRACE = \"t\";\n\n    private static final String OPT_TIMING = \"g\";\n\n    private static final String OPT_TRIM_L = \"trim\";\n\n    private static final String OPT_USER = \"u\";\n\n    private static final String OPT_WRITE_TO_FILE = \"w\";\n\n    private static final String PMODE_IN = \"IN\";\n\n    private static final String PMODE_INOUT = \"INOUT\";\n\n    private static final String PMODE_OUT = \"OUT\";\n\n    private static final String PMODE_UNK = \"Unknown\";\n\n    private static final String PMODES = PMODE_IN + \", \" + PMODE_INOUT + \", \" + PMODE_OUT + \", \" + PMODE_UNK;\n\n    // @formatter:off\n    private static final String EXPECTED = \"usage: org.apache.commons.cli.bug.BugCLI162Test\" + CR +\n            \" -2,--jdbc2sfmd <arg>        Converts the JDBC file in the first argument\" + CR +\n            \"                             to an SMFD file specified in the second\" + CR +\n            \"                             argument.\" + CR +\n            \" -a,--paramNames <arg>       Parameter XML names; default names are\" + CR +\n            \"                             param1, param2, etc. Example: -a \\\"pname1\" + CR +\n            \"                             pname2\\\"\" + CR +\n            \" -b,--jdbc <arg>             Writes a JDBC binding node file for the given\" + CR +\n            \"                             SQL\" + CR +\n            \" -c,--url <arg>              Connection URL\" + CR +\n            \" -d,--driver <arg>           JDBC driver class name\" + CR +\n            \" -e,--description <arg>      SFMD description. A default description is\" + CR +\n            \"                             used if omited. Example: -e \\\"Runs such and\" + CR +\n            \"                             such\\\"\" + CR +\n            \" -f,--sfmd <arg>             Writes a SFMD file for the given SQL\" + CR +\n            \" -g,--printTiming            Prints timing information\" + CR +\n            \" -h,--help                   Prints help and quits\" + CR +\n            \" -i,--interactive            Runs in interactive mode, reading and writing\" + CR +\n            \"                             from the console, 'go' or '/' sends a\" + CR +\n            \"                             statement\" + CR +\n            \" -j,--node <arg>             Writes a JDBC node file for the given SQL\" + CR +\n            \"                             (internal debugging)\" + CR +\n            \" -l,--columnNames <arg>      Column XML names; default names column\" + CR +\n            \"                             labels. Example: -l \\\"cname1 cname2\\\"\" + CR +\n            \" -m,--printMetaData          Prints metadata information\" + CR +\n            \" -n,--info                   Prints driver information and properties. If\" + CR +\n            \"                             -c is not specified, all drivers on the\" + CR +\n            \"                             classpath are displayed.\" + CR +\n            \" -o,--paramModes <arg>       Parameters modes (1=IN, 2=INOUT, 4=OUT,\" + CR +\n            \"                             0=Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -o \\\"4\" + CR +\n            \"                             1\\\"\" + CR +\n            \" -O,--paramModeNames <arg>   Parameters mode names (IN, INOUT, OUT,\" + CR +\n            \"                             Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -O \\\"OUT\" + CR +\n            \"                             IN\\\"\" + CR +\n            \" -p,--password <arg>         The database password for the user specified\" + CR +\n            \"                             with the -u option. You can obfuscate the\" + CR +\n            \"                             password with\" + CR +\n            \"                             org.mortbay.jetty.security.Password, see\" + CR +\n            \"                             https://docs.codehaus.org/display/JETTY/Secur\" + CR +\n            \"                             ing+Passwords\" + CR +\n            \" -s,--sql <arg>              Runs SQL or {call stored_procedure(?, ?)} or\" + CR +\n            \"                             {?=call function(?, ?)}\" + CR +\n            \" -t,--printStack             Prints stack traces on errors\" + CR +\n            \"    --trim <arg>             Trims leading and trailing spaces from all\" + CR +\n            \"                             column values. Column XML names can be\" + CR +\n            \"                             optionally specified to set which columns to\" + CR +\n            \"                             trim.\" + CR +\n            \" -u,--user <arg>             A database user name\" + CR +\n            \" -w,--outfile <arg>          Writes the SQL output to the given file\" + CR +\n            \" -y,--paramTypes <arg>       Parameter types from java.sql.Types. -y and\" + CR +\n            \"                             -Y are mutually exclusive. Example: -y \\\"-10\" + CR +\n            \"                             12\\\"\" + CR +\n            \" -Y,--paramTypeNames <arg>   Parameter java.sql.Types names. -y and -Y are\" + CR +\n            \"                             mutually exclusive. Example: -Y \\\"CURSOR\" + CR +\n            \"                             VARCHAR\\\"\" + CR;\n    // @formatter:on\n\n    private HelpFormatter formatter;\n\n    private StringWriter sw;\n\n    @BeforeEach\n    public void setUp() {\n        formatter = new HelpFormatter();\n        sw = new StringWriter();\n    }\n\n    @Test\n    public void testInfiniteLoop() {\n        final Options options = new Options();\n        options.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n        // used to hang & crash\n        formatter.printHelp(new PrintWriter(sw), 20, \"app\", null, options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null);\n\n        //@formatter:off\n        final String expected = \"usage: app\" + CR +\n                \" -h,--help   This is\" + CR +\n                \"             a\" + CR +\n                \"             looooon\" + CR +\n                \"             g\" + CR +\n                \"             descrip\" + CR +\n                \"             tion\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString());\n    }\n\n    @Test\n    public void testLongLineChunking() {\n        final Options options = new Options();\n        //@formatter:off\n        options.addOption(\"x\", \"extralongarg\", false,\n                          \"This description has ReallyLongValuesThatAreLongerThanTheWidthOfTheColumns \" +\n                          \"and also other ReallyLongValuesThatAreHugerAndBiggerThanTheWidthOfTheColumnsBob, \" +\n                          \"yes. \");\n        //@formatter:on\n        formatter.printHelp(new PrintWriter(sw), 35, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        //@formatter:off\n        final String expected = \"usage:\" + CR +\n                          \"       org.apache.commons.cli.bug.B\" + CR +\n                          \"       ugCLI162Test\" + CR +\n                          \"Header\" + CR +\n                          \"-x,--extralongarg     This\" + CR +\n                          \"                      description\" + CR +\n                          \"                      has\" + CR +\n                          \"                      ReallyLongVal\" + CR +\n                          \"                      uesThatAreLon\" + CR +\n                          \"                      gerThanTheWid\" + CR +\n                          \"                      thOfTheColumn\" + CR +\n                          \"                      s and also\" + CR +\n                          \"                      other\" + CR +\n                          \"                      ReallyLongVal\" + CR +\n                          \"                      uesThatAreHug\" + CR +\n                          \"                      erAndBiggerTh\" + CR +\n                          \"                      anTheWidthOfT\" + CR +\n                          \"                      heColumnsBob,\" + CR +\n                          \"                      yes.\" + CR +\n                          \"Footer\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString(), \"Long arguments did not split as expected\");\n    }\n\n    @Test\n    public void testLongLineChunkingIndentIgnored() {\n        final Options options = new Options();\n        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\");\n        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        //@formatter:off\n        final String expected = \"usage:\" + CR +\n                          \"       org.apache.comm\" + CR +\n                          \"       ons.cli.bug.Bug\" + CR +\n                          \"       CLI162Test\" + CR +\n                          \"Header\" + CR +\n                          \"-x,--extralongarg\" + CR +\n                          \" This description is\" + CR +\n                          \" Long.\" + CR +\n                          \"Footer\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString(), \"Long arguments did not split as expected\");\n    }\n\n    @Test\n    public void testPrintHelpLongLines() {\n        // Options build\n        final Options commandLineOptions;\n        commandLineOptions = new Options();\n        commandLineOptions.addOption(OPT_HELP, OPT_HELP_LONG, false, \"Prints help and quits\");\n        commandLineOptions.addOption(OPT_DRIVER, \"driver\", true, \"JDBC driver class name\");\n        //@formatter:off\n        commandLineOptions.addOption(OPT_DRIVER_INFO, \"info\", false, \"Prints driver information and properties. If \"\n            + OPT\n            + OPT_CONNECTION\n            + \" is not specified, all drivers on the classpath are displayed.\");\n        //@formatter:on\n        commandLineOptions.addOption(OPT_CONNECTION, \"url\", true, \"Connection URL\");\n        commandLineOptions.addOption(OPT_USER, \"user\", true, \"A database user name\");\n        //@formatter:off\n        commandLineOptions\n                .addOption(\n                        OPT_PASSWORD,\n                        OPT_PASSWORD_L,\n                        true,\n                        \"The database password for the user specified with the \"\n                            + OPT\n                            + OPT_USER\n                            + \" option. You can obfuscate the password with org.mortbay.jetty.security.Password,\"\n                            + \" see https://docs.codehaus.org/display/JETTY/Securing+Passwords\");\n        //@formatter:on\n        commandLineOptions.addOption(OPT_SQL, OPT_SQL_L, true, \"Runs SQL or {call stored_procedure(?, ?)} or {?=call function(?, ?)}\");\n        commandLineOptions.addOption(OPT_FILE_SFMD, \"sfmd\", true, \"Writes a SFMD file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_BINDING, \"jdbc\", true, \"Writes a JDBC binding node file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_JDBC, \"node\", true, \"Writes a JDBC node file for the given SQL (internal debugging)\");\n        commandLineOptions.addOption(OPT_WRITE_TO_FILE, \"outfile\", true, \"Writes the SQL output to the given file\");\n        commandLineOptions.addOption(OPT_DESCRIPTION, \"description\", true,\n            \"SFMD description. A default description is used if omited. Example: \" + OPT + OPT_DESCRIPTION + \" \\\"Runs such and such\\\"\");\n        commandLineOptions.addOption(OPT_INTERACTIVE, \"interactive\", false,\n            \"Runs in interactive mode, reading and writing from the console, 'go' or '/' sends a statement\");\n        commandLineOptions.addOption(OPT_TIMING, \"printTiming\", false, \"Prints timing information\");\n        commandLineOptions.addOption(OPT_METADATA, \"printMetaData\", false, \"Prints metadata information\");\n        commandLineOptions.addOption(OPT_STACK_TRACE, \"printStack\", false, \"Prints stack traces on errors\");\n        //@formatter:off\n        Option option = new Option(OPT_COLUMN_NAMES, \"columnNames\", true, \"Column XML names; default names column labels. Example: \"\n            + OPT\n            + OPT_COLUMN_NAMES\n            + \" \\\"cname1 cname2\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_NAMES, \"paramNames\", true, \"Parameter XML names; default names are param1, param2, etc. Example: \"\n            + OPT\n            + OPT_PARAM_NAMES\n            + \" \\\"pname1 pname2\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //\n        final OptionGroup pOutTypesOptionGroup = new OptionGroup();\n        final String pOutTypesOptionGroupDoc = OPT + OPT_PARAM_TYPES_INT + \" and \" + OPT + OPT_PARAM_TYPES_NAME + \" are mutually exclusive.\";\n        final String typesClassName = Types.class.getName();\n        //@formatter:off\n        option = new Option(OPT_PARAM_TYPES_INT, \"paramTypes\", true, \"Parameter types from \"\n            + typesClassName\n            + \". \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_INT\n            + \" \\\"-10 12\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_TYPES_NAME, \"paramTypeNames\", true, \"Parameter \"\n            + typesClassName\n            + \" names. \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_NAME\n            + \" \\\"CURSOR VARCHAR\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        commandLineOptions.addOptionGroup(pOutTypesOptionGroup);\n        //\n        final OptionGroup modesOptionGroup = new OptionGroup();\n        final String modesOptionGroupDoc = OPT + OPT_PARAM_MODES_INT + \" and \" + OPT + OPT_PARAM_MODES_NAME + \" are mutually exclusive.\";\n        //@formatter:off\n        option = new Option(OPT_PARAM_MODES_INT, \"paramModes\", true, \"Parameters modes (\"\n            + ParameterMetaData.parameterModeIn\n            + \"=IN, \"\n            + ParameterMetaData.parameterModeInOut\n            + \"=INOUT, \"\n            + ParameterMetaData.parameterModeOut\n            + \"=OUT, \"\n            + ParameterMetaData.parameterModeUnknown\n            + \"=Unknown\"\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_INT\n            + \" \\\"\"\n            + ParameterMetaData.parameterModeOut\n            + \" \"\n            + ParameterMetaData.parameterModeIn\n            + \"\\\"\");\n        //@formatter:on\n        modesOptionGroup.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_MODES_NAME, \"paramModeNames\", true, \"Parameters mode names (\"\n            + PMODES\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_NAME\n            + \" \\\"\"\n            + PMODE_OUT\n            + \" \"\n            + PMODE_IN\n            + \"\\\"\");\n        //@formatter:on\n        modesOptionGroup.addOption(option);\n        commandLineOptions.addOptionGroup(modesOptionGroup);\n        option = new Option(null, OPT_TRIM_L, true,\n            \"Trims leading and trailing spaces from all column values. Column XML names can be optionally specified to set which columns to trim.\");\n        option.setOptionalArg(true);\n        commandLineOptions.addOption(option);\n        option = new Option(OPT_JDBC_TO_SFMD, OPT_JDBC_TO_SFMD_L, true,\n            \"Converts the JDBC file in the first argument to an SMFD file specified in the second argument.\");\n        option.setArgs(2);\n        commandLineOptions.addOption(option);\n\n        formatter.printHelp(new PrintWriter(sw), HelpFormatter.DEFAULT_WIDTH, this.getClass().getName(), null, commandLineOptions,\n            HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null);\n        //@formatter:on\n        assertEquals(EXPECTED, sw.toString());\n    }\n\n}\n", "file_hash": "8324bbd59f4dcd9b38c190024245f8e4cc29f96540d25bc3687dc2baca2cccb7", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import java.io.PrintWriter;", "import java.io.StringWriter;", "import java.sql.ParameterMetaData;", "import java.sql.Types;", "import org.apache.commons.cli.HelpFormatter;", "import org.apache.commons.cli.Option;", "import org.apache.commons.cli.OptionGroup;", "import org.apache.commons.cli.Options;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class BugCLI162Test {\n    /** Constant for the line separator. */\n    private static final String CR = System.lineSeparator();\n\n    // Constants used for options\n    private static final String OPT = \"-\";\n\n    private static final String OPT_COLUMN_NAMES = \"l\";\n\n    private static final String OPT_CONNECTION = \"c\";\n\n    private static final String OPT_DESCRIPTION = \"e\";\n\n    private static final String OPT_DRIVER = \"d\";\n\n    private static final String OPT_DRIVER_INFO = \"n\";\n\n    private static final String OPT_FILE_BINDING = \"b\";\n\n    private static final String OPT_FILE_JDBC = \"j\";\n\n    private static final String OPT_FILE_SFMD = \"f\";\n\n    private static final String OPT_HELP = \"h\";\n\n    private static final String OPT_HELP_LONG = \"help\";\n\n    private static final String OPT_INTERACTIVE = \"i\";\n\n    private static final String OPT_JDBC_TO_SFMD = \"2\";\n\n    private static final String OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\";\n\n    private static final String OPT_METADATA = \"m\";\n\n    private static final String OPT_PARAM_MODES_INT = \"o\";\n\n    private static final String OPT_PARAM_MODES_NAME = \"O\";\n\n    private static final String OPT_PARAM_NAMES = \"a\";\n\n    private static final String OPT_PARAM_TYPES_INT = \"y\";\n\n    private static final String OPT_PARAM_TYPES_NAME = \"Y\";\n\n    private static final String OPT_PASSWORD = \"p\";\n\n    private static final String OPT_PASSWORD_L = \"password\";\n\n    private static final String OPT_SQL = \"s\";\n\n    private static final String OPT_SQL_L = \"sql\";\n\n    private static final String OPT_STACK_TRACE = \"t\";\n\n    private static final String OPT_TIMING = \"g\";\n\n    private static final String OPT_TRIM_L = \"trim\";\n\n    private static final String OPT_USER = \"u\";\n\n    private static final String OPT_WRITE_TO_FILE = \"w\";\n\n    private static final String PMODE_IN = \"IN\";\n\n    private static final String PMODE_INOUT = \"INOUT\";\n\n    private static final String PMODE_OUT = \"OUT\";\n\n    private static final String PMODE_UNK = \"Unknown\";\n\n    private static final String PMODES = PMODE_IN + \", \" + PMODE_INOUT + \", \" + PMODE_OUT + \", \" + PMODE_UNK;\n\n    // @formatter:off\n    private static final String EXPECTED = \"usage: org.apache.commons.cli.bug.BugCLI162Test\" + CR +\n            \" -2,--jdbc2sfmd <arg>        Converts the JDBC file in the first argument\" + CR +\n            \"                             to an SMFD file specified in the second\" + CR +\n            \"                             argument.\" + CR +\n            \" -a,--paramNames <arg>       Parameter XML names; default names are\" + CR +\n            \"                             param1, param2, etc. Example: -a \\\"pname1\" + CR +\n            \"                             pname2\\\"\" + CR +\n            \" -b,--jdbc <arg>             Writes a JDBC binding node file for the given\" + CR +\n            \"                             SQL\" + CR +\n            \" -c,--url <arg>              Connection URL\" + CR +\n            \" -d,--driver <arg>           JDBC driver class name\" + CR +\n            \" -e,--description <arg>      SFMD description. A default description is\" + CR +\n            \"                             used if omited. Example: -e \\\"Runs such and\" + CR +\n            \"                             such\\\"\" + CR +\n            \" -f,--sfmd <arg>             Writes a SFMD file for the given SQL\" + CR +\n            \" -g,--printTiming            Prints timing information\" + CR +\n            \" -h,--help                   Prints help and quits\" + CR +\n            \" -i,--interactive            Runs in interactive mode, reading and writing\" + CR +\n            \"                             from the console, 'go' or '/' sends a\" + CR +\n            \"                             statement\" + CR +\n            \" -j,--node <arg>             Writes a JDBC node file for the given SQL\" + CR +\n            \"                             (internal debugging)\" + CR +\n            \" -l,--columnNames <arg>      Column XML names; default names column\" + CR +\n            \"                             labels. Example: -l \\\"cname1 cname2\\\"\" + CR +\n            \" -m,--printMetaData          Prints metadata information\" + CR +\n            \" -n,--info                   Prints driver information and properties. If\" + CR +\n            \"                             -c is not specified, all drivers on the\" + CR +\n            \"                             classpath are displayed.\" + CR +\n            \" -o,--paramModes <arg>       Parameters modes (1=IN, 2=INOUT, 4=OUT,\" + CR +\n            \"                             0=Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -o \\\"4\" + CR +\n            \"                             1\\\"\" + CR +\n            \" -O,--paramModeNames <arg>   Parameters mode names (IN, INOUT, OUT,\" + CR +\n            \"                             Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -O \\\"OUT\" + CR +\n            \"                             IN\\\"\" + CR +\n            \" -p,--password <arg>         The database password for the user specified\" + CR +\n            \"                             with the -u option. You can obfuscate the\" + CR +\n            \"                             password with\" + CR +\n            \"                             org.mortbay.jetty.security.Password, see\" + CR +\n            \"                             https://docs.codehaus.org/display/JETTY/Secur\" + CR +\n            \"                             ing+Passwords\" + CR +\n            \" -s,--sql <arg>              Runs SQL or {call stored_procedure(?, ?)} or\" + CR +\n            \"                             {?=call function(?, ?)}\" + CR +\n            \" -t,--printStack             Prints stack traces on errors\" + CR +\n            \"    --trim <arg>             Trims leading and trailing spaces from all\" + CR +\n            \"                             column values. Column XML names can be\" + CR +\n            \"                             optionally specified to set which columns to\" + CR +\n            \"                             trim.\" + CR +\n            \" -u,--user <arg>             A database user name\" + CR +\n            \" -w,--outfile <arg>          Writes the SQL output to the given file\" + CR +\n            \" -y,--paramTypes <arg>       Parameter types from java.sql.Types. -y and\" + CR +\n            \"                             -Y are mutually exclusive. Example: -y \\\"-10\" + CR +\n            \"                             12\\\"\" + CR +\n            \" -Y,--paramTypeNames <arg>   Parameter java.sql.Types names. -y and -Y are\" + CR +\n            \"                             mutually exclusive. Example: -Y \\\"CURSOR\" + CR +\n            \"                             VARCHAR\\\"\" + CR;\n    // @formatter:on\n\n    private HelpFormatter formatter;\n\n    private StringWriter sw;\n\n    @BeforeEach\n    public void setUp() {\n        formatter = new HelpFormatter();\n        sw = new StringWriter();\n    }\n\n    @Test\n    public void testInfiniteLoop() {\n        final Options options = new Options();\n        options.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n        // used to hang & crash\n        formatter.printHelp(new PrintWriter(sw), 20, \"app\", null, options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null);\n\n        //@formatter:off\n        final String expected = \"usage: app\" + CR +\n                \" -h,--help   This is\" + CR +\n                \"             a\" + CR +\n                \"             looooon\" + CR +\n                \"             g\" + CR +\n                \"             descrip\" + CR +\n                \"             tion\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString());\n    }\n\n    @Test\n    public void testLongLineChunking() {\n        final Options options = new Options();\n        //@formatter:off\n        options.addOption(\"x\", \"extralongarg\", false,\n                          \"This description has ReallyLongValuesThatAreLongerThanTheWidthOfTheColumns \" +\n                          \"and also other ReallyLongValuesThatAreHugerAndBiggerThanTheWidthOfTheColumnsBob, \" +\n                          \"yes. \");\n        //@formatter:on\n        formatter.printHelp(new PrintWriter(sw), 35, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        //@formatter:off\n        final String expected = \"usage:\" + CR +\n                          \"       org.apache.commons.cli.bug.B\" + CR +\n                          \"       ugCLI162Test\" + CR +\n                          \"Header\" + CR +\n                          \"-x,--extralongarg     This\" + CR +\n                          \"                      description\" + CR +\n                          \"                      has\" + CR +\n                          \"                      ReallyLongVal\" + CR +\n                          \"                      uesThatAreLon\" + CR +\n                          \"                      gerThanTheWid\" + CR +\n                          \"                      thOfTheColumn\" + CR +\n                          \"                      s and also\" + CR +\n                          \"                      other\" + CR +\n                          \"                      ReallyLongVal\" + CR +\n                          \"                      uesThatAreHug\" + CR +\n                          \"                      erAndBiggerTh\" + CR +\n                          \"                      anTheWidthOfT\" + CR +\n                          \"                      heColumnsBob,\" + CR +\n                          \"                      yes.\" + CR +\n                          \"Footer\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString(), \"Long arguments did not split as expected\");\n    }\n\n    @Test\n    public void testLongLineChunkingIndentIgnored() {\n        final Options options = new Options();\n        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\");\n        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        //@formatter:off\n        final String expected = \"usage:\" + CR +\n                          \"       org.apache.comm\" + CR +\n                          \"       ons.cli.bug.Bug\" + CR +\n                          \"       CLI162Test\" + CR +\n                          \"Header\" + CR +\n                          \"-x,--extralongarg\" + CR +\n                          \" This description is\" + CR +\n                          \" Long.\" + CR +\n                          \"Footer\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString(), \"Long arguments did not split as expected\");\n    }\n\n    @Test\n    public void testPrintHelpLongLines() {\n        // Options build\n        final Options commandLineOptions;\n        commandLineOptions = new Options();\n        commandLineOptions.addOption(OPT_HELP, OPT_HELP_LONG, false, \"Prints help and quits\");\n        commandLineOptions.addOption(OPT_DRIVER, \"driver\", true, \"JDBC driver class name\");\n        //@formatter:off\n        commandLineOptions.addOption(OPT_DRIVER_INFO, \"info\", false, \"Prints driver information and properties. If \"\n            + OPT\n            + OPT_CONNECTION\n            + \" is not specified, all drivers on the classpath are displayed.\");\n        //@formatter:on\n        commandLineOptions.addOption(OPT_CONNECTION, \"url\", true, \"Connection URL\");\n        commandLineOptions.addOption(OPT_USER, \"user\", true, \"A database user name\");\n        //@formatter:off\n        commandLineOptions\n                .addOption(\n                        OPT_PASSWORD,\n                        OPT_PASSWORD_L,\n                        true,\n                        \"The database password for the user specified with the \"\n                            + OPT\n                            + OPT_USER\n                            + \" option. You can obfuscate the password with org.mortbay.jetty.security.Password,\"\n                            + \" see https://docs.codehaus.org/display/JETTY/Securing+Passwords\");\n        //@formatter:on\n        commandLineOptions.addOption(OPT_SQL, OPT_SQL_L, true, \"Runs SQL or {call stored_procedure(?, ?)} or {?=call function(?, ?)}\");\n        commandLineOptions.addOption(OPT_FILE_SFMD, \"sfmd\", true, \"Writes a SFMD file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_BINDING, \"jdbc\", true, \"Writes a JDBC binding node file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_JDBC, \"node\", true, \"Writes a JDBC node file for the given SQL (internal debugging)\");\n        commandLineOptions.addOption(OPT_WRITE_TO_FILE, \"outfile\", true, \"Writes the SQL output to the given file\");\n        commandLineOptions.addOption(OPT_DESCRIPTION, \"description\", true,\n            \"SFMD description. A default description is used if omited. Example: \" + OPT + OPT_DESCRIPTION + \" \\\"Runs such and such\\\"\");\n        commandLineOptions.addOption(OPT_INTERACTIVE, \"interactive\", false,\n            \"Runs in interactive mode, reading and writing from the console, 'go' or '/' sends a statement\");\n        commandLineOptions.addOption(OPT_TIMING, \"printTiming\", false, \"Prints timing information\");\n        commandLineOptions.addOption(OPT_METADATA, \"printMetaData\", false, \"Prints metadata information\");\n        commandLineOptions.addOption(OPT_STACK_TRACE, \"printStack\", false, \"Prints stack traces on errors\");\n        //@formatter:off\n        Option option = new Option(OPT_COLUMN_NAMES, \"columnNames\", true, \"Column XML names; default names column labels. Example: \"\n            + OPT\n            + OPT_COLUMN_NAMES\n            + \" \\\"cname1 cname2\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_NAMES, \"paramNames\", true, \"Parameter XML names; default names are param1, param2, etc. Example: \"\n            + OPT\n            + OPT_PARAM_NAMES\n            + \" \\\"pname1 pname2\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //\n        final OptionGroup pOutTypesOptionGroup = new OptionGroup();\n        final String pOutTypesOptionGroupDoc = OPT + OPT_PARAM_TYPES_INT + \" and \" + OPT + OPT_PARAM_TYPES_NAME + \" are mutually exclusive.\";\n        final String typesClassName = Types.class.getName();\n        //@formatter:off\n        option = new Option(OPT_PARAM_TYPES_INT, \"paramTypes\", true, \"Parameter types from \"\n            + typesClassName\n            + \". \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_INT\n            + \" \\\"-10 12\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_TYPES_NAME, \"paramTypeNames\", true, \"Parameter \"\n            + typesClassName\n            + \" names. \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_NAME\n            + \" \\\"CURSOR VARCHAR\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        commandLineOptions.addOptionGroup(pOutTypesOptionGroup);\n        //\n        final OptionGroup modesOptionGroup = new OptionGroup();\n        final String modesOptionGroupDoc = OPT + OPT_PARAM_MODES_INT + \" and \" + OPT + OPT_PARAM_MODES_NAME + \" are mutually exclusive.\";\n        //@formatter:off\n        option = new Option(OPT_PARAM_MODES_INT, \"paramModes\", true, \"Parameters modes (\"\n            + ParameterMetaData.parameterModeIn\n            + \"=IN, \"\n            + ParameterMetaData.parameterModeInOut\n            + \"=INOUT, \"\n            + ParameterMetaData.parameterModeOut\n            + \"=OUT, \"\n            + ParameterMetaData.parameterModeUnknown\n            + \"=Unknown\"\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_INT\n            + \" \\\"\"\n            + ParameterMetaData.parameterModeOut\n            + \" \"\n            + ParameterMetaData.parameterModeIn\n            + \"\\\"\");\n        //@formatter:on\n        modesOptionGroup.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_MODES_NAME, \"paramModeNames\", true, \"Parameters mode names (\"\n            + PMODES\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_NAME\n            + \" \\\"\"\n            + PMODE_OUT\n            + \" \"\n            + PMODE_IN\n            + \"\\\"\");\n        //@formatter:on\n        modesOptionGroup.addOption(option);\n        commandLineOptions.addOptionGroup(modesOptionGroup);\n        option = new Option(null, OPT_TRIM_L, true,\n            \"Trims leading and trailing spaces from all column values. Column XML names can be optionally specified to set which columns to trim.\");\n        option.setOptionalArg(true);\n        commandLineOptions.addOption(option);\n        option = new Option(OPT_JDBC_TO_SFMD, OPT_JDBC_TO_SFMD_L, true,\n            \"Converts the JDBC file in the first argument to an SMFD file specified in the second argument.\");\n        option.setArgs(2);\n        commandLineOptions.addOption(option);\n\n        formatter.printHelp(new PrintWriter(sw), HelpFormatter.DEFAULT_WIDTH, this.getClass().getName(), null, commandLineOptions,\n            HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null);\n        //@formatter:on\n        assertEquals(EXPECTED, sw.toString());\n    }\n\n}", "definition": "public class BugCLI162Test", "class_docstring": "", "name": "BugCLI162Test", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final String CR = System.lineSeparator();", "docstring": " Constant for the line separator.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "CR = System.lineSeparator()", "syntax_pass": true}, {"attribute_expression": "private static final String OPT = \"-\";", "docstring": " Constants used for options", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT = \"-\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_COLUMN_NAMES = \"l\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_COLUMN_NAMES = \"l\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_CONNECTION = \"c\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_CONNECTION = \"c\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_DESCRIPTION = \"e\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_DESCRIPTION = \"e\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_DRIVER = \"d\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_DRIVER = \"d\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_DRIVER_INFO = \"n\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_DRIVER_INFO = \"n\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_FILE_BINDING = \"b\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_FILE_BINDING = \"b\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_FILE_JDBC = \"j\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_FILE_JDBC = \"j\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_FILE_SFMD = \"f\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_FILE_SFMD = \"f\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_HELP = \"h\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_HELP = \"h\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_HELP_LONG = \"help\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_HELP_LONG = \"help\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_INTERACTIVE = \"i\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_INTERACTIVE = \"i\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_JDBC_TO_SFMD = \"2\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_JDBC_TO_SFMD = \"2\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_METADATA = \"m\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_METADATA = \"m\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PARAM_MODES_INT = \"o\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PARAM_MODES_INT = \"o\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PARAM_MODES_NAME = \"O\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PARAM_MODES_NAME = \"O\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PARAM_NAMES = \"a\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PARAM_NAMES = \"a\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PARAM_TYPES_INT = \"y\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PARAM_TYPES_INT = \"y\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PARAM_TYPES_NAME = \"Y\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PARAM_TYPES_NAME = \"Y\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PASSWORD = \"p\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PASSWORD = \"p\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PASSWORD_L = \"password\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PASSWORD_L = \"password\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_SQL = \"s\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_SQL = \"s\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_SQL_L = \"sql\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_SQL_L = \"sql\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_STACK_TRACE = \"t\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_STACK_TRACE = \"t\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_TIMING = \"g\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_TIMING = \"g\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_TRIM_L = \"trim\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_TRIM_L = \"trim\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_USER = \"u\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_USER = \"u\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_WRITE_TO_FILE = \"w\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_WRITE_TO_FILE = \"w\"", "syntax_pass": true}, {"attribute_expression": "private static final String PMODE_IN = \"IN\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PMODE_IN = \"IN\"", "syntax_pass": true}, {"attribute_expression": "private static final String PMODE_INOUT = \"INOUT\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PMODE_INOUT = \"INOUT\"", "syntax_pass": true}, {"attribute_expression": "private static final String PMODE_OUT = \"OUT\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PMODE_OUT = \"OUT\"", "syntax_pass": true}, {"attribute_expression": "private static final String PMODE_UNK = \"Unknown\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PMODE_UNK = \"Unknown\"", "syntax_pass": true}, {"attribute_expression": "private static final String PMODES = PMODE_IN + \", \" + PMODE_INOUT + \", \" + PMODE_OUT + \", \" + PMODE_UNK;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PMODES = PMODE_IN + \", \" + PMODE_INOUT + \", \" + PMODE_OUT + \", \" + PMODE_UNK", "syntax_pass": true}, {"attribute_expression": "private static final String EXPECTED = \"usage: org.apache.commons.cli.bug.BugCLI162Test\" + CR +\n            \" -2,--jdbc2sfmd <arg>        Converts the JDBC file in the first argument\" + CR +\n            \"                             to an SMFD file specified in the second\" + CR +\n            \"                             argument.\" + CR +\n            \" -a,--paramNames <arg>       Parameter XML names; default names are\" + CR +\n            \"                             param1, param2, etc. Example: -a \\\"pname1\" + CR +\n            \"                             pname2\\\"\" + CR +\n            \" -b,--jdbc <arg>             Writes a JDBC binding node file for the given\" + CR +\n            \"                             SQL\" + CR +\n            \" -c,--url <arg>              Connection URL\" + CR +\n            \" -d,--driver <arg>           JDBC driver class name\" + CR +\n            \" -e,--description <arg>      SFMD description. A default description is\" + CR +\n            \"                             used if omited. Example: -e \\\"Runs such and\" + CR +\n            \"                             such\\\"\" + CR +\n            \" -f,--sfmd <arg>             Writes a SFMD file for the given SQL\" + CR +\n            \" -g,--printTiming            Prints timing information\" + CR +\n            \" -h,--help                   Prints help and quits\" + CR +\n            \" -i,--interactive            Runs in interactive mode, reading and writing\" + CR +\n            \"                             from the console, 'go' or '/' sends a\" + CR +\n            \"                             statement\" + CR +\n            \" -j,--node <arg>             Writes a JDBC node file for the given SQL\" + CR +\n            \"                             (internal debugging)\" + CR +\n            \" -l,--columnNames <arg>      Column XML names; default names column\" + CR +\n            \"                             labels. Example: -l \\\"cname1 cname2\\\"\" + CR +\n            \" -m,--printMetaData          Prints metadata information\" + CR +\n            \" -n,--info                   Prints driver information and properties. If\" + CR +\n            \"                             -c is not specified, all drivers on the\" + CR +\n            \"                             classpath are displayed.\" + CR +\n            \" -o,--paramModes <arg>       Parameters modes (1=IN, 2=INOUT, 4=OUT,\" + CR +\n            \"                             0=Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -o \\\"4\" + CR +\n            \"                             1\\\"\" + CR +\n            \" -O,--paramModeNames <arg>   Parameters mode names (IN, INOUT, OUT,\" + CR +\n            \"                             Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -O \\\"OUT\" + CR +\n            \"                             IN\\\"\" + CR +\n            \" -p,--password <arg>         The database password for the user specified\" + CR +\n            \"                             with the -u option. You can obfuscate the\" + CR +\n            \"                             password with\" + CR +\n            \"                             org.mortbay.jetty.security.Password, see\" + CR +\n            \"                             https://docs.codehaus.org/display/JETTY/Secur\" + CR +\n            \"                             ing+Passwords\" + CR +\n            \" -s,--sql <arg>              Runs SQL or {call stored_procedure(?, ?)} or\" + CR +\n            \"                             {?=call function(?, ?)}\" + CR +\n            \" -t,--printStack             Prints stack traces on errors\" + CR +\n            \"    --trim <arg>             Trims leading and trailing spaces from all\" + CR +\n            \"                             column values. Column XML names can be\" + CR +\n            \"                             optionally specified to set which columns to\" + CR +\n            \"                             trim.\" + CR +\n            \" -u,--user <arg>             A database user name\" + CR +\n            \" -w,--outfile <arg>          Writes the SQL output to the given file\" + CR +\n            \" -y,--paramTypes <arg>       Parameter types from java.sql.Types. -y and\" + CR +\n            \"                             -Y are mutually exclusive. Example: -y \\\"-10\" + CR +\n            \"                             12\\\"\" + CR +\n            \" -Y,--paramTypeNames <arg>   Parameter java.sql.Types names. -y and -Y are\" + CR +\n            \"                             mutually exclusive. Example: -Y \\\"CURSOR\" + CR +\n            \"                             VARCHAR\\\"\" + CR;", "docstring": " @formatter:off", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "EXPECTED = \"usage: org.apache.commons.cli.bug.BugCLI162Test\" + CR +\n            \" -2,--jdbc2sfmd <arg>        Converts the JDBC file in the first argument\" + CR +\n            \"                             to an SMFD file specified in the second\" + CR +\n            \"                             argument.\" + CR +\n            \" -a,--paramNames <arg>       Parameter XML names; default names are\" + CR +\n            \"                             param1, param2, etc. Example: -a \\\"pname1\" + CR +\n            \"                             pname2\\\"\" + CR +\n            \" -b,--jdbc <arg>             Writes a JDBC binding node file for the given\" + CR +\n            \"                             SQL\" + CR +\n            \" -c,--url <arg>              Connection URL\" + CR +\n            \" -d,--driver <arg>           JDBC driver class name\" + CR +\n            \" -e,--description <arg>      SFMD description. A default description is\" + CR +\n            \"                             used if omited. Example: -e \\\"Runs such and\" + CR +\n            \"                             such\\\"\" + CR +\n            \" -f,--sfmd <arg>             Writes a SFMD file for the given SQL\" + CR +\n            \" -g,--printTiming            Prints timing information\" + CR +\n            \" -h,--help                   Prints help and quits\" + CR +\n            \" -i,--interactive            Runs in interactive mode, reading and writing\" + CR +\n            \"                             from the console, 'go' or '/' sends a\" + CR +\n            \"                             statement\" + CR +\n            \" -j,--node <arg>             Writes a JDBC node file for the given SQL\" + CR +\n            \"                             (internal debugging)\" + CR +\n            \" -l,--columnNames <arg>      Column XML names; default names column\" + CR +\n            \"                             labels. Example: -l \\\"cname1 cname2\\\"\" + CR +\n            \" -m,--printMetaData          Prints metadata information\" + CR +\n            \" -n,--info                   Prints driver information and properties. If\" + CR +\n            \"                             -c is not specified, all drivers on the\" + CR +\n            \"                             classpath are displayed.\" + CR +\n            \" -o,--paramModes <arg>       Parameters modes (1=IN, 2=INOUT, 4=OUT,\" + CR +\n            \"                             0=Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -o \\\"4\" + CR +\n            \"                             1\\\"\" + CR +\n            \" -O,--paramModeNames <arg>   Parameters mode names (IN, INOUT, OUT,\" + CR +\n            \"                             Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -O \\\"OUT\" + CR +\n            \"                             IN\\\"\" + CR +\n            \" -p,--password <arg>         The database password for the user specified\" + CR +\n            \"                             with the -u option. You can obfuscate the\" + CR +\n            \"                             password with\" + CR +\n            \"                             org.mortbay.jetty.security.Password, see\" + CR +\n            \"                             https://docs.codehaus.org/display/JETTY/Secur\" + CR +\n            \"                             ing+Passwords\" + CR +\n            \" -s,--sql <arg>              Runs SQL or {call stored_procedure(?, ?)} or\" + CR +\n            \"                             {?=call function(?, ?)}\" + CR +\n            \" -t,--printStack             Prints stack traces on errors\" + CR +\n            \"    --trim <arg>             Trims leading and trailing spaces from all\" + CR +\n            \"                             column values. Column XML names can be\" + CR +\n            \"                             optionally specified to set which columns to\" + CR +\n            \"                             trim.\" + CR +\n            \" -u,--user <arg>             A database user name\" + CR +\n            \" -w,--outfile <arg>          Writes the SQL output to the given file\" + CR +\n            \" -y,--paramTypes <arg>       Parameter types from java.sql.Types. -y and\" + CR +\n            \"                             -Y are mutually exclusive. Example: -y \\\"-10\" + CR +\n            \"                             12\\\"\" + CR +\n            \" -Y,--paramTypeNames <arg>   Parameter java.sql.Types names. -y and -Y are\" + CR +\n            \"                             mutually exclusive. Example: -Y \\\"CURSOR\" + CR +\n            \"                             VARCHAR\\\"\" + CR", "syntax_pass": true}, {"attribute_expression": "private HelpFormatter formatter;", "docstring": " @formatter:on", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HelpFormatter", "name": "formatter", "syntax_pass": true}, {"attribute_expression": "private StringWriter sw;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StringWriter", "name": "sw", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        formatter = new HelpFormatter();\n        sw = new StringWriter();\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        formatter = new HelpFormatter();\n        sw = new StringWriter();\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testInfiniteLoop() {\n        final Options options = new Options();\n        options.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n        // used to hang & crash\n        formatter.printHelp(new PrintWriter(sw), 20, \"app\", null, options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null);\n\n        //@formatter:off\n        final String expected = \"usage: app\" + CR +\n                \" -h,--help   This is\" + CR +\n                \"             a\" + CR +\n                \"             looooon\" + CR +\n                \"             g\" + CR +\n                \"             descrip\" + CR +\n                \"             tion\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInfiniteLoop", "params": [], "body": "                                   {\n        final Options options = new Options();\n        options.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n        // used to hang & crash\n        formatter.printHelp(new PrintWriter(sw), 20, \"app\", null, options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null);\n\n        //@formatter:off\n        final String expected = \"usage: app\" + CR +\n                \" -h,--help   This is\" + CR +\n                \"             a\" + CR +\n                \"             looooon\" + CR +\n                \"             g\" + CR +\n                \"             descrip\" + CR +\n                \"             tion\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString());\n    }", "signature": "@Test\n    public void testInfiniteLoop()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongLineChunking() {\n        final Options options = new Options();\n        //@formatter:off\n        options.addOption(\"x\", \"extralongarg\", false,\n                          \"This description has ReallyLongValuesThatAreLongerThanTheWidthOfTheColumns \" +\n                          \"and also other ReallyLongValuesThatAreHugerAndBiggerThanTheWidthOfTheColumnsBob, \" +\n                          \"yes. \");\n        //@formatter:on\n        formatter.printHelp(new PrintWriter(sw), 35, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        //@formatter:off\n        final String expected = \"usage:\" + CR +\n                          \"       org.apache.commons.cli.bug.B\" + CR +\n                          \"       ugCLI162Test\" + CR +\n                          \"Header\" + CR +\n                          \"-x,--extralongarg     This\" + CR +\n                          \"                      description\" + CR +\n                          \"                      has\" + CR +\n                          \"                      ReallyLongVal\" + CR +\n                          \"                      uesThatAreLon\" + CR +\n                          \"                      gerThanTheWid\" + CR +\n                          \"                      thOfTheColumn\" + CR +\n                          \"                      s and also\" + CR +\n                          \"                      other\" + CR +\n                          \"                      ReallyLongVal\" + CR +\n                          \"                      uesThatAreHug\" + CR +\n                          \"                      erAndBiggerTh\" + CR +\n                          \"                      anTheWidthOfT\" + CR +\n                          \"                      heColumnsBob,\" + CR +\n                          \"                      yes.\" + CR +\n                          \"Footer\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString(), \"Long arguments did not split as expected\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongLineChunking", "params": [], "body": "                                       {\n        final Options options = new Options();\n        //@formatter:off\n        options.addOption(\"x\", \"extralongarg\", false,\n                          \"This description has ReallyLongValuesThatAreLongerThanTheWidthOfTheColumns \" +\n                          \"and also other ReallyLongValuesThatAreHugerAndBiggerThanTheWidthOfTheColumnsBob, \" +\n                          \"yes. \");\n        //@formatter:on\n        formatter.printHelp(new PrintWriter(sw), 35, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        //@formatter:off\n        final String expected = \"usage:\" + CR +\n                          \"       org.apache.commons.cli.bug.B\" + CR +\n                          \"       ugCLI162Test\" + CR +\n                          \"Header\" + CR +\n                          \"-x,--extralongarg     This\" + CR +\n                          \"                      description\" + CR +\n                          \"                      has\" + CR +\n                          \"                      ReallyLongVal\" + CR +\n                          \"                      uesThatAreLon\" + CR +\n                          \"                      gerThanTheWid\" + CR +\n                          \"                      thOfTheColumn\" + CR +\n                          \"                      s and also\" + CR +\n                          \"                      other\" + CR +\n                          \"                      ReallyLongVal\" + CR +\n                          \"                      uesThatAreHug\" + CR +\n                          \"                      erAndBiggerTh\" + CR +\n                          \"                      anTheWidthOfT\" + CR +\n                          \"                      heColumnsBob,\" + CR +\n                          \"                      yes.\" + CR +\n                          \"Footer\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString(), \"Long arguments did not split as expected\");\n    }", "signature": "@Test\n    public void testLongLineChunking()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLongLineChunkingIndentIgnored() {\n        final Options options = new Options();\n        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\");\n        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        //@formatter:off\n        final String expected = \"usage:\" + CR +\n                          \"       org.apache.comm\" + CR +\n                          \"       ons.cli.bug.Bug\" + CR +\n                          \"       CLI162Test\" + CR +\n                          \"Header\" + CR +\n                          \"-x,--extralongarg\" + CR +\n                          \" This description is\" + CR +\n                          \" Long.\" + CR +\n                          \"Footer\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString(), \"Long arguments did not split as expected\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLongLineChunkingIndentIgnored", "params": [], "body": "                                                    {\n        final Options options = new Options();\n        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\");\n        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        //@formatter:off\n        final String expected = \"usage:\" + CR +\n                          \"       org.apache.comm\" + CR +\n                          \"       ons.cli.bug.Bug\" + CR +\n                          \"       CLI162Test\" + CR +\n                          \"Header\" + CR +\n                          \"-x,--extralongarg\" + CR +\n                          \" This description is\" + CR +\n                          \" Long.\" + CR +\n                          \"Footer\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString(), \"Long arguments did not split as expected\");\n    }", "signature": "@Test\n    public void testLongLineChunkingIndentIgnored()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPrintHelpLongLines() {\n        // Options build\n        final Options commandLineOptions;\n        commandLineOptions = new Options();\n        commandLineOptions.addOption(OPT_HELP, OPT_HELP_LONG, false, \"Prints help and quits\");\n        commandLineOptions.addOption(OPT_DRIVER, \"driver\", true, \"JDBC driver class name\");\n        //@formatter:off\n        commandLineOptions.addOption(OPT_DRIVER_INFO, \"info\", false, \"Prints driver information and properties. If \"\n            + OPT\n            + OPT_CONNECTION\n            + \" is not specified, all drivers on the classpath are displayed.\");\n        //@formatter:on\n        commandLineOptions.addOption(OPT_CONNECTION, \"url\", true, \"Connection URL\");\n        commandLineOptions.addOption(OPT_USER, \"user\", true, \"A database user name\");\n        //@formatter:off\n        commandLineOptions\n                .addOption(\n                        OPT_PASSWORD,\n                        OPT_PASSWORD_L,\n                        true,\n                        \"The database password for the user specified with the \"\n                            + OPT\n                            + OPT_USER\n                            + \" option. You can obfuscate the password with org.mortbay.jetty.security.Password,\"\n                            + \" see https://docs.codehaus.org/display/JETTY/Securing+Passwords\");\n        //@formatter:on\n        commandLineOptions.addOption(OPT_SQL, OPT_SQL_L, true, \"Runs SQL or {call stored_procedure(?, ?)} or {?=call function(?, ?)}\");\n        commandLineOptions.addOption(OPT_FILE_SFMD, \"sfmd\", true, \"Writes a SFMD file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_BINDING, \"jdbc\", true, \"Writes a JDBC binding node file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_JDBC, \"node\", true, \"Writes a JDBC node file for the given SQL (internal debugging)\");\n        commandLineOptions.addOption(OPT_WRITE_TO_FILE, \"outfile\", true, \"Writes the SQL output to the given file\");\n        commandLineOptions.addOption(OPT_DESCRIPTION, \"description\", true,\n            \"SFMD description. A default description is used if omited. Example: \" + OPT + OPT_DESCRIPTION + \" \\\"Runs such and such\\\"\");\n        commandLineOptions.addOption(OPT_INTERACTIVE, \"interactive\", false,\n            \"Runs in interactive mode, reading and writing from the console, 'go' or '/' sends a statement\");\n        commandLineOptions.addOption(OPT_TIMING, \"printTiming\", false, \"Prints timing information\");\n        commandLineOptions.addOption(OPT_METADATA, \"printMetaData\", false, \"Prints metadata information\");\n        commandLineOptions.addOption(OPT_STACK_TRACE, \"printStack\", false, \"Prints stack traces on errors\");\n        //@formatter:off\n        Option option = new Option(OPT_COLUMN_NAMES, \"columnNames\", true, \"Column XML names; default names column labels. Example: \"\n            + OPT\n            + OPT_COLUMN_NAMES\n            + \" \\\"cname1 cname2\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_NAMES, \"paramNames\", true, \"Parameter XML names; default names are param1, param2, etc. Example: \"\n            + OPT\n            + OPT_PARAM_NAMES\n            + \" \\\"pname1 pname2\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //\n        final OptionGroup pOutTypesOptionGroup = new OptionGroup();\n        final String pOutTypesOptionGroupDoc = OPT + OPT_PARAM_TYPES_INT + \" and \" + OPT + OPT_PARAM_TYPES_NAME + \" are mutually exclusive.\";\n        final String typesClassName = Types.class.getName();\n        //@formatter:off\n        option = new Option(OPT_PARAM_TYPES_INT, \"paramTypes\", true, \"Parameter types from \"\n            + typesClassName\n            + \". \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_INT\n            + \" \\\"-10 12\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_TYPES_NAME, \"paramTypeNames\", true, \"Parameter \"\n            + typesClassName\n            + \" names. \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_NAME\n            + \" \\\"CURSOR VARCHAR\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        commandLineOptions.addOptionGroup(pOutTypesOptionGroup);\n        //\n        final OptionGroup modesOptionGroup = new OptionGroup();\n        final String modesOptionGroupDoc = OPT + OPT_PARAM_MODES_INT + \" and \" + OPT + OPT_PARAM_MODES_NAME + \" are mutually exclusive.\";\n        //@formatter:off\n        option = new Option(OPT_PARAM_MODES_INT, \"paramModes\", true, \"Parameters modes (\"\n            + ParameterMetaData.parameterModeIn\n            + \"=IN, \"\n            + ParameterMetaData.parameterModeInOut\n            + \"=INOUT, \"\n            + ParameterMetaData.parameterModeOut\n            + \"=OUT, \"\n            + ParameterMetaData.parameterModeUnknown\n            + \"=Unknown\"\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_INT\n            + \" \\\"\"\n            + ParameterMetaData.parameterModeOut\n            + \" \"\n            + ParameterMetaData.parameterModeIn\n            + \"\\\"\");\n        //@formatter:on\n        modesOptionGroup.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_MODES_NAME, \"paramModeNames\", true, \"Parameters mode names (\"\n            + PMODES\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_NAME\n            + \" \\\"\"\n            + PMODE_OUT\n            + \" \"\n            + PMODE_IN\n            + \"\\\"\");\n        //@formatter:on\n        modesOptionGroup.addOption(option);\n        commandLineOptions.addOptionGroup(modesOptionGroup);\n        option = new Option(null, OPT_TRIM_L, true,\n            \"Trims leading and trailing spaces from all column values. Column XML names can be optionally specified to set which columns to trim.\");\n        option.setOptionalArg(true);\n        commandLineOptions.addOption(option);\n        option = new Option(OPT_JDBC_TO_SFMD, OPT_JDBC_TO_SFMD_L, true,\n            \"Converts the JDBC file in the first argument to an SMFD file specified in the second argument.\");\n        option.setArgs(2);\n        commandLineOptions.addOption(option);\n\n        formatter.printHelp(new PrintWriter(sw), HelpFormatter.DEFAULT_WIDTH, this.getClass().getName(), null, commandLineOptions,\n            HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null);\n        //@formatter:on\n        assertEquals(EXPECTED, sw.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPrintHelpLongLines", "params": [], "body": "                                         {\n        // Options build\n        final Options commandLineOptions;\n        commandLineOptions = new Options();\n        commandLineOptions.addOption(OPT_HELP, OPT_HELP_LONG, false, \"Prints help and quits\");\n        commandLineOptions.addOption(OPT_DRIVER, \"driver\", true, \"JDBC driver class name\");\n        //@formatter:off\n        commandLineOptions.addOption(OPT_DRIVER_INFO, \"info\", false, \"Prints driver information and properties. If \"\n            + OPT\n            + OPT_CONNECTION\n            + \" is not specified, all drivers on the classpath are displayed.\");\n        //@formatter:on\n        commandLineOptions.addOption(OPT_CONNECTION, \"url\", true, \"Connection URL\");\n        commandLineOptions.addOption(OPT_USER, \"user\", true, \"A database user name\");\n        //@formatter:off\n        commandLineOptions\n                .addOption(\n                        OPT_PASSWORD,\n                        OPT_PASSWORD_L,\n                        true,\n                        \"The database password for the user specified with the \"\n                            + OPT\n                            + OPT_USER\n                            + \" option. You can obfuscate the password with org.mortbay.jetty.security.Password,\"\n                            + \" see https://docs.codehaus.org/display/JETTY/Securing+Passwords\");\n        //@formatter:on\n        commandLineOptions.addOption(OPT_SQL, OPT_SQL_L, true, \"Runs SQL or {call stored_procedure(?, ?)} or {?=call function(?, ?)}\");\n        commandLineOptions.addOption(OPT_FILE_SFMD, \"sfmd\", true, \"Writes a SFMD file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_BINDING, \"jdbc\", true, \"Writes a JDBC binding node file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_JDBC, \"node\", true, \"Writes a JDBC node file for the given SQL (internal debugging)\");\n        commandLineOptions.addOption(OPT_WRITE_TO_FILE, \"outfile\", true, \"Writes the SQL output to the given file\");\n        commandLineOptions.addOption(OPT_DESCRIPTION, \"description\", true,\n            \"SFMD description. A default description is used if omited. Example: \" + OPT + OPT_DESCRIPTION + \" \\\"Runs such and such\\\"\");\n        commandLineOptions.addOption(OPT_INTERACTIVE, \"interactive\", false,\n            \"Runs in interactive mode, reading and writing from the console, 'go' or '/' sends a statement\");\n        commandLineOptions.addOption(OPT_TIMING, \"printTiming\", false, \"Prints timing information\");\n        commandLineOptions.addOption(OPT_METADATA, \"printMetaData\", false, \"Prints metadata information\");\n        commandLineOptions.addOption(OPT_STACK_TRACE, \"printStack\", false, \"Prints stack traces on errors\");\n        //@formatter:off\n        Option option = new Option(OPT_COLUMN_NAMES, \"columnNames\", true, \"Column XML names; default names column labels. Example: \"\n            + OPT\n            + OPT_COLUMN_NAMES\n            + \" \\\"cname1 cname2\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_NAMES, \"paramNames\", true, \"Parameter XML names; default names are param1, param2, etc. Example: \"\n            + OPT\n            + OPT_PARAM_NAMES\n            + \" \\\"pname1 pname2\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //\n        final OptionGroup pOutTypesOptionGroup = new OptionGroup();\n        final String pOutTypesOptionGroupDoc = OPT + OPT_PARAM_TYPES_INT + \" and \" + OPT + OPT_PARAM_TYPES_NAME + \" are mutually exclusive.\";\n        final String typesClassName = Types.class.getName();\n        //@formatter:off\n        option = new Option(OPT_PARAM_TYPES_INT, \"paramTypes\", true, \"Parameter types from \"\n            + typesClassName\n            + \". \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_INT\n            + \" \\\"-10 12\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_TYPES_NAME, \"paramTypeNames\", true, \"Parameter \"\n            + typesClassName\n            + \" names. \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_NAME\n            + \" \\\"CURSOR VARCHAR\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        commandLineOptions.addOptionGroup(pOutTypesOptionGroup);\n        //\n        final OptionGroup modesOptionGroup = new OptionGroup();\n        final String modesOptionGroupDoc = OPT + OPT_PARAM_MODES_INT + \" and \" + OPT + OPT_PARAM_MODES_NAME + \" are mutually exclusive.\";\n        //@formatter:off\n        option = new Option(OPT_PARAM_MODES_INT, \"paramModes\", true, \"Parameters modes (\"\n            + ParameterMetaData.parameterModeIn\n            + \"=IN, \"\n            + ParameterMetaData.parameterModeInOut\n            + \"=INOUT, \"\n            + ParameterMetaData.parameterModeOut\n            + \"=OUT, \"\n            + ParameterMetaData.parameterModeUnknown\n            + \"=Unknown\"\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_INT\n            + \" \\\"\"\n            + ParameterMetaData.parameterModeOut\n            + \" \"\n            + ParameterMetaData.parameterModeIn\n            + \"\\\"\");\n        //@formatter:on\n        modesOptionGroup.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_MODES_NAME, \"paramModeNames\", true, \"Parameters mode names (\"\n            + PMODES\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_NAME\n            + \" \\\"\"\n            + PMODE_OUT\n            + \" \"\n            + PMODE_IN\n            + \"\\\"\");\n        //@formatter:on\n        modesOptionGroup.addOption(option);\n        commandLineOptions.addOptionGroup(modesOptionGroup);\n        option = new Option(null, OPT_TRIM_L, true,\n            \"Trims leading and trailing spaces from all column values. Column XML names can be optionally specified to set which columns to trim.\");\n        option.setOptionalArg(true);\n        commandLineOptions.addOption(option);\n        option = new Option(OPT_JDBC_TO_SFMD, OPT_JDBC_TO_SFMD_L, true,\n            \"Converts the JDBC file in the first argument to an SMFD file specified in the second argument.\");\n        option.setArgs(2);\n        commandLineOptions.addOption(option);\n\n        formatter.printHelp(new PrintWriter(sw), HelpFormatter.DEFAULT_WIDTH, this.getClass().getName(), null, commandLineOptions,\n            HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null);\n        //@formatter:on\n        assertEquals(EXPECTED, sw.toString());\n    }", "signature": "@Test\n    public void testPrintHelpLongLines()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugCLI18Test.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli.bug;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\n\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.junit.jupiter.api.Test;\n\n/**\n * https://issues.apache.org/jira/browse/CLI-18\n */\npublic class BugCLI18Test {\n    @Test\n    public void testCLI18() {\n        final Options options = new Options();\n        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb dksh fkshd fkhs dkfhsdk fhskd hksdks dhfowehfsdhfkjshf skfhkshf sf jkshfk sfh skfh skf f\"));\n        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final StringWriter out = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\",\n            \"dsfkfsh kdh hsd hsdh fkshdf ksdh fskdh fsdh fkshfk sfdkjhskjh fkjh fkjsh khsdkj hfskdhf skjdfh ksf khf s\", options, 2, 2,\n            \"blort j jgj j jg jhghjghjgjhgjhg jgjhgj jhg jhg hjg jgjhghjg jhg hjg jhgjg jgjhghjg jg jgjhgjgjg jhg jhgjh\" + '\\r' + '\\n' + \"rarrr\", true);\n    }\n}\n", "file_hash": "ea0bc19c6d7fd91980bb547b8690021ef8ab970d753377923f5bd5e9120fee43", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import java.io.PrintWriter;", "import java.io.StringWriter;", "import org.apache.commons.cli.HelpFormatter;", "import org.apache.commons.cli.Option;", "import org.apache.commons.cli.Options;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class BugCLI18Test {\n    @Test\n    public void testCLI18() {\n        final Options options = new Options();\n        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb dksh fkshd fkhs dkfhsdk fhskd hksdks dhfowehfsdhfkjshf skfhkshf sf jkshfk sfh skfh skf f\"));\n        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final StringWriter out = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\",\n            \"dsfkfsh kdh hsd hsdh fkshdf ksdh fskdh fsdh fkshfk sfdkjhskjh fkjh fkjsh khsdkj hfskdhf skjdfh ksf khf s\", options, 2, 2,\n            \"blort j jgj j jg jhghjghjgjhgjhg jgjhgj jhg jhg hjg jgjhghjg jhg hjg jhgjg jgjhghjg jg jgjhgjgjg jhg jhgjh\" + '\\r' + '\\n' + \"rarrr\", true);\n    }\n}", "definition": "public class BugCLI18Test", "class_docstring": "\nhttps://issues.apache.org/jira/browse/CLI-18\n", "name": "BugCLI18Test", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testCLI18() {\n        final Options options = new Options();\n        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb dksh fkshd fkhs dkfhsdk fhskd hksdks dhfowehfsdhfkjshf skfhkshf sf jkshfk sfh skfh skf f\"));\n        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final StringWriter out = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\",\n            \"dsfkfsh kdh hsd hsdh fkshdf ksdh fskdh fsdh fkshfk sfdkjhskjh fkjh fkjsh khsdkj hfskdhf skjdfh ksf khf s\", options, 2, 2,\n            \"blort j jgj j jg jhghjghjgjhgjhg jgjhgj jhg jhg hjg jgjhghjg jhg hjg jhgjg jgjhghjg jg jgjhgjgjg jhg jhgjh\" + '\\r' + '\\n' + \"rarrr\", true);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCLI18", "params": [], "body": "                            {\n        final Options options = new Options();\n        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb dksh fkshd fkhs dkfhsdk fhskd hksdks dhfowehfsdhfkjshf skfhkshf sf jkshfk sfh skfh skf f\"));\n        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final StringWriter out = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\",\n            \"dsfkfsh kdh hsd hsdh fkshdf ksdh fskdh fsdh fkshfk sfdkjhskjh fkjh fkjsh khsdkj hfskdhf skjdfh ksf khf s\", options, 2, 2,\n            \"blort j jgj j jg jhghjghjgjhgjhg jgjhgj jhg jhg hjg jgjhghjg jhg hjg jhgjg jgjhghjg jg jgjhgjgjg jhg jhgjh\" + '\\r' + '\\n' + \"rarrr\", true);\n    }", "signature": "@Test\n    public void testCLI18()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugCLI312Test.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli.bug;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.MissingArgumentException;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Demonstrates inconsistencies in parsing Java property-style options.\n */\npublic class BugCLI312Test {\n    @Test\n    public void testNoOptionValues() {\n        final Option o1 = Option.builder(\"A\").build();\n        final Option o2 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n        final Options options = new Options().addOption(o1).addOption(o2);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        assertThrows(MissingArgumentException.class, () -> parser.parse(options, \"-D -A\".split(\" \")));\n    }\n\n    @Test\n    public void testPropertyStyleOption_withGetOptionProperties() throws ParseException {\n        final Option o1 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n\n        final Options options = new Options();\n        options.addOption(o1);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        final CommandLine cl = parser.parse(options, \"-Dv -Dw=1 -D x=2 -D y -D z=3 other\".split(\" \"));\n        assertArrayEquals(new String[] {\"v\", \"w\", \"1\", \"x\", \"2\", \"y\", \"z\", \"3\"}, cl.getOptionValues('D'));\n\n        final Properties properties = cl.getOptionProperties(\"D\");\n        assertEquals(\"true\", properties.getProperty(\"v\"));\n        assertEquals(\"1\", properties.getProperty(\"w\"));\n        assertEquals(\"2\", properties.getProperty(\"x\"));\n        assertEquals(\"true\", properties.getProperty(\"y\"));\n        assertEquals(\"3\", properties.getProperty(\"z\"));\n        assertEquals(5, properties.size());\n        assertEquals(\"other\", cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testPropertyStyleOption_withGetOptions() throws ParseException {\n        final Option o1 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n\n        final Options options = new Options();\n        options.addOption(o1);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        final CommandLine cl = parser.parse(options, \"-Dv -Dw=1 -D x=2 -D y -D z=3 other\".split(\" \"));\n        assertArrayEquals(new String[] {\"v\", \"w\", \"1\", \"x\", \"2\", \"y\", \"z\", \"3\"}, cl.getOptionValues('D'));\n\n        int defineOptionsFound = 0;\n        for (final Option o : cl.getOptions()) {\n            if (\"D\".equals(o.getOpt())) {\n                defineOptionsFound++;\n\n                switch (defineOptionsFound) {\n                case 1:\n                    assertArrayEquals(new String[] {\"v\"}, o.getValues());\n                    break;\n                case 2:\n                    assertArrayEquals(new String[] {\"w\", \"1\"}, o.getValues());\n                    break;\n                case 3:\n                    assertArrayEquals(new String[] {\"x\", \"2\"}, o.getValues());\n                    break;\n                case 4:\n                    assertArrayEquals(new String[] {\"y\"}, o.getValues());\n                    break;\n                case 5:\n                    assertArrayEquals(new String[] {\"z\", \"3\"}, o.getValues());\n                    break;\n                default:\n                    fail(\"Didn't expect \" + defineOptionsFound + \" occurrences of -D\");\n                    break;\n                }\n            }\n        }\n        assertEquals(\"other\", cl.getArgList().get(0));\n    }\n}\n", "file_hash": "0467a102adbc0cb617f7cd8a0ac7b7df882180d470640b5e8e18a8c8b87b97c8", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import static org.junit.jupiter.api.Assertions.assertArrayEquals;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import static org.junit.jupiter.api.Assertions.fail;", "import java.util.Properties;", "import org.apache.commons.cli.CommandLine;", "import org.apache.commons.cli.CommandLineParser;", "import org.apache.commons.cli.DefaultParser;", "import org.apache.commons.cli.MissingArgumentException;", "import org.apache.commons.cli.Option;", "import org.apache.commons.cli.Options;", "import org.apache.commons.cli.ParseException;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class BugCLI312Test {\n    @Test\n    public void testNoOptionValues() {\n        final Option o1 = Option.builder(\"A\").build();\n        final Option o2 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n        final Options options = new Options().addOption(o1).addOption(o2);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        assertThrows(MissingArgumentException.class, () -> parser.parse(options, \"-D -A\".split(\" \")));\n    }\n\n    @Test\n    public void testPropertyStyleOption_withGetOptionProperties() throws ParseException {\n        final Option o1 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n\n        final Options options = new Options();\n        options.addOption(o1);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        final CommandLine cl = parser.parse(options, \"-Dv -Dw=1 -D x=2 -D y -D z=3 other\".split(\" \"));\n        assertArrayEquals(new String[] {\"v\", \"w\", \"1\", \"x\", \"2\", \"y\", \"z\", \"3\"}, cl.getOptionValues('D'));\n\n        final Properties properties = cl.getOptionProperties(\"D\");\n        assertEquals(\"true\", properties.getProperty(\"v\"));\n        assertEquals(\"1\", properties.getProperty(\"w\"));\n        assertEquals(\"2\", properties.getProperty(\"x\"));\n        assertEquals(\"true\", properties.getProperty(\"y\"));\n        assertEquals(\"3\", properties.getProperty(\"z\"));\n        assertEquals(5, properties.size());\n        assertEquals(\"other\", cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testPropertyStyleOption_withGetOptions() throws ParseException {\n        final Option o1 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n\n        final Options options = new Options();\n        options.addOption(o1);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        final CommandLine cl = parser.parse(options, \"-Dv -Dw=1 -D x=2 -D y -D z=3 other\".split(\" \"));\n        assertArrayEquals(new String[] {\"v\", \"w\", \"1\", \"x\", \"2\", \"y\", \"z\", \"3\"}, cl.getOptionValues('D'));\n\n        int defineOptionsFound = 0;\n        for (final Option o : cl.getOptions()) {\n            if (\"D\".equals(o.getOpt())) {\n                defineOptionsFound++;\n\n                switch (defineOptionsFound) {\n                case 1:\n                    assertArrayEquals(new String[] {\"v\"}, o.getValues());\n                    break;\n                case 2:\n                    assertArrayEquals(new String[] {\"w\", \"1\"}, o.getValues());\n                    break;\n                case 3:\n                    assertArrayEquals(new String[] {\"x\", \"2\"}, o.getValues());\n                    break;\n                case 4:\n                    assertArrayEquals(new String[] {\"y\"}, o.getValues());\n                    break;\n                case 5:\n                    assertArrayEquals(new String[] {\"z\", \"3\"}, o.getValues());\n                    break;\n                default:\n                    fail(\"Didn't expect \" + defineOptionsFound + \" occurrences of -D\");\n                    break;\n                }\n            }\n        }\n        assertEquals(\"other\", cl.getArgList().get(0));\n    }\n}", "definition": "public class BugCLI312Test", "class_docstring": "\nDemonstrates inconsistencies in parsing Java property-style options.\n", "name": "BugCLI312Test", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testNoOptionValues() {\n        final Option o1 = Option.builder(\"A\").build();\n        final Option o2 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n        final Options options = new Options().addOption(o1).addOption(o2);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        assertThrows(MissingArgumentException.class, () -> parser.parse(options, \"-D -A\".split(\" \")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNoOptionValues", "params": [], "body": "                                     {\n        final Option o1 = Option.builder(\"A\").build();\n        final Option o2 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n        final Options options = new Options().addOption(o1).addOption(o2);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        assertThrows(MissingArgumentException.class, () -> parser.parse(options, \"-D -A\".split(\" \")));\n    }", "signature": "@Test\n    public void testNoOptionValues()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPropertyStyleOption_withGetOptionProperties() throws ParseException {\n        final Option o1 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n\n        final Options options = new Options();\n        options.addOption(o1);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        final CommandLine cl = parser.parse(options, \"-Dv -Dw=1 -D x=2 -D y -D z=3 other\".split(\" \"));\n        assertArrayEquals(new String[] {\"v\", \"w\", \"1\", \"x\", \"2\", \"y\", \"z\", \"3\"}, cl.getOptionValues('D'));\n\n        final Properties properties = cl.getOptionProperties(\"D\");\n        assertEquals(\"true\", properties.getProperty(\"v\"));\n        assertEquals(\"1\", properties.getProperty(\"w\"));\n        assertEquals(\"2\", properties.getProperty(\"x\"));\n        assertEquals(\"true\", properties.getProperty(\"y\"));\n        assertEquals(\"3\", properties.getProperty(\"z\"));\n        assertEquals(5, properties.size());\n        assertEquals(\"other\", cl.getArgList().get(0));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertyStyleOption_withGetOptionProperties", "params": [], "body": "                                                                                        {\n        final Option o1 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n\n        final Options options = new Options();\n        options.addOption(o1);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        final CommandLine cl = parser.parse(options, \"-Dv -Dw=1 -D x=2 -D y -D z=3 other\".split(\" \"));\n        assertArrayEquals(new String[] {\"v\", \"w\", \"1\", \"x\", \"2\", \"y\", \"z\", \"3\"}, cl.getOptionValues('D'));\n\n        final Properties properties = cl.getOptionProperties(\"D\");\n        assertEquals(\"true\", properties.getProperty(\"v\"));\n        assertEquals(\"1\", properties.getProperty(\"w\"));\n        assertEquals(\"2\", properties.getProperty(\"x\"));\n        assertEquals(\"true\", properties.getProperty(\"y\"));\n        assertEquals(\"3\", properties.getProperty(\"z\"));\n        assertEquals(5, properties.size());\n        assertEquals(\"other\", cl.getArgList().get(0));\n    }", "signature": "@Test\n    public void testPropertyStyleOption_withGetOptionProperties()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPropertyStyleOption_withGetOptions() throws ParseException {\n        final Option o1 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n\n        final Options options = new Options();\n        options.addOption(o1);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        final CommandLine cl = parser.parse(options, \"-Dv -Dw=1 -D x=2 -D y -D z=3 other\".split(\" \"));\n        assertArrayEquals(new String[] {\"v\", \"w\", \"1\", \"x\", \"2\", \"y\", \"z\", \"3\"}, cl.getOptionValues('D'));\n\n        int defineOptionsFound = 0;\n        for (final Option o : cl.getOptions()) {\n            if (\"D\".equals(o.getOpt())) {\n                defineOptionsFound++;\n\n                switch (defineOptionsFound) {\n                case 1:\n                    assertArrayEquals(new String[] {\"v\"}, o.getValues());\n                    break;\n                case 2:\n                    assertArrayEquals(new String[] {\"w\", \"1\"}, o.getValues());\n                    break;\n                case 3:\n                    assertArrayEquals(new String[] {\"x\", \"2\"}, o.getValues());\n                    break;\n                case 4:\n                    assertArrayEquals(new String[] {\"y\"}, o.getValues());\n                    break;\n                case 5:\n                    assertArrayEquals(new String[] {\"z\", \"3\"}, o.getValues());\n                    break;\n                default:\n                    fail(\"Didn't expect \" + defineOptionsFound + \" occurrences of -D\");\n                    break;\n                }\n            }\n        }\n        assertEquals(\"other\", cl.getArgList().get(0));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPropertyStyleOption_withGetOptions", "params": [], "body": "                                                                               {\n        final Option o1 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n\n        final Options options = new Options();\n        options.addOption(o1);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        final CommandLine cl = parser.parse(options, \"-Dv -Dw=1 -D x=2 -D y -D z=3 other\".split(\" \"));\n        assertArrayEquals(new String[] {\"v\", \"w\", \"1\", \"x\", \"2\", \"y\", \"z\", \"3\"}, cl.getOptionValues('D'));\n\n        int defineOptionsFound = 0;\n        for (final Option o : cl.getOptions()) {\n            if (\"D\".equals(o.getOpt())) {\n                defineOptionsFound++;\n\n                switch (defineOptionsFound) {\n                case 1:\n                    assertArrayEquals(new String[] {\"v\"}, o.getValues());\n                    break;\n                case 2:\n                    assertArrayEquals(new String[] {\"w\", \"1\"}, o.getValues());\n                    break;\n                case 3:\n                    assertArrayEquals(new String[] {\"x\", \"2\"}, o.getValues());\n                    break;\n                case 4:\n                    assertArrayEquals(new String[] {\"y\"}, o.getValues());\n                    break;\n                case 5:\n                    assertArrayEquals(new String[] {\"z\", \"3\"}, o.getValues());\n                    break;\n                default:\n                    fail(\"Didn't expect \" + defineOptionsFound + \" occurrences of -D\");\n                    break;\n                }\n            }\n        }\n        assertEquals(\"other\", cl.getArgList().get(0));\n    }", "signature": "@Test\n    public void testPropertyStyleOption_withGetOptions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/cli/bug/BugCLI252Test.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli.bug;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.apache.commons.cli.AmbiguousOptionException;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.junit.jupiter.api.Test;\n\npublic class BugCLI252Test {\n\n    private Options getOptions() {\n        final Options options = new Options();\n        options.addOption(Option.builder().longOpt(\"prefix\").build());\n        options.addOption(Option.builder().longOpt(\"prefixplusplus\").build());\n        return options;\n    }\n\n    @Test\n    public void testAmbiquousOptionName() {\n        assertThrows(AmbiguousOptionException.class, () ->\n                new DefaultParser().parse(getOptions(), new String[]{\"--pref\"})\n        );\n    }\n\n    @Test\n    public void testExactOptionNameMatch() throws ParseException {\n        new DefaultParser().parse(getOptions(), new String[] {\"--prefix\"});\n    }\n\n}\n", "file_hash": "7022b91bc72f53e45f8f614b377d1647d00cb20784a8b618f0de5f5de5011021", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli.bug;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import org.apache.commons.cli.AmbiguousOptionException;", "import org.apache.commons.cli.DefaultParser;", "import org.apache.commons.cli.Option;", "import org.apache.commons.cli.Options;", "import org.apache.commons.cli.ParseException;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class BugCLI252Test {\n\n    private Options getOptions() {\n        final Options options = new Options();\n        options.addOption(Option.builder().longOpt(\"prefix\").build());\n        options.addOption(Option.builder().longOpt(\"prefixplusplus\").build());\n        return options;\n    }\n\n    @Test\n    public void testAmbiquousOptionName() {\n        assertThrows(AmbiguousOptionException.class, () ->\n                new DefaultParser().parse(getOptions(), new String[]{\"--pref\"})\n        );\n    }\n\n    @Test\n    public void testExactOptionNameMatch() throws ParseException {\n        new DefaultParser().parse(getOptions(), new String[] {\"--prefix\"});\n    }\n\n}", "definition": "public class BugCLI252Test", "class_docstring": "", "name": "BugCLI252Test", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Options getOptions() {\n        final Options options = new Options();\n        options.addOption(Option.builder().longOpt(\"prefix\").build());\n        options.addOption(Option.builder().longOpt(\"prefixplusplus\").build());\n        return options;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Options", "classes": []}, "name": "getOptions", "params": [], "body": "                                 {\n        final Options options = new Options();\n        options.addOption(Option.builder().longOpt(\"prefix\").build());\n        options.addOption(Option.builder().longOpt(\"prefixplusplus\").build());\n        return options;\n    }", "signature": "private Options getOptions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAmbiquousOptionName() {\n        assertThrows(AmbiguousOptionException.class, () ->\n                new DefaultParser().parse(getOptions(), new String[]{\"--pref\"})\n        );\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAmbiquousOptionName", "params": [], "body": "                                          {\n        assertThrows(AmbiguousOptionException.class, () ->\n                new DefaultParser().parse(getOptions(), new String[]{\"--pref\"})\n        );\n    }", "signature": "@Test\n    public void testAmbiquousOptionName()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExactOptionNameMatch() throws ParseException {\n        new DefaultParser().parse(getOptions(), new String[] {\"--prefix\"});\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExactOptionNameMatch", "params": [], "body": "                                                                 {\n        new DefaultParser().parse(getOptions(), new String[] {\"--prefix\"});\n    }", "signature": "@Test\n    public void testExactOptionNameMatch()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Thrown during parsing signaling an unrecognized option.\n */\npublic class UnrecognizedOptionException extends ParseException {\n\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = -252504690284625623L;\n\n    /** The unrecognized option. */\n    private final String option;\n\n    /**\n     * Constructs a new {@code UnrecognizedArgumentException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public UnrecognizedOptionException(final String message) {\n        this(message, null);\n    }\n\n    /**\n     * Constructs a new {@code UnrecognizedArgumentException} with the specified option and detail message.\n     *\n     * @param message the detail message\n     * @param option the unrecognized option\n     * @since 1.2\n     */\n    public UnrecognizedOptionException(final String message, final String option) {\n        super(message);\n        this.option = option;\n    }\n\n    /**\n     * Gets the unrecognized option.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public String getOption() {\n        return option;\n    }\n}\n", "file_hash": "ac3bea8e16bc3e05263535636839fe21e140e0c0d899d0f12613e57f64ee3af9", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;"], "methods": [], "classes": [{"original_string": "public class UnrecognizedOptionException extends ParseException {\n\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = -252504690284625623L;\n\n    /** The unrecognized option. */\n    private final String option;\n\n    /**\n     * Constructs a new {@code UnrecognizedArgumentException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public UnrecognizedOptionException(final String message) {\n        this(message, null);\n    }\n\n    /**\n     * Constructs a new {@code UnrecognizedArgumentException} with the specified option and detail message.\n     *\n     * @param message the detail message\n     * @param option the unrecognized option\n     * @since 1.2\n     */\n    public UnrecognizedOptionException(final String message, final String option) {\n        super(message);\n        this.option = option;\n    }\n\n    /**\n     * Gets the unrecognized option.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public String getOption() {\n        return option;\n    }\n}", "definition": "public class UnrecognizedOptionException extends ParseException", "class_docstring": "\nThrown during parsing signaling an unrecognized option.\n", "name": "UnrecognizedOptionException", "super_interfaces": [], "superclasses": "ParseException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -252504690284625623L;", "docstring": "\nThis exception {@code serialVersionUID}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -252504690284625623L", "syntax_pass": true}, {"attribute_expression": "private final String option;", "docstring": " The unrecognized option.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "option", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public UnrecognizedOptionException(final String message) {\n        this(message, null);\n    }", "docstring": "\nConstructs a new {@code UnrecognizedArgumentException} with the specified detail message.\n\n@param message the detail message\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "UnrecognizedOptionException", "params": [{"name": "message", "type": "String"}], "body": "                                                             {\n        this(message, null);\n    }", "signature": "public UnrecognizedOptionException(final String message)"}, {"syntax_pass": true, "original_string": "    public UnrecognizedOptionException(final String message, final String option) {\n        super(message);\n        this.option = option;\n    }", "docstring": "\nConstructs a new {@code UnrecognizedArgumentException} with the specified option and detail message.\n\n@param message the detail message\n@param option the unrecognized option\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "UnrecognizedOptionException", "params": [{"name": "message", "type": "String"}, {"name": "option", "type": "String"}], "body": "                                                                                  {\n        super(message);\n        this.option = option;\n    }", "signature": "public UnrecognizedOptionException(final String message, final String option)"}, {"syntax_pass": true, "original_string": "    public String getOption() {\n        return option;\n    }", "docstring": "\nGets the unrecognized option.\n\n@return the related option\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOption", "params": [], "body": "                              {\n        return option;\n    }", "signature": "public String getOption()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/Option.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport static org.apache.commons.cli.Util.EMPTY_STRING_ARRAY;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * Describes a single command-line option. It maintains information regarding the short-name of the option, the long-name, if any exists, a flag indicating if\n * an argument is required for this option, and a self-documenting description of the option.\n * <p>\n * An Option is not created independently, but is created through an instance of {@link Options}. An Option is required to have at least a short or a long-name.\n * </p>\n * <p>\n * <b>Note:</b> once an {@link Option} has been added to an instance of {@link Options}, its required flag cannot be changed.\n * </p>\n *\n * @see org.apache.commons.cli.Options\n * @see org.apache.commons.cli.CommandLine\n */\npublic class Option implements Cloneable, Serializable {\n\n    /**\n     * Builds {@code Option} instances using descriptive methods.\n     * <p>\n     * Example usage:\n     * </p>\n     *\n     * <pre>\n     * Option option = Option.builder(\"a\").required(true).longOpt(\"arg-name\").build();\n     * </pre>\n     *\n     * @since 1.3\n     */\n    public static final class Builder {\n\n        /** The default type. */\n        private static final Class<String> DEFAULT_TYPE = String.class;\n\n        /**\n         * Returns the input Class or the default type (String) if null.\n         *\n         * @param type the candidate Class.\n         * @return the input Class or the default type (String) if null.\n         */\n        private static Class<?> toType(final Class<?> type) {\n            return type != null ? type : DEFAULT_TYPE;\n        }\n\n        /** The number of argument values this option can have. */\n        private int argCount = UNINITIALIZED;\n\n        /** The name of the argument for this option. */\n        private String argName;\n\n        /** The converter to convert to type. **/\n        private Converter<?, ?> converter;\n\n        /** Specifies whether this option is deprecated. */\n        private DeprecatedAttributes deprecated;\n\n        /** Description of the option. */\n        private String description;\n\n        /** The long representation of the option. */\n        private String longOption;\n\n        /** The name of the option. */\n        private String option;\n\n        /** Specifies whether the argument value of this Option is optional. */\n        private boolean optionalArg;\n\n        /** Specifies whether this option is required to be present. */\n        private boolean required;\n\n        /** Specifies the version when this option was added.  May be null */\n        private String since;\n\n        /** The type of this Option. */\n        private Class<?> type = DEFAULT_TYPE;\n\n        /** The character that is the value separator. */\n        private char valueSeparator;\n\n        /**\n         * Constructs a new {@code Builder} with the minimum required parameters for an {@code Option} instance.\n         *\n         * @param option short representation of the option.\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n         */\n        private Builder(final String option) throws IllegalArgumentException {\n            option(option);\n        }\n\n        /**\n         * Sets the display name for the argument value.\n         *\n         * @param argName the display name for the argument value.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder argName(final String argName) {\n            this.argName = argName;\n            return this;\n        }\n\n        /**\n         * Constructs an Option with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link Option}.\n         * @throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set.\n         */\n        public Option build() {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }\n\n        /**\n         * Sets the converter for the option.\n         * <p>\n         * Note: See {@link TypeHandler} for serialization discussion.\n         * </p>\n         *\n         * @param converter the Converter to use.\n         * @return this builder, to allow method chaining.\n         * @since 1.7.0\n         */\n        public Builder converter(final Converter<?, ?> converter) {\n            this.converter = converter;\n            return this;\n        }\n\n        /**\n         * Marks this Option as deprecated.\n         *\n         * @return this builder.\n         * @since 1.7.0\n         */\n        public Builder deprecated() {\n            return deprecated(DeprecatedAttributes.DEFAULT);\n        }\n\n        /**\n         * Sets whether the Option is deprecated.\n         *\n         * @param deprecated specifies whether the Option is deprecated.\n         * @return this builder.\n         * @since 1.7.0\n         */\n        public Builder deprecated(final DeprecatedAttributes deprecated) {\n            this.deprecated = deprecated;\n            return this;\n        }\n\n        /**\n         * Sets the description for this option.\n         *\n         * @param description the description of the option.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder desc(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Tests whether the Option will require an argument.\n         *\n         * @return this builder, to allow method chaining.\n         */\n        public Builder hasArg() {\n            return hasArg(true);\n        }\n\n        /**\n         * Tests whether the Option has an argument or not.\n         *\n         * @param hasArg specifies whether the Option takes an argument or not.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder hasArg(final boolean hasArg) {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : UNINITIALIZED;\n            return this;\n        }\n\n        /**\n         * Tests whether the Option can have unlimited argument values.\n         *\n         * @return this builder.\n         */\n        public Builder hasArgs() {\n            argCount = UNLIMITED_VALUES;\n            return this;\n        }\n\n        /**\n         * Sets the long name of the Option.\n         *\n         * @param longOption the long name of the Option\n         * @return this builder.\n         */\n        public Builder longOpt(final String longOption) {\n            this.longOption = longOption;\n            return this;\n        }\n\n        /**\n         * Sets the number of argument values the Option can take.\n         *\n         * @param argCount the number of argument values\n         * @return this builder.\n         */\n        public Builder numberOfArgs(final int argCount) {\n            this.argCount = argCount;\n            return this;\n        }\n\n        /**\n         * Sets the name of the Option.\n         *\n         * @param option the name of the Option.\n         * @return this builder.\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n         * @since 1.5.0\n         */\n        public Builder option(final String option) throws IllegalArgumentException {\n            this.option = OptionValidator.validate(option);\n            return this;\n        }\n\n        /**\n         * Sets whether the Option can have an optional argument.\n         *\n         * @param optionalArg specifies whether the Option can have an optional argument.\n         * @return this builder.\n         */\n        public Builder optionalArg(final boolean optionalArg) {\n            if (optionalArg && argCount == UNINITIALIZED) {\n                argCount = 1;\n            }\n            this.optionalArg = optionalArg;\n            return this;\n        }\n\n        /**\n         * Marks this Option as required.\n         *\n         * @return this builder.\n         */\n        public Builder required() {\n            return required(true);\n        }\n\n        /**\n         * Sets whether the Option is required.\n         *\n         * @param required specifies whether the Option is required.\n         * @return this builder.\n         */\n        public Builder required(final boolean required) {\n            this.required = required;\n            return this;\n        }\n\n        /** Sets the version number when this option was first defined.\"\n         *\n         * @param since the version number when this option was first defined.\n         * @return this builder.\n         */\n        public Builder since(final String since) {\n            this.since = since;\n            return this;\n        }\n\n        /**\n         * Sets the type of the Option.\n         *\n         * @param type the type of the Option.\n         * @return this builder.\n         */\n        public Builder type(final Class<?> type) {\n            this.type = toType(type);\n            return this;\n        }\n\n        /**\n         * The Option will use '=' as a means to separate argument value.\n         *\n         * @return this builder.\n         */\n        public Builder valueSeparator() {\n            return valueSeparator(Char.EQUAL);\n        }\n\n        /**\n         * The Option will use {@code sep} as a means to separate argument values.\n         * <p>\n         * <b>Example:</b>\n         * </p>\n         *\n         * <pre>\n         * Option opt = Option.builder(\"D\").hasArgs().valueSeparator('=').build();\n         * Options options = new Options();\n         * options.addOption(opt);\n         * String[] args = { \"-Dkey=value\" };\n         * CommandLineParser parser = new DefaultParser();\n         * CommandLine line = parser.parse(options, args);\n         * String propertyName = line.getOptionValues(\"D\")[0]; // will be \"key\"\n         * String propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n         * </pre>\n         *\n         * @param valueSeparator The value separator.\n         * @return this builder.\n         */\n        public Builder valueSeparator(final char valueSeparator) {\n            this.valueSeparator = valueSeparator;\n            return this;\n        }\n\n    }\n\n    /** Empty array. */\n    static final Option[] EMPTY_ARRAY = {};\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** Specifies the number of argument values has not been specified. */\n    public static final int UNINITIALIZED = -1;\n\n    /** Specifies the number of argument values is infinite. */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @return a new {@link Builder} instance.\n     * @since 1.3\n     */\n    public static Builder builder() {\n        return builder(null);\n    }\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @param option short representation of the option.\n     * @return a new {@link Builder} instance.\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     * @since 1.3\n     */\n    public static Builder builder(final String option) {\n        return new Builder(option);\n    }\n\n    /** The number of argument values this option can have. */\n    private int argCount = UNINITIALIZED;\n\n    /** The name of the argument for this option. */\n    private String argName;\n\n    /** The explicit converter for this option. May be null. */\n    private transient Converter<?, ?> converter;\n\n    /**\n     * Specifies whether this option is deprecated, may be null.\n     * <p>\n     * If you want to serialize this field, use a serialization proxy.\n     * </p>\n     */\n    private final transient DeprecatedAttributes deprecated;\n\n    /** Description of the option. */\n    private String description;\n\n    /** The long representation of the option. */\n    private String longOption;\n\n    /** The name of the option. */\n    private final String option;\n\n    /** Specifies whether the argument value of this Option is optional. */\n    private boolean optionalArg;\n\n    /** Specifies whether this option is required to be present. */\n    private boolean required;\n\n    /** Specifies the version when this option was added.  May be null */\n    private String since;\n\n    /** The type of this Option. */\n    private Class<?> type = String.class;\n\n    /** The list of argument values. **/\n    private List<String> values = new ArrayList<>();\n\n    /** The character that is the value separator. */\n    private char valueSeparator;\n\n    /**\n     * Private constructor used by the nested Builder class.\n     *\n     * @param builder builder used to create this option.\n     */\n    private Option(final Builder builder) {\n        this.argName = builder.argName;\n        this.description = builder.description;\n        this.longOption = builder.longOption;\n        this.argCount = builder.argCount;\n        this.option = builder.option;\n        this.optionalArg = builder.optionalArg;\n        this.deprecated = builder.deprecated;\n        this.required = builder.required;\n        this.since = builder.since;\n        this.type = builder.type;\n        this.valueSeparator = builder.valueSeparator;\n        this.converter = builder.converter;\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option      short representation of the option.\n     * @param hasArg      specifies whether the Option takes an argument or not.\n     * @param description describes the function of the option.\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final boolean hasArg, final String description) throws IllegalArgumentException {\n        this(option, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters. The option does not take an argument.\n     *\n     * @param option      short representation of the option.\n     * @param description describes the function of the option.\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String description) throws IllegalArgumentException {\n        this(option, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option      short representation of the option.\n     * @param longOption  the long representation of the option.\n     * @param hasArg      specifies whether the Option takes an argument or not.\n     * @param description describes the function of the option.\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String longOption, final boolean hasArg, final String description) throws IllegalArgumentException {\n        // ensure that the option is valid\n        this.deprecated = null;\n        this.option = OptionValidator.validate(option);\n        this.longOption = longOption;\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg) {\n            this.argCount = 1;\n        }\n        this.description = description;\n    }\n\n    /**\n     * Tests whether the option can accept more arguments.\n     *\n     * @return false if the maximum number of arguments is reached.\n     * @since 1.3\n     */\n    boolean acceptsArg() {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (argCount <= 0 || values.size() < argCount);\n    }\n\n    /**\n     * Adds the value to this Option. If the number of arguments is greater than zero and there is enough space in the list then add the value. Otherwise, throw\n     * a runtime exception.\n     *\n     * @param value The value to be added to this Option.\n     */\n    private void add(final String value) {\n        if (!acceptsArg()) {\n            throw new IllegalArgumentException(\"Cannot add value, list full.\");\n        }\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal API that was made public in 1.0. It currently throws an UnsupportedOperationException.\n     *\n     * @param value the value to add.\n     * @return always throws an {@link UnsupportedOperationException}.\n     * @throws UnsupportedOperationException always.\n     * @deprecated Unused.\n     */\n    @Deprecated\n    public boolean addValue(final String value) {\n        throw new UnsupportedOperationException(\n                \"The addValue method is not intended for client use. Subclasses should use the processValue method instead.\");\n    }\n\n    /**\n     * Clears the Option values. After a parse is complete, these are left with data in them and they need clearing if another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues() {\n        values.clear();\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public and in 1.1 rather than throwing a CloneNotSupportedException it throws a\n     * RuntimeException so as to maintain backwards compatible at the API level.\n     *\n     * After calling this method, it is very likely you will want to call clearValues().\n     *\n     * @return a clone of this Option instance.\n     * @throws RuntimeException if a {@link CloneNotSupportedException} has been thrown by {@code super.clone()}.\n     */\n    @Override\n    public Object clone() {\n        try {\n            final Option option = (Option) super.clone();\n            option.values = new ArrayList<>(values);\n            return option;\n        } catch (final CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Option)) {\n            return false;\n        }\n        final Option other = (Option) obj;\n        return Objects.equals(longOption, other.longOption) && Objects.equals(option, other.option);\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName() {\n        return argName;\n    }\n\n    /**\n     * Gets the number of argument values this Option can take.\n     *\n     * <p>\n     * A value equal to the constant {@link #UNINITIALIZED} (= -1) indicates the number of arguments has not been specified. A value equal to the constant\n     * {@link #UNLIMITED_VALUES} (= -2) indicates that this options takes an unlimited amount of values.\n     * </p>\n     *\n     * @return num the number of argument values.\n     * @see #UNINITIALIZED\n     * @see #UNLIMITED_VALUES\n     */\n    public int getArgs() {\n        return argCount;\n    }\n\n    /**\n     * Gets the value to type converter.\n     *\n     * @return the value to type converter.\n     * @since 1.7.0\n     */\n    public Converter<?, ?> getConverter() {\n        return converter == null ? TypeHandler.getDefault().getConverter(type) : converter;\n    }\n\n    /**\n     * Gets deprecated attributes if any.\n     *\n     * @return boolean deprecated attributes or null.\n     * @since 1.7.0\n     */\n    public DeprecatedAttributes getDeprecated() {\n        return deprecated;\n    }\n\n    /**\n     * Gets the self-documenting description of this Option.\n     *\n     * @return The string description of this option.\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Gets the id of this Option. This is only set when the Option shortOpt is a single character. This is used for switch statements.\n     *\n     * @return the id of this Option.\n     */\n    public int getId() {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Gets the 'unique' Option identifier. This is the option value if set or the long value if the options value is not set.\n     *\n     * @return the 'unique' Option identifier.\n     * @since 1.7.0\n     */\n    public String getKey() {\n        // if 'opt' is null, then it is a 'long' option\n        return option == null ? longOption : option;\n    }\n\n    /**\n     * Gets the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name.\n     */\n    public String getLongOpt() {\n        return longOption;\n    }\n\n    /**\n     * Gets the name of this Option.\n     *\n     * It is this String which can be used with {@link CommandLine#hasOption(String opt)} and {@link CommandLine#getOptionValue(String opt)} to check for\n     * existence and argument.\n     *\n     * @return The name of this option.\n     */\n    public String getOpt() {\n        return option;\n    }\n\n    /**\n     * Gets the version when this option was added.\n     * @return the version when this option was added, or {@code null} if not set.\n     */\n    public String getSince() {\n        return since;\n    }\n\n\n    /**\n     * Gets the type of this Option.\n     *\n     * @return The type of this option.\n     */\n    public Object getType() {\n        return type;\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @return the value/first value of this Option or {@code null} if there is no value.\n     */\n    public String getValue() {\n        return hasNoValues() ? null : values.get(0);\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or {@code null} if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1 or greater than the number of the values for this Option.\n     */\n    public String getValue(final int index) throws IndexOutOfBoundsException {\n        return hasNoValues() ? null : values.get(index);\n    }\n\n    /**\n     * Gets the value/first value of this Option or the {@code defaultValue} if there is no value.\n     *\n     * @param defaultValue The value to be returned if there is no value.\n     *\n     * @return the value/first value of this Option or the {@code defaultValue} if there are no values.\n     */\n    public String getValue(final String defaultValue) {\n        final String value = getValue();\n        return value != null ? value : defaultValue;\n    }\n\n    /**\n     * Gets the values of this Option as a String array or null if there are no values.\n     *\n     * @return the values of this Option as a String array or null if there are no values.\n     */\n    public String[] getValues() {\n        return hasNoValues() ? null : values.toArray(EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Gets the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator() {\n        return valueSeparator;\n    }\n\n    /**\n     * Gets the values of this Option as a List or null if there are no values.\n     *\n     * @return the values of this Option as a List or null if there are no values.\n     */\n    public List<String> getValuesList() {\n        return values;\n    }\n\n    /**\n     * Tests whether this Option requires an argument.\n     *\n     * @return boolean flag indicating if an argument is required.\n     */\n    public boolean hasArg() {\n        return argCount > 0 || argCount == UNLIMITED_VALUES;\n    }\n\n    /**\n     * Tests whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName() {\n        return argName != null && !argName.isEmpty();\n    }\n\n    /**\n     * Tests whether this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed.\n     */\n    public boolean hasArgs() {\n        return argCount > 1 || argCount == UNLIMITED_VALUES;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(longOption, option);\n    }\n\n    /**\n     * Tests whether this Option has a long name.\n     *\n     * @return boolean flag indicating existence of a long name.\n     */\n    public boolean hasLongOpt() {\n        return longOption != null;\n    }\n\n    /**\n     * Tests whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues() {\n        return values.isEmpty();\n    }\n\n    /**\n     * Tests whether this Option can have an optional argument.\n     *\n     * @return whether this Option can have an optional argument.\n     */\n    public boolean hasOptionalArg() {\n        return optionalArg;\n    }\n\n    /**\n     * Tests whether this Option has specified a value separator.\n     *\n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator() {\n        return valueSeparator > 0;\n    }\n\n    /**\n     * Tests whether this Option is deprecated.\n     *\n     * @return boolean flag indicating whether this Option is deprecated.\n     * @since 1.7.0\n     */\n    public boolean isDeprecated() {\n        return deprecated != null;\n    }\n\n    /**\n     * Tests whether this Option is required.\n     *\n     * @return boolean flag indicating whether this Option is required.\n     */\n    public boolean isRequired() {\n        return required;\n    }\n\n    /**\n     * Processes the value. If this Option has a value separator the value will have to be parsed into individual tokens. When n-1 tokens have been processed\n     * and there are more value separators in the value, parsing is ceased and the remaining characters are added as a single token.\n     *\n     * @param value The String to be processed.\n     */\n    void processValue(final String value) {\n        if (argCount == UNINITIALIZED) {\n            throw new IllegalArgumentException(\"NO_ARGS_ALLOWED\");\n        }\n        String add = value;\n        // this Option has a separator character\n        if (hasValueSeparator()) {\n            // get the separator character\n            final char sep = getValueSeparator();\n            // store the index for the value separator\n            int index = add.indexOf(sep);\n            // while there are more value separators\n            while (index != -1) {\n                // next value to be added\n                if (values.size() == argCount - 1) {\n                    break;\n                }\n                // store\n                add(add.substring(0, index));\n                // parse\n                add = add.substring(index + 1);\n                // get new index\n                index = add.indexOf(sep);\n            }\n        }\n        // store the actual value or the last value that has been parsed\n        add(add);\n    }\n\n    /**\n     * Tests whether the option requires more arguments to be valid.\n     *\n     * @return false if the option doesn't require more arguments.\n     */\n    boolean requiresArg() {\n        if (optionalArg) {\n            return false;\n        }\n        if (argCount == UNLIMITED_VALUES) {\n            return values.isEmpty();\n        }\n        return acceptsArg();\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(final String argName) {\n        this.argName = argName;\n    }\n\n    /**\n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values.\n     */\n    public void setArgs(final int num) {\n        this.argCount = num;\n    }\n\n    /**\n     * Sets the value to type converter.\n     *\n     * @param converter The converter to convert the string value to the type.\n     * @since 1.7.0\n     */\n    public void setConverter(final Converter<?, ?> converter) {\n        this.converter = converter;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option.\n     *\n     * @param description The description of this option.\n     * @since 1.1\n     */\n    public void setDescription(final String description) {\n        this.description = description;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option.\n     */\n    public void setLongOpt(final String longOpt) {\n        this.longOption = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have an optional argument.\n     */\n    public void setOptionalArg(final boolean optionalArg) {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory.\n     */\n    public void setRequired(final boolean required) {\n        this.required = required;\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option.\n     * @since 1.3\n     */\n    public void setType(final Class<?> type) {\n        this.type = Builder.toType(type);\n    }\n\n    /**\n     * Sets the type of this Option.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class} object.\n     * </p>\n     *\n     * @param type the type of this Option.\n     * @deprecated since 1.3, use {@link #setType(Class)} instead.\n     */\n    @Deprecated\n    public void setType(final Object type) {\n        setType((Class<?>) type);\n    }\n\n    /**\n     * Sets the value separator. For example if the argument value was a Java property, the value separator would be '='.\n     *\n     * @param valueSeparator The value separator.\n     */\n    public void setValueSeparator(final char valueSeparator) {\n        this.valueSeparator = valueSeparator;\n    }\n\n    String toDeprecatedString() {\n        if (!isDeprecated()) {\n            return \"\";\n        }\n        // @formatter:off\n        final StringBuilder buf = new StringBuilder()\n                .append(\"Option '\")\n                .append(option)\n                .append(Char.APOS);\n        // @formatter:on\n        if (longOption != null) {\n            buf.append(Char.APOS).append(longOption).append(Char.APOS);\n        }\n        buf.append(\": \").append(deprecated);\n        return buf.toString();\n    }\n\n    /**\n     * Creates a String suitable for debugging.\n     *\n     * @return a String suitable for debugging.\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder().append(\"[ \");\n        buf.append(\"Option \");\n        buf.append(option);\n        if (longOption != null) {\n            buf.append(Char.SP).append(longOption);\n        }\n        if (isDeprecated()) {\n            buf.append(Char.SP);\n            buf.append(deprecated.toString());\n        }\n        if (hasArgs()) {\n            buf.append(\"[ARG...]\");\n        } else if (hasArg()) {\n            buf.append(\" [ARG]\");\n        }\n        // @formatter:off\n        return buf.append(\" :: \")\n            .append(description)\n            .append(\" :: \")\n            .append(type)\n            .append(\" ]\")\n            .toString();\n        // @formatter:on\n    }\n}\n", "file_hash": "b53f01d0280c90f913b6f952925b64c9f742d55c48e5e3db7fce1246c6ad3fa5", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import static org.apache.commons.cli.Util.EMPTY_STRING_ARRAY;", "import java.io.Serializable;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class Option implements Cloneable, Serializable {\n\n    /**\n     * Builds {@code Option} instances using descriptive methods.\n     * <p>\n     * Example usage:\n     * </p>\n     *\n     * <pre>\n     * Option option = Option.builder(\"a\").required(true).longOpt(\"arg-name\").build();\n     * </pre>\n     *\n     * @since 1.3\n     */\n    public static final class Builder {\n\n        /** The default type. */\n        private static final Class<String> DEFAULT_TYPE = String.class;\n\n        /**\n         * Returns the input Class or the default type (String) if null.\n         *\n         * @param type the candidate Class.\n         * @return the input Class or the default type (String) if null.\n         */\n        private static Class<?> toType(final Class<?> type) {\n            return type != null ? type : DEFAULT_TYPE;\n        }\n\n        /** The number of argument values this option can have. */\n        private int argCount = UNINITIALIZED;\n\n        /** The name of the argument for this option. */\n        private String argName;\n\n        /** The converter to convert to type. **/\n        private Converter<?, ?> converter;\n\n        /** Specifies whether this option is deprecated. */\n        private DeprecatedAttributes deprecated;\n\n        /** Description of the option. */\n        private String description;\n\n        /** The long representation of the option. */\n        private String longOption;\n\n        /** The name of the option. */\n        private String option;\n\n        /** Specifies whether the argument value of this Option is optional. */\n        private boolean optionalArg;\n\n        /** Specifies whether this option is required to be present. */\n        private boolean required;\n\n        /** Specifies the version when this option was added.  May be null */\n        private String since;\n\n        /** The type of this Option. */\n        private Class<?> type = DEFAULT_TYPE;\n\n        /** The character that is the value separator. */\n        private char valueSeparator;\n\n        /**\n         * Constructs a new {@code Builder} with the minimum required parameters for an {@code Option} instance.\n         *\n         * @param option short representation of the option.\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n         */\n        private Builder(final String option) throws IllegalArgumentException {\n            option(option);\n        }\n\n        /**\n         * Sets the display name for the argument value.\n         *\n         * @param argName the display name for the argument value.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder argName(final String argName) {\n            this.argName = argName;\n            return this;\n        }\n\n        /**\n         * Constructs an Option with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link Option}.\n         * @throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set.\n         */\n        public Option build() {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }\n\n        /**\n         * Sets the converter for the option.\n         * <p>\n         * Note: See {@link TypeHandler} for serialization discussion.\n         * </p>\n         *\n         * @param converter the Converter to use.\n         * @return this builder, to allow method chaining.\n         * @since 1.7.0\n         */\n        public Builder converter(final Converter<?, ?> converter) {\n            this.converter = converter;\n            return this;\n        }\n\n        /**\n         * Marks this Option as deprecated.\n         *\n         * @return this builder.\n         * @since 1.7.0\n         */\n        public Builder deprecated() {\n            return deprecated(DeprecatedAttributes.DEFAULT);\n        }\n\n        /**\n         * Sets whether the Option is deprecated.\n         *\n         * @param deprecated specifies whether the Option is deprecated.\n         * @return this builder.\n         * @since 1.7.0\n         */\n        public Builder deprecated(final DeprecatedAttributes deprecated) {\n            this.deprecated = deprecated;\n            return this;\n        }\n\n        /**\n         * Sets the description for this option.\n         *\n         * @param description the description of the option.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder desc(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Tests whether the Option will require an argument.\n         *\n         * @return this builder, to allow method chaining.\n         */\n        public Builder hasArg() {\n            return hasArg(true);\n        }\n\n        /**\n         * Tests whether the Option has an argument or not.\n         *\n         * @param hasArg specifies whether the Option takes an argument or not.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder hasArg(final boolean hasArg) {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : UNINITIALIZED;\n            return this;\n        }\n\n        /**\n         * Tests whether the Option can have unlimited argument values.\n         *\n         * @return this builder.\n         */\n        public Builder hasArgs() {\n            argCount = UNLIMITED_VALUES;\n            return this;\n        }\n\n        /**\n         * Sets the long name of the Option.\n         *\n         * @param longOption the long name of the Option\n         * @return this builder.\n         */\n        public Builder longOpt(final String longOption) {\n            this.longOption = longOption;\n            return this;\n        }\n\n        /**\n         * Sets the number of argument values the Option can take.\n         *\n         * @param argCount the number of argument values\n         * @return this builder.\n         */\n        public Builder numberOfArgs(final int argCount) {\n            this.argCount = argCount;\n            return this;\n        }\n\n        /**\n         * Sets the name of the Option.\n         *\n         * @param option the name of the Option.\n         * @return this builder.\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n         * @since 1.5.0\n         */\n        public Builder option(final String option) throws IllegalArgumentException {\n            this.option = OptionValidator.validate(option);\n            return this;\n        }\n\n        /**\n         * Sets whether the Option can have an optional argument.\n         *\n         * @param optionalArg specifies whether the Option can have an optional argument.\n         * @return this builder.\n         */\n        public Builder optionalArg(final boolean optionalArg) {\n            if (optionalArg && argCount == UNINITIALIZED) {\n                argCount = 1;\n            }\n            this.optionalArg = optionalArg;\n            return this;\n        }\n\n        /**\n         * Marks this Option as required.\n         *\n         * @return this builder.\n         */\n        public Builder required() {\n            return required(true);\n        }\n\n        /**\n         * Sets whether the Option is required.\n         *\n         * @param required specifies whether the Option is required.\n         * @return this builder.\n         */\n        public Builder required(final boolean required) {\n            this.required = required;\n            return this;\n        }\n\n        /** Sets the version number when this option was first defined.\"\n         *\n         * @param since the version number when this option was first defined.\n         * @return this builder.\n         */\n        public Builder since(final String since) {\n            this.since = since;\n            return this;\n        }\n\n        /**\n         * Sets the type of the Option.\n         *\n         * @param type the type of the Option.\n         * @return this builder.\n         */\n        public Builder type(final Class<?> type) {\n            this.type = toType(type);\n            return this;\n        }\n\n        /**\n         * The Option will use '=' as a means to separate argument value.\n         *\n         * @return this builder.\n         */\n        public Builder valueSeparator() {\n            return valueSeparator(Char.EQUAL);\n        }\n\n        /**\n         * The Option will use {@code sep} as a means to separate argument values.\n         * <p>\n         * <b>Example:</b>\n         * </p>\n         *\n         * <pre>\n         * Option opt = Option.builder(\"D\").hasArgs().valueSeparator('=').build();\n         * Options options = new Options();\n         * options.addOption(opt);\n         * String[] args = { \"-Dkey=value\" };\n         * CommandLineParser parser = new DefaultParser();\n         * CommandLine line = parser.parse(options, args);\n         * String propertyName = line.getOptionValues(\"D\")[0]; // will be \"key\"\n         * String propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n         * </pre>\n         *\n         * @param valueSeparator The value separator.\n         * @return this builder.\n         */\n        public Builder valueSeparator(final char valueSeparator) {\n            this.valueSeparator = valueSeparator;\n            return this;\n        }\n\n    }\n\n    /** Empty array. */\n    static final Option[] EMPTY_ARRAY = {};\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** Specifies the number of argument values has not been specified. */\n    public static final int UNINITIALIZED = -1;\n\n    /** Specifies the number of argument values is infinite. */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @return a new {@link Builder} instance.\n     * @since 1.3\n     */\n    public static Builder builder() {\n        return builder(null);\n    }\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @param option short representation of the option.\n     * @return a new {@link Builder} instance.\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     * @since 1.3\n     */\n    public static Builder builder(final String option) {\n        return new Builder(option);\n    }\n\n    /** The number of argument values this option can have. */\n    private int argCount = UNINITIALIZED;\n\n    /** The name of the argument for this option. */\n    private String argName;\n\n    /** The explicit converter for this option. May be null. */\n    private transient Converter<?, ?> converter;\n\n    /**\n     * Specifies whether this option is deprecated, may be null.\n     * <p>\n     * If you want to serialize this field, use a serialization proxy.\n     * </p>\n     */\n    private final transient DeprecatedAttributes deprecated;\n\n    /** Description of the option. */\n    private String description;\n\n    /** The long representation of the option. */\n    private String longOption;\n\n    /** The name of the option. */\n    private final String option;\n\n    /** Specifies whether the argument value of this Option is optional. */\n    private boolean optionalArg;\n\n    /** Specifies whether this option is required to be present. */\n    private boolean required;\n\n    /** Specifies the version when this option was added.  May be null */\n    private String since;\n\n    /** The type of this Option. */\n    private Class<?> type = String.class;\n\n    /** The list of argument values. **/\n    private List<String> values = new ArrayList<>();\n\n    /** The character that is the value separator. */\n    private char valueSeparator;\n\n    /**\n     * Private constructor used by the nested Builder class.\n     *\n     * @param builder builder used to create this option.\n     */\n    private Option(final Builder builder) {\n        this.argName = builder.argName;\n        this.description = builder.description;\n        this.longOption = builder.longOption;\n        this.argCount = builder.argCount;\n        this.option = builder.option;\n        this.optionalArg = builder.optionalArg;\n        this.deprecated = builder.deprecated;\n        this.required = builder.required;\n        this.since = builder.since;\n        this.type = builder.type;\n        this.valueSeparator = builder.valueSeparator;\n        this.converter = builder.converter;\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option      short representation of the option.\n     * @param hasArg      specifies whether the Option takes an argument or not.\n     * @param description describes the function of the option.\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final boolean hasArg, final String description) throws IllegalArgumentException {\n        this(option, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters. The option does not take an argument.\n     *\n     * @param option      short representation of the option.\n     * @param description describes the function of the option.\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String description) throws IllegalArgumentException {\n        this(option, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option      short representation of the option.\n     * @param longOption  the long representation of the option.\n     * @param hasArg      specifies whether the Option takes an argument or not.\n     * @param description describes the function of the option.\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String longOption, final boolean hasArg, final String description) throws IllegalArgumentException {\n        // ensure that the option is valid\n        this.deprecated = null;\n        this.option = OptionValidator.validate(option);\n        this.longOption = longOption;\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg) {\n            this.argCount = 1;\n        }\n        this.description = description;\n    }\n\n    /**\n     * Tests whether the option can accept more arguments.\n     *\n     * @return false if the maximum number of arguments is reached.\n     * @since 1.3\n     */\n    boolean acceptsArg() {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (argCount <= 0 || values.size() < argCount);\n    }\n\n    /**\n     * Adds the value to this Option. If the number of arguments is greater than zero and there is enough space in the list then add the value. Otherwise, throw\n     * a runtime exception.\n     *\n     * @param value The value to be added to this Option.\n     */\n    private void add(final String value) {\n        if (!acceptsArg()) {\n            throw new IllegalArgumentException(\"Cannot add value, list full.\");\n        }\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal API that was made public in 1.0. It currently throws an UnsupportedOperationException.\n     *\n     * @param value the value to add.\n     * @return always throws an {@link UnsupportedOperationException}.\n     * @throws UnsupportedOperationException always.\n     * @deprecated Unused.\n     */\n    @Deprecated\n    public boolean addValue(final String value) {\n        throw new UnsupportedOperationException(\n                \"The addValue method is not intended for client use. Subclasses should use the processValue method instead.\");\n    }\n\n    /**\n     * Clears the Option values. After a parse is complete, these are left with data in them and they need clearing if another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues() {\n        values.clear();\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public and in 1.1 rather than throwing a CloneNotSupportedException it throws a\n     * RuntimeException so as to maintain backwards compatible at the API level.\n     *\n     * After calling this method, it is very likely you will want to call clearValues().\n     *\n     * @return a clone of this Option instance.\n     * @throws RuntimeException if a {@link CloneNotSupportedException} has been thrown by {@code super.clone()}.\n     */\n    @Override\n    public Object clone() {\n        try {\n            final Option option = (Option) super.clone();\n            option.values = new ArrayList<>(values);\n            return option;\n        } catch (final CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Option)) {\n            return false;\n        }\n        final Option other = (Option) obj;\n        return Objects.equals(longOption, other.longOption) && Objects.equals(option, other.option);\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName() {\n        return argName;\n    }\n\n    /**\n     * Gets the number of argument values this Option can take.\n     *\n     * <p>\n     * A value equal to the constant {@link #UNINITIALIZED} (= -1) indicates the number of arguments has not been specified. A value equal to the constant\n     * {@link #UNLIMITED_VALUES} (= -2) indicates that this options takes an unlimited amount of values.\n     * </p>\n     *\n     * @return num the number of argument values.\n     * @see #UNINITIALIZED\n     * @see #UNLIMITED_VALUES\n     */\n    public int getArgs() {\n        return argCount;\n    }\n\n    /**\n     * Gets the value to type converter.\n     *\n     * @return the value to type converter.\n     * @since 1.7.0\n     */\n    public Converter<?, ?> getConverter() {\n        return converter == null ? TypeHandler.getDefault().getConverter(type) : converter;\n    }\n\n    /**\n     * Gets deprecated attributes if any.\n     *\n     * @return boolean deprecated attributes or null.\n     * @since 1.7.0\n     */\n    public DeprecatedAttributes getDeprecated() {\n        return deprecated;\n    }\n\n    /**\n     * Gets the self-documenting description of this Option.\n     *\n     * @return The string description of this option.\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Gets the id of this Option. This is only set when the Option shortOpt is a single character. This is used for switch statements.\n     *\n     * @return the id of this Option.\n     */\n    public int getId() {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Gets the 'unique' Option identifier. This is the option value if set or the long value if the options value is not set.\n     *\n     * @return the 'unique' Option identifier.\n     * @since 1.7.0\n     */\n    public String getKey() {\n        // if 'opt' is null, then it is a 'long' option\n        return option == null ? longOption : option;\n    }\n\n    /**\n     * Gets the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name.\n     */\n    public String getLongOpt() {\n        return longOption;\n    }\n\n    /**\n     * Gets the name of this Option.\n     *\n     * It is this String which can be used with {@link CommandLine#hasOption(String opt)} and {@link CommandLine#getOptionValue(String opt)} to check for\n     * existence and argument.\n     *\n     * @return The name of this option.\n     */\n    public String getOpt() {\n        return option;\n    }\n\n    /**\n     * Gets the version when this option was added.\n     * @return the version when this option was added, or {@code null} if not set.\n     */\n    public String getSince() {\n        return since;\n    }\n\n\n    /**\n     * Gets the type of this Option.\n     *\n     * @return The type of this option.\n     */\n    public Object getType() {\n        return type;\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @return the value/first value of this Option or {@code null} if there is no value.\n     */\n    public String getValue() {\n        return hasNoValues() ? null : values.get(0);\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or {@code null} if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1 or greater than the number of the values for this Option.\n     */\n    public String getValue(final int index) throws IndexOutOfBoundsException {\n        return hasNoValues() ? null : values.get(index);\n    }\n\n    /**\n     * Gets the value/first value of this Option or the {@code defaultValue} if there is no value.\n     *\n     * @param defaultValue The value to be returned if there is no value.\n     *\n     * @return the value/first value of this Option or the {@code defaultValue} if there are no values.\n     */\n    public String getValue(final String defaultValue) {\n        final String value = getValue();\n        return value != null ? value : defaultValue;\n    }\n\n    /**\n     * Gets the values of this Option as a String array or null if there are no values.\n     *\n     * @return the values of this Option as a String array or null if there are no values.\n     */\n    public String[] getValues() {\n        return hasNoValues() ? null : values.toArray(EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Gets the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator() {\n        return valueSeparator;\n    }\n\n    /**\n     * Gets the values of this Option as a List or null if there are no values.\n     *\n     * @return the values of this Option as a List or null if there are no values.\n     */\n    public List<String> getValuesList() {\n        return values;\n    }\n\n    /**\n     * Tests whether this Option requires an argument.\n     *\n     * @return boolean flag indicating if an argument is required.\n     */\n    public boolean hasArg() {\n        return argCount > 0 || argCount == UNLIMITED_VALUES;\n    }\n\n    /**\n     * Tests whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName() {\n        return argName != null && !argName.isEmpty();\n    }\n\n    /**\n     * Tests whether this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed.\n     */\n    public boolean hasArgs() {\n        return argCount > 1 || argCount == UNLIMITED_VALUES;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(longOption, option);\n    }\n\n    /**\n     * Tests whether this Option has a long name.\n     *\n     * @return boolean flag indicating existence of a long name.\n     */\n    public boolean hasLongOpt() {\n        return longOption != null;\n    }\n\n    /**\n     * Tests whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues() {\n        return values.isEmpty();\n    }\n\n    /**\n     * Tests whether this Option can have an optional argument.\n     *\n     * @return whether this Option can have an optional argument.\n     */\n    public boolean hasOptionalArg() {\n        return optionalArg;\n    }\n\n    /**\n     * Tests whether this Option has specified a value separator.\n     *\n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator() {\n        return valueSeparator > 0;\n    }\n\n    /**\n     * Tests whether this Option is deprecated.\n     *\n     * @return boolean flag indicating whether this Option is deprecated.\n     * @since 1.7.0\n     */\n    public boolean isDeprecated() {\n        return deprecated != null;\n    }\n\n    /**\n     * Tests whether this Option is required.\n     *\n     * @return boolean flag indicating whether this Option is required.\n     */\n    public boolean isRequired() {\n        return required;\n    }\n\n    /**\n     * Processes the value. If this Option has a value separator the value will have to be parsed into individual tokens. When n-1 tokens have been processed\n     * and there are more value separators in the value, parsing is ceased and the remaining characters are added as a single token.\n     *\n     * @param value The String to be processed.\n     */\n    void processValue(final String value) {\n        if (argCount == UNINITIALIZED) {\n            throw new IllegalArgumentException(\"NO_ARGS_ALLOWED\");\n        }\n        String add = value;\n        // this Option has a separator character\n        if (hasValueSeparator()) {\n            // get the separator character\n            final char sep = getValueSeparator();\n            // store the index for the value separator\n            int index = add.indexOf(sep);\n            // while there are more value separators\n            while (index != -1) {\n                // next value to be added\n                if (values.size() == argCount - 1) {\n                    break;\n                }\n                // store\n                add(add.substring(0, index));\n                // parse\n                add = add.substring(index + 1);\n                // get new index\n                index = add.indexOf(sep);\n            }\n        }\n        // store the actual value or the last value that has been parsed\n        add(add);\n    }\n\n    /**\n     * Tests whether the option requires more arguments to be valid.\n     *\n     * @return false if the option doesn't require more arguments.\n     */\n    boolean requiresArg() {\n        if (optionalArg) {\n            return false;\n        }\n        if (argCount == UNLIMITED_VALUES) {\n            return values.isEmpty();\n        }\n        return acceptsArg();\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(final String argName) {\n        this.argName = argName;\n    }\n\n    /**\n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values.\n     */\n    public void setArgs(final int num) {\n        this.argCount = num;\n    }\n\n    /**\n     * Sets the value to type converter.\n     *\n     * @param converter The converter to convert the string value to the type.\n     * @since 1.7.0\n     */\n    public void setConverter(final Converter<?, ?> converter) {\n        this.converter = converter;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option.\n     *\n     * @param description The description of this option.\n     * @since 1.1\n     */\n    public void setDescription(final String description) {\n        this.description = description;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option.\n     */\n    public void setLongOpt(final String longOpt) {\n        this.longOption = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have an optional argument.\n     */\n    public void setOptionalArg(final boolean optionalArg) {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory.\n     */\n    public void setRequired(final boolean required) {\n        this.required = required;\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option.\n     * @since 1.3\n     */\n    public void setType(final Class<?> type) {\n        this.type = Builder.toType(type);\n    }\n\n    /**\n     * Sets the type of this Option.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class} object.\n     * </p>\n     *\n     * @param type the type of this Option.\n     * @deprecated since 1.3, use {@link #setType(Class)} instead.\n     */\n    @Deprecated\n    public void setType(final Object type) {\n        setType((Class<?>) type);\n    }\n\n    /**\n     * Sets the value separator. For example if the argument value was a Java property, the value separator would be '='.\n     *\n     * @param valueSeparator The value separator.\n     */\n    public void setValueSeparator(final char valueSeparator) {\n        this.valueSeparator = valueSeparator;\n    }\n\n    String toDeprecatedString() {\n        if (!isDeprecated()) {\n            return \"\";\n        }\n        // @formatter:off\n        final StringBuilder buf = new StringBuilder()\n                .append(\"Option '\")\n                .append(option)\n                .append(Char.APOS);\n        // @formatter:on\n        if (longOption != null) {\n            buf.append(Char.APOS).append(longOption).append(Char.APOS);\n        }\n        buf.append(\": \").append(deprecated);\n        return buf.toString();\n    }\n\n    /**\n     * Creates a String suitable for debugging.\n     *\n     * @return a String suitable for debugging.\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder().append(\"[ \");\n        buf.append(\"Option \");\n        buf.append(option);\n        if (longOption != null) {\n            buf.append(Char.SP).append(longOption);\n        }\n        if (isDeprecated()) {\n            buf.append(Char.SP);\n            buf.append(deprecated.toString());\n        }\n        if (hasArgs()) {\n            buf.append(\"[ARG...]\");\n        } else if (hasArg()) {\n            buf.append(\" [ARG]\");\n        }\n        // @formatter:off\n        return buf.append(\" :: \")\n            .append(description)\n            .append(\" :: \")\n            .append(type)\n            .append(\" ]\")\n            .toString();\n        // @formatter:on\n    }\n}", "definition": "public class Option implements Cloneable, Serializable", "class_docstring": "\nDescribes a single command-line option. It maintains information regarding the short-name of the option, the long-name, if any exists, a flag indicating if\nan argument is required for this option, and a self-documenting description of the option.\n<p>\nAn Option is not created independently, but is created through an instance of {@link Options}. An Option is required to have at least a short or a long-name.\n</p>\n<p>\n<b>Note:</b> once an {@link Option} has been added to an instance of {@link Options}, its required flag cannot be changed.\n</p>\n\n@see org.apache.commons.cli.Options\n@see org.apache.commons.cli.CommandLine\n", "name": "Option", "super_interfaces": ["Cloneable", "Serializable"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "static final Option[] EMPTY_ARRAY = {};", "docstring": " Empty array.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Option[]", "name": "EMPTY_ARRAY = {}", "syntax_pass": true}, {"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": " The serial version UID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "public static final int UNINITIALIZED = -1;", "docstring": " Specifies the number of argument values has not been specified.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "UNINITIALIZED = -1", "syntax_pass": true}, {"attribute_expression": "public static final int UNLIMITED_VALUES = -2;", "docstring": " Specifies the number of argument values is infinite.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "UNLIMITED_VALUES = -2", "syntax_pass": true}, {"attribute_expression": "private int argCount = UNINITIALIZED;", "docstring": " The number of argument values this option can have.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "argCount = UNINITIALIZED", "syntax_pass": true}, {"attribute_expression": "private String argName;", "docstring": " The name of the argument for this option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "argName", "syntax_pass": true}, {"attribute_expression": "private transient Converter<?, ?> converter;", "docstring": " The explicit converter for this option. May be null.", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Converter<?, ?>", "name": "converter", "syntax_pass": true}, {"attribute_expression": "private final transient DeprecatedAttributes deprecated;", "docstring": "\nSpecifies whether this option is deprecated, may be null.\n<p>\nIf you want to serialize this field, use a serialization proxy.\n</p>\n", "modifiers": "private final transient", "marker_annotations": [], "non_marker_annotations": ["private", "final", "transient"], "comments": [], "type": "DeprecatedAttributes", "name": "deprecated", "syntax_pass": true}, {"attribute_expression": "private String description;", "docstring": " Description of the option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "description", "syntax_pass": true}, {"attribute_expression": "private String longOption;", "docstring": " The long representation of the option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "longOption", "syntax_pass": true}, {"attribute_expression": "private final String option;", "docstring": " The name of the option.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "option", "syntax_pass": true}, {"attribute_expression": "private boolean optionalArg;", "docstring": " Specifies whether the argument value of this Option is optional.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "optionalArg", "syntax_pass": true}, {"attribute_expression": "private boolean required;", "docstring": " Specifies whether this option is required to be present.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "required", "syntax_pass": true}, {"attribute_expression": "private String since;", "docstring": " Specifies the version when this option was added.  May be null", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "since", "syntax_pass": true}, {"attribute_expression": "private Class<?> type = String.class;", "docstring": " The type of this Option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Class<?>", "name": "type = String.class", "syntax_pass": true}, {"attribute_expression": "private List<String> values = new ArrayList<>();", "docstring": " The list of argument values. *", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "values = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private char valueSeparator;", "docstring": " The character that is the value separator.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "char", "name": "valueSeparator", "syntax_pass": true}], "classes": [{"original_string": "    public static final class Builder {\n\n        /** The default type. */\n        private static final Class<String> DEFAULT_TYPE = String.class;\n\n        /**\n         * Returns the input Class or the default type (String) if null.\n         *\n         * @param type the candidate Class.\n         * @return the input Class or the default type (String) if null.\n         */\n        private static Class<?> toType(final Class<?> type) {\n            return type != null ? type : DEFAULT_TYPE;\n        }\n\n        /** The number of argument values this option can have. */\n        private int argCount = UNINITIALIZED;\n\n        /** The name of the argument for this option. */\n        private String argName;\n\n        /** The converter to convert to type. **/\n        private Converter<?, ?> converter;\n\n        /** Specifies whether this option is deprecated. */\n        private DeprecatedAttributes deprecated;\n\n        /** Description of the option. */\n        private String description;\n\n        /** The long representation of the option. */\n        private String longOption;\n\n        /** The name of the option. */\n        private String option;\n\n        /** Specifies whether the argument value of this Option is optional. */\n        private boolean optionalArg;\n\n        /** Specifies whether this option is required to be present. */\n        private boolean required;\n\n        /** Specifies the version when this option was added.  May be null */\n        private String since;\n\n        /** The type of this Option. */\n        private Class<?> type = DEFAULT_TYPE;\n\n        /** The character that is the value separator. */\n        private char valueSeparator;\n\n        /**\n         * Constructs a new {@code Builder} with the minimum required parameters for an {@code Option} instance.\n         *\n         * @param option short representation of the option.\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n         */\n        private Builder(final String option) throws IllegalArgumentException {\n            option(option);\n        }\n\n        /**\n         * Sets the display name for the argument value.\n         *\n         * @param argName the display name for the argument value.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder argName(final String argName) {\n            this.argName = argName;\n            return this;\n        }\n\n        /**\n         * Constructs an Option with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link Option}.\n         * @throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set.\n         */\n        public Option build() {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }\n\n        /**\n         * Sets the converter for the option.\n         * <p>\n         * Note: See {@link TypeHandler} for serialization discussion.\n         * </p>\n         *\n         * @param converter the Converter to use.\n         * @return this builder, to allow method chaining.\n         * @since 1.7.0\n         */\n        public Builder converter(final Converter<?, ?> converter) {\n            this.converter = converter;\n            return this;\n        }\n\n        /**\n         * Marks this Option as deprecated.\n         *\n         * @return this builder.\n         * @since 1.7.0\n         */\n        public Builder deprecated() {\n            return deprecated(DeprecatedAttributes.DEFAULT);\n        }\n\n        /**\n         * Sets whether the Option is deprecated.\n         *\n         * @param deprecated specifies whether the Option is deprecated.\n         * @return this builder.\n         * @since 1.7.0\n         */\n        public Builder deprecated(final DeprecatedAttributes deprecated) {\n            this.deprecated = deprecated;\n            return this;\n        }\n\n        /**\n         * Sets the description for this option.\n         *\n         * @param description the description of the option.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder desc(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Tests whether the Option will require an argument.\n         *\n         * @return this builder, to allow method chaining.\n         */\n        public Builder hasArg() {\n            return hasArg(true);\n        }\n\n        /**\n         * Tests whether the Option has an argument or not.\n         *\n         * @param hasArg specifies whether the Option takes an argument or not.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder hasArg(final boolean hasArg) {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : UNINITIALIZED;\n            return this;\n        }\n\n        /**\n         * Tests whether the Option can have unlimited argument values.\n         *\n         * @return this builder.\n         */\n        public Builder hasArgs() {\n            argCount = UNLIMITED_VALUES;\n            return this;\n        }\n\n        /**\n         * Sets the long name of the Option.\n         *\n         * @param longOption the long name of the Option\n         * @return this builder.\n         */\n        public Builder longOpt(final String longOption) {\n            this.longOption = longOption;\n            return this;\n        }\n\n        /**\n         * Sets the number of argument values the Option can take.\n         *\n         * @param argCount the number of argument values\n         * @return this builder.\n         */\n        public Builder numberOfArgs(final int argCount) {\n            this.argCount = argCount;\n            return this;\n        }\n\n        /**\n         * Sets the name of the Option.\n         *\n         * @param option the name of the Option.\n         * @return this builder.\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n         * @since 1.5.0\n         */\n        public Builder option(final String option) throws IllegalArgumentException {\n            this.option = OptionValidator.validate(option);\n            return this;\n        }\n\n        /**\n         * Sets whether the Option can have an optional argument.\n         *\n         * @param optionalArg specifies whether the Option can have an optional argument.\n         * @return this builder.\n         */\n        public Builder optionalArg(final boolean optionalArg) {\n            if (optionalArg && argCount == UNINITIALIZED) {\n                argCount = 1;\n            }\n            this.optionalArg = optionalArg;\n            return this;\n        }\n\n        /**\n         * Marks this Option as required.\n         *\n         * @return this builder.\n         */\n        public Builder required() {\n            return required(true);\n        }\n\n        /**\n         * Sets whether the Option is required.\n         *\n         * @param required specifies whether the Option is required.\n         * @return this builder.\n         */\n        public Builder required(final boolean required) {\n            this.required = required;\n            return this;\n        }\n\n        /** Sets the version number when this option was first defined.\"\n         *\n         * @param since the version number when this option was first defined.\n         * @return this builder.\n         */\n        public Builder since(final String since) {\n            this.since = since;\n            return this;\n        }\n\n        /**\n         * Sets the type of the Option.\n         *\n         * @param type the type of the Option.\n         * @return this builder.\n         */\n        public Builder type(final Class<?> type) {\n            this.type = toType(type);\n            return this;\n        }\n\n        /**\n         * The Option will use '=' as a means to separate argument value.\n         *\n         * @return this builder.\n         */\n        public Builder valueSeparator() {\n            return valueSeparator(Char.EQUAL);\n        }\n\n        /**\n         * The Option will use {@code sep} as a means to separate argument values.\n         * <p>\n         * <b>Example:</b>\n         * </p>\n         *\n         * <pre>\n         * Option opt = Option.builder(\"D\").hasArgs().valueSeparator('=').build();\n         * Options options = new Options();\n         * options.addOption(opt);\n         * String[] args = { \"-Dkey=value\" };\n         * CommandLineParser parser = new DefaultParser();\n         * CommandLine line = parser.parse(options, args);\n         * String propertyName = line.getOptionValues(\"D\")[0]; // will be \"key\"\n         * String propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n         * </pre>\n         *\n         * @param valueSeparator The value separator.\n         * @return this builder.\n         */\n        public Builder valueSeparator(final char valueSeparator) {\n            this.valueSeparator = valueSeparator;\n            return this;\n        }\n\n    }", "definition": "    public static final class Builder", "class_docstring": "\nBuilds {@code Option} instances using descriptive methods.\n<p>\nExample usage:\n</p>\n\n<pre>\nOption option = Option.builder(\"a\").required(true).longOpt(\"arg-name\").build();\n</pre>\n\n@since 1.3\n", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final Class<String> DEFAULT_TYPE = String.class;", "docstring": " The default type.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Class<String>", "name": "DEFAULT_TYPE = String.class", "syntax_pass": true}, {"attribute_expression": "private int argCount = UNINITIALIZED;", "docstring": " The number of argument values this option can have.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "argCount = UNINITIALIZED", "syntax_pass": true}, {"attribute_expression": "private String argName;", "docstring": " The name of the argument for this option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "argName", "syntax_pass": true}, {"attribute_expression": "private Converter<?, ?> converter;", "docstring": " The converter to convert to type. *", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Converter<?, ?>", "name": "converter", "syntax_pass": true}, {"attribute_expression": "private DeprecatedAttributes deprecated;", "docstring": " Specifies whether this option is deprecated.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DeprecatedAttributes", "name": "deprecated", "syntax_pass": true}, {"attribute_expression": "private String description;", "docstring": " Description of the option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "description", "syntax_pass": true}, {"attribute_expression": "private String longOption;", "docstring": " The long representation of the option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "longOption", "syntax_pass": true}, {"attribute_expression": "private String option;", "docstring": " The name of the option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "option", "syntax_pass": true}, {"attribute_expression": "private boolean optionalArg;", "docstring": " Specifies whether the argument value of this Option is optional.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "optionalArg", "syntax_pass": true}, {"attribute_expression": "private boolean required;", "docstring": " Specifies whether this option is required to be present.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "required", "syntax_pass": true}, {"attribute_expression": "private String since;", "docstring": " Specifies the version when this option was added.  May be null", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "since", "syntax_pass": true}, {"attribute_expression": "private Class<?> type = DEFAULT_TYPE;", "docstring": " The type of this Option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Class<?>", "name": "type = DEFAULT_TYPE", "syntax_pass": true}, {"attribute_expression": "private char valueSeparator;", "docstring": " The character that is the value separator.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "char", "name": "valueSeparator", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private static Class<?> toType(final Class<?> type) {\n            return type != null ? type : DEFAULT_TYPE;\n        }", "docstring": "\nReturns the input Class or the default type (String) if null.\n\n@param type the candidate Class.\n@return the input Class or the default type (String) if null.\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Class<?>", "classes": []}, "name": "toType", "params": [{"name": "type", "type": "Class<?>"}], "body": "                                                            {\n            return type != null ? type : DEFAULT_TYPE;\n        }", "signature": "private static Class<?> toType(final Class<?> type)"}, {"syntax_pass": true, "original_string": "        private Builder(final String option) throws IllegalArgumentException {\n            option(option);\n        }", "docstring": "\nConstructs a new {@code Builder} with the minimum required parameters for an {@code Option} instance.\n\n@param option short representation of the option.\n@throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Builder", "params": [{"name": "option", "type": "String"}], "body": "                                                                             {\n            option(option);\n        }", "signature": "private Builder(final String option)"}, {"syntax_pass": true, "original_string": "        public Builder argName(final String argName) {\n            this.argName = argName;\n            return this;\n        }", "docstring": "\nSets the display name for the argument value.\n\n@param argName the display name for the argument value.\n@return this builder, to allow method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "argName", "params": [{"name": "argName", "type": "String"}], "body": "                                                     {\n            this.argName = argName;\n            return this;\n        }", "signature": "public Builder argName(final String argName)"}, {"syntax_pass": true, "original_string": "        public Option build() {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }", "docstring": "\nConstructs an Option with the values declared by this {@link Builder}.\n\n@return the new {@link Option}.\n@throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Option", "classes": []}, "name": "build", "params": [], "body": "                              {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }", "signature": "public Option build()"}, {"syntax_pass": true, "original_string": "        public Builder converter(final Converter<?, ?> converter) {\n            this.converter = converter;\n            return this;\n        }", "docstring": "\nSets the converter for the option.\n<p>\nNote: See {@link TypeHandler} for serialization discussion.\n</p>\n\n@param converter the Converter to use.\n@return this builder, to allow method chaining.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "converter", "params": [{"name": "converter", "type": "Converter<?, ?>"}], "body": "                                                                  {\n            this.converter = converter;\n            return this;\n        }", "signature": "public Builder converter(final Converter<?, ?> converter)"}, {"syntax_pass": true, "original_string": "        public Builder deprecated() {\n            return deprecated(DeprecatedAttributes.DEFAULT);\n        }", "docstring": "\nMarks this Option as deprecated.\n\n@return this builder.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "deprecated", "params": [], "body": "                                    {\n            return deprecated(DeprecatedAttributes.DEFAULT);\n        }", "signature": "public Builder deprecated()"}, {"syntax_pass": true, "original_string": "        public Builder deprecated(final DeprecatedAttributes deprecated) {\n            this.deprecated = deprecated;\n            return this;\n        }", "docstring": "\nSets whether the Option is deprecated.\n\n@param deprecated specifies whether the Option is deprecated.\n@return this builder.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "deprecated", "params": [{"name": "deprecated", "type": "DeprecatedAttributes"}], "body": "                                                                         {\n            this.deprecated = deprecated;\n            return this;\n        }", "signature": "public Builder deprecated(final DeprecatedAttributes deprecated)"}, {"syntax_pass": true, "original_string": "        public Builder desc(final String description) {\n            this.description = description;\n            return this;\n        }", "docstring": "\nSets the description for this option.\n\n@param description the description of the option.\n@return this builder, to allow method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "desc", "params": [{"name": "description", "type": "String"}], "body": "                                                      {\n            this.description = description;\n            return this;\n        }", "signature": "public Builder desc(final String description)"}, {"syntax_pass": true, "original_string": "        public Builder hasArg() {\n            return hasArg(true);\n        }", "docstring": "\nTests whether the Option will require an argument.\n\n@return this builder, to allow method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "hasArg", "params": [], "body": "                                {\n            return hasArg(true);\n        }", "signature": "public Builder hasArg()"}, {"syntax_pass": true, "original_string": "        public Builder hasArg(final boolean hasArg) {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : UNINITIALIZED;\n            return this;\n        }", "docstring": "\nTests whether the Option has an argument or not.\n\n@param hasArg specifies whether the Option takes an argument or not.\n@return this builder, to allow method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "hasArg", "params": [{"name": "hasArg", "type": "boolean"}], "body": "                                                    {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : UNINITIALIZED;\n            return this;\n        }", "signature": "public Builder hasArg(final boolean hasArg)"}, {"syntax_pass": true, "original_string": "        public Builder hasArgs() {\n            argCount = UNLIMITED_VALUES;\n            return this;\n        }", "docstring": "\nTests whether the Option can have unlimited argument values.\n\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "hasArgs", "params": [], "body": "                                 {\n            argCount = UNLIMITED_VALUES;\n            return this;\n        }", "signature": "public Builder hasArgs()"}, {"syntax_pass": true, "original_string": "        public Builder longOpt(final String longOption) {\n            this.longOption = longOption;\n            return this;\n        }", "docstring": "\nSets the long name of the Option.\n\n@param longOption the long name of the Option\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "longOpt", "params": [{"name": "longOption", "type": "String"}], "body": "                                                        {\n            this.longOption = longOption;\n            return this;\n        }", "signature": "public Builder longOpt(final String longOption)"}, {"syntax_pass": true, "original_string": "        public Builder numberOfArgs(final int argCount) {\n            this.argCount = argCount;\n            return this;\n        }", "docstring": "\nSets the number of argument values the Option can take.\n\n@param argCount the number of argument values\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "numberOfArgs", "params": [{"name": "argCount", "type": "int"}], "body": "                                                        {\n            this.argCount = argCount;\n            return this;\n        }", "signature": "public Builder numberOfArgs(final int argCount)"}, {"syntax_pass": true, "original_string": "        public Builder option(final String option) throws IllegalArgumentException {\n            this.option = OptionValidator.validate(option);\n            return this;\n        }", "docstring": "\nSets the name of the Option.\n\n@param option the name of the Option.\n@return this builder.\n@throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "option", "params": [{"name": "option", "type": "String"}], "body": "                                                                                   {\n            this.option = OptionValidator.validate(option);\n            return this;\n        }", "signature": "public Builder option(final String option)"}, {"syntax_pass": true, "original_string": "        public Builder optionalArg(final boolean optionalArg) {\n            if (optionalArg && argCount == UNINITIALIZED) {\n                argCount = 1;\n            }\n            this.optionalArg = optionalArg;\n            return this;\n        }", "docstring": "\nSets whether the Option can have an optional argument.\n\n@param optionalArg specifies whether the Option can have an optional argument.\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "optionalArg", "params": [{"name": "optionalArg", "type": "boolean"}], "body": "                                                              {\n            if (optionalArg && argCount == UNINITIALIZED) {\n                argCount = 1;\n            }\n            this.optionalArg = optionalArg;\n            return this;\n        }", "signature": "public Builder optionalArg(final boolean optionalArg)"}, {"syntax_pass": true, "original_string": "        public Builder required() {\n            return required(true);\n        }", "docstring": "\nMarks this Option as required.\n\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "required", "params": [], "body": "                                  {\n            return required(true);\n        }", "signature": "public Builder required()"}, {"syntax_pass": true, "original_string": "        public Builder required(final boolean required) {\n            this.required = required;\n            return this;\n        }", "docstring": "\nSets whether the Option is required.\n\n@param required specifies whether the Option is required.\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "required", "params": [{"name": "required", "type": "boolean"}], "body": "                                                        {\n            this.required = required;\n            return this;\n        }", "signature": "public Builder required(final boolean required)"}, {"syntax_pass": true, "original_string": "        public Builder since(final String since) {\n            this.since = since;\n            return this;\n        }", "docstring": " Sets the version number when this option was first defined.\"\n\n@param since the version number when this option was first defined.\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "since", "params": [{"name": "since", "type": "String"}], "body": "                                                 {\n            this.since = since;\n            return this;\n        }", "signature": "public Builder since(final String since)"}, {"syntax_pass": true, "original_string": "        public Builder type(final Class<?> type) {\n            this.type = toType(type);\n            return this;\n        }", "docstring": "\nSets the type of the Option.\n\n@param type the type of the Option.\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "type", "params": [{"name": "type", "type": "Class<?>"}], "body": "                                                 {\n            this.type = toType(type);\n            return this;\n        }", "signature": "public Builder type(final Class<?> type)"}, {"syntax_pass": true, "original_string": "        public Builder valueSeparator() {\n            return valueSeparator(Char.EQUAL);\n        }", "docstring": "\nThe Option will use '=' as a means to separate argument value.\n\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "valueSeparator", "params": [], "body": "                                        {\n            return valueSeparator(Char.EQUAL);\n        }", "signature": "public Builder valueSeparator()"}, {"syntax_pass": true, "original_string": "        public Builder valueSeparator(final char valueSeparator) {\n            this.valueSeparator = valueSeparator;\n            return this;\n        }", "docstring": "\nThe Option will use {@code sep} as a means to separate argument values.\n<p>\n<b>Example:</b>\n</p>\n\n<pre>\nOption opt = Option.builder(\"D\").hasArgs().valueSeparator('=').build();\nOptions options = new Options();\noptions.addOption(opt);\nString[] args = { \"-Dkey=value\" };\nCommandLineParser parser = new DefaultParser();\nCommandLine line = parser.parse(options, args);\nString propertyName = line.getOptionValues(\"D\")[0]; // will be \"key\"\nString propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n</pre>\n\n@param valueSeparator The value separator.\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "valueSeparator", "params": [{"name": "valueSeparator", "type": "char"}], "body": "                                                                 {\n            this.valueSeparator = valueSeparator;\n            return this;\n        }", "signature": "public Builder valueSeparator(final char valueSeparator)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static Builder builder() {\n        return builder(null);\n    }", "docstring": "\nReturns a {@link Builder} to create an {@link Option} using descriptive methods.\n\n@return a new {@link Builder} instance.\n@since 1.3\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "builder", "params": [], "body": "                                    {\n        return builder(null);\n    }", "signature": "public static Builder builder()"}, {"syntax_pass": true, "original_string": "    public static Builder builder(final String option) {\n        return new Builder(option);\n    }", "docstring": "\nReturns a {@link Builder} to create an {@link Option} using descriptive methods.\n\n@param option short representation of the option.\n@return a new {@link Builder} instance.\n@throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n@since 1.3\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "builder", "params": [{"name": "option", "type": "String"}], "body": "                                                       {\n        return new Builder(option);\n    }", "signature": "public static Builder builder(final String option)"}, {"syntax_pass": true, "original_string": "    private Option(final Builder builder) {\n        this.argName = builder.argName;\n        this.description = builder.description;\n        this.longOption = builder.longOption;\n        this.argCount = builder.argCount;\n        this.option = builder.option;\n        this.optionalArg = builder.optionalArg;\n        this.deprecated = builder.deprecated;\n        this.required = builder.required;\n        this.since = builder.since;\n        this.type = builder.type;\n        this.valueSeparator = builder.valueSeparator;\n        this.converter = builder.converter;\n    }", "docstring": "\nPrivate constructor used by the nested Builder class.\n\n@param builder builder used to create this option.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Option", "params": [{"name": "builder", "type": "Builder"}], "body": "                                          {\n        this.argName = builder.argName;\n        this.description = builder.description;\n        this.longOption = builder.longOption;\n        this.argCount = builder.argCount;\n        this.option = builder.option;\n        this.optionalArg = builder.optionalArg;\n        this.deprecated = builder.deprecated;\n        this.required = builder.required;\n        this.since = builder.since;\n        this.type = builder.type;\n        this.valueSeparator = builder.valueSeparator;\n        this.converter = builder.converter;\n    }", "signature": "private Option(final Builder builder)"}, {"syntax_pass": true, "original_string": "    public Option(final String option, final boolean hasArg, final String description) throws IllegalArgumentException {\n        this(option, null, hasArg, description);\n    }", "docstring": "\nCreates an Option using the specified parameters.\n\n@param option      short representation of the option.\n@param hasArg      specifies whether the Option takes an argument or not.\n@param description describes the function of the option.\n\n@throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Option", "params": [{"name": "option", "type": "String"}, {"name": "hasArg", "type": "boolean"}, {"name": "description", "type": "String"}], "body": "                                                                                                                       {\n        this(option, null, hasArg, description);\n    }", "signature": "public Option(final String option, final boolean hasArg, final String description)"}, {"syntax_pass": true, "original_string": "    public Option(final String option, final String description) throws IllegalArgumentException {\n        this(option, null, false, description);\n    }", "docstring": "\nCreates an Option using the specified parameters. The option does not take an argument.\n\n@param option      short representation of the option.\n@param description describes the function of the option.\n\n@throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Option", "params": [{"name": "option", "type": "String"}, {"name": "description", "type": "String"}], "body": "                                                                                                 {\n        this(option, null, false, description);\n    }", "signature": "public Option(final String option, final String description)"}, {"syntax_pass": true, "original_string": "    public Option(final String option, final String longOption, final boolean hasArg, final String description) throws IllegalArgumentException {\n        // ensure that the option is valid\n        this.deprecated = null;\n        this.option = OptionValidator.validate(option);\n        this.longOption = longOption;\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg) {\n            this.argCount = 1;\n        }\n        this.description = description;\n    }", "docstring": "\nCreates an Option using the specified parameters.\n\n@param option      short representation of the option.\n@param longOption  the long representation of the option.\n@param hasArg      specifies whether the Option takes an argument or not.\n@param description describes the function of the option.\n\n@throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Option", "params": [{"name": "option", "type": "String"}, {"name": "longOption", "type": "String"}, {"name": "hasArg", "type": "boolean"}, {"name": "description", "type": "String"}], "body": "                                                                                                                                                {\n        // ensure that the option is valid\n        this.deprecated = null;\n        this.option = OptionValidator.validate(option);\n        this.longOption = longOption;\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg) {\n            this.argCount = 1;\n        }\n        this.description = description;\n    }", "signature": "public Option(final String option, final String longOption, final boolean hasArg, final String description)"}, {"syntax_pass": true, "original_string": "    boolean acceptsArg() {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (argCount <= 0 || values.size() < argCount);\n    }", "docstring": "\nTests whether the option can accept more arguments.\n\n@return false if the maximum number of arguments is reached.\n@since 1.3\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "acceptsArg", "params": [], "body": "                         {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (argCount <= 0 || values.size() < argCount);\n    }", "signature": "boolean acceptsArg()"}, {"syntax_pass": true, "original_string": "    private void add(final String value) {\n        if (!acceptsArg()) {\n            throw new IllegalArgumentException(\"Cannot add value, list full.\");\n        }\n        // store value\n        values.add(value);\n    }", "docstring": "\nAdds the value to this Option. If the number of arguments is greater than zero and there is enough space in the list then add the value. Otherwise, throw\na runtime exception.\n\n@param value The value to be added to this Option.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "value", "type": "String"}], "body": "                                         {\n        if (!acceptsArg()) {\n            throw new IllegalArgumentException(\"Cannot add value, list full.\");\n        }\n        // store value\n        values.add(value);\n    }", "signature": "private void add(final String value)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public boolean addValue(final String value) {\n        throw new UnsupportedOperationException(\n                \"The addValue method is not intended for client use. Subclasses should use the processValue method instead.\");\n    }", "docstring": "\nThis method is not intended to be used. It was a piece of internal API that was made public in 1.0. It currently throws an UnsupportedOperationException.\n\n@param value the value to add.\n@return always throws an {@link UnsupportedOperationException}.\n@throws UnsupportedOperationException always.\n@deprecated Unused.\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "addValue", "params": [{"name": "value", "type": "String"}], "body": "                                                {\n        throw new UnsupportedOperationException(\n                \"The addValue method is not intended for client use. Subclasses should use the processValue method instead.\");\n    }", "signature": "@Deprecated\n    public boolean addValue(final String value)"}, {"syntax_pass": true, "original_string": "    void clearValues() {\n        values.clear();\n    }", "docstring": "\nClears the Option values. After a parse is complete, these are left with data in them and they need clearing if another parse is done.\n\nSee: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "clearValues", "params": [], "body": "                       {\n        values.clear();\n    }", "signature": "void clearValues()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Object clone() {\n        try {\n            final Option option = (Option) super.clone();\n            option.values = new ArrayList<>(values);\n            return option;\n        } catch (final CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e.getMessage(), e);\n        }\n    }", "docstring": "\nA rather odd clone method - due to incorrect code in 1.0 it is public and in 1.1 rather than throwing a CloneNotSupportedException it throws a\nRuntimeException so as to maintain backwards compatible at the API level.\n\nAfter calling this method, it is very likely you will want to call clearValues().\n\n@return a clone of this Option instance.\n@throws RuntimeException if a {@link CloneNotSupportedException} has been thrown by {@code super.clone()}.\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "clone", "params": [], "body": "                          {\n        try {\n            final Option option = (Option) super.clone();\n            option.values = new ArrayList<>(values);\n            return option;\n        } catch (final CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e.getMessage(), e);\n        }\n    }", "signature": "@Override\n    public Object clone()"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Option)) {\n            return false;\n        }\n        final Option other = (Option) obj;\n        return Objects.equals(longOption, other.longOption) && Objects.equals(option, other.option);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                            {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Option)) {\n            return false;\n        }\n        final Option other = (Option) obj;\n        return Objects.equals(longOption, other.longOption) && Objects.equals(option, other.option);\n    }", "signature": "@Override\n    public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "    public String getArgName() {\n        return argName;\n    }", "docstring": "\nGets the display name for the argument value.\n\n@return the display name for the argument value.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getArgName", "params": [], "body": "                               {\n        return argName;\n    }", "signature": "public String getArgName()"}, {"syntax_pass": true, "original_string": "    public int getArgs() {\n        return argCount;\n    }", "docstring": "\nGets the number of argument values this Option can take.\n\n<p>\nA value equal to the constant {@link #UNINITIALIZED} (= -1) indicates the number of arguments has not been specified. A value equal to the constant\n{@link #UNLIMITED_VALUES} (= -2) indicates that this options takes an unlimited amount of values.\n</p>\n\n@return num the number of argument values.\n@see #UNINITIALIZED\n@see #UNLIMITED_VALUES\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getArgs", "params": [], "body": "                         {\n        return argCount;\n    }", "signature": "public int getArgs()"}, {"syntax_pass": true, "original_string": "    public Converter<?, ?> getConverter() {\n        return converter == null ? TypeHandler.getDefault().getConverter(type) : converter;\n    }", "docstring": "\nGets the value to type converter.\n\n@return the value to type converter.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Converter<?, ?>", "classes": []}, "name": "getConverter", "params": [], "body": "                                          {\n        return converter == null ? TypeHandler.getDefault().getConverter(type) : converter;\n    }", "signature": "public Converter<?, ?> getConverter()"}, {"syntax_pass": true, "original_string": "    public DeprecatedAttributes getDeprecated() {\n        return deprecated;\n    }", "docstring": "\nGets deprecated attributes if any.\n\n@return boolean deprecated attributes or null.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeprecatedAttributes", "classes": []}, "name": "getDeprecated", "params": [], "body": "                                                {\n        return deprecated;\n    }", "signature": "public DeprecatedAttributes getDeprecated()"}, {"syntax_pass": true, "original_string": "    public String getDescription() {\n        return description;\n    }", "docstring": "\nGets the self-documenting description of this Option.\n\n@return The string description of this option.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getDescription", "params": [], "body": "                                   {\n        return description;\n    }", "signature": "public String getDescription()"}, {"syntax_pass": true, "original_string": "    public int getId() {\n        return getKey().charAt(0);\n    }", "docstring": "\nGets the id of this Option. This is only set when the Option shortOpt is a single character. This is used for switch statements.\n\n@return the id of this Option.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getId", "params": [], "body": "                       {\n        return getKey().charAt(0);\n    }", "signature": "public int getId()"}, {"syntax_pass": true, "original_string": "    public String getKey() {\n        // if 'opt' is null, then it is a 'long' option\n        return option == null ? longOption : option;\n    }", "docstring": "\nGets the 'unique' Option identifier. This is the option value if set or the long value if the options value is not set.\n\n@return the 'unique' Option identifier.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getKey", "params": [], "body": "                           {\n        // if 'opt' is null, then it is a 'long' option\n        return option == null ? longOption : option;\n    }", "signature": "public String getKey()"}, {"syntax_pass": true, "original_string": "    public String getLongOpt() {\n        return longOption;\n    }", "docstring": "\nGets the long name of this Option.\n\n@return Long name of this option, or null, if there is no long name.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getLongOpt", "params": [], "body": "                               {\n        return longOption;\n    }", "signature": "public String getLongOpt()"}, {"syntax_pass": true, "original_string": "    public String getOpt() {\n        return option;\n    }", "docstring": "\nGets the name of this Option.\n\nIt is this String which can be used with {@link CommandLine#hasOption(String opt)} and {@link CommandLine#getOptionValue(String opt)} to check for\nexistence and argument.\n\n@return The name of this option.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOpt", "params": [], "body": "                           {\n        return option;\n    }", "signature": "public String getOpt()"}, {"syntax_pass": true, "original_string": "    public String getSince() {\n        return since;\n    }", "docstring": "\nGets the version when this option was added.\n@return the version when this option was added, or {@code null} if not set.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getSince", "params": [], "body": "                             {\n        return since;\n    }", "signature": "public String getSince()"}, {"syntax_pass": true, "original_string": "    public Object getType() {\n        return type;\n    }", "docstring": "\nGets the type of this Option.\n\n@return The type of this option.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "getType", "params": [], "body": "                            {\n        return type;\n    }", "signature": "public Object getType()"}, {"syntax_pass": true, "original_string": "    public String getValue() {\n        return hasNoValues() ? null : values.get(0);\n    }", "docstring": "\nGets the specified value of this Option or {@code null} if there is no value.\n\n@return the value/first value of this Option or {@code null} if there is no value.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getValue", "params": [], "body": "                             {\n        return hasNoValues() ? null : values.get(0);\n    }", "signature": "public String getValue()"}, {"syntax_pass": true, "original_string": "    public String getValue(final int index) throws IndexOutOfBoundsException {\n        return hasNoValues() ? null : values.get(index);\n    }", "docstring": "\nGets the specified value of this Option or {@code null} if there is no value.\n\n@param index The index of the value to be returned.\n\n@return the specified value of this Option or {@code null} if there is no value.\n\n@throws IndexOutOfBoundsException if index is less than 1 or greater than the number of the values for this Option.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getValue", "params": [{"name": "index", "type": "int"}], "body": "                                                                             {\n        return hasNoValues() ? null : values.get(index);\n    }", "signature": "public String getValue(final int index)"}, {"syntax_pass": true, "original_string": "    public String getValue(final String defaultValue) {\n        final String value = getValue();\n        return value != null ? value : defaultValue;\n    }", "docstring": "\nGets the value/first value of this Option or the {@code defaultValue} if there is no value.\n\n@param defaultValue The value to be returned if there is no value.\n\n@return the value/first value of this Option or the {@code defaultValue} if there are no values.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getValue", "params": [{"name": "defaultValue", "type": "String"}], "body": "                                                      {\n        final String value = getValue();\n        return value != null ? value : defaultValue;\n    }", "signature": "public String getValue(final String defaultValue)"}, {"syntax_pass": true, "original_string": "    public String[] getValues() {\n        return hasNoValues() ? null : values.toArray(EMPTY_STRING_ARRAY);\n    }", "docstring": "\nGets the values of this Option as a String array or null if there are no values.\n\n@return the values of this Option as a String array or null if there are no values.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String[]", "classes": []}, "name": "getValues", "params": [], "body": "                                {\n        return hasNoValues() ? null : values.toArray(EMPTY_STRING_ARRAY);\n    }", "signature": "public String[] getValues()"}, {"syntax_pass": true, "original_string": "    public char getValueSeparator() {\n        return valueSeparator;\n    }", "docstring": "\nGets the value separator character.\n\n@return the value separator character.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "name": "getValueSeparator", "params": [], "body": "                                    {\n        return valueSeparator;\n    }", "signature": "public char getValueSeparator()"}, {"syntax_pass": true, "original_string": "    public List<String> getValuesList() {\n        return values;\n    }", "docstring": "\nGets the values of this Option as a List or null if there are no values.\n\n@return the values of this Option as a List or null if there are no values.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getValuesList", "params": [], "body": "                                        {\n        return values;\n    }", "signature": "public List<String> getValuesList()"}, {"syntax_pass": true, "original_string": "    public boolean hasArg() {\n        return argCount > 0 || argCount == UNLIMITED_VALUES;\n    }", "docstring": "\nTests whether this Option requires an argument.\n\n@return boolean flag indicating if an argument is required.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasArg", "params": [], "body": "                            {\n        return argCount > 0 || argCount == UNLIMITED_VALUES;\n    }", "signature": "public boolean hasArg()"}, {"syntax_pass": true, "original_string": "    public boolean hasArgName() {\n        return argName != null && !argName.isEmpty();\n    }", "docstring": "\nTests whether the display name for the argument value has been set.\n\n@return if the display name for the argument value has been set.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasArgName", "params": [], "body": "                                {\n        return argName != null && !argName.isEmpty();\n    }", "signature": "public boolean hasArgName()"}, {"syntax_pass": true, "original_string": "    public boolean hasArgs() {\n        return argCount > 1 || argCount == UNLIMITED_VALUES;\n    }", "docstring": "\nTests whether this Option can take many values.\n\n@return boolean flag indicating if multiple values are allowed.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasArgs", "params": [], "body": "                             {\n        return argCount > 1 || argCount == UNLIMITED_VALUES;\n    }", "signature": "public boolean hasArgs()"}, {"syntax_pass": true, "original_string": "    @Override\n    public int hashCode() {\n        return Objects.hash(longOption, option);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                          {\n        return Objects.hash(longOption, option);\n    }", "signature": "@Override\n    public int hashCode()"}, {"syntax_pass": true, "original_string": "    public boolean hasLongOpt() {\n        return longOption != null;\n    }", "docstring": "\nTests whether this Option has a long name.\n\n@return boolean flag indicating existence of a long name.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasLongOpt", "params": [], "body": "                                {\n        return longOption != null;\n    }", "signature": "public boolean hasLongOpt()"}, {"syntax_pass": true, "original_string": "    private boolean hasNoValues() {\n        return values.isEmpty();\n    }", "docstring": "\nTests whether this Option has any values.\n\n@return whether this Option has any values.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNoValues", "params": [], "body": "                                  {\n        return values.isEmpty();\n    }", "signature": "private boolean hasNoValues()"}, {"syntax_pass": true, "original_string": "    public boolean hasOptionalArg() {\n        return optionalArg;\n    }", "docstring": "\nTests whether this Option can have an optional argument.\n\n@return whether this Option can have an optional argument.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasOptionalArg", "params": [], "body": "                                    {\n        return optionalArg;\n    }", "signature": "public boolean hasOptionalArg()"}, {"syntax_pass": true, "original_string": "    public boolean hasValueSeparator() {\n        return valueSeparator > 0;\n    }", "docstring": "\nTests whether this Option has specified a value separator.\n\n@return whether this Option has specified a value separator.\n@since 1.1\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasValueSeparator", "params": [], "body": "                                       {\n        return valueSeparator > 0;\n    }", "signature": "public boolean hasValueSeparator()"}, {"syntax_pass": true, "original_string": "    public boolean isDeprecated() {\n        return deprecated != null;\n    }", "docstring": "\nTests whether this Option is deprecated.\n\n@return boolean flag indicating whether this Option is deprecated.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDeprecated", "params": [], "body": "                                  {\n        return deprecated != null;\n    }", "signature": "public boolean isDeprecated()"}, {"syntax_pass": true, "original_string": "    public boolean isRequired() {\n        return required;\n    }", "docstring": "\nTests whether this Option is required.\n\n@return boolean flag indicating whether this Option is required.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRequired", "params": [], "body": "                                {\n        return required;\n    }", "signature": "public boolean isRequired()"}, {"syntax_pass": true, "original_string": "    void processValue(final String value) {\n        if (argCount == UNINITIALIZED) {\n            throw new IllegalArgumentException(\"NO_ARGS_ALLOWED\");\n        }\n        String add = value;\n        // this Option has a separator character\n        if (hasValueSeparator()) {\n            // get the separator character\n            final char sep = getValueSeparator();\n            // store the index for the value separator\n            int index = add.indexOf(sep);\n            // while there are more value separators\n            while (index != -1) {\n                // next value to be added\n                if (values.size() == argCount - 1) {\n                    break;\n                }\n                // store\n                add(add.substring(0, index));\n                // parse\n                add = add.substring(index + 1);\n                // get new index\n                index = add.indexOf(sep);\n            }\n        }\n        // store the actual value or the last value that has been parsed\n        add(add);\n    }", "docstring": "\nProcesses the value. If this Option has a value separator the value will have to be parsed into individual tokens. When n-1 tokens have been processed\nand there are more value separators in the value, parsing is ceased and the remaining characters are added as a single token.\n\n@param value The String to be processed.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "processValue", "params": [{"name": "value", "type": "String"}], "body": "                                          {\n        if (argCount == UNINITIALIZED) {\n            throw new IllegalArgumentException(\"NO_ARGS_ALLOWED\");\n        }\n        String add = value;\n        // this Option has a separator character\n        if (hasValueSeparator()) {\n            // get the separator character\n            final char sep = getValueSeparator();\n            // store the index for the value separator\n            int index = add.indexOf(sep);\n            // while there are more value separators\n            while (index != -1) {\n                // next value to be added\n                if (values.size() == argCount - 1) {\n                    break;\n                }\n                // store\n                add(add.substring(0, index));\n                // parse\n                add = add.substring(index + 1);\n                // get new index\n                index = add.indexOf(sep);\n            }\n        }\n        // store the actual value or the last value that has been parsed\n        add(add);\n    }", "signature": "void processValue(final String value)"}, {"syntax_pass": true, "original_string": "    boolean requiresArg() {\n        if (optionalArg) {\n            return false;\n        }\n        if (argCount == UNLIMITED_VALUES) {\n            return values.isEmpty();\n        }\n        return acceptsArg();\n    }", "docstring": "\nTests whether the option requires more arguments to be valid.\n\n@return false if the option doesn't require more arguments.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "requiresArg", "params": [], "body": "                          {\n        if (optionalArg) {\n            return false;\n        }\n        if (argCount == UNLIMITED_VALUES) {\n            return values.isEmpty();\n        }\n        return acceptsArg();\n    }", "signature": "boolean requiresArg()"}, {"syntax_pass": true, "original_string": "    public void setArgName(final String argName) {\n        this.argName = argName;\n    }", "docstring": "\nSets the display name for the argument value.\n\n@param argName the display name for the argument value.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setArgName", "params": [{"name": "argName", "type": "String"}], "body": "                                                 {\n        this.argName = argName;\n    }", "signature": "public void setArgName(final String argName)"}, {"syntax_pass": true, "original_string": "    public void setArgs(final int num) {\n        this.argCount = num;\n    }", "docstring": "\nSets the number of argument values this Option can take.\n\n@param num the number of argument values.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setArgs", "params": [{"name": "num", "type": "int"}], "body": "                                       {\n        this.argCount = num;\n    }", "signature": "public void setArgs(final int num)"}, {"syntax_pass": true, "original_string": "    public void setConverter(final Converter<?, ?> converter) {\n        this.converter = converter;\n    }", "docstring": "\nSets the value to type converter.\n\n@param converter The converter to convert the string value to the type.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setConverter", "params": [{"name": "converter", "type": "Converter<?, ?>"}], "body": "                                                              {\n        this.converter = converter;\n    }", "signature": "public void setConverter(final Converter<?, ?> converter)"}, {"syntax_pass": true, "original_string": "    public void setDescription(final String description) {\n        this.description = description;\n    }", "docstring": "\nSets the self-documenting description of this Option.\n\n@param description The description of this option.\n@since 1.1\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setDescription", "params": [{"name": "description", "type": "String"}], "body": "                                                         {\n        this.description = description;\n    }", "signature": "public void setDescription(final String description)"}, {"syntax_pass": true, "original_string": "    public void setLongOpt(final String longOpt) {\n        this.longOption = longOpt;\n    }", "docstring": "\nSets the long name of this Option.\n\n@param longOpt the long name of this Option.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setLongOpt", "params": [{"name": "longOpt", "type": "String"}], "body": "                                                 {\n        this.longOption = longOpt;\n    }", "signature": "public void setLongOpt(final String longOpt)"}, {"syntax_pass": true, "original_string": "    public void setOptionalArg(final boolean optionalArg) {\n        this.optionalArg = optionalArg;\n    }", "docstring": "\nSets whether this Option can have an optional argument.\n\n@param optionalArg specifies whether the Option can have an optional argument.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setOptionalArg", "params": [{"name": "optionalArg", "type": "boolean"}], "body": "                                                          {\n        this.optionalArg = optionalArg;\n    }", "signature": "public void setOptionalArg(final boolean optionalArg)"}, {"syntax_pass": true, "original_string": "    public void setRequired(final boolean required) {\n        this.required = required;\n    }", "docstring": "\nSets whether this Option is mandatory.\n\n@param required specifies whether this Option is mandatory.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setRequired", "params": [{"name": "required", "type": "boolean"}], "body": "                                                    {\n        this.required = required;\n    }", "signature": "public void setRequired(final boolean required)"}, {"syntax_pass": true, "original_string": "    public void setType(final Class<?> type) {\n        this.type = Builder.toType(type);\n    }", "docstring": "\nSets the type of this Option.\n\n@param type the type of this Option.\n@since 1.3\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setType", "params": [{"name": "type", "type": "Class<?>"}], "body": "                                             {\n        this.type = Builder.toType(type);\n    }", "signature": "public void setType(final Class<?> type)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public void setType(final Object type) {\n        setType((Class<?>) type);\n    }", "docstring": "\nSets the type of this Option.\n<p>\n<b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class} object.\n</p>\n\n@param type the type of this Option.\n@deprecated since 1.3, use {@link #setType(Class)} instead.\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setType", "params": [{"name": "type", "type": "Object"}], "body": "                                           {\n        setType((Class<?>) type);\n    }", "signature": "@Deprecated\n    public void setType(final Object type)"}, {"syntax_pass": true, "original_string": "    public void setValueSeparator(final char valueSeparator) {\n        this.valueSeparator = valueSeparator;\n    }", "docstring": "\nSets the value separator. For example if the argument value was a Java property, the value separator would be '='.\n\n@param valueSeparator The value separator.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setValueSeparator", "params": [{"name": "valueSeparator", "type": "char"}], "body": "                                                             {\n        this.valueSeparator = valueSeparator;\n    }", "signature": "public void setValueSeparator(final char valueSeparator)"}, {"syntax_pass": true, "original_string": "    String toDeprecatedString() {\n        if (!isDeprecated()) {\n            return \"\";\n        }\n        // @formatter:off\n        final StringBuilder buf = new StringBuilder()\n                .append(\"Option '\")\n                .append(option)\n                .append(Char.APOS);\n        // @formatter:on\n        if (longOption != null) {\n            buf.append(Char.APOS).append(longOption).append(Char.APOS);\n        }\n        buf.append(\": \").append(deprecated);\n        return buf.toString();\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "toDeprecatedString", "params": [], "body": "                                {\n        if (!isDeprecated()) {\n            return \"\";\n        }\n        // @formatter:off\n        final StringBuilder buf = new StringBuilder()\n                .append(\"Option '\")\n                .append(option)\n                .append(Char.APOS);\n        // @formatter:on\n        if (longOption != null) {\n            buf.append(Char.APOS).append(longOption).append(Char.APOS);\n        }\n        buf.append(\": \").append(deprecated);\n        return buf.toString();\n    }", "signature": "String toDeprecatedString()"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder().append(\"[ \");\n        buf.append(\"Option \");\n        buf.append(option);\n        if (longOption != null) {\n            buf.append(Char.SP).append(longOption);\n        }\n        if (isDeprecated()) {\n            buf.append(Char.SP);\n            buf.append(deprecated.toString());\n        }\n        if (hasArgs()) {\n            buf.append(\"[ARG...]\");\n        } else if (hasArg()) {\n            buf.append(\" [ARG]\");\n        }\n        // @formatter:off\n        return buf.append(\" :: \")\n            .append(description)\n            .append(\" :: \")\n            .append(type)\n            .append(\" ]\")\n            .toString();\n        // @formatter:on\n    }", "docstring": "\nCreates a String suitable for debugging.\n\n@return a String suitable for debugging.\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        final StringBuilder buf = new StringBuilder().append(\"[ \");\n        buf.append(\"Option \");\n        buf.append(option);\n        if (longOption != null) {\n            buf.append(Char.SP).append(longOption);\n        }\n        if (isDeprecated()) {\n            buf.append(Char.SP);\n            buf.append(deprecated.toString());\n        }\n        if (hasArgs()) {\n            buf.append(\"[ARG...]\");\n        } else if (hasArg()) {\n            buf.append(\" [ARG]\");\n        }\n        // @formatter:off\n        return buf.append(\" :: \")\n            .append(description)\n            .append(\" :: \")\n            .append(type)\n            .append(\" ]\")\n            .toString();\n        // @formatter:on\n    }", "signature": "@Override\n    public String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/MissingArgumentException.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Thrown when an option requiring an argument is not provided with an argument.\n */\npublic class MissingArgumentException extends ParseException {\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = -7098538588704965017L;\n\n    /** The option requiring additional arguments */\n    private Option option;\n\n    /**\n     * Constructs a new {@code MissingArgumentException} with the specified detail message.\n     *\n     * @param option the option requiring an argument\n     * @since 1.2\n     */\n    public MissingArgumentException(final Option option) {\n        this(\"Missing argument for option: \" + option.getKey());\n        this.option = option;\n    }\n\n    /**\n     * Constructs a new {@code MissingArgumentException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public MissingArgumentException(final String message) {\n        super(message);\n    }\n\n    /**\n     * Gets the option requiring an argument that wasn't provided on the command line.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public Option getOption() {\n        return option;\n    }\n}\n", "file_hash": "814a9ccf045b39a52196849a4df8705a6c5307058eac9eb166037c2e80c01e04", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;"], "methods": [], "classes": [{"original_string": "public class MissingArgumentException extends ParseException {\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = -7098538588704965017L;\n\n    /** The option requiring additional arguments */\n    private Option option;\n\n    /**\n     * Constructs a new {@code MissingArgumentException} with the specified detail message.\n     *\n     * @param option the option requiring an argument\n     * @since 1.2\n     */\n    public MissingArgumentException(final Option option) {\n        this(\"Missing argument for option: \" + option.getKey());\n        this.option = option;\n    }\n\n    /**\n     * Constructs a new {@code MissingArgumentException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public MissingArgumentException(final String message) {\n        super(message);\n    }\n\n    /**\n     * Gets the option requiring an argument that wasn't provided on the command line.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public Option getOption() {\n        return option;\n    }\n}", "definition": "public class MissingArgumentException extends ParseException", "class_docstring": "\nThrown when an option requiring an argument is not provided with an argument.\n", "name": "MissingArgumentException", "super_interfaces": [], "superclasses": "ParseException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -7098538588704965017L;", "docstring": "\nThis exception {@code serialVersionUID}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -7098538588704965017L", "syntax_pass": true}, {"attribute_expression": "private Option option;", "docstring": " The option requiring additional arguments", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "option", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public MissingArgumentException(final Option option) {\n        this(\"Missing argument for option: \" + option.getKey());\n        this.option = option;\n    }", "docstring": "\nConstructs a new {@code MissingArgumentException} with the specified detail message.\n\n@param option the option requiring an argument\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MissingArgumentException", "params": [{"name": "option", "type": "Option"}], "body": "                                                         {\n        this(\"Missing argument for option: \" + option.getKey());\n        this.option = option;\n    }", "signature": "public MissingArgumentException(final Option option)"}, {"syntax_pass": true, "original_string": "    public MissingArgumentException(final String message) {\n        super(message);\n    }", "docstring": "\nConstructs a new {@code MissingArgumentException} with the specified detail message.\n\n@param message the detail message\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MissingArgumentException", "params": [{"name": "message", "type": "String"}], "body": "                                                          {\n        super(message);\n    }", "signature": "public MissingArgumentException(final String message)"}, {"syntax_pass": true, "original_string": "    public Option getOption() {\n        return option;\n    }", "docstring": "\nGets the option requiring an argument that wasn't provided on the command line.\n\n@return the related option\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Option", "classes": []}, "name": "getOption", "params": [], "body": "                              {\n        return option;\n    }", "signature": "public Option getOption()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/Util.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Contains useful helper methods for classes within this package.\n */\nfinal class Util {\n\n    /**\n     * An empty immutable {@code String} array.\n     */\n    static final String[] EMPTY_STRING_ARRAY = {};\n\n    /**\n     * Tests whether the given array is null or empty.\n     *\n     * @param array the array to test.\n     * @return the given array is null or empty.\n     */\n    static boolean isEmpty(final Object[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * Tests whether the given string is null or empty.\n     *\n     * @param str The string to test.\n     * @return Whether the given string is null or empty.\n     */\n    static boolean isEmpty(final String str) {\n        return str == null || str.isEmpty();\n    }\n\n    /**\n     * Removes the leading and trailing quotes from {@code str}. E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes should be removed.\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(final String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int length = str.length();\n        if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1) {\n            return str.substring(1, length - 1);\n        }\n        return str;\n    }\n\n    /**\n     * Removes the hyphens from the beginning of {@code str} and return the new String.\n     *\n     * @param str The string from which the hyphens should be removed.\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(final String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (str.startsWith(\"--\")) {\n            return str.substring(2);\n        }\n        if (str.startsWith(\"-\")) {\n            return str.substring(1);\n        }\n        return str;\n    }\n\n    private Util() {\n        // no instances\n    }\n}\n", "file_hash": "2a438338f3db7934050e6c9782e7e2d92995dc0c79875e38d6909b22f2952f26", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;"], "methods": [], "classes": [{"original_string": "final class Util {\n\n    /**\n     * An empty immutable {@code String} array.\n     */\n    static final String[] EMPTY_STRING_ARRAY = {};\n\n    /**\n     * Tests whether the given array is null or empty.\n     *\n     * @param array the array to test.\n     * @return the given array is null or empty.\n     */\n    static boolean isEmpty(final Object[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * Tests whether the given string is null or empty.\n     *\n     * @param str The string to test.\n     * @return Whether the given string is null or empty.\n     */\n    static boolean isEmpty(final String str) {\n        return str == null || str.isEmpty();\n    }\n\n    /**\n     * Removes the leading and trailing quotes from {@code str}. E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes should be removed.\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(final String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int length = str.length();\n        if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1) {\n            return str.substring(1, length - 1);\n        }\n        return str;\n    }\n\n    /**\n     * Removes the hyphens from the beginning of {@code str} and return the new String.\n     *\n     * @param str The string from which the hyphens should be removed.\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(final String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (str.startsWith(\"--\")) {\n            return str.substring(2);\n        }\n        if (str.startsWith(\"-\")) {\n            return str.substring(1);\n        }\n        return str;\n    }\n\n    private Util() {\n        // no instances\n    }\n}", "definition": "final class Util", "class_docstring": "\nContains useful helper methods for classes within this package.\n", "name": "Util", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "static final String[] EMPTY_STRING_ARRAY = {};", "docstring": "\nAn empty immutable {@code String} array.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "EMPTY_STRING_ARRAY = {}", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    static boolean isEmpty(final Object[] array) {\n        return array == null || array.length == 0;\n    }", "docstring": "\nTests whether the given array is null or empty.\n\n@param array the array to test.\n@return the given array is null or empty.\n", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [{"name": "array", "type": "Object[]"}], "body": "                                                 {\n        return array == null || array.length == 0;\n    }", "signature": "static boolean isEmpty(final Object[] array)"}, {"syntax_pass": true, "original_string": "    static boolean isEmpty(final String str) {\n        return str == null || str.isEmpty();\n    }", "docstring": "\nTests whether the given string is null or empty.\n\n@param str The string to test.\n@return Whether the given string is null or empty.\n", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [{"name": "str", "type": "String"}], "body": "                                             {\n        return str == null || str.isEmpty();\n    }", "signature": "static boolean isEmpty(final String str)"}, {"syntax_pass": true, "original_string": "    static String stripLeadingAndTrailingQuotes(final String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int length = str.length();\n        if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1) {\n            return str.substring(1, length - 1);\n        }\n        return str;\n    }", "docstring": "\nRemoves the leading and trailing quotes from {@code str}. E.g. if str is '\"one two\"', then 'one two' is returned.\n\n@param str The string from which the leading and trailing quotes should be removed.\n@return The string without the leading and trailing quotes.\n", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "name": "stripLeadingAndTrailingQuotes", "params": [{"name": "str", "type": "String"}], "body": "                                                                  {\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int length = str.length();\n        if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1) {\n            return str.substring(1, length - 1);\n        }\n        return str;\n    }", "signature": "static String stripLeadingAndTrailingQuotes(final String str)"}, {"syntax_pass": true, "original_string": "    static String stripLeadingHyphens(final String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (str.startsWith(\"--\")) {\n            return str.substring(2);\n        }\n        if (str.startsWith(\"-\")) {\n            return str.substring(1);\n        }\n        return str;\n    }", "docstring": "\nRemoves the hyphens from the beginning of {@code str} and return the new String.\n\n@param str The string from which the hyphens should be removed.\n@return the new String.\n", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "name": "stripLeadingHyphens", "params": [{"name": "str", "type": "String"}], "body": "                                                        {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (str.startsWith(\"--\")) {\n            return str.substring(2);\n        }\n        if (str.startsWith(\"-\")) {\n            return str.substring(1);\n        }\n        return str;\n    }", "signature": "static String stripLeadingHyphens(final String str)"}, {"syntax_pass": true, "original_string": "    private Util() {\n        // no instances\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Util", "params": [], "body": "                   {\n        // no instances\n    }", "signature": "private Util()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/BasicParser.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * The class BasicParser provides a very simple implementation of the {@link Parser#flatten(Options,String[],boolean)\n * flatten} method.\n *\n * @deprecated since 1.3, use the {@link DefaultParser} instead\n */\n@Deprecated\npublic class BasicParser extends Parser {\n    /**\n     * <p>\n     * A simple implementation of {@link Parser}'s abstract {@link Parser#flatten(Options, String[], boolean) flatten}\n     * method.\n     * </p>\n     *\n     * <p>\n     * <b>Note:</b> {@code options} and {@code stopAtNonOption} are not used in this {@code flatten} method.\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening when an non option is found.\n     * @return The {@code arguments} String array.\n     */\n    @Override\n    protected String[] flatten(@SuppressWarnings(\"unused\") final Options options, final String[] arguments,\n        @SuppressWarnings(\"unused\") final boolean stopAtNonOption) {\n        // just echo the arguments\n        return arguments;\n    }\n}\n", "file_hash": "196577254a138ce2432aea4d1948bbad97357cbb6b1d5ba230c0757704e99ac6", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;"], "methods": [], "classes": [{"original_string": "@Deprecated\npublic class BasicParser extends Parser {\n    /**\n     * <p>\n     * A simple implementation of {@link Parser}'s abstract {@link Parser#flatten(Options, String[], boolean) flatten}\n     * method.\n     * </p>\n     *\n     * <p>\n     * <b>Note:</b> {@code options} and {@code stopAtNonOption} are not used in this {@code flatten} method.\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening when an non option is found.\n     * @return The {@code arguments} String array.\n     */\n    @Override\n    protected String[] flatten(@SuppressWarnings(\"unused\") final Options options, final String[] arguments,\n        @SuppressWarnings(\"unused\") final boolean stopAtNonOption) {\n        // just echo the arguments\n        return arguments;\n    }\n}", "definition": "@Deprecated\npublic class BasicParser extends Parser", "class_docstring": "\nThe class BasicParser provides a very simple implementation of the {@link Parser#flatten(Options,String[],boolean)\nflatten} method.\n\n@deprecated since 1.3, use the {@link DefaultParser} instead\n", "name": "BasicParser", "super_interfaces": [], "superclasses": "Parser", "attributes": {"modifiers": "@Deprecated\npublic", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    protected String[] flatten(@SuppressWarnings(\"unused\") final Options options, final String[] arguments,\n        @SuppressWarnings(\"unused\") final boolean stopAtNonOption) {\n        // just echo the arguments\n        return arguments;\n    }", "docstring": "\n<p>\nA simple implementation of {@link Parser}'s abstract {@link Parser#flatten(Options, String[], boolean) flatten}\nmethod.\n</p>\n\n<p>\n<b>Note:</b> {@code options} and {@code stopAtNonOption} are not used in this {@code flatten} method.\n</p>\n\n@param options The command line {@link Options}\n@param arguments The command line arguments to be parsed\n@param stopAtNonOption Specifies whether to stop flattening when an non option is found.\n@return The {@code arguments} String array.\n", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String[]", "classes": []}, "name": "flatten", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "                                                                   {\n        // just echo the arguments\n        return arguments;\n    }", "signature": "@Override\n    protected String[] flatten(@SuppressWarnings(\"unused\") final Options options, final String[] arguments,\n        @SuppressWarnings(\"unused\") final boolean stopAtNonOption)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/OptionGroup.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n */\npublic class OptionGroup implements Serializable {\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** Hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<>();\n\n    /** The name of the selected option */\n    private String selected;\n\n    /** Specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Adds the given {@code Option} to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(final Option option) {\n        // key - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n        return this;\n    }\n\n    /**\n     * Gets the names of the options in this group as a {@code Collection}.\n     *\n     * @return the names of the options in this group as a {@code Collection}.\n     */\n    public Collection<String> getNames() {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * Gets the options in this group as a {@code Collection}.\n     *\n     * @return the options in this group as a {@code Collection}.\n     */\n    public Collection<Option> getOptions() {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Gets the selected option name.\n     *\n     * If the selected option is deprecated <em>no warning is logged</em>.\n     * @return the selected option name.\n     */\n    public String getSelected() {\n        return selected;\n    }\n\n    /**\n     * Tests whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired() {\n        return required;\n    }\n\n    /**\n     * Tests whether an option is selected.\n     *\n     *  If an option is selected and is deprecated <em>no warning is logged</em>.\n     * @return whether whether an option is selected.\n     * @since 1.9.0\n     */\n    public boolean isSelected() {\n        return selected != null;\n    }\n\n    /**\n     * Sets whether this group is required.\n     *\n     * @param required whether this group is required.\n     */\n    public void setRequired(final boolean required) {\n        this.required = required;\n    }\n\n    /**\n     * Sets the selected option of this group to {@code name}.\n     *\n     * If the selected option is deprecated <em>no warning is logged</em>.\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has already been selected.\n     */\n    public void setSelected(final Option option) throws AlreadySelectedException {\n        if (option == null) {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        // if no option has already been selected or the\n        // same option is being reselected then set the\n        // selected member variable\n        if (selected != null && !selected.equals(option.getKey())) {\n            throw new AlreadySelectedException(this, option);\n        }\n        selected = option.getKey();\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     *\n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buff = new StringBuilder();\n        final Iterator<Option> iter = getOptions().iterator();\n        buff.append(\"[\");\n        while (iter.hasNext()) {\n            final Option option = iter.next();\n            if (option.getOpt() != null) {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            } else {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n\n            if (option.getDescription() != null) {\n                buff.append(Char.SP);\n                buff.append(option.getDescription());\n            }\n\n            if (iter.hasNext()) {\n                buff.append(\", \");\n            }\n        }\n        buff.append(\"]\");\n        return buff.toString();\n    }\n}\n", "file_hash": "07cea5e63a72d186a25a9caa3a8a363a95f376147610a486dba4a2d48c361449", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.io.Serializable;", "import java.util.Collection;", "import java.util.Iterator;", "import java.util.LinkedHashMap;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "public class OptionGroup implements Serializable {\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** Hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<>();\n\n    /** The name of the selected option */\n    private String selected;\n\n    /** Specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Adds the given {@code Option} to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(final Option option) {\n        // key - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n        return this;\n    }\n\n    /**\n     * Gets the names of the options in this group as a {@code Collection}.\n     *\n     * @return the names of the options in this group as a {@code Collection}.\n     */\n    public Collection<String> getNames() {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * Gets the options in this group as a {@code Collection}.\n     *\n     * @return the options in this group as a {@code Collection}.\n     */\n    public Collection<Option> getOptions() {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Gets the selected option name.\n     *\n     * If the selected option is deprecated <em>no warning is logged</em>.\n     * @return the selected option name.\n     */\n    public String getSelected() {\n        return selected;\n    }\n\n    /**\n     * Tests whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired() {\n        return required;\n    }\n\n    /**\n     * Tests whether an option is selected.\n     *\n     *  If an option is selected and is deprecated <em>no warning is logged</em>.\n     * @return whether whether an option is selected.\n     * @since 1.9.0\n     */\n    public boolean isSelected() {\n        return selected != null;\n    }\n\n    /**\n     * Sets whether this group is required.\n     *\n     * @param required whether this group is required.\n     */\n    public void setRequired(final boolean required) {\n        this.required = required;\n    }\n\n    /**\n     * Sets the selected option of this group to {@code name}.\n     *\n     * If the selected option is deprecated <em>no warning is logged</em>.\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has already been selected.\n     */\n    public void setSelected(final Option option) throws AlreadySelectedException {\n        if (option == null) {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        // if no option has already been selected or the\n        // same option is being reselected then set the\n        // selected member variable\n        if (selected != null && !selected.equals(option.getKey())) {\n            throw new AlreadySelectedException(this, option);\n        }\n        selected = option.getKey();\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     *\n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buff = new StringBuilder();\n        final Iterator<Option> iter = getOptions().iterator();\n        buff.append(\"[\");\n        while (iter.hasNext()) {\n            final Option option = iter.next();\n            if (option.getOpt() != null) {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            } else {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n\n            if (option.getDescription() != null) {\n                buff.append(Char.SP);\n                buff.append(option.getDescription());\n            }\n\n            if (iter.hasNext()) {\n                buff.append(\", \");\n            }\n        }\n        buff.append(\"]\");\n        return buff.toString();\n    }\n}", "definition": "public class OptionGroup implements Serializable", "class_docstring": "\nA group of mutually exclusive options.\n", "name": "OptionGroup", "super_interfaces": ["Serializable"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": " The serial version UID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Option> optionMap = new LinkedHashMap<>();", "docstring": " Hold the options", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Option>", "name": "optionMap = new LinkedHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private String selected;", "docstring": " The name of the selected option", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "selected", "syntax_pass": true}, {"attribute_expression": "private boolean required;", "docstring": " Specified whether this group is required", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "required", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public OptionGroup addOption(final Option option) {\n        // key - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n        return this;\n    }", "docstring": "\nAdds the given {@code Option} to this group.\n\n@param option the option to add to this group\n@return this option group with the option added\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OptionGroup", "classes": []}, "name": "addOption", "params": [{"name": "option", "type": "Option"}], "body": "                                                      {\n        // key - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n        return this;\n    }", "signature": "public OptionGroup addOption(final Option option)"}, {"syntax_pass": true, "original_string": "    public Collection<String> getNames() {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }", "docstring": "\nGets the names of the options in this group as a {@code Collection}.\n\n@return the names of the options in this group as a {@code Collection}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<String>", "classes": []}, "name": "getNames", "params": [], "body": "                                         {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }", "signature": "public Collection<String> getNames()"}, {"syntax_pass": true, "original_string": "    public Collection<Option> getOptions() {\n        // the values are the collection of options\n        return optionMap.values();\n    }", "docstring": "\nGets the options in this group as a {@code Collection}.\n\n@return the options in this group as a {@code Collection}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<Option>", "classes": []}, "name": "getOptions", "params": [], "body": "                                           {\n        // the values are the collection of options\n        return optionMap.values();\n    }", "signature": "public Collection<Option> getOptions()"}, {"syntax_pass": true, "original_string": "    public String getSelected() {\n        return selected;\n    }", "docstring": "\nGets the selected option name.\n\nIf the selected option is deprecated <em>no warning is logged</em>.\n@return the selected option name.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getSelected", "params": [], "body": "                                {\n        return selected;\n    }", "signature": "public String getSelected()"}, {"syntax_pass": true, "original_string": "    public boolean isRequired() {\n        return required;\n    }", "docstring": "\nTests whether this option group is required.\n\n@return whether this option group is required\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRequired", "params": [], "body": "                                {\n        return required;\n    }", "signature": "public boolean isRequired()"}, {"syntax_pass": true, "original_string": "    public boolean isSelected() {\n        return selected != null;\n    }", "docstring": "\nTests whether an option is selected.\n\n If an option is selected and is deprecated <em>no warning is logged</em>.\n@return whether whether an option is selected.\n@since 1.9.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isSelected", "params": [], "body": "                                {\n        return selected != null;\n    }", "signature": "public boolean isSelected()"}, {"syntax_pass": true, "original_string": "    public void setRequired(final boolean required) {\n        this.required = required;\n    }", "docstring": "\nSets whether this group is required.\n\n@param required whether this group is required.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setRequired", "params": [{"name": "required", "type": "boolean"}], "body": "                                                    {\n        this.required = required;\n    }", "signature": "public void setRequired(final boolean required)"}, {"syntax_pass": true, "original_string": "    public void setSelected(final Option option) throws AlreadySelectedException {\n        if (option == null) {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        // if no option has already been selected or the\n        // same option is being reselected then set the\n        // selected member variable\n        if (selected != null && !selected.equals(option.getKey())) {\n            throw new AlreadySelectedException(this, option);\n        }\n        selected = option.getKey();\n    }", "docstring": "\nSets the selected option of this group to {@code name}.\n\nIf the selected option is deprecated <em>no warning is logged</em>.\n@param option the option that is selected\n@throws AlreadySelectedException if an option from this group has already been selected.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setSelected", "params": [{"name": "option", "type": "Option"}], "body": "                                                                                 {\n        if (option == null) {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        // if no option has already been selected or the\n        // same option is being reselected then set the\n        // selected member variable\n        if (selected != null && !selected.equals(option.getKey())) {\n            throw new AlreadySelectedException(this, option);\n        }\n        selected = option.getKey();\n    }", "signature": "public void setSelected(final Option option)"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        final StringBuilder buff = new StringBuilder();\n        final Iterator<Option> iter = getOptions().iterator();\n        buff.append(\"[\");\n        while (iter.hasNext()) {\n            final Option option = iter.next();\n            if (option.getOpt() != null) {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            } else {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n\n            if (option.getDescription() != null) {\n                buff.append(Char.SP);\n                buff.append(option.getDescription());\n            }\n\n            if (iter.hasNext()) {\n                buff.append(\", \");\n            }\n        }\n        buff.append(\"]\");\n        return buff.toString();\n    }", "docstring": "\nReturns the stringified version of this OptionGroup.\n\n@return the stringified representation of this group\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        final StringBuilder buff = new StringBuilder();\n        final Iterator<Option> iter = getOptions().iterator();\n        buff.append(\"[\");\n        while (iter.hasNext()) {\n            final Option option = iter.next();\n            if (option.getOpt() != null) {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            } else {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n\n            if (option.getDescription() != null) {\n                buff.append(Char.SP);\n                buff.append(option.getDescription());\n            }\n\n            if (iter.hasNext()) {\n                buff.append(\", \");\n            }\n        }\n        buff.append(\"]\");\n        return buff.toString();\n    }", "signature": "@Override\n    public String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/AlreadySelectedException.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Thrown when more than one option in an option group has been provided.\n */\npublic class AlreadySelectedException extends ParseException {\n\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 3674381532418544760L;\n\n    /** The option group selected. */\n    private final OptionGroup group;\n\n    /** The option that triggered the exception. */\n    private final Option option;\n\n    /**\n     * Constructs a new {@code AlreadySelectedException} for the specified option group.\n     *\n     * @param group the option group already selected\n     * @param option the option that triggered the exception\n     * @since 1.2\n     */\n    public AlreadySelectedException(final OptionGroup group, final Option option) {\n        this(String.format(\"The option '%s' was specified but an option from this group has already been selected: '%s'\", option.getKey(), group.getSelected()),\n                group, option);\n    }\n\n    /**\n     * Constructs a new {@code AlreadySelectedException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public AlreadySelectedException(final String message) {\n        this(message, null, null);\n    }\n\n    private AlreadySelectedException(final String message, final OptionGroup group, final Option option) {\n        super(message);\n        this.group = group;\n        this.option = option;\n    }\n\n    /**\n     * Gets the option that was added to the group and triggered the exception.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public Option getOption() {\n        return option;\n    }\n\n    /**\n     * Gets the option group where another option has been selected.\n     *\n     * @return the related option group\n     * @since 1.2\n     */\n    public OptionGroup getOptionGroup() {\n        return group;\n    }\n}\n", "file_hash": "4d67078e559c3b46808545612036ddaa50f67e736c00e9c3010ee8c75aaff3b5", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;"], "methods": [], "classes": [{"original_string": "public class AlreadySelectedException extends ParseException {\n\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 3674381532418544760L;\n\n    /** The option group selected. */\n    private final OptionGroup group;\n\n    /** The option that triggered the exception. */\n    private final Option option;\n\n    /**\n     * Constructs a new {@code AlreadySelectedException} for the specified option group.\n     *\n     * @param group the option group already selected\n     * @param option the option that triggered the exception\n     * @since 1.2\n     */\n    public AlreadySelectedException(final OptionGroup group, final Option option) {\n        this(String.format(\"The option '%s' was specified but an option from this group has already been selected: '%s'\", option.getKey(), group.getSelected()),\n                group, option);\n    }\n\n    /**\n     * Constructs a new {@code AlreadySelectedException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public AlreadySelectedException(final String message) {\n        this(message, null, null);\n    }\n\n    private AlreadySelectedException(final String message, final OptionGroup group, final Option option) {\n        super(message);\n        this.group = group;\n        this.option = option;\n    }\n\n    /**\n     * Gets the option that was added to the group and triggered the exception.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public Option getOption() {\n        return option;\n    }\n\n    /**\n     * Gets the option group where another option has been selected.\n     *\n     * @return the related option group\n     * @since 1.2\n     */\n    public OptionGroup getOptionGroup() {\n        return group;\n    }\n}", "definition": "public class AlreadySelectedException extends ParseException", "class_docstring": "\nThrown when more than one option in an option group has been provided.\n", "name": "AlreadySelectedException", "super_interfaces": [], "superclasses": "ParseException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 3674381532418544760L;", "docstring": "\nThis exception {@code serialVersionUID}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3674381532418544760L", "syntax_pass": true}, {"attribute_expression": "private final OptionGroup group;", "docstring": " The option group selected.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OptionGroup", "name": "group", "syntax_pass": true}, {"attribute_expression": "private final Option option;", "docstring": " The option that triggered the exception.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Option", "name": "option", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public AlreadySelectedException(final OptionGroup group, final Option option) {\n        this(String.format(\"The option '%s' was specified but an option from this group has already been selected: '%s'\", option.getKey(), group.getSelected()),\n                group, option);\n    }", "docstring": "\nConstructs a new {@code AlreadySelectedException} for the specified option group.\n\n@param group the option group already selected\n@param option the option that triggered the exception\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AlreadySelectedException", "params": [{"name": "group", "type": "OptionGroup"}, {"name": "option", "type": "Option"}], "body": "                                                                                  {\n        this(String.format(\"The option '%s' was specified but an option from this group has already been selected: '%s'\", option.getKey(), group.getSelected()),\n                group, option);\n    }", "signature": "public AlreadySelectedException(final OptionGroup group, final Option option)"}, {"syntax_pass": true, "original_string": "    public AlreadySelectedException(final String message) {\n        this(message, null, null);\n    }", "docstring": "\nConstructs a new {@code AlreadySelectedException} with the specified detail message.\n\n@param message the detail message\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AlreadySelectedException", "params": [{"name": "message", "type": "String"}], "body": "                                                          {\n        this(message, null, null);\n    }", "signature": "public AlreadySelectedException(final String message)"}, {"syntax_pass": true, "original_string": "    private AlreadySelectedException(final String message, final OptionGroup group, final Option option) {\n        super(message);\n        this.group = group;\n        this.option = option;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "AlreadySelectedException", "params": [{"name": "message", "type": "String"}, {"name": "group", "type": "OptionGroup"}, {"name": "option", "type": "Option"}], "body": "                                                                                                         {\n        super(message);\n        this.group = group;\n        this.option = option;\n    }", "signature": "private AlreadySelectedException(final String message, final OptionGroup group, final Option option)"}, {"syntax_pass": true, "original_string": "    public Option getOption() {\n        return option;\n    }", "docstring": "\nGets the option that was added to the group and triggered the exception.\n\n@return the related option\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Option", "classes": []}, "name": "getOption", "params": [], "body": "                              {\n        return option;\n    }", "signature": "public Option getOption()"}, {"syntax_pass": true, "original_string": "    public OptionGroup getOptionGroup() {\n        return group;\n    }", "docstring": "\nGets the option group where another option has been selected.\n\n@return the related option group\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OptionGroup", "classes": []}, "name": "getOptionGroup", "params": [], "body": "                                        {\n        return group;\n    }", "signature": "public OptionGroup getOptionGroup()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/DefaultParser.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.function.Consumer;\n\n/**\n * Default parser.\n *\n * @since 1.3\n */\npublic class DefaultParser implements CommandLineParser {\n\n    /**\n     * A nested builder class to create {@code DefaultParser} instances\n     * using descriptive methods.\n     *\n     * Example usage:\n     * <pre>\n     * DefaultParser parser = Option.builder()\n     *     .setAllowPartialMatching(false)\n     *     .setStripLeadingAndTrailingQuotes(false)\n     *     .build();\n     * </pre>\n     *\n     * @since 1.5.0\n     */\n    public static final class Builder {\n\n        /** Flag indicating if partial matching of long options is supported. */\n        private boolean allowPartialMatching = true;\n\n        /**\n         * The deprecated option handler.\n         * <p>\n         * If you want to serialize this field, use a serialization proxy.\n         * </p>\n         */\n        private Consumer<Option> deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n\n        /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments. */\n        private Boolean stripLeadingAndTrailingQuotes;\n\n        /**\n         * Constructs a new {@code Builder} for a {@code DefaultParser} instance.\n         *\n         * Both allowPartialMatching and stripLeadingAndTrailingQuotes are true by default,\n         * mimicking the argument-less constructor.\n         */\n        private Builder() {\n        }\n\n        /**\n         * Builds an DefaultParser with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link DefaultParser}\n         * @since 1.5.0\n         */\n        public DefaultParser build() {\n            return new DefaultParser(allowPartialMatching, stripLeadingAndTrailingQuotes, deprecatedHandler);\n        }\n\n        /**\n         * Sets if partial matching of long options is supported.\n         *\n         * By \"partial matching\" we mean that given the following code:\n         *\n         * <pre>\n         * {\n         *     &#64;code\n         *     final Options options = new Options();\n         *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n         *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n         *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n         * }\n         * </pre>\n         *\n         * If \"partial matching\" is turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n         * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n         *\n         * @param allowPartialMatching whether to allow partial matching of long options\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setAllowPartialMatching(final boolean allowPartialMatching) {\n            this.allowPartialMatching = allowPartialMatching;\n            return this;\n        }\n\n        /**\n         * Sets the deprecated option handler.\n         *\n         * @param deprecatedHandler the deprecated option handler.\n         * @return {@code this} instance.\n         * @since 1.7.0\n         */\n        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }\n\n        /**\n         * Sets if balanced leading and trailing double quotes should be stripped from option arguments.\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is true,\n         * the outermost balanced double quotes of option arguments values will be removed.\n         * For example, {@code -o '\"x\"'} getValue() will return {@code x}, instead of {@code \"x\"}\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is null,\n         * then quotes will be stripped from option values separated by space from the option, but\n         * kept in other cases, which is the historic behavior.\n         *\n         * @param stripLeadingAndTrailingQuotes whether balanced leading and trailing double quotes should be stripped from option arguments.\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setStripLeadingAndTrailingQuotes(final Boolean stripLeadingAndTrailingQuotes) {\n            this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n            return this;\n        }\n    }\n\n    /**\n     * Creates a new {@link Builder} to create an {@link DefaultParser} using descriptive\n     * methods.\n     *\n     * @return a new {@link Builder} instance\n     * @since 1.5.0\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    static int indexOfEqual(final String token) {\n        return token.indexOf(Char.EQUAL);\n    }\n\n    /** The command-line instance. */\n    protected CommandLine cmd;\n\n    /** The current options. */\n    protected Options options;\n\n    /**\n     * Flag indicating how unrecognized tokens are handled. {@code true} to stop the parsing and add the remaining\n     * tokens to the args list. {@code false} to throw an exception.\n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n\n    /** The last option parsed. */\n    protected Option currentOption;\n\n    /** Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n\n    /** The required options and groups expected to be found when parsing the command line. */\n    protected List expectedOpts;\n\n    /** Flag indicating if partial matching of long options is supported. */\n    private final boolean allowPartialMatching;\n\n    /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments.\n     * null represents the historic arbitrary behavior */\n    private final Boolean stripLeadingAndTrailingQuotes;\n\n    /**\n     * The deprecated option handler.\n     * <p>\n     * If you want to serialize this field, use a serialization proxy.\n     * </p>\n     */\n    private final Consumer<Option> deprecatedHandler;\n\n    /**\n     * Creates a new DefaultParser instance with partial matching enabled.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     *\n     * <pre>\n     * {\n     *     &#64;code\n     *     final Options options = new Options();\n     *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     * }\n     * </pre>\n     *\n     * with \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n     * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n     * options.\n     */\n    public DefaultParser() {\n        this.allowPartialMatching = true;\n        this.stripLeadingAndTrailingQuotes = null;\n        this.deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n    }\n\n    /**\n     * Create a new DefaultParser instance with the specified partial matching policy.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     *\n     * <pre>\n     * {\n     *     &#64;code\n     *     final Options options = new Options();\n     *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     * }\n     * </pre>\n     *\n     * with \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n     * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n     * options.\n     *\n     * @param allowPartialMatching if partial matching of long options shall be enabled\n     */\n    public DefaultParser(final boolean allowPartialMatching) {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = null;\n        this.deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n    }\n\n    /**\n     * Creates a new DefaultParser instance with the specified partial matching and quote\n     * stripping policy.\n     *\n     * @param allowPartialMatching if partial matching of long options shall be enabled\n     * @param stripLeadingAndTrailingQuotes if balanced outer double quoutes should be stripped\n     */\n    private DefaultParser(final boolean allowPartialMatching, final Boolean stripLeadingAndTrailingQuotes, final Consumer<Option> deprecatedHandler) {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n        this.deprecatedHandler = deprecatedHandler;\n    }\n\n    /**\n     * Throws a {@link MissingArgumentException} if the current option didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg()) {\n            if (isJavaProperty(currentOption.getKey()) && currentOption.getValuesList().size() == 1) {\n                return;\n            }\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty()) {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Searches for a prefix that is the long name of an option (-Xmx512m)\n     *\n     * @param token\n     */\n    private String getLongPrefix(final String token) {\n        final String t = Util.stripLeadingHyphens(token);\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--) {\n            final String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix)) {\n                opt = prefix;\n                break;\n            }\n        }\n        return opt;\n    }\n\n    /**\n     * Gets a list of matching option strings for the given token, depending on the selected partial matching policy.\n     *\n     * @param token the token (may contain leading dashes)\n     * @return the list of matching option strings or an empty list if no matching option could be found\n     */\n    private List<String> getMatchingLongOptions(final String token) {\n        if (allowPartialMatching) {\n            return options.getMatchingOptions(token);\n        }\n        final List<String> matches = new ArrayList<>(1);\n        if (options.hasLongOption(token)) {\n            matches.add(options.getOption(token).getLongOpt());\n        }\n        return matches;\n    }\n\n    /**\n     * Breaks {@code token} into its constituent parts using the following algorithm.\n     *\n     * <ul>\n     * <li>ignore the first character (\"<b>-</b>\")</li>\n     * <li>for each remaining character check if an {@link Option} exists with that id.</li>\n     * <li>if an {@link Option} does exist then add that character prepended with \"<b>-</b>\" to the list of processed\n     * tokens.</li>\n     * <li>if the {@link Option} can have an argument value and there are remaining characters in the token then add the\n     * remaining characters as a token to the list of processed tokens.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS</b> set then add the\n     * special token \"<b>--</b>\" followed by the remaining characters and also the remaining tokens directly to the\n     * processed tokens list.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS NOT</b> set then add\n     * that character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b> at the first non-Option encountered.\n     * @throws ParseException if there are any problems encountered while parsing the command line token.\n     */\n    protected void handleConcatenatedOptions(final String token) throws ParseException {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n            if (!options.hasOption(ch)) {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n            handleOption(options.getOption(ch));\n            if (currentOption != null && token.length() != i + 1) {\n                // add the trail as an argument of the option\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(i + 1)));\n                break;\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L --L=V --L V --l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOption(final String token) throws ParseException {\n        if (indexOfEqual(token) == -1) {\n            handleLongOptionWithoutEqual(token);\n        } else {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L=V -L=V --l=V -l=V\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(final String token) throws ParseException {\n        final int pos = indexOfEqual(token);\n        final String value = token.substring(pos + 1);\n        final String opt = token.substring(0, pos);\n        final List<String> matchingOpts = getMatchingLongOptions(opt);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(opt)) {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(opt) ? opt : matchingOpts.get(0);\n            final Option option = options.getOption(key);\n            if (option.acceptsArg()) {\n                handleOption(option);\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\n                currentOption = null;\n            } else {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L -L --l -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(final String token) throws ParseException {\n        final List<String> matchingOpts = getMatchingLongOptions(token);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(token)) {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(token) ? token : matchingOpts.get(0);\n            handleOption(options.getOption(key));\n        }\n    }\n\n    private void handleOption(final Option option) throws ParseException {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n        final Option copy = (Option) option.clone();\n        updateRequiredOptions(copy);\n        cmd.addOption(copy);\n        currentOption = copy.hasArg() ? copy : null;\n    }\n\n    /**\n     * Sets the values of Options using the values in {@code properties}.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.isSelected();\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties\n                final String value = properties.getProperty(option);\n\n                if (opt.hasArg()) {\n                    if (Util.isEmpty(opt.getValues())) {\n                        opt.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * -S -SV -S V -S=V -S1S2 -S1S2 V -SV1=V2\n     *\n     * -L -LV -L V -L=V -l\n     *\n     * @param hyphenToken the command line token to handle\n     */\n    private void handleShortAndLongOption(final String hyphenToken) throws ParseException {\n        final String token = Util.stripLeadingHyphens(hyphenToken);\n        final int pos = indexOfEqual(token);\n        if (token.length() == 1) {\n            // -S\n            if (options.hasShortOption(token)) {\n                handleOption(options.getOption(token));\n            } else {\n                handleUnknownToken(hyphenToken);\n            }\n        } else if (pos == -1) {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(token)) {\n                handleOption(options.getOption(token));\n            } else if (!getMatchingLongOptions(token).isEmpty()) {\n                // -L or -l\n                handleLongOptionWithoutEqual(hyphenToken);\n            } else {\n                // look for a long prefix (-Xmx512m)\n                final String opt = getLongPrefix(token);\n\n                if (opt != null && options.getOption(opt).acceptsArg()) {\n                    handleOption(options.getOption(opt));\n                    currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(opt.length())));\n                    currentOption = null;\n                } else if (isJavaProperty(token)) {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(token.substring(0, 1)));\n                    currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(1)));\n                    currentOption = null;\n                } else {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(hyphenToken);\n                }\n            }\n        } else {\n            // equal sign found (-xxx=yyy)\n            final String opt = token.substring(0, pos);\n            final String value = token.substring(pos + 1);\n\n            if (opt.length() == 1) {\n                // -S=V\n                final Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg()) {\n                    handleOption(option);\n                    currentOption.processValue(value);\n                    currentOption = null;\n                } else {\n                    handleUnknownToken(hyphenToken);\n                }\n            } else if (isJavaProperty(opt)) {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.processValue(opt.substring(1));\n                currentOption.processValue(value);\n                currentOption = null;\n            } else {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(hyphenToken);\n            }\n        }\n    }\n\n    /**\n     * Handles any command line token.\n     *\n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(final String token) throws ParseException {\n        if (token != null) {\n            currentToken = token;\n            if (skipParsing) {\n                cmd.addArg(token);\n            } else if (\"--\".equals(token)) {\n                skipParsing = true;\n            } else if (currentOption != null && currentOption.acceptsArg() && isArgument(token)) {\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOn(token));\n            } else if (token.startsWith(\"--\")) {\n                handleLongOption(token);\n            } else if (token.startsWith(\"-\") && !\"-\".equals(token)) {\n                handleShortAndLongOption(token);\n            } else {\n                handleUnknownToken(token);\n            }\n            if (currentOption != null && !currentOption.acceptsArg()) {\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an UnrecognizedOptionException is thrown. Otherwise the\n     * token is added to the arguments of the command line. If the stopAtNonOption flag is set, this stops the parsing and\n     * the remaining tokens are added as-is in the arguments of the command line.\n     *\n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(final String token) throws ParseException {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n        cmd.addArg(token);\n        if (stopAtNonOption) {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Tests if the token is a valid argument.\n     *\n     * @param token\n     */\n    private boolean isArgument(final String token) {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Tests if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(final String token) {\n        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n        final Option option = options.getOption(opt);\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    /**\n     * Tests if the token looks like a long option.\n     *\n     * @param token\n     */\n    private boolean isLongOption(final String token) {\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n        final int pos = indexOfEqual(token);\n        final String t = pos == -1 ? token : token.substring(0, pos);\n        if (!getMatchingLongOptions(t).isEmpty()) {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        if (getLongPrefix(token) != null && !token.startsWith(\"--\")) {\n            // -LV\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Tests if the token is a negative number.\n     *\n     * @param token\n     */\n    private boolean isNegativeNumber(final String token) {\n        try {\n            Double.parseDouble(token);\n            return true;\n        } catch (final NumberFormatException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests if the token looks like an option.\n     *\n     * @param token\n     */\n    private boolean isOption(final String token) {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tests if the token looks like a short option.\n     *\n     * @param token\n     */\n    private boolean isShortOption(final String token) {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n        // remove leading \"-\" and \"=value\"\n        final int pos = indexOfEqual(token);\n        final String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName)) {\n            return true;\n        }\n        // check for several concatenated short options\n        return !optName.isEmpty() && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null);\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)\n        throws ParseException {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList<>(options.getRequiredOptions());\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        cmd = CommandLine.builder().setDeprecatedHandler(deprecatedHandler).build();\n        if (arguments != null) {\n            for (final String argument : arguments) {\n                handleToken(argument);\n            }\n        }\n        // check the arguments of the last option\n        checkRequiredArgs();\n        // add the default options\n        handleProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }\n\n    /**\n     * Strips balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\n     * If stripLeadingAndTrailingQuotes is null, then do not strip\n     *\n     * @param token a string\n     * @return token with the quotes stripped (if set)\n     */\n    private String stripLeadingAndTrailingQuotesDefaultOff(final String token) {\n        if (stripLeadingAndTrailingQuotes != null && stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }\n\n    /**\n     * Strips balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\n     * If stripLeadingAndTrailingQuotes is null, then do not strip\n     *\n     * @param token a string\n     * @return token with the quotes stripped (if set)\n     */\n    private String stripLeadingAndTrailingQuotesDefaultOn(final String token) {\n        if (stripLeadingAndTrailingQuotes == null || stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param option\n     */\n    private void updateRequiredOptions(final Option option) throws AlreadySelectedException {\n        if (option.isRequired()) {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null) {\n            final OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired()) {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n}\n", "file_hash": "481a436fccabef8157852d8542db46ca0e04c31a74006f52903adf15609b81d3", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.util.ArrayList;", "import java.util.Enumeration;", "import java.util.List;", "import java.util.Properties;", "import java.util.function.Consumer;"], "methods": [], "classes": [{"original_string": "public class DefaultParser implements CommandLineParser {\n\n    /**\n     * A nested builder class to create {@code DefaultParser} instances\n     * using descriptive methods.\n     *\n     * Example usage:\n     * <pre>\n     * DefaultParser parser = Option.builder()\n     *     .setAllowPartialMatching(false)\n     *     .setStripLeadingAndTrailingQuotes(false)\n     *     .build();\n     * </pre>\n     *\n     * @since 1.5.0\n     */\n    public static final class Builder {\n\n        /** Flag indicating if partial matching of long options is supported. */\n        private boolean allowPartialMatching = true;\n\n        /**\n         * The deprecated option handler.\n         * <p>\n         * If you want to serialize this field, use a serialization proxy.\n         * </p>\n         */\n        private Consumer<Option> deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n\n        /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments. */\n        private Boolean stripLeadingAndTrailingQuotes;\n\n        /**\n         * Constructs a new {@code Builder} for a {@code DefaultParser} instance.\n         *\n         * Both allowPartialMatching and stripLeadingAndTrailingQuotes are true by default,\n         * mimicking the argument-less constructor.\n         */\n        private Builder() {\n        }\n\n        /**\n         * Builds an DefaultParser with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link DefaultParser}\n         * @since 1.5.0\n         */\n        public DefaultParser build() {\n            return new DefaultParser(allowPartialMatching, stripLeadingAndTrailingQuotes, deprecatedHandler);\n        }\n\n        /**\n         * Sets if partial matching of long options is supported.\n         *\n         * By \"partial matching\" we mean that given the following code:\n         *\n         * <pre>\n         * {\n         *     &#64;code\n         *     final Options options = new Options();\n         *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n         *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n         *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n         * }\n         * </pre>\n         *\n         * If \"partial matching\" is turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n         * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n         *\n         * @param allowPartialMatching whether to allow partial matching of long options\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setAllowPartialMatching(final boolean allowPartialMatching) {\n            this.allowPartialMatching = allowPartialMatching;\n            return this;\n        }\n\n        /**\n         * Sets the deprecated option handler.\n         *\n         * @param deprecatedHandler the deprecated option handler.\n         * @return {@code this} instance.\n         * @since 1.7.0\n         */\n        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }\n\n        /**\n         * Sets if balanced leading and trailing double quotes should be stripped from option arguments.\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is true,\n         * the outermost balanced double quotes of option arguments values will be removed.\n         * For example, {@code -o '\"x\"'} getValue() will return {@code x}, instead of {@code \"x\"}\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is null,\n         * then quotes will be stripped from option values separated by space from the option, but\n         * kept in other cases, which is the historic behavior.\n         *\n         * @param stripLeadingAndTrailingQuotes whether balanced leading and trailing double quotes should be stripped from option arguments.\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setStripLeadingAndTrailingQuotes(final Boolean stripLeadingAndTrailingQuotes) {\n            this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n            return this;\n        }\n    }\n\n    /**\n     * Creates a new {@link Builder} to create an {@link DefaultParser} using descriptive\n     * methods.\n     *\n     * @return a new {@link Builder} instance\n     * @since 1.5.0\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    static int indexOfEqual(final String token) {\n        return token.indexOf(Char.EQUAL);\n    }\n\n    /** The command-line instance. */\n    protected CommandLine cmd;\n\n    /** The current options. */\n    protected Options options;\n\n    /**\n     * Flag indicating how unrecognized tokens are handled. {@code true} to stop the parsing and add the remaining\n     * tokens to the args list. {@code false} to throw an exception.\n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n\n    /** The last option parsed. */\n    protected Option currentOption;\n\n    /** Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n\n    /** The required options and groups expected to be found when parsing the command line. */\n    protected List expectedOpts;\n\n    /** Flag indicating if partial matching of long options is supported. */\n    private final boolean allowPartialMatching;\n\n    /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments.\n     * null represents the historic arbitrary behavior */\n    private final Boolean stripLeadingAndTrailingQuotes;\n\n    /**\n     * The deprecated option handler.\n     * <p>\n     * If you want to serialize this field, use a serialization proxy.\n     * </p>\n     */\n    private final Consumer<Option> deprecatedHandler;\n\n    /**\n     * Creates a new DefaultParser instance with partial matching enabled.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     *\n     * <pre>\n     * {\n     *     &#64;code\n     *     final Options options = new Options();\n     *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     * }\n     * </pre>\n     *\n     * with \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n     * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n     * options.\n     */\n    public DefaultParser() {\n        this.allowPartialMatching = true;\n        this.stripLeadingAndTrailingQuotes = null;\n        this.deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n    }\n\n    /**\n     * Create a new DefaultParser instance with the specified partial matching policy.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     *\n     * <pre>\n     * {\n     *     &#64;code\n     *     final Options options = new Options();\n     *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     * }\n     * </pre>\n     *\n     * with \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n     * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n     * options.\n     *\n     * @param allowPartialMatching if partial matching of long options shall be enabled\n     */\n    public DefaultParser(final boolean allowPartialMatching) {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = null;\n        this.deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n    }\n\n    /**\n     * Creates a new DefaultParser instance with the specified partial matching and quote\n     * stripping policy.\n     *\n     * @param allowPartialMatching if partial matching of long options shall be enabled\n     * @param stripLeadingAndTrailingQuotes if balanced outer double quoutes should be stripped\n     */\n    private DefaultParser(final boolean allowPartialMatching, final Boolean stripLeadingAndTrailingQuotes, final Consumer<Option> deprecatedHandler) {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n        this.deprecatedHandler = deprecatedHandler;\n    }\n\n    /**\n     * Throws a {@link MissingArgumentException} if the current option didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg()) {\n            if (isJavaProperty(currentOption.getKey()) && currentOption.getValuesList().size() == 1) {\n                return;\n            }\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty()) {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Searches for a prefix that is the long name of an option (-Xmx512m)\n     *\n     * @param token\n     */\n    private String getLongPrefix(final String token) {\n        final String t = Util.stripLeadingHyphens(token);\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--) {\n            final String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix)) {\n                opt = prefix;\n                break;\n            }\n        }\n        return opt;\n    }\n\n    /**\n     * Gets a list of matching option strings for the given token, depending on the selected partial matching policy.\n     *\n     * @param token the token (may contain leading dashes)\n     * @return the list of matching option strings or an empty list if no matching option could be found\n     */\n    private List<String> getMatchingLongOptions(final String token) {\n        if (allowPartialMatching) {\n            return options.getMatchingOptions(token);\n        }\n        final List<String> matches = new ArrayList<>(1);\n        if (options.hasLongOption(token)) {\n            matches.add(options.getOption(token).getLongOpt());\n        }\n        return matches;\n    }\n\n    /**\n     * Breaks {@code token} into its constituent parts using the following algorithm.\n     *\n     * <ul>\n     * <li>ignore the first character (\"<b>-</b>\")</li>\n     * <li>for each remaining character check if an {@link Option} exists with that id.</li>\n     * <li>if an {@link Option} does exist then add that character prepended with \"<b>-</b>\" to the list of processed\n     * tokens.</li>\n     * <li>if the {@link Option} can have an argument value and there are remaining characters in the token then add the\n     * remaining characters as a token to the list of processed tokens.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS</b> set then add the\n     * special token \"<b>--</b>\" followed by the remaining characters and also the remaining tokens directly to the\n     * processed tokens list.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS NOT</b> set then add\n     * that character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b> at the first non-Option encountered.\n     * @throws ParseException if there are any problems encountered while parsing the command line token.\n     */\n    protected void handleConcatenatedOptions(final String token) throws ParseException {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n            if (!options.hasOption(ch)) {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n            handleOption(options.getOption(ch));\n            if (currentOption != null && token.length() != i + 1) {\n                // add the trail as an argument of the option\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(i + 1)));\n                break;\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L --L=V --L V --l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOption(final String token) throws ParseException {\n        if (indexOfEqual(token) == -1) {\n            handleLongOptionWithoutEqual(token);\n        } else {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L=V -L=V --l=V -l=V\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(final String token) throws ParseException {\n        final int pos = indexOfEqual(token);\n        final String value = token.substring(pos + 1);\n        final String opt = token.substring(0, pos);\n        final List<String> matchingOpts = getMatchingLongOptions(opt);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(opt)) {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(opt) ? opt : matchingOpts.get(0);\n            final Option option = options.getOption(key);\n            if (option.acceptsArg()) {\n                handleOption(option);\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\n                currentOption = null;\n            } else {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L -L --l -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(final String token) throws ParseException {\n        final List<String> matchingOpts = getMatchingLongOptions(token);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(token)) {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(token) ? token : matchingOpts.get(0);\n            handleOption(options.getOption(key));\n        }\n    }\n\n    private void handleOption(final Option option) throws ParseException {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n        final Option copy = (Option) option.clone();\n        updateRequiredOptions(copy);\n        cmd.addOption(copy);\n        currentOption = copy.hasArg() ? copy : null;\n    }\n\n    /**\n     * Sets the values of Options using the values in {@code properties}.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.isSelected();\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties\n                final String value = properties.getProperty(option);\n\n                if (opt.hasArg()) {\n                    if (Util.isEmpty(opt.getValues())) {\n                        opt.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * -S -SV -S V -S=V -S1S2 -S1S2 V -SV1=V2\n     *\n     * -L -LV -L V -L=V -l\n     *\n     * @param hyphenToken the command line token to handle\n     */\n    private void handleShortAndLongOption(final String hyphenToken) throws ParseException {\n        final String token = Util.stripLeadingHyphens(hyphenToken);\n        final int pos = indexOfEqual(token);\n        if (token.length() == 1) {\n            // -S\n            if (options.hasShortOption(token)) {\n                handleOption(options.getOption(token));\n            } else {\n                handleUnknownToken(hyphenToken);\n            }\n        } else if (pos == -1) {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(token)) {\n                handleOption(options.getOption(token));\n            } else if (!getMatchingLongOptions(token).isEmpty()) {\n                // -L or -l\n                handleLongOptionWithoutEqual(hyphenToken);\n            } else {\n                // look for a long prefix (-Xmx512m)\n                final String opt = getLongPrefix(token);\n\n                if (opt != null && options.getOption(opt).acceptsArg()) {\n                    handleOption(options.getOption(opt));\n                    currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(opt.length())));\n                    currentOption = null;\n                } else if (isJavaProperty(token)) {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(token.substring(0, 1)));\n                    currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(1)));\n                    currentOption = null;\n                } else {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(hyphenToken);\n                }\n            }\n        } else {\n            // equal sign found (-xxx=yyy)\n            final String opt = token.substring(0, pos);\n            final String value = token.substring(pos + 1);\n\n            if (opt.length() == 1) {\n                // -S=V\n                final Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg()) {\n                    handleOption(option);\n                    currentOption.processValue(value);\n                    currentOption = null;\n                } else {\n                    handleUnknownToken(hyphenToken);\n                }\n            } else if (isJavaProperty(opt)) {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.processValue(opt.substring(1));\n                currentOption.processValue(value);\n                currentOption = null;\n            } else {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(hyphenToken);\n            }\n        }\n    }\n\n    /**\n     * Handles any command line token.\n     *\n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(final String token) throws ParseException {\n        if (token != null) {\n            currentToken = token;\n            if (skipParsing) {\n                cmd.addArg(token);\n            } else if (\"--\".equals(token)) {\n                skipParsing = true;\n            } else if (currentOption != null && currentOption.acceptsArg() && isArgument(token)) {\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOn(token));\n            } else if (token.startsWith(\"--\")) {\n                handleLongOption(token);\n            } else if (token.startsWith(\"-\") && !\"-\".equals(token)) {\n                handleShortAndLongOption(token);\n            } else {\n                handleUnknownToken(token);\n            }\n            if (currentOption != null && !currentOption.acceptsArg()) {\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an UnrecognizedOptionException is thrown. Otherwise the\n     * token is added to the arguments of the command line. If the stopAtNonOption flag is set, this stops the parsing and\n     * the remaining tokens are added as-is in the arguments of the command line.\n     *\n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(final String token) throws ParseException {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n        cmd.addArg(token);\n        if (stopAtNonOption) {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Tests if the token is a valid argument.\n     *\n     * @param token\n     */\n    private boolean isArgument(final String token) {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Tests if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(final String token) {\n        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n        final Option option = options.getOption(opt);\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    /**\n     * Tests if the token looks like a long option.\n     *\n     * @param token\n     */\n    private boolean isLongOption(final String token) {\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n        final int pos = indexOfEqual(token);\n        final String t = pos == -1 ? token : token.substring(0, pos);\n        if (!getMatchingLongOptions(t).isEmpty()) {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        if (getLongPrefix(token) != null && !token.startsWith(\"--\")) {\n            // -LV\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Tests if the token is a negative number.\n     *\n     * @param token\n     */\n    private boolean isNegativeNumber(final String token) {\n        try {\n            Double.parseDouble(token);\n            return true;\n        } catch (final NumberFormatException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests if the token looks like an option.\n     *\n     * @param token\n     */\n    private boolean isOption(final String token) {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tests if the token looks like a short option.\n     *\n     * @param token\n     */\n    private boolean isShortOption(final String token) {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n        // remove leading \"-\" and \"=value\"\n        final int pos = indexOfEqual(token);\n        final String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName)) {\n            return true;\n        }\n        // check for several concatenated short options\n        return !optName.isEmpty() && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null);\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)\n        throws ParseException {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList<>(options.getRequiredOptions());\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        cmd = CommandLine.builder().setDeprecatedHandler(deprecatedHandler).build();\n        if (arguments != null) {\n            for (final String argument : arguments) {\n                handleToken(argument);\n            }\n        }\n        // check the arguments of the last option\n        checkRequiredArgs();\n        // add the default options\n        handleProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }\n\n    /**\n     * Strips balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\n     * If stripLeadingAndTrailingQuotes is null, then do not strip\n     *\n     * @param token a string\n     * @return token with the quotes stripped (if set)\n     */\n    private String stripLeadingAndTrailingQuotesDefaultOff(final String token) {\n        if (stripLeadingAndTrailingQuotes != null && stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }\n\n    /**\n     * Strips balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\n     * If stripLeadingAndTrailingQuotes is null, then do not strip\n     *\n     * @param token a string\n     * @return token with the quotes stripped (if set)\n     */\n    private String stripLeadingAndTrailingQuotesDefaultOn(final String token) {\n        if (stripLeadingAndTrailingQuotes == null || stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param option\n     */\n    private void updateRequiredOptions(final Option option) throws AlreadySelectedException {\n        if (option.isRequired()) {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null) {\n            final OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired()) {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n}", "definition": "public class DefaultParser implements CommandLineParser", "class_docstring": "\nDefault parser.\n\n@since 1.3\n", "name": "DefaultParser", "super_interfaces": ["CommandLineParser"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "protected CommandLine cmd;", "docstring": " The command-line instance.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "CommandLine", "name": "cmd", "syntax_pass": true}, {"attribute_expression": "protected Options options;", "docstring": " The current options.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}, {"attribute_expression": "protected boolean stopAtNonOption;", "docstring": "\nFlag indicating how unrecognized tokens are handled. {@code true} to stop the parsing and add the remaining\ntokens to the args list. {@code false} to throw an exception.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "stopAtNonOption", "syntax_pass": true}, {"attribute_expression": "protected String currentToken;", "docstring": " The token currently processed.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "currentToken", "syntax_pass": true}, {"attribute_expression": "protected Option currentOption;", "docstring": " The last option parsed.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Option", "name": "currentOption", "syntax_pass": true}, {"attribute_expression": "protected boolean skipParsing;", "docstring": " Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "skipParsing", "syntax_pass": true}, {"attribute_expression": "protected List expectedOpts;", "docstring": " The required options and groups expected to be found when parsing the command line.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List", "name": "expectedOpts", "syntax_pass": true}, {"attribute_expression": "private final boolean allowPartialMatching;", "docstring": " Flag indicating if partial matching of long options is supported.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "allowPartialMatching", "syntax_pass": true}, {"attribute_expression": "private final Boolean stripLeadingAndTrailingQuotes;", "docstring": " Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments.\nnull represents the historic arbitrary behavior", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Boolean", "name": "stripLeadingAndTrailingQuotes", "syntax_pass": true}, {"attribute_expression": "private final Consumer<Option> deprecatedHandler;", "docstring": "\nThe deprecated option handler.\n<p>\nIf you want to serialize this field, use a serialization proxy.\n</p>\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Consumer<Option>", "name": "deprecatedHandler", "syntax_pass": true}], "classes": [{"original_string": "    public static final class Builder {\n\n        /** Flag indicating if partial matching of long options is supported. */\n        private boolean allowPartialMatching = true;\n\n        /**\n         * The deprecated option handler.\n         * <p>\n         * If you want to serialize this field, use a serialization proxy.\n         * </p>\n         */\n        private Consumer<Option> deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n\n        /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments. */\n        private Boolean stripLeadingAndTrailingQuotes;\n\n        /**\n         * Constructs a new {@code Builder} for a {@code DefaultParser} instance.\n         *\n         * Both allowPartialMatching and stripLeadingAndTrailingQuotes are true by default,\n         * mimicking the argument-less constructor.\n         */\n        private Builder() {\n        }\n\n        /**\n         * Builds an DefaultParser with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link DefaultParser}\n         * @since 1.5.0\n         */\n        public DefaultParser build() {\n            return new DefaultParser(allowPartialMatching, stripLeadingAndTrailingQuotes, deprecatedHandler);\n        }\n\n        /**\n         * Sets if partial matching of long options is supported.\n         *\n         * By \"partial matching\" we mean that given the following code:\n         *\n         * <pre>\n         * {\n         *     &#64;code\n         *     final Options options = new Options();\n         *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n         *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n         *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n         * }\n         * </pre>\n         *\n         * If \"partial matching\" is turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n         * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n         *\n         * @param allowPartialMatching whether to allow partial matching of long options\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setAllowPartialMatching(final boolean allowPartialMatching) {\n            this.allowPartialMatching = allowPartialMatching;\n            return this;\n        }\n\n        /**\n         * Sets the deprecated option handler.\n         *\n         * @param deprecatedHandler the deprecated option handler.\n         * @return {@code this} instance.\n         * @since 1.7.0\n         */\n        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }\n\n        /**\n         * Sets if balanced leading and trailing double quotes should be stripped from option arguments.\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is true,\n         * the outermost balanced double quotes of option arguments values will be removed.\n         * For example, {@code -o '\"x\"'} getValue() will return {@code x}, instead of {@code \"x\"}\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is null,\n         * then quotes will be stripped from option values separated by space from the option, but\n         * kept in other cases, which is the historic behavior.\n         *\n         * @param stripLeadingAndTrailingQuotes whether balanced leading and trailing double quotes should be stripped from option arguments.\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setStripLeadingAndTrailingQuotes(final Boolean stripLeadingAndTrailingQuotes) {\n            this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n            return this;\n        }\n    }", "definition": "    public static final class Builder", "class_docstring": "\nA nested builder class to create {@code DefaultParser} instances\nusing descriptive methods.\n\nExample usage:\n<pre>\nDefaultParser parser = Option.builder()\n    .setAllowPartialMatching(false)\n    .setStripLeadingAndTrailingQuotes(false)\n    .build();\n</pre>\n\n@since 1.5.0\n", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private boolean allowPartialMatching = true;", "docstring": " Flag indicating if partial matching of long options is supported.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "allowPartialMatching = true", "syntax_pass": true}, {"attribute_expression": "private Consumer<Option> deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;", "docstring": "\nThe deprecated option handler.\n<p>\nIf you want to serialize this field, use a serialization proxy.\n</p>\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Consumer<Option>", "name": "deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER", "syntax_pass": true}, {"attribute_expression": "private Boolean stripLeadingAndTrailingQuotes;", "docstring": " Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Boolean", "name": "stripLeadingAndTrailingQuotes", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private Builder() {\n        }", "docstring": "\nConstructs a new {@code Builder} for a {@code DefaultParser} instance.\n\nBoth allowPartialMatching and stripLeadingAndTrailingQuotes are true by default,\nmimicking the argument-less constructor.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Builder", "params": [], "body": "                          {\n        }", "signature": "private Builder()"}, {"syntax_pass": true, "original_string": "        public DefaultParser build() {\n            return new DefaultParser(allowPartialMatching, stripLeadingAndTrailingQuotes, deprecatedHandler);\n        }", "docstring": "\nBuilds an DefaultParser with the values declared by this {@link Builder}.\n\n@return the new {@link DefaultParser}\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DefaultParser", "classes": []}, "name": "build", "params": [], "body": "                                     {\n            return new DefaultParser(allowPartialMatching, stripLeadingAndTrailingQuotes, deprecatedHandler);\n        }", "signature": "public DefaultParser build()"}, {"syntax_pass": true, "original_string": "        public Builder setAllowPartialMatching(final boolean allowPartialMatching) {\n            this.allowPartialMatching = allowPartialMatching;\n            return this;\n        }", "docstring": "\nSets if partial matching of long options is supported.\n\nBy \"partial matching\" we mean that given the following code:\n\n<pre>\n{\n    &#64;code\n    final Options options = new Options();\n    options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n    options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n    options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n}\n</pre>\n\nIf \"partial matching\" is turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n\"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n\n@param allowPartialMatching whether to allow partial matching of long options\n@return this builder, to allow method chaining\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setAllowPartialMatching", "params": [{"name": "allowPartialMatching", "type": "boolean"}], "body": "                                                                                   {\n            this.allowPartialMatching = allowPartialMatching;\n            return this;\n        }", "signature": "public Builder setAllowPartialMatching(final boolean allowPartialMatching)"}, {"syntax_pass": true, "original_string": "        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }", "docstring": "\nSets the deprecated option handler.\n\n@param deprecatedHandler the deprecated option handler.\n@return {@code this} instance.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setDeprecatedHandler", "params": [{"name": "deprecatedHandler", "type": "Consumer<Option>"}], "body": "                                                                                      {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }", "signature": "public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler)"}, {"syntax_pass": true, "original_string": "        public Builder setStripLeadingAndTrailingQuotes(final Boolean stripLeadingAndTrailingQuotes) {\n            this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n            return this;\n        }", "docstring": "\nSets if balanced leading and trailing double quotes should be stripped from option arguments.\n\nIf \"stripping of balanced leading and trailing double quotes from option arguments\" is true,\nthe outermost balanced double quotes of option arguments values will be removed.\nFor example, {@code -o '\"x\"'} getValue() will return {@code x}, instead of {@code \"x\"}\n\nIf \"stripping of balanced leading and trailing double quotes from option arguments\" is null,\nthen quotes will be stripped from option values separated by space from the option, but\nkept in other cases, which is the historic behavior.\n\n@param stripLeadingAndTrailingQuotes whether balanced leading and trailing double quotes should be stripped from option arguments.\n@return this builder, to allow method chaining\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setStripLeadingAndTrailingQuotes", "params": [{"name": "stripLeadingAndTrailingQuotes", "type": "Boolean"}], "body": "                                                                                                     {\n            this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n            return this;\n        }", "signature": "public Builder setStripLeadingAndTrailingQuotes(final Boolean stripLeadingAndTrailingQuotes)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static Builder builder() {\n        return new Builder();\n    }", "docstring": "\nCreates a new {@link Builder} to create an {@link DefaultParser} using descriptive\nmethods.\n\n@return a new {@link Builder} instance\n@since 1.5.0\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "builder", "params": [], "body": "                                    {\n        return new Builder();\n    }", "signature": "public static Builder builder()"}, {"syntax_pass": true, "original_string": "    static int indexOfEqual(final String token) {\n        return token.indexOf(Char.EQUAL);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "int", "classes": []}, "name": "indexOfEqual", "params": [{"name": "token", "type": "String"}], "body": "                                                {\n        return token.indexOf(Char.EQUAL);\n    }", "signature": "static int indexOfEqual(final String token)"}, {"syntax_pass": true, "original_string": "    public DefaultParser() {\n        this.allowPartialMatching = true;\n        this.stripLeadingAndTrailingQuotes = null;\n        this.deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n    }", "docstring": "\nCreates a new DefaultParser instance with partial matching enabled.\n\nBy \"partial matching\" we mean that given the following code:\n\n<pre>\n{\n    &#64;code\n    final Options options = new Options();\n    options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n    options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n    options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n}\n</pre>\n\nwith \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n\"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\noptions.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "DefaultParser", "params": [], "body": "                           {\n        this.allowPartialMatching = true;\n        this.stripLeadingAndTrailingQuotes = null;\n        this.deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n    }", "signature": "public DefaultParser()"}, {"syntax_pass": true, "original_string": "    public DefaultParser(final boolean allowPartialMatching) {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = null;\n        this.deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n    }", "docstring": "\nCreate a new DefaultParser instance with the specified partial matching policy.\n\nBy \"partial matching\" we mean that given the following code:\n\n<pre>\n{\n    &#64;code\n    final Options options = new Options();\n    options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n    options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n    options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n}\n</pre>\n\nwith \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n\"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\noptions.\n\n@param allowPartialMatching if partial matching of long options shall be enabled\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "DefaultParser", "params": [{"name": "allowPartialMatching", "type": "boolean"}], "body": "                                                             {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = null;\n        this.deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n    }", "signature": "public DefaultParser(final boolean allowPartialMatching)"}, {"syntax_pass": true, "original_string": "    private DefaultParser(final boolean allowPartialMatching, final Boolean stripLeadingAndTrailingQuotes, final Consumer<Option> deprecatedHandler) {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n        this.deprecatedHandler = deprecatedHandler;\n    }", "docstring": "\nCreates a new DefaultParser instance with the specified partial matching and quote\nstripping policy.\n\n@param allowPartialMatching if partial matching of long options shall be enabled\n@param stripLeadingAndTrailingQuotes if balanced outer double quoutes should be stripped\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "DefaultParser", "params": [{"name": "allowPartialMatching", "type": "boolean"}, {"name": "stripLeadingAndTrailingQuotes", "type": "Boolean"}, {"name": "deprecatedHandler", "type": "Consumer<Option>"}], "body": "                                                                                                                                                     {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n        this.deprecatedHandler = deprecatedHandler;\n    }", "signature": "private DefaultParser(final boolean allowPartialMatching, final Boolean stripLeadingAndTrailingQuotes, final Consumer<Option> deprecatedHandler)"}, {"syntax_pass": true, "original_string": "    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg()) {\n            if (isJavaProperty(currentOption.getKey()) && currentOption.getValuesList().size() == 1) {\n                return;\n            }\n            throw new MissingArgumentException(currentOption);\n        }\n    }", "docstring": "\nThrows a {@link MissingArgumentException} if the current option didn't receive the number of arguments expected.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "checkRequiredArgs", "params": [], "body": "                                                           {\n        if (currentOption != null && currentOption.requiresArg()) {\n            if (isJavaProperty(currentOption.getKey()) && currentOption.getValuesList().size() == 1) {\n                return;\n            }\n            throw new MissingArgumentException(currentOption);\n        }\n    }", "signature": "private void checkRequiredArgs()"}, {"syntax_pass": true, "original_string": "    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty()) {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }", "docstring": "\nThrows a {@link MissingOptionException} if all of the required options are not present.\n\n@throws MissingOptionException if any of the required Options are not present.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "checkRequiredOptions", "params": [], "body": "                                                                        {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty()) {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }", "signature": "protected void checkRequiredOptions()"}, {"syntax_pass": true, "original_string": "    private String getLongPrefix(final String token) {\n        final String t = Util.stripLeadingHyphens(token);\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--) {\n            final String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix)) {\n                opt = prefix;\n                break;\n            }\n        }\n        return opt;\n    }", "docstring": "\nSearches for a prefix that is the long name of an option (-Xmx512m)\n\n@param token\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "getLongPrefix", "params": [{"name": "token", "type": "String"}], "body": "                                                     {\n        final String t = Util.stripLeadingHyphens(token);\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--) {\n            final String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix)) {\n                opt = prefix;\n                break;\n            }\n        }\n        return opt;\n    }", "signature": "private String getLongPrefix(final String token)"}, {"syntax_pass": true, "original_string": "    private List<String> getMatchingLongOptions(final String token) {\n        if (allowPartialMatching) {\n            return options.getMatchingOptions(token);\n        }\n        final List<String> matches = new ArrayList<>(1);\n        if (options.hasLongOption(token)) {\n            matches.add(options.getOption(token).getLongOpt());\n        }\n        return matches;\n    }", "docstring": "\nGets a list of matching option strings for the given token, depending on the selected partial matching policy.\n\n@param token the token (may contain leading dashes)\n@return the list of matching option strings or an empty list if no matching option could be found\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getMatchingLongOptions", "params": [{"name": "token", "type": "String"}], "body": "                                                                    {\n        if (allowPartialMatching) {\n            return options.getMatchingOptions(token);\n        }\n        final List<String> matches = new ArrayList<>(1);\n        if (options.hasLongOption(token)) {\n            matches.add(options.getOption(token).getLongOpt());\n        }\n        return matches;\n    }", "signature": "private List<String> getMatchingLongOptions(final String token)"}, {"syntax_pass": true, "original_string": "    protected void handleConcatenatedOptions(final String token) throws ParseException {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n            if (!options.hasOption(ch)) {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n            handleOption(options.getOption(ch));\n            if (currentOption != null && token.length() != i + 1) {\n                // add the trail as an argument of the option\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(i + 1)));\n                break;\n            }\n        }\n    }", "docstring": "\nBreaks {@code token} into its constituent parts using the following algorithm.\n\n<ul>\n<li>ignore the first character (\"<b>-</b>\")</li>\n<li>for each remaining character check if an {@link Option} exists with that id.</li>\n<li>if an {@link Option} does exist then add that character prepended with \"<b>-</b>\" to the list of processed\ntokens.</li>\n<li>if the {@link Option} can have an argument value and there are remaining characters in the token then add the\nremaining characters as a token to the list of processed tokens.</li>\n<li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS</b> set then add the\nspecial token \"<b>--</b>\" followed by the remaining characters and also the remaining tokens directly to the\nprocessed tokens list.</li>\n<li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS NOT</b> set then add\nthat character prepended with \"<b>-</b>\".</li>\n</ul>\n\n@param token The current token to be <b>burst</b> at the first non-Option encountered.\n@throws ParseException if there are any problems encountered while parsing the command line token.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "handleConcatenatedOptions", "params": [{"name": "token", "type": "String"}], "body": "                                                                                       {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n            if (!options.hasOption(ch)) {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n            handleOption(options.getOption(ch));\n            if (currentOption != null && token.length() != i + 1) {\n                // add the trail as an argument of the option\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(i + 1)));\n                break;\n            }\n        }\n    }", "signature": "protected void handleConcatenatedOptions(final String token)"}, {"syntax_pass": true, "original_string": "    private void handleLongOption(final String token) throws ParseException {\n        if (indexOfEqual(token) == -1) {\n            handleLongOptionWithoutEqual(token);\n        } else {\n            handleLongOptionWithEqual(token);\n        }\n    }", "docstring": "\nHandles the following tokens:\n\n--L --L=V --L V --l\n\n@param token the command line token to handle\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "handleLongOption", "params": [{"name": "token", "type": "String"}], "body": "                                                                            {\n        if (indexOfEqual(token) == -1) {\n            handleLongOptionWithoutEqual(token);\n        } else {\n            handleLongOptionWithEqual(token);\n        }\n    }", "signature": "private void handleLongOption(final String token)"}, {"syntax_pass": true, "original_string": "    private void handleLongOptionWithEqual(final String token) throws ParseException {\n        final int pos = indexOfEqual(token);\n        final String value = token.substring(pos + 1);\n        final String opt = token.substring(0, pos);\n        final List<String> matchingOpts = getMatchingLongOptions(opt);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(opt)) {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(opt) ? opt : matchingOpts.get(0);\n            final Option option = options.getOption(key);\n            if (option.acceptsArg()) {\n                handleOption(option);\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\n                currentOption = null;\n            } else {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }", "docstring": "\nHandles the following tokens:\n\n--L=V -L=V --l=V -l=V\n\n@param token the command line token to handle\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "handleLongOptionWithEqual", "params": [{"name": "token", "type": "String"}], "body": "                                                                                     {\n        final int pos = indexOfEqual(token);\n        final String value = token.substring(pos + 1);\n        final String opt = token.substring(0, pos);\n        final List<String> matchingOpts = getMatchingLongOptions(opt);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(opt)) {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(opt) ? opt : matchingOpts.get(0);\n            final Option option = options.getOption(key);\n            if (option.acceptsArg()) {\n                handleOption(option);\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\n                currentOption = null;\n            } else {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }", "signature": "private void handleLongOptionWithEqual(final String token)"}, {"syntax_pass": true, "original_string": "    private void handleLongOptionWithoutEqual(final String token) throws ParseException {\n        final List<String> matchingOpts = getMatchingLongOptions(token);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(token)) {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(token) ? token : matchingOpts.get(0);\n            handleOption(options.getOption(key));\n        }\n    }", "docstring": "\nHandles the following tokens:\n\n--L -L --l -l\n\n@param token the command line token to handle\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "handleLongOptionWithoutEqual", "params": [{"name": "token", "type": "String"}], "body": "                                                                                        {\n        final List<String> matchingOpts = getMatchingLongOptions(token);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(token)) {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(token) ? token : matchingOpts.get(0);\n            handleOption(options.getOption(key));\n        }\n    }", "signature": "private void handleLongOptionWithoutEqual(final String token)"}, {"syntax_pass": true, "original_string": "    private void handleOption(final Option option) throws ParseException {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n        final Option copy = (Option) option.clone();\n        updateRequiredOptions(copy);\n        cmd.addOption(copy);\n        currentOption = copy.hasArg() ? copy : null;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "handleOption", "params": [{"name": "option", "type": "Option"}], "body": "                                                                         {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n        final Option copy = (Option) option.clone();\n        updateRequiredOptions(copy);\n        cmd.addOption(copy);\n        currentOption = copy.hasArg() ? copy : null;\n    }", "signature": "private void handleOption(final Option option)"}, {"syntax_pass": true, "original_string": "    private void handleProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.isSelected();\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties\n                final String value = properties.getProperty(option);\n\n                if (opt.hasArg()) {\n                    if (Util.isEmpty(opt.getValues())) {\n                        opt.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }", "docstring": "\nSets the values of Options using the values in {@code properties}.\n\n@param properties The value properties to be processed.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "handleProperties", "params": [{"name": "properties", "type": "Properties"}], "body": "                                                                                     {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.isSelected();\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties\n                final String value = properties.getProperty(option);\n\n                if (opt.hasArg()) {\n                    if (Util.isEmpty(opt.getValues())) {\n                        opt.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }", "signature": "private void handleProperties(final Properties properties)"}, {"syntax_pass": true, "original_string": "    private void handleShortAndLongOption(final String hyphenToken) throws ParseException {\n        final String token = Util.stripLeadingHyphens(hyphenToken);\n        final int pos = indexOfEqual(token);\n        if (token.length() == 1) {\n            // -S\n            if (options.hasShortOption(token)) {\n                handleOption(options.getOption(token));\n            } else {\n                handleUnknownToken(hyphenToken);\n            }\n        } else if (pos == -1) {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(token)) {\n                handleOption(options.getOption(token));\n            } else if (!getMatchingLongOptions(token).isEmpty()) {\n                // -L or -l\n                handleLongOptionWithoutEqual(hyphenToken);\n            } else {\n                // look for a long prefix (-Xmx512m)\n                final String opt = getLongPrefix(token);\n\n                if (opt != null && options.getOption(opt).acceptsArg()) {\n                    handleOption(options.getOption(opt));\n                    currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(opt.length())));\n                    currentOption = null;\n                } else if (isJavaProperty(token)) {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(token.substring(0, 1)));\n                    currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(1)));\n                    currentOption = null;\n                } else {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(hyphenToken);\n                }\n            }\n        } else {\n            // equal sign found (-xxx=yyy)\n            final String opt = token.substring(0, pos);\n            final String value = token.substring(pos + 1);\n\n            if (opt.length() == 1) {\n                // -S=V\n                final Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg()) {\n                    handleOption(option);\n                    currentOption.processValue(value);\n                    currentOption = null;\n                } else {\n                    handleUnknownToken(hyphenToken);\n                }\n            } else if (isJavaProperty(opt)) {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.processValue(opt.substring(1));\n                currentOption.processValue(value);\n                currentOption = null;\n            } else {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(hyphenToken);\n            }\n        }\n    }", "docstring": "\nHandles the following tokens:\n\n-S -SV -S V -S=V -S1S2 -S1S2 V -SV1=V2\n\n-L -LV -L V -L=V -l\n\n@param hyphenToken the command line token to handle\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "handleShortAndLongOption", "params": [{"name": "hyphenToken", "type": "String"}], "body": "                                                                                          {\n        final String token = Util.stripLeadingHyphens(hyphenToken);\n        final int pos = indexOfEqual(token);\n        if (token.length() == 1) {\n            // -S\n            if (options.hasShortOption(token)) {\n                handleOption(options.getOption(token));\n            } else {\n                handleUnknownToken(hyphenToken);\n            }\n        } else if (pos == -1) {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(token)) {\n                handleOption(options.getOption(token));\n            } else if (!getMatchingLongOptions(token).isEmpty()) {\n                // -L or -l\n                handleLongOptionWithoutEqual(hyphenToken);\n            } else {\n                // look for a long prefix (-Xmx512m)\n                final String opt = getLongPrefix(token);\n\n                if (opt != null && options.getOption(opt).acceptsArg()) {\n                    handleOption(options.getOption(opt));\n                    currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(opt.length())));\n                    currentOption = null;\n                } else if (isJavaProperty(token)) {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(token.substring(0, 1)));\n                    currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(1)));\n                    currentOption = null;\n                } else {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(hyphenToken);\n                }\n            }\n        } else {\n            // equal sign found (-xxx=yyy)\n            final String opt = token.substring(0, pos);\n            final String value = token.substring(pos + 1);\n\n            if (opt.length() == 1) {\n                // -S=V\n                final Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg()) {\n                    handleOption(option);\n                    currentOption.processValue(value);\n                    currentOption = null;\n                } else {\n                    handleUnknownToken(hyphenToken);\n                }\n            } else if (isJavaProperty(opt)) {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.processValue(opt.substring(1));\n                currentOption.processValue(value);\n                currentOption = null;\n            } else {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(hyphenToken);\n            }\n        }\n    }", "signature": "private void handleShortAndLongOption(final String hyphenToken)"}, {"syntax_pass": true, "original_string": "    private void handleToken(final String token) throws ParseException {\n        if (token != null) {\n            currentToken = token;\n            if (skipParsing) {\n                cmd.addArg(token);\n            } else if (\"--\".equals(token)) {\n                skipParsing = true;\n            } else if (currentOption != null && currentOption.acceptsArg() && isArgument(token)) {\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOn(token));\n            } else if (token.startsWith(\"--\")) {\n                handleLongOption(token);\n            } else if (token.startsWith(\"-\") && !\"-\".equals(token)) {\n                handleShortAndLongOption(token);\n            } else {\n                handleUnknownToken(token);\n            }\n            if (currentOption != null && !currentOption.acceptsArg()) {\n                currentOption = null;\n            }\n        }\n    }", "docstring": "\nHandles any command line token.\n\n@param token the command line token to handle\n@throws ParseException\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "handleToken", "params": [{"name": "token", "type": "String"}], "body": "                                                                       {\n        if (token != null) {\n            currentToken = token;\n            if (skipParsing) {\n                cmd.addArg(token);\n            } else if (\"--\".equals(token)) {\n                skipParsing = true;\n            } else if (currentOption != null && currentOption.acceptsArg() && isArgument(token)) {\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOn(token));\n            } else if (token.startsWith(\"--\")) {\n                handleLongOption(token);\n            } else if (token.startsWith(\"-\") && !\"-\".equals(token)) {\n                handleShortAndLongOption(token);\n            } else {\n                handleUnknownToken(token);\n            }\n            if (currentOption != null && !currentOption.acceptsArg()) {\n                currentOption = null;\n            }\n        }\n    }", "signature": "private void handleToken(final String token)"}, {"syntax_pass": true, "original_string": "    private void handleUnknownToken(final String token) throws ParseException {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n        cmd.addArg(token);\n        if (stopAtNonOption) {\n            skipParsing = true;\n        }\n    }", "docstring": "\nHandles an unknown token. If the token starts with a dash an UnrecognizedOptionException is thrown. Otherwise the\ntoken is added to the arguments of the command line. If the stopAtNonOption flag is set, this stops the parsing and\nthe remaining tokens are added as-is in the arguments of the command line.\n\n@param token the command line token to handle\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "handleUnknownToken", "params": [{"name": "token", "type": "String"}], "body": "                                                                              {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n        cmd.addArg(token);\n        if (stopAtNonOption) {\n            skipParsing = true;\n        }\n    }", "signature": "private void handleUnknownToken(final String token)"}, {"syntax_pass": true, "original_string": "    private boolean isArgument(final String token) {\n        return !isOption(token) || isNegativeNumber(token);\n    }", "docstring": "\nTests if the token is a valid argument.\n\n@param token\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isArgument", "params": [{"name": "token", "type": "String"}], "body": "                                                   {\n        return !isOption(token) || isNegativeNumber(token);\n    }", "signature": "private boolean isArgument(final String token)"}, {"syntax_pass": true, "original_string": "    private boolean isJavaProperty(final String token) {\n        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n        final Option option = options.getOption(opt);\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }", "docstring": "\nTests if the specified token is a Java-like property (-Dkey=value).\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isJavaProperty", "params": [{"name": "token", "type": "String"}], "body": "                                                       {\n        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n        final Option option = options.getOption(opt);\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }", "signature": "private boolean isJavaProperty(final String token)"}, {"syntax_pass": true, "original_string": "    private boolean isLongOption(final String token) {\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n        final int pos = indexOfEqual(token);\n        final String t = pos == -1 ? token : token.substring(0, pos);\n        if (!getMatchingLongOptions(t).isEmpty()) {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        if (getLongPrefix(token) != null && !token.startsWith(\"--\")) {\n            // -LV\n            return true;\n        }\n        return false;\n    }", "docstring": "\nTests if the token looks like a long option.\n\n@param token\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isLongOption", "params": [{"name": "token", "type": "String"}], "body": "                                                     {\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n        final int pos = indexOfEqual(token);\n        final String t = pos == -1 ? token : token.substring(0, pos);\n        if (!getMatchingLongOptions(t).isEmpty()) {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        if (getLongPrefix(token) != null && !token.startsWith(\"--\")) {\n            // -LV\n            return true;\n        }\n        return false;\n    }", "signature": "private boolean isLongOption(final String token)"}, {"syntax_pass": true, "original_string": "    private boolean isNegativeNumber(final String token) {\n        try {\n            Double.parseDouble(token);\n            return true;\n        } catch (final NumberFormatException e) {\n            return false;\n        }\n    }", "docstring": "\nTests if the token is a negative number.\n\n@param token\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNegativeNumber", "params": [{"name": "token", "type": "String"}], "body": "                                                         {\n        try {\n            Double.parseDouble(token);\n            return true;\n        } catch (final NumberFormatException e) {\n            return false;\n        }\n    }", "signature": "private boolean isNegativeNumber(final String token)"}, {"syntax_pass": true, "original_string": "    private boolean isOption(final String token) {\n        return isLongOption(token) || isShortOption(token);\n    }", "docstring": "\nTests if the token looks like an option.\n\n@param token\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isOption", "params": [{"name": "token", "type": "String"}], "body": "                                                 {\n        return isLongOption(token) || isShortOption(token);\n    }", "signature": "private boolean isOption(final String token)"}, {"syntax_pass": true, "original_string": "    private boolean isShortOption(final String token) {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n        // remove leading \"-\" and \"=value\"\n        final int pos = indexOfEqual(token);\n        final String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName)) {\n            return true;\n        }\n        // check for several concatenated short options\n        return !optName.isEmpty() && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }", "docstring": "\nTests if the token looks like a short option.\n\n@param token\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isShortOption", "params": [{"name": "token", "type": "String"}], "body": "                                                      {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n        // remove leading \"-\" and \"=value\"\n        final int pos = indexOfEqual(token);\n        final String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName)) {\n            return true;\n        }\n        // check for several concatenated short options\n        return !optName.isEmpty() && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }", "signature": "private boolean isShortOption(final String token)"}, {"syntax_pass": true, "original_string": "    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "parse", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}], "body": "                                                                                                    {\n        return parse(options, arguments, null);\n    }", "signature": "@Override\n    public CommandLine parse(final Options options, final String[] arguments)"}, {"syntax_pass": true, "original_string": "    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "parse", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "                                                                                                                                   {\n        return parse(options, arguments, null, stopAtNonOption);\n    }", "signature": "@Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption)"}, {"syntax_pass": true, "original_string": "    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }", "docstring": "\nParses the arguments according to the specified options and properties.\n\n@param options the specified Options\n@param arguments the command line arguments\n@param properties command line option name-value pairs\n@return the list of atomic option and value tokens\n\n@throws ParseException if there are any problems encountered while parsing the command line tokens.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "parse", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}, {"name": "properties", "type": "Properties"}], "body": "                                                                                                                                 {\n        return parse(options, arguments, properties, false);\n    }", "signature": "public CommandLine parse(final Options options, final String[] arguments, final Properties properties)"}, {"syntax_pass": true, "original_string": "    public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)\n        throws ParseException {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList<>(options.getRequiredOptions());\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        cmd = CommandLine.builder().setDeprecatedHandler(deprecatedHandler).build();\n        if (arguments != null) {\n            for (final String argument : arguments) {\n                handleToken(argument);\n            }\n        }\n        // check the arguments of the last option\n        checkRequiredArgs();\n        // add the default options\n        handleProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }", "docstring": "\nParses the arguments according to the specified options and properties.\n\n@param options the specified Options\n@param arguments the command line arguments\n@param properties command line option name-value pairs\n@param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n       are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n       ParseException.\n\n@return the list of atomic option and value tokens\n@throws ParseException if there are any problems encountered while parsing the command line tokens.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "parse", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}, {"name": "properties", "type": "Properties"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "                              {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList<>(options.getRequiredOptions());\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        cmd = CommandLine.builder().setDeprecatedHandler(deprecatedHandler).build();\n        if (arguments != null) {\n            for (final String argument : arguments) {\n                handleToken(argument);\n            }\n        }\n        // check the arguments of the last option\n        checkRequiredArgs();\n        // add the default options\n        handleProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }", "signature": "public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)"}, {"syntax_pass": true, "original_string": "    private String stripLeadingAndTrailingQuotesDefaultOff(final String token) {\n        if (stripLeadingAndTrailingQuotes != null && stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }", "docstring": "\nStrips balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\nIf stripLeadingAndTrailingQuotes is null, then do not strip\n\n@param token a string\n@return token with the quotes stripped (if set)\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "stripLeadingAndTrailingQuotesDefaultOff", "params": [{"name": "token", "type": "String"}], "body": "                                                                               {\n        if (stripLeadingAndTrailingQuotes != null && stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }", "signature": "private String stripLeadingAndTrailingQuotesDefaultOff(final String token)"}, {"syntax_pass": true, "original_string": "    private String stripLeadingAndTrailingQuotesDefaultOn(final String token) {\n        if (stripLeadingAndTrailingQuotes == null || stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }", "docstring": "\nStrips balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\nIf stripLeadingAndTrailingQuotes is null, then do not strip\n\n@param token a string\n@return token with the quotes stripped (if set)\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "stripLeadingAndTrailingQuotesDefaultOn", "params": [{"name": "token", "type": "String"}], "body": "                                                                              {\n        if (stripLeadingAndTrailingQuotes == null || stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }", "signature": "private String stripLeadingAndTrailingQuotesDefaultOn(final String token)"}, {"syntax_pass": true, "original_string": "    private void updateRequiredOptions(final Option option) throws AlreadySelectedException {\n        if (option.isRequired()) {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null) {\n            final OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired()) {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }", "docstring": "\nRemoves the option or its group from the list of expected elements.\n\n@param option\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "updateRequiredOptions", "params": [{"name": "option", "type": "Option"}], "body": "                                                                                            {\n        if (option.isRequired()) {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null) {\n            final OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired()) {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }", "signature": "private void updateRequiredOptions(final Option option)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/ParseException.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Base for Exceptions thrown during parsing of a command-line.\n */\npublic class ParseException extends Exception {\n\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 9112808380089253192L;\n\n    /**\n     * Converts any exception except {@code UnsupportedOperationException} to a {@code ParseException}.\n     * if {@code e} is an instance of {@code ParseException} it is returned, otherwise a {@code ParseException} is\n     * created that wraps it.\n     * <p>\n     * Note: {@code UnsupportedOperationException} are not wrapped.  This is to solve a legacy expected exception problem and will be\n     * removed in the future.</p>\n     * @param e the exception to convert.\n     * @return the ParseException.\n     * @throws UnsupportedOperationException due to legacy expectations.  Will be removed in the future.\n     * @since 1.7.0\n     */\n    public static ParseException wrap(final Throwable e) throws UnsupportedOperationException {\n        if (e instanceof UnsupportedOperationException) {\n            throw (UnsupportedOperationException) e;\n        }\n\n        if (e instanceof ParseException) {\n            return (ParseException) e;\n        }\n        return new ParseException(e);\n    }\n\n    /**\n     * Constructs a new {@code ParseException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public ParseException(final String message) {\n        super(message);\n    }\n\n    /**\n     * Constructs a new {@code ParseException} wrapping the specified exception.\n     *\n     * @param e the Exception to wrap.\n     */\n    public ParseException(final Throwable e) {\n        super(e);\n    }\n}\n", "file_hash": "9bc86b03ba2c101d6089e27e60ee17aa5825b09f0fed5647d3266550d2e4765a", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;"], "methods": [], "classes": [{"original_string": "public class ParseException extends Exception {\n\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 9112808380089253192L;\n\n    /**\n     * Converts any exception except {@code UnsupportedOperationException} to a {@code ParseException}.\n     * if {@code e} is an instance of {@code ParseException} it is returned, otherwise a {@code ParseException} is\n     * created that wraps it.\n     * <p>\n     * Note: {@code UnsupportedOperationException} are not wrapped.  This is to solve a legacy expected exception problem and will be\n     * removed in the future.</p>\n     * @param e the exception to convert.\n     * @return the ParseException.\n     * @throws UnsupportedOperationException due to legacy expectations.  Will be removed in the future.\n     * @since 1.7.0\n     */\n    public static ParseException wrap(final Throwable e) throws UnsupportedOperationException {\n        if (e instanceof UnsupportedOperationException) {\n            throw (UnsupportedOperationException) e;\n        }\n\n        if (e instanceof ParseException) {\n            return (ParseException) e;\n        }\n        return new ParseException(e);\n    }\n\n    /**\n     * Constructs a new {@code ParseException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public ParseException(final String message) {\n        super(message);\n    }\n\n    /**\n     * Constructs a new {@code ParseException} wrapping the specified exception.\n     *\n     * @param e the Exception to wrap.\n     */\n    public ParseException(final Throwable e) {\n        super(e);\n    }\n}", "definition": "public class ParseException extends Exception", "class_docstring": "\nBase for Exceptions thrown during parsing of a command-line.\n", "name": "ParseException", "super_interfaces": [], "superclasses": "Exception", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 9112808380089253192L;", "docstring": "\nThis exception {@code serialVersionUID}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 9112808380089253192L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static ParseException wrap(final Throwable e) throws UnsupportedOperationException {\n        if (e instanceof UnsupportedOperationException) {\n            throw (UnsupportedOperationException) e;\n        }\n\n        if (e instanceof ParseException) {\n            return (ParseException) e;\n        }\n        return new ParseException(e);\n    }", "docstring": "\nConverts any exception except {@code UnsupportedOperationException} to a {@code ParseException}.\nif {@code e} is an instance of {@code ParseException} it is returned, otherwise a {@code ParseException} is\ncreated that wraps it.\n<p>\nNote: {@code UnsupportedOperationException} are not wrapped.  This is to solve a legacy expected exception problem and will be\nremoved in the future.</p>\n@param e the exception to convert.\n@return the ParseException.\n@throws UnsupportedOperationException due to legacy expectations.  Will be removed in the future.\n@since 1.7.0\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ParseException", "classes": []}, "name": "wrap", "params": [{"name": "e", "type": "Throwable"}], "body": "                                                                                              {\n        if (e instanceof UnsupportedOperationException) {\n            throw (UnsupportedOperationException) e;\n        }\n\n        if (e instanceof ParseException) {\n            return (ParseException) e;\n        }\n        return new ParseException(e);\n    }", "signature": "public static ParseException wrap(final Throwable e)"}, {"syntax_pass": true, "original_string": "    public ParseException(final String message) {\n        super(message);\n    }", "docstring": "\nConstructs a new {@code ParseException} with the specified detail message.\n\n@param message the detail message\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParseException", "params": [{"name": "message", "type": "String"}], "body": "                                                {\n        super(message);\n    }", "signature": "public ParseException(final String message)"}, {"syntax_pass": true, "original_string": "    public ParseException(final Throwable e) {\n        super(e);\n    }", "docstring": "\nConstructs a new {@code ParseException} wrapping the specified exception.\n\n@param e the Exception to wrap.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParseException", "params": [{"name": "e", "type": "Throwable"}], "body": "                                             {\n        super(e);\n    }", "signature": "public ParseException(final Throwable e)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/Converter.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.InvalidPathException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * The definition of the functional interface to call when doing a conversion. Like {@code Function<String,T>} but can throw an Exception.\n *\n * @param <T> The return type for the function.\n * @param <E> The kind of thrown exception or error.\n * @since 1.7.0\n */\n@FunctionalInterface\npublic interface Converter<T, E extends Throwable> {\n    // See also Apache Commons Lang FailableFunction\n\n    /**\n     * The default converter. Does nothing.\n     */\n    Converter<?, RuntimeException> DEFAULT = s -> s;\n\n    /**\n     * Class name converter. Calls {@link Class#forName(String)}.\n     */\n    Converter<Class<?>, ClassNotFoundException> CLASS = Class::forName;\n\n    /**\n     * File name converter. Calls {@link File#File(String)}.\n     */\n    Converter<File, NullPointerException> FILE = File::new;\n\n    /**\n     * Path converter. Calls {@link Paths#get(java.net.URI)}.\n     */\n    Converter<Path, InvalidPathException> PATH = Paths::get;\n\n    /**\n     * Number converter. Converts to a Double if a decimal point ('.') is in the string or a Long otherwise.\n     */\n    Converter<Number, NumberFormatException> NUMBER = s -> s.indexOf('.') != -1 ? (Number) Double.valueOf(s) : (Number) Long.valueOf(s);\n\n    /**\n     * Converts a class name to an instance of the class. Uses the Class converter to find the class and then call the default constructor.\n     *\n     * @see #CLASS\n     */\n    Converter<Object, ReflectiveOperationException> OBJECT = s -> CLASS.apply(s).getConstructor().newInstance();\n\n    /**\n     * Creates a URL. Calls {@link URL#URL(String)}.\n     */\n    Converter<URL, MalformedURLException> URL = URL::new;\n\n    /**\n     * Converts to a date using the format string Form \"EEE MMM dd HH:mm:ss zzz yyyy\".\n     */\n    Converter<Date, java.text.ParseException> DATE = s -> new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\").parse(s);\n\n    /**\n     * Applies the conversion function to the String argument.\n     *\n     * @param string the String to convert\n     * @return the Object from the conversion.\n     * @throws E on error.\n     */\n    T apply(String string) throws E;\n}\n", "file_hash": "5f55ed01a6596a80fec3c07a97901b26b207e6b3609ed77707f41fd3ae361fed", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.io.File;", "import java.net.MalformedURLException;", "import java.net.URL;", "import java.nio.file.InvalidPathException;", "import java.nio.file.Path;", "import java.nio.file.Paths;", "import java.text.SimpleDateFormat;", "import java.util.Date;"], "methods": [], "classes": [], "interfaces": [{"original_string": "@FunctionalInterface\npublic interface Converter<T, E extends Throwable> {\n    // See also Apache Commons Lang FailableFunction\n\n    /**\n     * The default converter. Does nothing.\n     */\n    Converter<?, RuntimeException> DEFAULT = s -> s;\n\n    /**\n     * Class name converter. Calls {@link Class#forName(String)}.\n     */\n    Converter<Class<?>, ClassNotFoundException> CLASS = Class::forName;\n\n    /**\n     * File name converter. Calls {@link File#File(String)}.\n     */\n    Converter<File, NullPointerException> FILE = File::new;\n\n    /**\n     * Path converter. Calls {@link Paths#get(java.net.URI)}.\n     */\n    Converter<Path, InvalidPathException> PATH = Paths::get;\n\n    /**\n     * Number converter. Converts to a Double if a decimal point ('.') is in the string or a Long otherwise.\n     */\n    Converter<Number, NumberFormatException> NUMBER = s -> s.indexOf('.') != -1 ? (Number) Double.valueOf(s) : (Number) Long.valueOf(s);\n\n    /**\n     * Converts a class name to an instance of the class. Uses the Class converter to find the class and then call the default constructor.\n     *\n     * @see #CLASS\n     */\n    Converter<Object, ReflectiveOperationException> OBJECT = s -> CLASS.apply(s).getConstructor().newInstance();\n\n    /**\n     * Creates a URL. Calls {@link URL#URL(String)}.\n     */\n    Converter<URL, MalformedURLException> URL = URL::new;\n\n    /**\n     * Converts to a date using the format string Form \"EEE MMM dd HH:mm:ss zzz yyyy\".\n     */\n    Converter<Date, java.text.ParseException> DATE = s -> new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\").parse(s);\n\n    /**\n     * Applies the conversion function to the String argument.\n     *\n     * @param string the String to convert\n     * @return the Object from the conversion.\n     * @throws E on error.\n     */\n    T apply(String string) throws E;\n}", "definition": "@FunctionalInterface\npublic interface Converter<T, E extends Throwable>", "interface_docstring": "\nThe definition of the functional interface to call when doing a conversion. Like {@code Function<String,T>} but can throw an Exception.\n\n@param <T> The return type for the function.\n@param <E> The kind of thrown exception or error.\n@since 1.7.0\n", "name": "Converter", "extends_interfaces": [], "attributes": {"modifiers": "@FunctionalInterface\npublic", "marker_annotations": ["@FunctionalInterface"], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    T apply(String string) throws E;", "docstring": "\nApplies the conversion function to the String argument.\n\n@param string the String to convert\n@return the Object from the conversion.\n@throws E on error.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "name": "apply", "params": [{"name": "string", "type": "String"}], "body": "", "signature": "T apply(String string)"}]}], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/OptionValidator.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Validates an Option string.\n */\nfinal class OptionValidator {\n    /* package private for testing access */\n    /** The array of additional characters allowed as the first character in the option but not in the rest of the option */\n    static final char[] ADDITIONAL_OPTION_CHARS = {'?', '@'};\n    /** The array of additional characters allowed in the rest of the option but not in the first position */\n    static final char[] ADDITIONAL_LONG_CHARS = {'-'};\n\n    /**\n     * Returns whether the specified character is a valid character.\n     * A character is valid if any of the following conditions are true:\n     * <ul>\n     * <li>it is a letter</li>\n     * <li>it is a currency symbol (such as '$')</li>\n     * <li>it is a connecting punctuation character (such as '_')</li>\n     * <li>it is a digit</li>\n     * <li>it is a numeric letter (such as a Roman numeral character)</li>\n     * <li>it is a combining mark</li>\n     * <li>it is a non-spacing mark</li>\n     * <li>isIdentifierIgnorable returns true for the character</li>\n     * <li>it is a hyphen/dash ('-')</li>\n     * </ul>\n     * @param c the character to validate\n     * @return true if {@code c} is a valid character letter.\n     */\n    private static boolean isValidChar(final char c) {\n        return Character.isJavaIdentifierPart(c) || search(ADDITIONAL_LONG_CHARS, c);\n    }\n\n    /**\n     * Returns whether the specified character is a valid Option.\n     * A character is valid if any of the following conditions are true:\n     * <ul>\n     * <li>it is a letter</li>\n     * <li>it is a currency symbol (such as '$')</li>\n     * <li>it is a connecting punctuation character (such as '_')</li>\n     * <li>it is a digit</li>\n     * <li>it is a numeric letter (such as a Roman numeral character)</li>\n     * <li>it is a combining mark</li>\n     * <li>it is a non-spacing mark</li>\n     * <li>isIdentifierIgnorable returns true for the character</li>\n     * <li>it is a question mark or 'at' sign ('?' or '@')</li>\n     * </ul>\n     * @param c the option to validate\n     * @return true if {@code c} is a letter, '?' or '@', otherwise false.\n     */\n    private static boolean isValidOpt(final char c) {\n        return Character.isJavaIdentifierPart(c) || search(ADDITIONAL_OPTION_CHARS, c);\n    }\n\n    /**\n     * Checks the char array for a matching char.\n     * @param chars the char array to search\n     * @param c the char to look for.\n     * @return {@code true} if {@code c} was in {@code ary}, {@code false} otherwise.\n     */\n    private static boolean search(final char[] chars, final char c) {\n        for (final char a : chars) {\n            if (a == c) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Validates whether {@code opt} is a permissible Option shortOpt. The rules that specify if the {@code opt}\n     * is valid are:\n     *\n     * <ul>\n     * <li>a single character {@code opt} that is either Chars.SP(special case), '?', '@' or a letter</li>\n     * <li>a multi character {@code opt} that only contains valid characters</li>\n     * </ul>\n     * </p><p>\n     * A character is valid if any of the following conditions are true:\n     * <ul>\n     * <li>it is a letter</li>\n     * <li>it is a currency symbol (such as '$')</li>\n     * <li>it is a connecting punctuation character (such as '_')</li>\n     * <li>it is a digit</li>\n     * <li>it is a numeric letter (such as a Roman numeral character)</li>\n     * <li>it is a combining mark</li>\n     * <li>it is a non-spacing mark</li>\n     * <li>isIdentifierIgnorable returns true for the character</li>\n     * <li>it is a hyphen/dash ('-')</li>\n     * </ul>\n     * </p><p>\n     * In case {@code opt} is {@code null} no further validation is performed.\n     *\n     * @param option The option string to validate, may be null\n     * @throws IllegalArgumentException if the Option is not valid.\n     */\n    static String validate(final String option) throws IllegalArgumentException {\n        // if opt is null do not check further.\n        if (option == null) {\n            return null;\n        }\n        if (option.isEmpty()) {\n            throw new IllegalArgumentException(\"Empty option name.\");\n        }\n        final char[] chars = option.toCharArray();\n        final char ch0 = chars[0];\n        if (!isValidOpt(ch0)) {\n            throw new IllegalArgumentException(String.format(\"Illegal option name '%s'.\", ch0));\n        }\n        // handle the multi-character opt\n        if (option.length() > 1) {\n            for (int i = 1; i < chars.length; i++) {\n                final char ch = chars[i];\n                if (!isValidChar(ch)) {\n                    throw new IllegalArgumentException(String.format(\"The option '%s' contains an illegal \" + \"character : '%s'.\", option, ch));\n                }\n            }\n        }\n        return option;\n    }\n}\n", "file_hash": "c3c422ffd2d7dbc7241e697ed7f4638fb53cb7bc77ba4fa2559697098a456334", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;"], "methods": [], "classes": [{"original_string": "final class OptionValidator {\n    /* package private for testing access */\n    /** The array of additional characters allowed as the first character in the option but not in the rest of the option */\n    static final char[] ADDITIONAL_OPTION_CHARS = {'?', '@'};\n    /** The array of additional characters allowed in the rest of the option but not in the first position */\n    static final char[] ADDITIONAL_LONG_CHARS = {'-'};\n\n    /**\n     * Returns whether the specified character is a valid character.\n     * A character is valid if any of the following conditions are true:\n     * <ul>\n     * <li>it is a letter</li>\n     * <li>it is a currency symbol (such as '$')</li>\n     * <li>it is a connecting punctuation character (such as '_')</li>\n     * <li>it is a digit</li>\n     * <li>it is a numeric letter (such as a Roman numeral character)</li>\n     * <li>it is a combining mark</li>\n     * <li>it is a non-spacing mark</li>\n     * <li>isIdentifierIgnorable returns true for the character</li>\n     * <li>it is a hyphen/dash ('-')</li>\n     * </ul>\n     * @param c the character to validate\n     * @return true if {@code c} is a valid character letter.\n     */\n    private static boolean isValidChar(final char c) {\n        return Character.isJavaIdentifierPart(c) || search(ADDITIONAL_LONG_CHARS, c);\n    }\n\n    /**\n     * Returns whether the specified character is a valid Option.\n     * A character is valid if any of the following conditions are true:\n     * <ul>\n     * <li>it is a letter</li>\n     * <li>it is a currency symbol (such as '$')</li>\n     * <li>it is a connecting punctuation character (such as '_')</li>\n     * <li>it is a digit</li>\n     * <li>it is a numeric letter (such as a Roman numeral character)</li>\n     * <li>it is a combining mark</li>\n     * <li>it is a non-spacing mark</li>\n     * <li>isIdentifierIgnorable returns true for the character</li>\n     * <li>it is a question mark or 'at' sign ('?' or '@')</li>\n     * </ul>\n     * @param c the option to validate\n     * @return true if {@code c} is a letter, '?' or '@', otherwise false.\n     */\n    private static boolean isValidOpt(final char c) {\n        return Character.isJavaIdentifierPart(c) || search(ADDITIONAL_OPTION_CHARS, c);\n    }\n\n    /**\n     * Checks the char array for a matching char.\n     * @param chars the char array to search\n     * @param c the char to look for.\n     * @return {@code true} if {@code c} was in {@code ary}, {@code false} otherwise.\n     */\n    private static boolean search(final char[] chars, final char c) {\n        for (final char a : chars) {\n            if (a == c) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Validates whether {@code opt} is a permissible Option shortOpt. The rules that specify if the {@code opt}\n     * is valid are:\n     *\n     * <ul>\n     * <li>a single character {@code opt} that is either Chars.SP(special case), '?', '@' or a letter</li>\n     * <li>a multi character {@code opt} that only contains valid characters</li>\n     * </ul>\n     * </p><p>\n     * A character is valid if any of the following conditions are true:\n     * <ul>\n     * <li>it is a letter</li>\n     * <li>it is a currency symbol (such as '$')</li>\n     * <li>it is a connecting punctuation character (such as '_')</li>\n     * <li>it is a digit</li>\n     * <li>it is a numeric letter (such as a Roman numeral character)</li>\n     * <li>it is a combining mark</li>\n     * <li>it is a non-spacing mark</li>\n     * <li>isIdentifierIgnorable returns true for the character</li>\n     * <li>it is a hyphen/dash ('-')</li>\n     * </ul>\n     * </p><p>\n     * In case {@code opt} is {@code null} no further validation is performed.\n     *\n     * @param option The option string to validate, may be null\n     * @throws IllegalArgumentException if the Option is not valid.\n     */\n    static String validate(final String option) throws IllegalArgumentException {\n        // if opt is null do not check further.\n        if (option == null) {\n            return null;\n        }\n        if (option.isEmpty()) {\n            throw new IllegalArgumentException(\"Empty option name.\");\n        }\n        final char[] chars = option.toCharArray();\n        final char ch0 = chars[0];\n        if (!isValidOpt(ch0)) {\n            throw new IllegalArgumentException(String.format(\"Illegal option name '%s'.\", ch0));\n        }\n        // handle the multi-character opt\n        if (option.length() > 1) {\n            for (int i = 1; i < chars.length; i++) {\n                final char ch = chars[i];\n                if (!isValidChar(ch)) {\n                    throw new IllegalArgumentException(String.format(\"The option '%s' contains an illegal \" + \"character : '%s'.\", option, ch));\n                }\n            }\n        }\n        return option;\n    }\n}", "definition": "final class OptionValidator", "class_docstring": "\nValidates an Option string.\n", "name": "OptionValidator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "static final char[] ADDITIONAL_OPTION_CHARS = {'?', '@'};", "docstring": " The array of additional characters allowed as the first character in the option but not in the rest of the option", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char[]", "name": "ADDITIONAL_OPTION_CHARS = {'?', '@'}", "syntax_pass": true}, {"attribute_expression": "static final char[] ADDITIONAL_LONG_CHARS = {'-'};", "docstring": " The array of additional characters allowed in the rest of the option but not in the first position", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char[]", "name": "ADDITIONAL_LONG_CHARS = {'-'}", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static boolean isValidChar(final char c) {\n        return Character.isJavaIdentifierPart(c) || search(ADDITIONAL_LONG_CHARS, c);\n    }", "docstring": "\nReturns whether the specified character is a valid character.\nA character is valid if any of the following conditions are true:\n<ul>\n<li>it is a letter</li>\n<li>it is a currency symbol (such as '$')</li>\n<li>it is a connecting punctuation character (such as '_')</li>\n<li>it is a digit</li>\n<li>it is a numeric letter (such as a Roman numeral character)</li>\n<li>it is a combining mark</li>\n<li>it is a non-spacing mark</li>\n<li>isIdentifierIgnorable returns true for the character</li>\n<li>it is a hyphen/dash ('-')</li>\n</ul>\n@param c the character to validate\n@return true if {@code c} is a valid character letter.\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isValidChar", "params": [{"name": "c", "type": "char"}], "body": "                                                     {\n        return Character.isJavaIdentifierPart(c) || search(ADDITIONAL_LONG_CHARS, c);\n    }", "signature": "private static boolean isValidChar(final char c)"}, {"syntax_pass": true, "original_string": "    private static boolean isValidOpt(final char c) {\n        return Character.isJavaIdentifierPart(c) || search(ADDITIONAL_OPTION_CHARS, c);\n    }", "docstring": "\nReturns whether the specified character is a valid Option.\nA character is valid if any of the following conditions are true:\n<ul>\n<li>it is a letter</li>\n<li>it is a currency symbol (such as '$')</li>\n<li>it is a connecting punctuation character (such as '_')</li>\n<li>it is a digit</li>\n<li>it is a numeric letter (such as a Roman numeral character)</li>\n<li>it is a combining mark</li>\n<li>it is a non-spacing mark</li>\n<li>isIdentifierIgnorable returns true for the character</li>\n<li>it is a question mark or 'at' sign ('?' or '@')</li>\n</ul>\n@param c the option to validate\n@return true if {@code c} is a letter, '?' or '@', otherwise false.\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isValidOpt", "params": [{"name": "c", "type": "char"}], "body": "                                                    {\n        return Character.isJavaIdentifierPart(c) || search(ADDITIONAL_OPTION_CHARS, c);\n    }", "signature": "private static boolean isValidOpt(final char c)"}, {"syntax_pass": true, "original_string": "    private static boolean search(final char[] chars, final char c) {\n        for (final char a : chars) {\n            if (a == c) {\n                return true;\n            }\n        }\n        return false;\n    }", "docstring": "\nChecks the char array for a matching char.\n@param chars the char array to search\n@param c the char to look for.\n@return {@code true} if {@code c} was in {@code ary}, {@code false} otherwise.\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "search", "params": [{"name": "chars", "type": "char[]"}, {"name": "c", "type": "char"}], "body": "                                                                    {\n        for (final char a : chars) {\n            if (a == c) {\n                return true;\n            }\n        }\n        return false;\n    }", "signature": "private static boolean search(final char[] chars, final char c)"}, {"syntax_pass": true, "original_string": "    static String validate(final String option) throws IllegalArgumentException {\n        // if opt is null do not check further.\n        if (option == null) {\n            return null;\n        }\n        if (option.isEmpty()) {\n            throw new IllegalArgumentException(\"Empty option name.\");\n        }\n        final char[] chars = option.toCharArray();\n        final char ch0 = chars[0];\n        if (!isValidOpt(ch0)) {\n            throw new IllegalArgumentException(String.format(\"Illegal option name '%s'.\", ch0));\n        }\n        // handle the multi-character opt\n        if (option.length() > 1) {\n            for (int i = 1; i < chars.length; i++) {\n                final char ch = chars[i];\n                if (!isValidChar(ch)) {\n                    throw new IllegalArgumentException(String.format(\"The option '%s' contains an illegal \" + \"character : '%s'.\", option, ch));\n                }\n            }\n        }\n        return option;\n    }", "docstring": "\nValidates whether {@code opt} is a permissible Option shortOpt. The rules that specify if the {@code opt}\nis valid are:\n\n<ul>\n<li>a single character {@code opt} that is either Chars.SP(special case), '?', '@' or a letter</li>\n<li>a multi character {@code opt} that only contains valid characters</li>\n</ul>\n</p><p>\nA character is valid if any of the following conditions are true:\n<ul>\n<li>it is a letter</li>\n<li>it is a currency symbol (such as '$')</li>\n<li>it is a connecting punctuation character (such as '_')</li>\n<li>it is a digit</li>\n<li>it is a numeric letter (such as a Roman numeral character)</li>\n<li>it is a combining mark</li>\n<li>it is a non-spacing mark</li>\n<li>isIdentifierIgnorable returns true for the character</li>\n<li>it is a hyphen/dash ('-')</li>\n</ul>\n</p><p>\nIn case {@code opt} is {@code null} no further validation is performed.\n\n@param option The option string to validate, may be null\n@throws IllegalArgumentException if the Option is not valid.\n", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "name": "validate", "params": [{"name": "option", "type": "String"}], "body": "                                                                                {\n        // if opt is null do not check further.\n        if (option == null) {\n            return null;\n        }\n        if (option.isEmpty()) {\n            throw new IllegalArgumentException(\"Empty option name.\");\n        }\n        final char[] chars = option.toCharArray();\n        final char ch0 = chars[0];\n        if (!isValidOpt(ch0)) {\n            throw new IllegalArgumentException(String.format(\"Illegal option name '%s'.\", ch0));\n        }\n        // handle the multi-character opt\n        if (option.length() > 1) {\n            for (int i = 1; i < chars.length; i++) {\n                final char ch = chars[i];\n                if (!isValidChar(ch)) {\n                    throw new IllegalArgumentException(String.format(\"The option '%s' contains an illegal \" + \"character : '%s'.\", option, ch));\n                }\n            }\n        }\n        return option;\n    }", "signature": "static String validate(final String option)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/TypeHandler.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.URL;\nimport java.nio.file.Path;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * TypeHandler will handle the pluggable conversion and verification of Option types. It handles the mapping of classes to bot converters and verifiers. It\n * provides the default conversion and verification methods when converters and verifiers are not explicitly set.\n * <p>\n * If Options are serialized and deserialized their converters and verifiers will revert to the defaults defined in this class. To correctly de-serialize\n * Options with custom converters and/or verifiers, using the default serialization methods, this class should be properly configured with the custom converters\n * and verifiers for the specific class.\n * </p>\n */\npublic class TypeHandler {\n\n    /**\n     * The default TypeHandler.\n     */\n    private static final TypeHandler DEFAULT = new TypeHandler();\n\n    /** Value of hex conversion of strings */\n    private static final int HEX_RADIX = 16;\n\n    /**\n     * Returns the class whose name is {@code className}.\n     *\n     * @param className the class name\n     * @return The class if it is found\n     * @throws ParseException if the class could not be found\n     */\n    public static Class<?> createClass(final String className) throws ParseException {\n        return createValue(className, Class.class);\n    }\n\n    /**\n     * Returns the date represented by {@code string}.\n     * <p>\n     * This method is not yet implemented and always throws an {@link UnsupportedOperationException}.\n     * </p>\n     *\n     * @param string the date string\n     * @return The date if {@code string} is a valid date string, otherwise return null.\n     */\n    public static Date createDate(final String string) {\n        return createValueUnchecked(string, Date.class);\n    }\n\n    /**\n     * Creates a default converter map.\n     *\n     * @return a default converter map.\n     * @since 1.7.0\n     */\n    public static Map<Class<?>, Converter<?, ? extends Throwable>> createDefaultMap() {\n        return putDefaultMap(new HashMap<>());\n    }\n\n    /**\n     * Returns the File represented by {@code string}.\n     *\n     * @param string the File location\n     * @return The file represented by {@code string}.\n     */\n    public static File createFile(final String string) {\n        return createValueUnchecked(string, File.class);\n    }\n\n    /**\n     * Creates the File[] represented by {@code string}.\n     *\n     * <p>\n     * This method is not yet implemented and always throws an {@link UnsupportedOperationException}.\n     * </p>\n     *\n     * @param string the paths to the files\n     * @return The File[] represented by {@code string}.\n     * @throws UnsupportedOperationException always\n     * @deprecated with no replacement\n     */\n    @Deprecated // since 1.7.0\n    public static File[] createFiles(final String string) {\n        // to implement/port:\n        // return FileW.findFiles(string);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    /**\n     * Creates a number from a String. If a '.' is present, it creates a Double, otherwise a Long.\n     *\n     * @param string the value\n     * @return the number represented by {@code string}\n     * @throws ParseException if {@code string} is not a number\n     */\n    @Deprecated // since 1.7.0\n    public static Number createNumber(final String string) throws ParseException {\n        return createValue(string, Number.class);\n    }\n\n    /**\n     * Creates an Object from the class name and empty constructor.\n     *\n     * @param className the argument value\n     * @return the initialized object\n     * @throws ParseException if the class could not be found or the object could not be created\n     * @deprecated use {@link #createValue(String, Class)}\n     */\n    @Deprecated // since 1.7.0\n    public static Object createObject(final String className) throws ParseException {\n        return createValue(className, Object.class);\n    }\n\n    /**\n     * Creates the URL represented by {@code string}.\n     *\n     * @param string the URL string\n     * @return The URL in {@code string} is well-formed\n     * @throws ParseException if the URL in {@code string} is not well-formed\n     */\n    public static URL createURL(final String string) throws ParseException {\n        return createValue(string, URL.class);\n    }\n\n    /**\n     * Creates the @code Object} of type {@code clazz} with the value of {@code string}.\n     *\n     * @param string the command line value\n     * @param clazz  the class representing the type of argument\n     * @param <T>    type of argument\n     * @return The instance of {@code clazz} initialized with the value of {@code string}.\n     * @throws ParseException if the value creation for the given class threw an exception.\n     */\n    public static <T> T createValue(final String string, final Class<T> clazz) throws ParseException {\n        try {\n            return getDefault().getConverter(clazz).apply(string);\n        } catch (final Throwable e) {\n            throw ParseException.wrap(e);\n        }\n    }\n\n    /**\n     * Creates the {@code Object} of type {@code obj} with the value of {@code string}.\n     *\n     * @param string the command line value\n     * @param obj    the type of argument\n     * @return The instance of {@code obj} initialized with the value of {@code string}.\n     * @throws ParseException if the value creation for the given object type failed\n     * @deprecated use {@link #createValue(String, Class)}\n     */\n    @Deprecated // since 1.7.0\n    public static Object createValue(final String string, final Object obj) throws ParseException {\n        return createValue(string, (Class<?>) obj);\n    }\n\n    /**\n     * Delegates to {@link #createValue(String, Class)} throwing IllegalArgumentException instead of ParseException.\n     *\n     * @param string the command line value\n     * @param clazz  the class representing the type of argument\n     * @param <T>    type of argument\n     * @return The instance of {@code clazz} initialized with the value of {@code string}.\n     * @throws IllegalArgumentException if the value creation for the given class threw an exception.\n     */\n    private static <T> T createValueUnchecked(final String string, final Class<T> clazz) {\n        try {\n            return createValue(string, clazz);\n        } catch (final ParseException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    /**\n     * Gets the default TypeHandler.\n     *\n     * @return the default TypeHandler.\n     * @since 1.7.0\n     */\n    public static TypeHandler getDefault() {\n        return DEFAULT;\n    }\n\n    /**\n     * Returns the opened FileInputStream represented by {@code string}.\n     *\n     * @param string the file location\n     * @return The file input stream represented by {@code string}.\n     * @throws ParseException if the file is not exist or not readable\n     * @deprecated use {@link #createValue(String, Class)}\n     */\n    @Deprecated // since 1.7.0\n    public static FileInputStream openFile(final String string) throws ParseException {\n        return createValue(string, FileInputStream.class);\n    }\n\n    private static Map<Class<?>, Converter<?, ? extends Throwable>> putDefaultMap(final Map<Class<?>, Converter<?, ? extends Throwable>> map) {\n        map.put(Object.class, Converter.OBJECT);\n        map.put(Class.class, Converter.CLASS);\n        map.put(Date.class, Converter.DATE);\n        map.put(File.class, Converter.FILE);\n        map.put(Path.class, Converter.PATH);\n        map.put(Number.class, Converter.NUMBER);\n        map.put(URL.class, Converter.URL);\n        map.put(FileInputStream.class, FileInputStream::new);\n        map.put(Long.class, Long::parseLong);\n        map.put(Integer.class, Integer::parseInt);\n        map.put(Short.class, Short::parseShort);\n        map.put(Byte.class, Byte::parseByte);\n        map.put(Character.class, s -> s.startsWith(\"\\\\u\") ? Character.toChars(Integer.parseInt(s.substring(2), HEX_RADIX))[0] : s.charAt(0));\n        map.put(Double.class, Double::parseDouble);\n        map.put(Float.class, Float::parseFloat);\n        map.put(BigInteger.class, BigInteger::new);\n        map.put(BigDecimal.class, BigDecimal::new);\n        return map;\n    }\n\n    /**\n     * Map of Class to Converter.\n     * <p>\n     * For each entry, that Class' type must match the Converter's first type.\n     * </p>\n     */\n    private final Map<Class<?>, Converter<?, ? extends Throwable>> converterMap;\n\n    /**\n     * Constructs a default initialized instance.\n     */\n    public TypeHandler() {\n        this(createDefaultMap());\n    }\n\n    /**\n     * Constructs a default initialized instance.\n     * <p>\n     * For each entry, that Class' type must match the Converter's first type.\n     * </p>\n     *\n     * @param converterMap The converter map, not null.\n     * @since 1.7.0\n     */\n    public TypeHandler(final Map<Class<?>, Converter<?, ? extends Throwable>> converterMap) {\n        this.converterMap = Objects.requireNonNull(converterMap, \"converterMap\");\n    }\n\n    /**\n     * Gets the registered converter for the the Class, or {@link Converter#DEFAULT} if absent.\n     *\n     * @param <T>   The Class parameter type.\n     * @param clazz The Class to get the Converter for.\n     * @return the registered converter if any, {@link Converter#DEFAULT} otherwise.\n     * @since 1.7.0\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public <T> Converter<T, ?> getConverter(final Class<T> clazz) {\n        return (Converter<T, ?>) converterMap.getOrDefault(clazz, Converter.DEFAULT);\n    }\n\n}\n", "file_hash": "35194b6c51c30dca80ca71d7c9a777d36f11ca230e1a2c9d9e3f5ee8d77f3489", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.io.File;", "import java.io.FileInputStream;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import java.net.URL;", "import java.nio.file.Path;", "import java.util.Date;", "import java.util.HashMap;", "import java.util.Map;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class TypeHandler {\n\n    /**\n     * The default TypeHandler.\n     */\n    private static final TypeHandler DEFAULT = new TypeHandler();\n\n    /** Value of hex conversion of strings */\n    private static final int HEX_RADIX = 16;\n\n    /**\n     * Returns the class whose name is {@code className}.\n     *\n     * @param className the class name\n     * @return The class if it is found\n     * @throws ParseException if the class could not be found\n     */\n    public static Class<?> createClass(final String className) throws ParseException {\n        return createValue(className, Class.class);\n    }\n\n    /**\n     * Returns the date represented by {@code string}.\n     * <p>\n     * This method is not yet implemented and always throws an {@link UnsupportedOperationException}.\n     * </p>\n     *\n     * @param string the date string\n     * @return The date if {@code string} is a valid date string, otherwise return null.\n     */\n    public static Date createDate(final String string) {\n        return createValueUnchecked(string, Date.class);\n    }\n\n    /**\n     * Creates a default converter map.\n     *\n     * @return a default converter map.\n     * @since 1.7.0\n     */\n    public static Map<Class<?>, Converter<?, ? extends Throwable>> createDefaultMap() {\n        return putDefaultMap(new HashMap<>());\n    }\n\n    /**\n     * Returns the File represented by {@code string}.\n     *\n     * @param string the File location\n     * @return The file represented by {@code string}.\n     */\n    public static File createFile(final String string) {\n        return createValueUnchecked(string, File.class);\n    }\n\n    /**\n     * Creates the File[] represented by {@code string}.\n     *\n     * <p>\n     * This method is not yet implemented and always throws an {@link UnsupportedOperationException}.\n     * </p>\n     *\n     * @param string the paths to the files\n     * @return The File[] represented by {@code string}.\n     * @throws UnsupportedOperationException always\n     * @deprecated with no replacement\n     */\n    @Deprecated // since 1.7.0\n    public static File[] createFiles(final String string) {\n        // to implement/port:\n        // return FileW.findFiles(string);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    /**\n     * Creates a number from a String. If a '.' is present, it creates a Double, otherwise a Long.\n     *\n     * @param string the value\n     * @return the number represented by {@code string}\n     * @throws ParseException if {@code string} is not a number\n     */\n    @Deprecated // since 1.7.0\n    public static Number createNumber(final String string) throws ParseException {\n        return createValue(string, Number.class);\n    }\n\n    /**\n     * Creates an Object from the class name and empty constructor.\n     *\n     * @param className the argument value\n     * @return the initialized object\n     * @throws ParseException if the class could not be found or the object could not be created\n     * @deprecated use {@link #createValue(String, Class)}\n     */\n    @Deprecated // since 1.7.0\n    public static Object createObject(final String className) throws ParseException {\n        return createValue(className, Object.class);\n    }\n\n    /**\n     * Creates the URL represented by {@code string}.\n     *\n     * @param string the URL string\n     * @return The URL in {@code string} is well-formed\n     * @throws ParseException if the URL in {@code string} is not well-formed\n     */\n    public static URL createURL(final String string) throws ParseException {\n        return createValue(string, URL.class);\n    }\n\n    /**\n     * Creates the @code Object} of type {@code clazz} with the value of {@code string}.\n     *\n     * @param string the command line value\n     * @param clazz  the class representing the type of argument\n     * @param <T>    type of argument\n     * @return The instance of {@code clazz} initialized with the value of {@code string}.\n     * @throws ParseException if the value creation for the given class threw an exception.\n     */\n    public static <T> T createValue(final String string, final Class<T> clazz) throws ParseException {\n        try {\n            return getDefault().getConverter(clazz).apply(string);\n        } catch (final Throwable e) {\n            throw ParseException.wrap(e);\n        }\n    }\n\n    /**\n     * Creates the {@code Object} of type {@code obj} with the value of {@code string}.\n     *\n     * @param string the command line value\n     * @param obj    the type of argument\n     * @return The instance of {@code obj} initialized with the value of {@code string}.\n     * @throws ParseException if the value creation for the given object type failed\n     * @deprecated use {@link #createValue(String, Class)}\n     */\n    @Deprecated // since 1.7.0\n    public static Object createValue(final String string, final Object obj) throws ParseException {\n        return createValue(string, (Class<?>) obj);\n    }\n\n    /**\n     * Delegates to {@link #createValue(String, Class)} throwing IllegalArgumentException instead of ParseException.\n     *\n     * @param string the command line value\n     * @param clazz  the class representing the type of argument\n     * @param <T>    type of argument\n     * @return The instance of {@code clazz} initialized with the value of {@code string}.\n     * @throws IllegalArgumentException if the value creation for the given class threw an exception.\n     */\n    private static <T> T createValueUnchecked(final String string, final Class<T> clazz) {\n        try {\n            return createValue(string, clazz);\n        } catch (final ParseException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    /**\n     * Gets the default TypeHandler.\n     *\n     * @return the default TypeHandler.\n     * @since 1.7.0\n     */\n    public static TypeHandler getDefault() {\n        return DEFAULT;\n    }\n\n    /**\n     * Returns the opened FileInputStream represented by {@code string}.\n     *\n     * @param string the file location\n     * @return The file input stream represented by {@code string}.\n     * @throws ParseException if the file is not exist or not readable\n     * @deprecated use {@link #createValue(String, Class)}\n     */\n    @Deprecated // since 1.7.0\n    public static FileInputStream openFile(final String string) throws ParseException {\n        return createValue(string, FileInputStream.class);\n    }\n\n    private static Map<Class<?>, Converter<?, ? extends Throwable>> putDefaultMap(final Map<Class<?>, Converter<?, ? extends Throwable>> map) {\n        map.put(Object.class, Converter.OBJECT);\n        map.put(Class.class, Converter.CLASS);\n        map.put(Date.class, Converter.DATE);\n        map.put(File.class, Converter.FILE);\n        map.put(Path.class, Converter.PATH);\n        map.put(Number.class, Converter.NUMBER);\n        map.put(URL.class, Converter.URL);\n        map.put(FileInputStream.class, FileInputStream::new);\n        map.put(Long.class, Long::parseLong);\n        map.put(Integer.class, Integer::parseInt);\n        map.put(Short.class, Short::parseShort);\n        map.put(Byte.class, Byte::parseByte);\n        map.put(Character.class, s -> s.startsWith(\"\\\\u\") ? Character.toChars(Integer.parseInt(s.substring(2), HEX_RADIX))[0] : s.charAt(0));\n        map.put(Double.class, Double::parseDouble);\n        map.put(Float.class, Float::parseFloat);\n        map.put(BigInteger.class, BigInteger::new);\n        map.put(BigDecimal.class, BigDecimal::new);\n        return map;\n    }\n\n    /**\n     * Map of Class to Converter.\n     * <p>\n     * For each entry, that Class' type must match the Converter's first type.\n     * </p>\n     */\n    private final Map<Class<?>, Converter<?, ? extends Throwable>> converterMap;\n\n    /**\n     * Constructs a default initialized instance.\n     */\n    public TypeHandler() {\n        this(createDefaultMap());\n    }\n\n    /**\n     * Constructs a default initialized instance.\n     * <p>\n     * For each entry, that Class' type must match the Converter's first type.\n     * </p>\n     *\n     * @param converterMap The converter map, not null.\n     * @since 1.7.0\n     */\n    public TypeHandler(final Map<Class<?>, Converter<?, ? extends Throwable>> converterMap) {\n        this.converterMap = Objects.requireNonNull(converterMap, \"converterMap\");\n    }\n\n    /**\n     * Gets the registered converter for the the Class, or {@link Converter#DEFAULT} if absent.\n     *\n     * @param <T>   The Class parameter type.\n     * @param clazz The Class to get the Converter for.\n     * @return the registered converter if any, {@link Converter#DEFAULT} otherwise.\n     * @since 1.7.0\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public <T> Converter<T, ?> getConverter(final Class<T> clazz) {\n        return (Converter<T, ?>) converterMap.getOrDefault(clazz, Converter.DEFAULT);\n    }\n\n}", "definition": "public class TypeHandler", "class_docstring": "\nTypeHandler will handle the pluggable conversion and verification of Option types. It handles the mapping of classes to bot converters and verifiers. It\nprovides the default conversion and verification methods when converters and verifiers are not explicitly set.\n<p>\nIf Options are serialized and deserialized their converters and verifiers will revert to the defaults defined in this class. To correctly de-serialize\nOptions with custom converters and/or verifiers, using the default serialization methods, this class should be properly configured with the custom converters\nand verifiers for the specific class.\n</p>\n", "name": "TypeHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final TypeHandler DEFAULT = new TypeHandler();", "docstring": "\nThe default TypeHandler.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TypeHandler", "name": "DEFAULT = new TypeHandler()", "syntax_pass": true}, {"attribute_expression": "private static final int HEX_RADIX = 16;", "docstring": " Value of hex conversion of strings", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "HEX_RADIX = 16", "syntax_pass": true}, {"attribute_expression": "private final Map<Class<?>, Converter<?, ? extends Throwable>> converterMap;", "docstring": "\nMap of Class to Converter.\n<p>\nFor each entry, that Class' type must match the Converter's first type.\n</p>\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Class<?>, Converter<?, ? extends Throwable>>", "name": "converterMap", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static Class<?> createClass(final String className) throws ParseException {\n        return createValue(className, Class.class);\n    }", "docstring": "\nReturns the class whose name is {@code className}.\n\n@param className the class name\n@return The class if it is found\n@throws ParseException if the class could not be found\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Class<?>", "classes": []}, "name": "createClass", "params": [{"name": "className", "type": "String"}], "body": "                                                                                     {\n        return createValue(className, Class.class);\n    }", "signature": "public static Class<?> createClass(final String className)"}, {"syntax_pass": true, "original_string": "    public static Date createDate(final String string) {\n        return createValueUnchecked(string, Date.class);\n    }", "docstring": "\nReturns the date represented by {@code string}.\n<p>\nThis method is not yet implemented and always throws an {@link UnsupportedOperationException}.\n</p>\n\n@param string the date string\n@return The date if {@code string} is a valid date string, otherwise return null.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Date", "classes": []}, "name": "createDate", "params": [{"name": "string", "type": "String"}], "body": "                                                       {\n        return createValueUnchecked(string, Date.class);\n    }", "signature": "public static Date createDate(final String string)"}, {"syntax_pass": true, "original_string": "    public static Map<Class<?>, Converter<?, ? extends Throwable>> createDefaultMap() {\n        return putDefaultMap(new HashMap<>());\n    }", "docstring": "\nCreates a default converter map.\n\n@return a default converter map.\n@since 1.7.0\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Map<Class<?>, Converter<?, ? extends Throwable>>", "classes": []}, "name": "createDefaultMap", "params": [], "body": "                                                                                      {\n        return putDefaultMap(new HashMap<>());\n    }", "signature": "public static Map<Class<?>, Converter<?, ? extends Throwable>> createDefaultMap()"}, {"syntax_pass": true, "original_string": "    public static File createFile(final String string) {\n        return createValueUnchecked(string, File.class);\n    }", "docstring": "\nReturns the File represented by {@code string}.\n\n@param string the File location\n@return The file represented by {@code string}.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "File", "classes": []}, "name": "createFile", "params": [{"name": "string", "type": "String"}], "body": "                                                       {\n        return createValueUnchecked(string, File.class);\n    }", "signature": "public static File createFile(final String string)"}, {"syntax_pass": true, "original_string": "    @Deprecated // since 1.7.0\n    public static File[] createFiles(final String string) {\n        // to implement/port:\n        // return FileW.findFiles(string);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }", "docstring": "\nCreates the File[] represented by {@code string}.\n\n<p>\nThis method is not yet implemented and always throws an {@link UnsupportedOperationException}.\n</p>\n\n@param string the paths to the files\n@return The File[] represented by {@code string}.\n@throws UnsupportedOperationException always\n@deprecated with no replacement\n", "attributes": {"modifiers": "@Deprecated // since 1.7.0\n    public static", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public", "static"], "comments": ["// since 1.7.0"], "return_type": "File[]", "classes": []}, "name": "createFiles", "params": [{"name": "string", "type": "String"}], "body": "                                                          {\n        // to implement/port:\n        // return FileW.findFiles(string);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }", "signature": "@Deprecated // since 1.7.0\n    public static File[] createFiles(final String string)"}, {"syntax_pass": true, "original_string": "    @Deprecated // since 1.7.0\n    public static Number createNumber(final String string) throws ParseException {\n        return createValue(string, Number.class);\n    }", "docstring": "\nCreates a number from a String. If a '.' is present, it creates a Double, otherwise a Long.\n\n@param string the value\n@return the number represented by {@code string}\n@throws ParseException if {@code string} is not a number\n", "attributes": {"modifiers": "@Deprecated // since 1.7.0\n    public static", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public", "static"], "comments": ["// since 1.7.0"], "return_type": "Number", "classes": []}, "name": "createNumber", "params": [{"name": "string", "type": "String"}], "body": "                                                                                 {\n        return createValue(string, Number.class);\n    }", "signature": "@Deprecated // since 1.7.0\n    public static Number createNumber(final String string)"}, {"syntax_pass": true, "original_string": "    @Deprecated // since 1.7.0\n    public static Object createObject(final String className) throws ParseException {\n        return createValue(className, Object.class);\n    }", "docstring": "\nCreates an Object from the class name and empty constructor.\n\n@param className the argument value\n@return the initialized object\n@throws ParseException if the class could not be found or the object could not be created\n@deprecated use {@link #createValue(String, Class)}\n", "attributes": {"modifiers": "@Deprecated // since 1.7.0\n    public static", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public", "static"], "comments": ["// since 1.7.0"], "return_type": "Object", "classes": []}, "name": "createObject", "params": [{"name": "className", "type": "String"}], "body": "                                                                                    {\n        return createValue(className, Object.class);\n    }", "signature": "@Deprecated // since 1.7.0\n    public static Object createObject(final String className)"}, {"syntax_pass": true, "original_string": "    public static URL createURL(final String string) throws ParseException {\n        return createValue(string, URL.class);\n    }", "docstring": "\nCreates the URL represented by {@code string}.\n\n@param string the URL string\n@return The URL in {@code string} is well-formed\n@throws ParseException if the URL in {@code string} is not well-formed\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "URL", "classes": []}, "name": "createURL", "params": [{"name": "string", "type": "String"}], "body": "                                                                           {\n        return createValue(string, URL.class);\n    }", "signature": "public static URL createURL(final String string)"}, {"syntax_pass": true, "original_string": "    public static <T> T createValue(final String string, final Class<T> clazz) throws ParseException {\n        try {\n            return getDefault().getConverter(clazz).apply(string);\n        } catch (final Throwable e) {\n            throw ParseException.wrap(e);\n        }\n    }", "docstring": "\nCreates the @code Object} of type {@code clazz} with the value of {@code string}.\n\n@param string the command line value\n@param clazz  the class representing the type of argument\n@param <T>    type of argument\n@return The instance of {@code clazz} initialized with the value of {@code string}.\n@throws ParseException if the value creation for the given class threw an exception.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "T", "classes": []}, "name": "createValue", "params": [{"name": "string", "type": "String"}, {"name": "clazz", "type": "Class<T>"}], "body": "                                                                                                     {\n        try {\n            return getDefault().getConverter(clazz).apply(string);\n        } catch (final Throwable e) {\n            throw ParseException.wrap(e);\n        }\n    }", "signature": "public static <T> T createValue(final String string, final Class<T> clazz)"}, {"syntax_pass": true, "original_string": "    @Deprecated // since 1.7.0\n    public static Object createValue(final String string, final Object obj) throws ParseException {\n        return createValue(string, (Class<?>) obj);\n    }", "docstring": "\nCreates the {@code Object} of type {@code obj} with the value of {@code string}.\n\n@param string the command line value\n@param obj    the type of argument\n@return The instance of {@code obj} initialized with the value of {@code string}.\n@throws ParseException if the value creation for the given object type failed\n@deprecated use {@link #createValue(String, Class)}\n", "attributes": {"modifiers": "@Deprecated // since 1.7.0\n    public static", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public", "static"], "comments": ["// since 1.7.0"], "return_type": "Object", "classes": []}, "name": "createValue", "params": [{"name": "string", "type": "String"}, {"name": "obj", "type": "Object"}], "body": "                                                                                                  {\n        return createValue(string, (Class<?>) obj);\n    }", "signature": "@Deprecated // since 1.7.0\n    public static Object createValue(final String string, final Object obj)"}, {"syntax_pass": true, "original_string": "    private static <T> T createValueUnchecked(final String string, final Class<T> clazz) {\n        try {\n            return createValue(string, clazz);\n        } catch (final ParseException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }", "docstring": "\nDelegates to {@link #createValue(String, Class)} throwing IllegalArgumentException instead of ParseException.\n\n@param string the command line value\n@param clazz  the class representing the type of argument\n@param <T>    type of argument\n@return The instance of {@code clazz} initialized with the value of {@code string}.\n@throws IllegalArgumentException if the value creation for the given class threw an exception.\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "T", "classes": []}, "name": "createValueUnchecked", "params": [{"name": "string", "type": "String"}, {"name": "clazz", "type": "Class<T>"}], "body": "                                                                                         {\n        try {\n            return createValue(string, clazz);\n        } catch (final ParseException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }", "signature": "private static <T> T createValueUnchecked(final String string, final Class<T> clazz)"}, {"syntax_pass": true, "original_string": "    public static TypeHandler getDefault() {\n        return DEFAULT;\n    }", "docstring": "\nGets the default TypeHandler.\n\n@return the default TypeHandler.\n@since 1.7.0\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "TypeHandler", "classes": []}, "name": "getDefault", "params": [], "body": "                                           {\n        return DEFAULT;\n    }", "signature": "public static TypeHandler getDefault()"}, {"syntax_pass": true, "original_string": "    @Deprecated // since 1.7.0\n    public static FileInputStream openFile(final String string) throws ParseException {\n        return createValue(string, FileInputStream.class);\n    }", "docstring": "\nReturns the opened FileInputStream represented by {@code string}.\n\n@param string the file location\n@return The file input stream represented by {@code string}.\n@throws ParseException if the file is not exist or not readable\n@deprecated use {@link #createValue(String, Class)}\n", "attributes": {"modifiers": "@Deprecated // since 1.7.0\n    public static", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public", "static"], "comments": ["// since 1.7.0"], "return_type": "FileInputStream", "classes": []}, "name": "openFile", "params": [{"name": "string", "type": "String"}], "body": "                                                                                      {\n        return createValue(string, FileInputStream.class);\n    }", "signature": "@Deprecated // since 1.7.0\n    public static FileInputStream openFile(final String string)"}, {"syntax_pass": true, "original_string": "    private static Map<Class<?>, Converter<?, ? extends Throwable>> putDefaultMap(final Map<Class<?>, Converter<?, ? extends Throwable>> map) {\n        map.put(Object.class, Converter.OBJECT);\n        map.put(Class.class, Converter.CLASS);\n        map.put(Date.class, Converter.DATE);\n        map.put(File.class, Converter.FILE);\n        map.put(Path.class, Converter.PATH);\n        map.put(Number.class, Converter.NUMBER);\n        map.put(URL.class, Converter.URL);\n        map.put(FileInputStream.class, FileInputStream::new);\n        map.put(Long.class, Long::parseLong);\n        map.put(Integer.class, Integer::parseInt);\n        map.put(Short.class, Short::parseShort);\n        map.put(Byte.class, Byte::parseByte);\n        map.put(Character.class, s -> s.startsWith(\"\\\\u\") ? Character.toChars(Integer.parseInt(s.substring(2), HEX_RADIX))[0] : s.charAt(0));\n        map.put(Double.class, Double::parseDouble);\n        map.put(Float.class, Float::parseFloat);\n        map.put(BigInteger.class, BigInteger::new);\n        map.put(BigDecimal.class, BigDecimal::new);\n        return map;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Map<Class<?>, Converter<?, ? extends Throwable>>", "classes": []}, "name": "putDefaultMap", "params": [{"name": "map", "type": "Map<Class<?>, Converter<?, ? extends Throwable>>"}], "body": "                                                                                                                                              {\n        map.put(Object.class, Converter.OBJECT);\n        map.put(Class.class, Converter.CLASS);\n        map.put(Date.class, Converter.DATE);\n        map.put(File.class, Converter.FILE);\n        map.put(Path.class, Converter.PATH);\n        map.put(Number.class, Converter.NUMBER);\n        map.put(URL.class, Converter.URL);\n        map.put(FileInputStream.class, FileInputStream::new);\n        map.put(Long.class, Long::parseLong);\n        map.put(Integer.class, Integer::parseInt);\n        map.put(Short.class, Short::parseShort);\n        map.put(Byte.class, Byte::parseByte);\n        map.put(Character.class, s -> s.startsWith(\"\\\\u\") ? Character.toChars(Integer.parseInt(s.substring(2), HEX_RADIX))[0] : s.charAt(0));\n        map.put(Double.class, Double::parseDouble);\n        map.put(Float.class, Float::parseFloat);\n        map.put(BigInteger.class, BigInteger::new);\n        map.put(BigDecimal.class, BigDecimal::new);\n        return map;\n    }", "signature": "private static Map<Class<?>, Converter<?, ? extends Throwable>> putDefaultMap(final Map<Class<?>, Converter<?, ? extends Throwable>> map)"}, {"syntax_pass": true, "original_string": "    public TypeHandler() {\n        this(createDefaultMap());\n    }", "docstring": "\nConstructs a default initialized instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TypeHandler", "params": [], "body": "                         {\n        this(createDefaultMap());\n    }", "signature": "public TypeHandler()"}, {"syntax_pass": true, "original_string": "    public TypeHandler(final Map<Class<?>, Converter<?, ? extends Throwable>> converterMap) {\n        this.converterMap = Objects.requireNonNull(converterMap, \"converterMap\");\n    }", "docstring": "\nConstructs a default initialized instance.\n<p>\nFor each entry, that Class' type must match the Converter's first type.\n</p>\n\n@param converterMap The converter map, not null.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TypeHandler", "params": [{"name": "converterMap", "type": "Map<Class<?>, Converter<?, ? extends Throwable>>"}], "body": "                                                                                            {\n        this.converterMap = Objects.requireNonNull(converterMap, \"converterMap\");\n    }", "signature": "public TypeHandler(final Map<Class<?>, Converter<?, ? extends Throwable>> converterMap)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public <T> Converter<T, ?> getConverter(final Class<T> clazz) {\n        return (Converter<T, ?>) converterMap.getOrDefault(clazz, Converter.DEFAULT);\n    }", "docstring": "\nGets the registered converter for the the Class, or {@link Converter#DEFAULT} if absent.\n\n@param <T>   The Class parameter type.\n@param clazz The Class to get the Converter for.\n@return the registered converter if any, {@link Converter#DEFAULT} otherwise.\n@since 1.7.0\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": ["// returned value will have type T because it is fixed by clazz"], "return_type": "Converter<T, ?>", "classes": []}, "name": "getConverter", "params": [{"name": "clazz", "type": "Class<T>"}], "body": "                                                                  {\n        return (Converter<T, ?>) converterMap.getOrDefault(clazz, Converter.DEFAULT);\n    }", "signature": "@SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public <T> Converter<T, ?> getConverter(final Class<T> clazz)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/Parser.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * {@code Parser} creates {@link CommandLine}s.\n *\n * @deprecated since 1.3, the two-pass parsing with the flatten method is not enough flexible to handle complex cases\n */\n@Deprecated\npublic abstract class Parser implements CommandLineParser {\n    /** CommandLine instance */\n    protected CommandLine cmd;\n\n    /** Current Options */\n    private Options options;\n\n    /** List of required options strings */\n    private List requiredOptions;\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!getRequiredOptions().isEmpty()) {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * Subclasses must implement this method to reduce the {@code arguments} that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Gets the options.\n     *\n     * @return the options.\n     */\n    protected Options getOptions() {\n        return options;\n    }\n\n    /**\n     * Gets the required options.\n     *\n     * @return the required options.\n     */\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n    /**\n     * Parses the specified {@code arguments} based on the specified {@link Options}.\n     *\n     * @param options the {@code Options}\n     * @param arguments the {@code arguments}\n     * @return the {@code CommandLine}\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parses the specified {@code arguments} based on the specified {@link Options}.\n     *\n     * @param options the {@code Options}\n     * @param arguments the {@code arguments}\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     * @return the {@code CommandLine}\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)\n            throws ParseException {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (final Option opt : options.helpOptions()) {\n            opt.clearValues();\n        }\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        // initialize members\n        setOptions(options);\n        cmd = CommandLine.builder().build();\n        boolean eatTheRest = false;\n        final List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments == null ? new String[0] : arguments, stopAtNonOption));\n        final ListIterator<String> iterator = tokenList.listIterator();\n        // process each flattened token\n        while (iterator.hasNext()) {\n            final String token = iterator.next();\n            if (token != null) {\n                // the value is the double-dash\n                if (\"--\".equals(token)) {\n                    eatTheRest = true;\n                } else if (\"-\".equals(token)) {\n                    // the value is a single dash\n                    if (stopAtNonOption) {\n                        eatTheRest = true;\n                    } else {\n                        cmd.addArg(token);\n                    }\n                } else if (token.startsWith(\"-\")) {\n                    // the value is an option\n                    if (stopAtNonOption && !getOptions().hasOption(token)) {\n                        eatTheRest = true;\n                        cmd.addArg(token);\n                    } else {\n                        processOption(token, iterator);\n                    }\n                } else {\n                    // the value is an argument\n                    cmd.addArg(token);\n                    if (stopAtNonOption) {\n                        eatTheRest = true;\n                    }\n                }\n                // eat the remaining tokens\n                if (eatTheRest) {\n                    while (iterator.hasNext()) {\n                        final String str = iterator.next();\n                        // ensure only one double-dash is added\n                        if (!\"--\".equals(str)) {\n                            cmd.addArg(str);\n                        }\n                    }\n                }\n            }\n        }\n        processProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }\n\n    /**\n     * Process the argument values for the specified Option {@code opt} using the values retrieved from the specified\n     * iterator {@code iter}.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line Options.\n     * @throws ParseException if an argument value is required and it is has not been found.\n     */\n    public void processArgs(final Option opt, final ListIterator<String> iter) throws ParseException {\n        // loop until an option is found\n        while (iter.hasNext()) {\n            final String str = iter.next();\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\")) {\n                iter.previous();\n                break;\n            }\n            // found a value\n            try {\n                opt.processValue(Util.stripLeadingAndTrailingQuotes(str));\n            } catch (final RuntimeException exp) {\n                iter.previous();\n                break;\n            }\n        }\n        if (opt.getValues() == null && !opt.hasOptionalArg()) {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    /**\n     * Process the Option specified by {@code arg} using the values retrieved from the specified iterator\n     * {@code iter}.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     * @throws ParseException if {@code arg} does not represent an Option\n     */\n    protected void processOption(final String arg, final ListIterator<String> iter) throws ParseException {\n        final boolean hasOption = getOptions().hasOption(arg);\n        // if there is no option throw an UnrecognizedOptionException\n        if (!hasOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n        // get the option represented by arg\n        final Option opt = (Option) getOptions().getOption(arg).clone();\n        // update the required options and groups\n        updateRequiredOptions(opt);\n        // if the option takes an argument value\n        if (opt.hasArg()) {\n            processArgs(opt, iter);\n        }\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n\n    /**\n     * Sets the values of Options using the values in {@code properties}.\n     *\n     * @param properties The value properties to be processed.\n     * @throws ParseException if there are any problems encountered while processing the properties.\n     */\n    protected void processProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.isSelected();\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties instance\n                final String value = properties.getProperty(option);\n                if (opt.hasArg()) {\n                    if (Util.isEmpty(opt.getValues())) {\n                        try {\n                            opt.processValue(value);\n                        } catch (final RuntimeException exp) { // NOPMD\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }\n\n    /**\n     * Sets the options.\n     *\n     * @param options the options.\n     */\n    protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = new ArrayList<>(options.getRequiredOptions());\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param opt\n     */\n    private void updateRequiredOptions(final Option opt) throws ParseException {\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired()) {\n            getRequiredOptions().remove(opt.getKey());\n        }\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null) {\n            final OptionGroup group = getOptions().getOptionGroup(opt);\n            if (group.isRequired()) {\n                getRequiredOptions().remove(group);\n            }\n            group.setSelected(opt);\n        }\n    }\n\n}\n", "file_hash": "5748eaef3c01bb0a42048f3e8fd9a434b5acd0a3103ae2773e64496f5a24fe6d", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Enumeration;", "import java.util.List;", "import java.util.ListIterator;", "import java.util.Properties;"], "methods": [], "classes": [{"original_string": "@Deprecated\npublic abstract class Parser implements CommandLineParser {\n    /** CommandLine instance */\n    protected CommandLine cmd;\n\n    /** Current Options */\n    private Options options;\n\n    /** List of required options strings */\n    private List requiredOptions;\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!getRequiredOptions().isEmpty()) {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * Subclasses must implement this method to reduce the {@code arguments} that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Gets the options.\n     *\n     * @return the options.\n     */\n    protected Options getOptions() {\n        return options;\n    }\n\n    /**\n     * Gets the required options.\n     *\n     * @return the required options.\n     */\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n    /**\n     * Parses the specified {@code arguments} based on the specified {@link Options}.\n     *\n     * @param options the {@code Options}\n     * @param arguments the {@code arguments}\n     * @return the {@code CommandLine}\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parses the specified {@code arguments} based on the specified {@link Options}.\n     *\n     * @param options the {@code Options}\n     * @param arguments the {@code arguments}\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     * @return the {@code CommandLine}\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)\n            throws ParseException {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (final Option opt : options.helpOptions()) {\n            opt.clearValues();\n        }\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        // initialize members\n        setOptions(options);\n        cmd = CommandLine.builder().build();\n        boolean eatTheRest = false;\n        final List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments == null ? new String[0] : arguments, stopAtNonOption));\n        final ListIterator<String> iterator = tokenList.listIterator();\n        // process each flattened token\n        while (iterator.hasNext()) {\n            final String token = iterator.next();\n            if (token != null) {\n                // the value is the double-dash\n                if (\"--\".equals(token)) {\n                    eatTheRest = true;\n                } else if (\"-\".equals(token)) {\n                    // the value is a single dash\n                    if (stopAtNonOption) {\n                        eatTheRest = true;\n                    } else {\n                        cmd.addArg(token);\n                    }\n                } else if (token.startsWith(\"-\")) {\n                    // the value is an option\n                    if (stopAtNonOption && !getOptions().hasOption(token)) {\n                        eatTheRest = true;\n                        cmd.addArg(token);\n                    } else {\n                        processOption(token, iterator);\n                    }\n                } else {\n                    // the value is an argument\n                    cmd.addArg(token);\n                    if (stopAtNonOption) {\n                        eatTheRest = true;\n                    }\n                }\n                // eat the remaining tokens\n                if (eatTheRest) {\n                    while (iterator.hasNext()) {\n                        final String str = iterator.next();\n                        // ensure only one double-dash is added\n                        if (!\"--\".equals(str)) {\n                            cmd.addArg(str);\n                        }\n                    }\n                }\n            }\n        }\n        processProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }\n\n    /**\n     * Process the argument values for the specified Option {@code opt} using the values retrieved from the specified\n     * iterator {@code iter}.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line Options.\n     * @throws ParseException if an argument value is required and it is has not been found.\n     */\n    public void processArgs(final Option opt, final ListIterator<String> iter) throws ParseException {\n        // loop until an option is found\n        while (iter.hasNext()) {\n            final String str = iter.next();\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\")) {\n                iter.previous();\n                break;\n            }\n            // found a value\n            try {\n                opt.processValue(Util.stripLeadingAndTrailingQuotes(str));\n            } catch (final RuntimeException exp) {\n                iter.previous();\n                break;\n            }\n        }\n        if (opt.getValues() == null && !opt.hasOptionalArg()) {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    /**\n     * Process the Option specified by {@code arg} using the values retrieved from the specified iterator\n     * {@code iter}.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     * @throws ParseException if {@code arg} does not represent an Option\n     */\n    protected void processOption(final String arg, final ListIterator<String> iter) throws ParseException {\n        final boolean hasOption = getOptions().hasOption(arg);\n        // if there is no option throw an UnrecognizedOptionException\n        if (!hasOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n        // get the option represented by arg\n        final Option opt = (Option) getOptions().getOption(arg).clone();\n        // update the required options and groups\n        updateRequiredOptions(opt);\n        // if the option takes an argument value\n        if (opt.hasArg()) {\n            processArgs(opt, iter);\n        }\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n\n    /**\n     * Sets the values of Options using the values in {@code properties}.\n     *\n     * @param properties The value properties to be processed.\n     * @throws ParseException if there are any problems encountered while processing the properties.\n     */\n    protected void processProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.isSelected();\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties instance\n                final String value = properties.getProperty(option);\n                if (opt.hasArg()) {\n                    if (Util.isEmpty(opt.getValues())) {\n                        try {\n                            opt.processValue(value);\n                        } catch (final RuntimeException exp) { // NOPMD\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }\n\n    /**\n     * Sets the options.\n     *\n     * @param options the options.\n     */\n    protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = new ArrayList<>(options.getRequiredOptions());\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param opt\n     */\n    private void updateRequiredOptions(final Option opt) throws ParseException {\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired()) {\n            getRequiredOptions().remove(opt.getKey());\n        }\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null) {\n            final OptionGroup group = getOptions().getOptionGroup(opt);\n            if (group.isRequired()) {\n                getRequiredOptions().remove(group);\n            }\n            group.setSelected(opt);\n        }\n    }\n\n}", "definition": "@Deprecated\npublic abstract class Parser implements CommandLineParser", "class_docstring": "\n{@code Parser} creates {@link CommandLine}s.\n\n@deprecated since 1.3, the two-pass parsing with the flatten method is not enough flexible to handle complex cases\n", "name": "Parser", "super_interfaces": ["CommandLineParser"], "superclasses": "", "attributes": {"modifiers": "@Deprecated\npublic abstract", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public", "abstract"], "comments": [], "fields": [{"attribute_expression": "protected CommandLine cmd;", "docstring": " CommandLine instance", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "CommandLine", "name": "cmd", "syntax_pass": true}, {"attribute_expression": "private Options options;", "docstring": " Current Options", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}, {"attribute_expression": "private List requiredOptions;", "docstring": " List of required options strings", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List", "name": "requiredOptions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!getRequiredOptions().isEmpty()) {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }", "docstring": "\nThrows a {@link MissingOptionException} if all of the required options are not present.\n\n@throws MissingOptionException if any of the required Options are not present.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "checkRequiredOptions", "params": [], "body": "                                                                        {\n        // if there are required options that have not been processed\n        if (!getRequiredOptions().isEmpty()) {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }", "signature": "protected void checkRequiredOptions()"}, {"syntax_pass": true, "original_string": "    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;", "docstring": "\nSubclasses must implement this method to reduce the {@code arguments} that have been passed to the parse method.\n\n@param opts The Options to parse the arguments by.\n@param arguments The arguments that have to be flattened.\n@param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n@return a String array of the flattened arguments\n@throws ParseException if there are any problems encountered while parsing the command line tokens.\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "String[]", "classes": []}, "name": "flatten", "params": [{"name": "opts", "type": "Options"}, {"name": "arguments", "type": "String[]"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "", "signature": "protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption)"}, {"syntax_pass": true, "original_string": "    protected Options getOptions() {\n        return options;\n    }", "docstring": "\nGets the options.\n\n@return the options.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Options", "classes": []}, "name": "getOptions", "params": [], "body": "                                   {\n        return options;\n    }", "signature": "protected Options getOptions()"}, {"syntax_pass": true, "original_string": "    protected List getRequiredOptions() {\n        return requiredOptions;\n    }", "docstring": "\nGets the required options.\n\n@return the required options.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "List", "classes": []}, "name": "getRequiredOptions", "params": [], "body": "                                        {\n        return requiredOptions;\n    }", "signature": "protected List getRequiredOptions()"}, {"syntax_pass": true, "original_string": "    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }", "docstring": "\nParses the specified {@code arguments} based on the specified {@link Options}.\n\n@param options the {@code Options}\n@param arguments the {@code arguments}\n@return the {@code CommandLine}\n@throws ParseException if there are any problems encountered while parsing the command line tokens.\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "parse", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}], "body": "                                                                                                    {\n        return parse(options, arguments, null, false);\n    }", "signature": "@Override\n    public CommandLine parse(final Options options, final String[] arguments)"}, {"syntax_pass": true, "original_string": "    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }", "docstring": "\nParses the specified {@code arguments} based on the specified {@link Options}.\n\n@param options the {@code Options}\n@param arguments the {@code arguments}\n@param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n       are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n       ParseException.\n@return the {@code CommandLine}\n@throws ParseException if an error occurs when parsing the arguments.\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "parse", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "                                                                                                                                   {\n        return parse(options, arguments, null, stopAtNonOption);\n    }", "signature": "@Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption)"}, {"syntax_pass": true, "original_string": "    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }", "docstring": "\nParse the arguments according to the specified options and properties.\n\n@param options the specified Options\n@param arguments the command line arguments\n@param properties command line option name-value pairs\n@return the list of atomic option and value tokens\n@throws ParseException if there are any problems encountered while parsing the command line tokens.\n@since 1.1\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "parse", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}, {"name": "properties", "type": "Properties"}], "body": "                                                                                                                                 {\n        return parse(options, arguments, properties, false);\n    }", "signature": "public CommandLine parse(final Options options, final String[] arguments, final Properties properties)"}, {"syntax_pass": true, "original_string": "    public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)\n            throws ParseException {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (final Option opt : options.helpOptions()) {\n            opt.clearValues();\n        }\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        // initialize members\n        setOptions(options);\n        cmd = CommandLine.builder().build();\n        boolean eatTheRest = false;\n        final List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments == null ? new String[0] : arguments, stopAtNonOption));\n        final ListIterator<String> iterator = tokenList.listIterator();\n        // process each flattened token\n        while (iterator.hasNext()) {\n            final String token = iterator.next();\n            if (token != null) {\n                // the value is the double-dash\n                if (\"--\".equals(token)) {\n                    eatTheRest = true;\n                } else if (\"-\".equals(token)) {\n                    // the value is a single dash\n                    if (stopAtNonOption) {\n                        eatTheRest = true;\n                    } else {\n                        cmd.addArg(token);\n                    }\n                } else if (token.startsWith(\"-\")) {\n                    // the value is an option\n                    if (stopAtNonOption && !getOptions().hasOption(token)) {\n                        eatTheRest = true;\n                        cmd.addArg(token);\n                    } else {\n                        processOption(token, iterator);\n                    }\n                } else {\n                    // the value is an argument\n                    cmd.addArg(token);\n                    if (stopAtNonOption) {\n                        eatTheRest = true;\n                    }\n                }\n                // eat the remaining tokens\n                if (eatTheRest) {\n                    while (iterator.hasNext()) {\n                        final String str = iterator.next();\n                        // ensure only one double-dash is added\n                        if (!\"--\".equals(str)) {\n                            cmd.addArg(str);\n                        }\n                    }\n                }\n            }\n        }\n        processProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }", "docstring": "\nParse the arguments according to the specified options and properties.\n\n@param options the specified Options\n@param arguments the command line arguments\n@param properties command line option name-value pairs\n@param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n       are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n       ParseException.\n@return the list of atomic option and value tokens\n@throws ParseException if there are any problems encountered while parsing the command line tokens.\n@since 1.1\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "parse", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}, {"name": "properties", "type": "Properties"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "                                  {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (final Option opt : options.helpOptions()) {\n            opt.clearValues();\n        }\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        // initialize members\n        setOptions(options);\n        cmd = CommandLine.builder().build();\n        boolean eatTheRest = false;\n        final List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments == null ? new String[0] : arguments, stopAtNonOption));\n        final ListIterator<String> iterator = tokenList.listIterator();\n        // process each flattened token\n        while (iterator.hasNext()) {\n            final String token = iterator.next();\n            if (token != null) {\n                // the value is the double-dash\n                if (\"--\".equals(token)) {\n                    eatTheRest = true;\n                } else if (\"-\".equals(token)) {\n                    // the value is a single dash\n                    if (stopAtNonOption) {\n                        eatTheRest = true;\n                    } else {\n                        cmd.addArg(token);\n                    }\n                } else if (token.startsWith(\"-\")) {\n                    // the value is an option\n                    if (stopAtNonOption && !getOptions().hasOption(token)) {\n                        eatTheRest = true;\n                        cmd.addArg(token);\n                    } else {\n                        processOption(token, iterator);\n                    }\n                } else {\n                    // the value is an argument\n                    cmd.addArg(token);\n                    if (stopAtNonOption) {\n                        eatTheRest = true;\n                    }\n                }\n                // eat the remaining tokens\n                if (eatTheRest) {\n                    while (iterator.hasNext()) {\n                        final String str = iterator.next();\n                        // ensure only one double-dash is added\n                        if (!\"--\".equals(str)) {\n                            cmd.addArg(str);\n                        }\n                    }\n                }\n            }\n        }\n        processProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }", "signature": "public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)"}, {"syntax_pass": true, "original_string": "    public void processArgs(final Option opt, final ListIterator<String> iter) throws ParseException {\n        // loop until an option is found\n        while (iter.hasNext()) {\n            final String str = iter.next();\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\")) {\n                iter.previous();\n                break;\n            }\n            // found a value\n            try {\n                opt.processValue(Util.stripLeadingAndTrailingQuotes(str));\n            } catch (final RuntimeException exp) {\n                iter.previous();\n                break;\n            }\n        }\n        if (opt.getValues() == null && !opt.hasOptionalArg()) {\n            throw new MissingArgumentException(opt);\n        }\n    }", "docstring": "\nProcess the argument values for the specified Option {@code opt} using the values retrieved from the specified\niterator {@code iter}.\n\n@param opt The current Option\n@param iter The iterator over the flattened command line Options.\n@throws ParseException if an argument value is required and it is has not been found.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "processArgs", "params": [{"name": "opt", "type": "Option"}, {"name": "iter", "type": "ListIterator<String>"}], "body": "                                                                                                     {\n        // loop until an option is found\n        while (iter.hasNext()) {\n            final String str = iter.next();\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\")) {\n                iter.previous();\n                break;\n            }\n            // found a value\n            try {\n                opt.processValue(Util.stripLeadingAndTrailingQuotes(str));\n            } catch (final RuntimeException exp) {\n                iter.previous();\n                break;\n            }\n        }\n        if (opt.getValues() == null && !opt.hasOptionalArg()) {\n            throw new MissingArgumentException(opt);\n        }\n    }", "signature": "public void processArgs(final Option opt, final ListIterator<String> iter)"}, {"syntax_pass": true, "original_string": "    protected void processOption(final String arg, final ListIterator<String> iter) throws ParseException {\n        final boolean hasOption = getOptions().hasOption(arg);\n        // if there is no option throw an UnrecognizedOptionException\n        if (!hasOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n        // get the option represented by arg\n        final Option opt = (Option) getOptions().getOption(arg).clone();\n        // update the required options and groups\n        updateRequiredOptions(opt);\n        // if the option takes an argument value\n        if (opt.hasArg()) {\n            processArgs(opt, iter);\n        }\n        // set the option on the command line\n        cmd.addOption(opt);\n    }", "docstring": "\nProcess the Option specified by {@code arg} using the values retrieved from the specified iterator\n{@code iter}.\n\n@param arg The String value representing an Option\n@param iter The iterator over the flattened command line arguments.\n@throws ParseException if {@code arg} does not represent an Option\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "processOption", "params": [{"name": "arg", "type": "String"}, {"name": "iter", "type": "ListIterator<String>"}], "body": "                                                                                                          {\n        final boolean hasOption = getOptions().hasOption(arg);\n        // if there is no option throw an UnrecognizedOptionException\n        if (!hasOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n        // get the option represented by arg\n        final Option opt = (Option) getOptions().getOption(arg).clone();\n        // update the required options and groups\n        updateRequiredOptions(opt);\n        // if the option takes an argument value\n        if (opt.hasArg()) {\n            processArgs(opt, iter);\n        }\n        // set the option on the command line\n        cmd.addOption(opt);\n    }", "signature": "protected void processOption(final String arg, final ListIterator<String> iter)"}, {"syntax_pass": true, "original_string": "    protected void processProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.isSelected();\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties instance\n                final String value = properties.getProperty(option);\n                if (opt.hasArg()) {\n                    if (Util.isEmpty(opt.getValues())) {\n                        try {\n                            opt.processValue(value);\n                        } catch (final RuntimeException exp) { // NOPMD\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }", "docstring": "\nSets the values of Options using the values in {@code properties}.\n\n@param properties The value properties to be processed.\n@throws ParseException if there are any problems encountered while processing the properties.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "processProperties", "params": [{"name": "properties", "type": "Properties"}], "body": "                                                                                        {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.isSelected();\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties instance\n                final String value = properties.getProperty(option);\n                if (opt.hasArg()) {\n                    if (Util.isEmpty(opt.getValues())) {\n                        try {\n                            opt.processValue(value);\n                        } catch (final RuntimeException exp) { // NOPMD\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }", "signature": "protected void processProperties(final Properties properties)"}, {"syntax_pass": true, "original_string": "    protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = new ArrayList<>(options.getRequiredOptions());\n    }", "docstring": "\nSets the options.\n\n@param options the options.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "setOptions", "params": [{"name": "options", "type": "Options"}], "body": "                                                     {\n        this.options = options;\n        this.requiredOptions = new ArrayList<>(options.getRequiredOptions());\n    }", "signature": "protected void setOptions(final Options options)"}, {"syntax_pass": true, "original_string": "    private void updateRequiredOptions(final Option opt) throws ParseException {\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired()) {\n            getRequiredOptions().remove(opt.getKey());\n        }\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null) {\n            final OptionGroup group = getOptions().getOptionGroup(opt);\n            if (group.isRequired()) {\n                getRequiredOptions().remove(group);\n            }\n            group.setSelected(opt);\n        }\n    }", "docstring": "\nRemoves the option or its group from the list of expected elements.\n\n@param opt\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "updateRequiredOptions", "params": [{"name": "opt", "type": "Option"}], "body": "                                                                               {\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired()) {\n            getRequiredOptions().remove(opt.getKey());\n        }\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null) {\n            final OptionGroup group = getOptions().getOptionGroup(opt);\n            if (group.isRequired()) {\n                getRequiredOptions().remove(group);\n            }\n            group.setSelected(opt);\n        }\n    }", "signature": "private void updateRequiredOptions(final Option opt)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/Options.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Main entry-point into the library.\n * <p>\n * Options represents a collection of {@link Option} objects, which describe the possible options for a command-line.\n * </p>\n * <p>\n * It may flexibly parse long and short options, with or without values. Additionally, it may parse only a portion of a\n * commandline, allowing for flexible multi-stage parsing.\n * </p>\n *\n * @see org.apache.commons.cli.CommandLine\n */\npublic class Options implements Serializable {\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** A map of the options with the character key */\n    private final Map<String, Option> shortOpts = new LinkedHashMap<>();\n\n    /** A map of the options with the long key */\n    private final Map<String, Option> longOpts = new LinkedHashMap<>();\n\n    /** A map of the required options */\n    // N.B. This can contain either a String (addOption) or an OptionGroup (addOptionGroup)\n    // TODO this seems wrong\n    private final List<Object> requiredOpts = new ArrayList<>();\n\n    /** A map of the option groups */\n    private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<>();\n\n    /**\n     * Adds an option instance\n     *\n     * @param opt the option that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOption(final Option opt) {\n        final String key = opt.getKey();\n        // add it to the long option list\n        if (opt.hasLongOpt()) {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n        // if the option is required add it to the required list\n        if (opt.isRequired()) {\n            if (requiredOpts.contains(key)) {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n        shortOpts.put(key, opt);\n        return this;\n    }\n\n    /**\n     * Adds an option that only contains a short-name.\n     * <p>\n     * It may be specified as requiring an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(final String opt, final boolean hasArg, final String description) {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }\n\n    /**\n     * Adds an option that only contains a short name.\n     * <p>\n     * The option does not take an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.3\n     */\n    public Options addOption(final String opt, final String description) {\n        addOption(opt, null, false, description);\n        return this;\n    }\n\n    /**\n     * Adds an option that contains a short-name and a long-name.\n     * <p>\n     * It may be specified as requiring an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(final String opt, final String longOpt, final boolean hasArg, final String description) {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }\n\n    /**\n     * Adds the specified option group.\n     *\n     * @param group the OptionGroup that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOptionGroup(final OptionGroup group) {\n        if (group.isRequired()) {\n            requiredOpts.add(group);\n        }\n        for (final Option option : group.getOptions()) {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n            optionGroups.put(option.getKey(), group);\n        }\n        return this;\n    }\n\n    /**\n     * Adds options to this option.  If any Option in {@code options} already exists\n     * in this Options an IllegalArgumentException is thrown\n     *\n     * @param options the options to add.\n     * @return The resulting Options instance.\n     * @since 1.7.0\n     */\n    public Options addOptions(final Options options) {\n        for (final Option opt : options.getOptions()) {\n            if (hasOption(opt.getKey())) {\n                throw new IllegalArgumentException(\"Duplicate key: \" + opt.getKey());\n            }\n            addOption(opt);\n        }\n        options.getOptionGroups().forEach(this::addOptionGroup);\n        return this;\n    }\n\n    /**\n     * Adds an option that contains a short-name and a long-name.\n     * <p>\n     * The added option is set as required. It may be specified as requiring an argument. This method is a shortcut for:\n     * </p>\n     * <pre>\n     * <code>\n     * Options option = new Option(opt, longOpt, hasArg, description);\n     * option.setRequired(true);\n     * options.add(option);\n     * </code>\n     * </pre>\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.4\n     */\n    public Options addRequiredOption(final String opt, final String longOpt, final boolean hasArg, final String description) {\n        final Option option = new Option(opt, longOpt, hasArg, description);\n        option.setRequired(true);\n        addOption(option);\n        return this;\n    }\n\n    /**\n     * Gets the options with a long name starting with the name specified.\n     *\n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        final List<String> matchingOpts = new ArrayList<>();\n        // for a perfect match return the single option only\n        if (longOpts.containsKey(clean)) {\n            return Collections.singletonList(clean);\n        }\n        for (final String longOpt : longOpts.keySet()) {\n            if (longOpt.startsWith(clean)) {\n                matchingOpts.add(longOpt);\n            }\n        }\n        return matchingOpts;\n    }\n\n    /**\n     * Gets the {@link Option} matching the long or short name specified.\n     * <p>\n     * The leading hyphens in the name are ignored (up to 2).\n     * </p>\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return the option represented by opt\n     */\n    public Option getOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        final Option option = shortOpts.get(clean);\n        return option != null ? option : longOpts.get(clean);\n    }\n\n    /**\n     * Gets the OptionGroup the {@code opt} belongs to.\n     *\n     * @param opt the option whose OptionGroup is being queried.\n     * @return the OptionGroup if {@code opt} is part of an OptionGroup, otherwise return null\n     */\n    public OptionGroup getOptionGroup(final Option opt) {\n        return optionGroups.get(opt.getKey());\n    }\n\n    /**\n     * Gets the OptionGroups that are members of this Options instance.\n     *\n     * @return a Collection of OptionGroup instances.\n     */\n    Collection<OptionGroup> getOptionGroups() {\n        /* The optionGroups map will have duplicates in the values() results.  We\n         * use the HashSet to filter out duplicates and return a collection of\n         * OpitonGroup.  The decision to return a Collection rather than a set\n         * was probably to keep symmetry with the getOptions() method.\n         */\n        return new HashSet<>(optionGroups.values());\n    }\n\n    /**\n     * Gets a read-only list of options in this set\n     *\n     * @return read-only Collection of {@link Option} objects in this descriptor\n     */\n    public Collection<Option> getOptions() {\n        return Collections.unmodifiableCollection(helpOptions());\n    }\n\n    /**\n     * Gets the required options.\n     *\n     * @return read-only List of required options\n     */\n    public List<?> getRequiredOptions() {\n        return Collections.unmodifiableList(requiredOpts);\n    }\n\n    /**\n     * Tests whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasLongOption(final String opt) {\n        return longOpts.containsKey(Util.stripLeadingHyphens(opt));\n    }\n\n    /**\n     * Tests whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     */\n    public boolean hasOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        return shortOpts.containsKey(clean) || longOpts.containsKey(clean);\n    }\n\n    /**\n     * Tests whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasShortOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        return shortOpts.containsKey(clean);\n    }\n\n    /**\n     * Returns the Options for use by the HelpFormatter.\n     *\n     * @return the List of Options\n     */\n    List<Option> helpOptions() {\n        return new ArrayList<>(shortOpts.values());\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder();\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n        return buf.toString();\n    }\n}\n", "file_hash": "d83bde826e20a04705b18133c2b7b56ba4a07cbe5bb54de6d64631f9d033da5d", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.io.Serializable;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.HashSet;", "import java.util.LinkedHashMap;", "import java.util.List;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "public class Options implements Serializable {\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** A map of the options with the character key */\n    private final Map<String, Option> shortOpts = new LinkedHashMap<>();\n\n    /** A map of the options with the long key */\n    private final Map<String, Option> longOpts = new LinkedHashMap<>();\n\n    /** A map of the required options */\n    // N.B. This can contain either a String (addOption) or an OptionGroup (addOptionGroup)\n    // TODO this seems wrong\n    private final List<Object> requiredOpts = new ArrayList<>();\n\n    /** A map of the option groups */\n    private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<>();\n\n    /**\n     * Adds an option instance\n     *\n     * @param opt the option that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOption(final Option opt) {\n        final String key = opt.getKey();\n        // add it to the long option list\n        if (opt.hasLongOpt()) {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n        // if the option is required add it to the required list\n        if (opt.isRequired()) {\n            if (requiredOpts.contains(key)) {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n        shortOpts.put(key, opt);\n        return this;\n    }\n\n    /**\n     * Adds an option that only contains a short-name.\n     * <p>\n     * It may be specified as requiring an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(final String opt, final boolean hasArg, final String description) {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }\n\n    /**\n     * Adds an option that only contains a short name.\n     * <p>\n     * The option does not take an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.3\n     */\n    public Options addOption(final String opt, final String description) {\n        addOption(opt, null, false, description);\n        return this;\n    }\n\n    /**\n     * Adds an option that contains a short-name and a long-name.\n     * <p>\n     * It may be specified as requiring an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(final String opt, final String longOpt, final boolean hasArg, final String description) {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }\n\n    /**\n     * Adds the specified option group.\n     *\n     * @param group the OptionGroup that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOptionGroup(final OptionGroup group) {\n        if (group.isRequired()) {\n            requiredOpts.add(group);\n        }\n        for (final Option option : group.getOptions()) {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n            optionGroups.put(option.getKey(), group);\n        }\n        return this;\n    }\n\n    /**\n     * Adds options to this option.  If any Option in {@code options} already exists\n     * in this Options an IllegalArgumentException is thrown\n     *\n     * @param options the options to add.\n     * @return The resulting Options instance.\n     * @since 1.7.0\n     */\n    public Options addOptions(final Options options) {\n        for (final Option opt : options.getOptions()) {\n            if (hasOption(opt.getKey())) {\n                throw new IllegalArgumentException(\"Duplicate key: \" + opt.getKey());\n            }\n            addOption(opt);\n        }\n        options.getOptionGroups().forEach(this::addOptionGroup);\n        return this;\n    }\n\n    /**\n     * Adds an option that contains a short-name and a long-name.\n     * <p>\n     * The added option is set as required. It may be specified as requiring an argument. This method is a shortcut for:\n     * </p>\n     * <pre>\n     * <code>\n     * Options option = new Option(opt, longOpt, hasArg, description);\n     * option.setRequired(true);\n     * options.add(option);\n     * </code>\n     * </pre>\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.4\n     */\n    public Options addRequiredOption(final String opt, final String longOpt, final boolean hasArg, final String description) {\n        final Option option = new Option(opt, longOpt, hasArg, description);\n        option.setRequired(true);\n        addOption(option);\n        return this;\n    }\n\n    /**\n     * Gets the options with a long name starting with the name specified.\n     *\n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        final List<String> matchingOpts = new ArrayList<>();\n        // for a perfect match return the single option only\n        if (longOpts.containsKey(clean)) {\n            return Collections.singletonList(clean);\n        }\n        for (final String longOpt : longOpts.keySet()) {\n            if (longOpt.startsWith(clean)) {\n                matchingOpts.add(longOpt);\n            }\n        }\n        return matchingOpts;\n    }\n\n    /**\n     * Gets the {@link Option} matching the long or short name specified.\n     * <p>\n     * The leading hyphens in the name are ignored (up to 2).\n     * </p>\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return the option represented by opt\n     */\n    public Option getOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        final Option option = shortOpts.get(clean);\n        return option != null ? option : longOpts.get(clean);\n    }\n\n    /**\n     * Gets the OptionGroup the {@code opt} belongs to.\n     *\n     * @param opt the option whose OptionGroup is being queried.\n     * @return the OptionGroup if {@code opt} is part of an OptionGroup, otherwise return null\n     */\n    public OptionGroup getOptionGroup(final Option opt) {\n        return optionGroups.get(opt.getKey());\n    }\n\n    /**\n     * Gets the OptionGroups that are members of this Options instance.\n     *\n     * @return a Collection of OptionGroup instances.\n     */\n    Collection<OptionGroup> getOptionGroups() {\n        /* The optionGroups map will have duplicates in the values() results.  We\n         * use the HashSet to filter out duplicates and return a collection of\n         * OpitonGroup.  The decision to return a Collection rather than a set\n         * was probably to keep symmetry with the getOptions() method.\n         */\n        return new HashSet<>(optionGroups.values());\n    }\n\n    /**\n     * Gets a read-only list of options in this set\n     *\n     * @return read-only Collection of {@link Option} objects in this descriptor\n     */\n    public Collection<Option> getOptions() {\n        return Collections.unmodifiableCollection(helpOptions());\n    }\n\n    /**\n     * Gets the required options.\n     *\n     * @return read-only List of required options\n     */\n    public List<?> getRequiredOptions() {\n        return Collections.unmodifiableList(requiredOpts);\n    }\n\n    /**\n     * Tests whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasLongOption(final String opt) {\n        return longOpts.containsKey(Util.stripLeadingHyphens(opt));\n    }\n\n    /**\n     * Tests whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     */\n    public boolean hasOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        return shortOpts.containsKey(clean) || longOpts.containsKey(clean);\n    }\n\n    /**\n     * Tests whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasShortOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        return shortOpts.containsKey(clean);\n    }\n\n    /**\n     * Returns the Options for use by the HelpFormatter.\n     *\n     * @return the List of Options\n     */\n    List<Option> helpOptions() {\n        return new ArrayList<>(shortOpts.values());\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder();\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n        return buf.toString();\n    }\n}", "definition": "public class Options implements Serializable", "class_docstring": "\nMain entry-point into the library.\n<p>\nOptions represents a collection of {@link Option} objects, which describe the possible options for a command-line.\n</p>\n<p>\nIt may flexibly parse long and short options, with or without values. Additionally, it may parse only a portion of a\ncommandline, allowing for flexible multi-stage parsing.\n</p>\n\n@see org.apache.commons.cli.CommandLine\n", "name": "Options", "super_interfaces": ["Serializable"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": " The serial version UID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Option> shortOpts = new LinkedHashMap<>();", "docstring": " A map of the options with the character key", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Option>", "name": "shortOpts = new LinkedHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Option> longOpts = new LinkedHashMap<>();", "docstring": " A map of the options with the long key", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Option>", "name": "longOpts = new LinkedHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final List<Object> requiredOpts = new ArrayList<>();", "docstring": " TODO this seems wrong", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Object>", "name": "requiredOpts = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<>();", "docstring": " A map of the option groups", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, OptionGroup>", "name": "optionGroups = new LinkedHashMap<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Options addOption(final Option opt) {\n        final String key = opt.getKey();\n        // add it to the long option list\n        if (opt.hasLongOpt()) {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n        // if the option is required add it to the required list\n        if (opt.isRequired()) {\n            if (requiredOpts.contains(key)) {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n        shortOpts.put(key, opt);\n        return this;\n    }", "docstring": "\nAdds an option instance\n\n@param opt the option that is to be added\n@return the resulting Options instance\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Options", "classes": []}, "name": "addOption", "params": [{"name": "opt", "type": "Option"}], "body": "                                               {\n        final String key = opt.getKey();\n        // add it to the long option list\n        if (opt.hasLongOpt()) {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n        // if the option is required add it to the required list\n        if (opt.isRequired()) {\n            if (requiredOpts.contains(key)) {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n        shortOpts.put(key, opt);\n        return this;\n    }", "signature": "public Options addOption(final Option opt)"}, {"syntax_pass": true, "original_string": "    public Options addOption(final String opt, final boolean hasArg, final String description) {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }", "docstring": "\nAdds an option that only contains a short-name.\n<p>\nIt may be specified as requiring an argument.\n</p>\n\n@param opt Short single-character name of the option.\n@param hasArg flag signalling if an argument is required after this option\n@param description Self-documenting description\n@return the resulting Options instance\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Options", "classes": []}, "name": "addOption", "params": [{"name": "opt", "type": "String"}, {"name": "hasArg", "type": "boolean"}, {"name": "description", "type": "String"}], "body": "                                                                                               {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }", "signature": "public Options addOption(final String opt, final boolean hasArg, final String description)"}, {"syntax_pass": true, "original_string": "    public Options addOption(final String opt, final String description) {\n        addOption(opt, null, false, description);\n        return this;\n    }", "docstring": "\nAdds an option that only contains a short name.\n<p>\nThe option does not take an argument.\n</p>\n\n@param opt Short single-character name of the option.\n@param description Self-documenting description\n@return the resulting Options instance\n@since 1.3\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Options", "classes": []}, "name": "addOption", "params": [{"name": "opt", "type": "String"}, {"name": "description", "type": "String"}], "body": "                                                                         {\n        addOption(opt, null, false, description);\n        return this;\n    }", "signature": "public Options addOption(final String opt, final String description)"}, {"syntax_pass": true, "original_string": "    public Options addOption(final String opt, final String longOpt, final boolean hasArg, final String description) {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }", "docstring": "\nAdds an option that contains a short-name and a long-name.\n<p>\nIt may be specified as requiring an argument.\n</p>\n\n@param opt Short single-character name of the option.\n@param longOpt Long multi-character name of the option.\n@param hasArg flag signalling if an argument is required after this option\n@param description Self-documenting description\n@return the resulting Options instance\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Options", "classes": []}, "name": "addOption", "params": [{"name": "opt", "type": "String"}, {"name": "longOpt", "type": "String"}, {"name": "hasArg", "type": "boolean"}, {"name": "description", "type": "String"}], "body": "                                                                                                                     {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }", "signature": "public Options addOption(final String opt, final String longOpt, final boolean hasArg, final String description)"}, {"syntax_pass": true, "original_string": "    public Options addOptionGroup(final OptionGroup group) {\n        if (group.isRequired()) {\n            requiredOpts.add(group);\n        }\n        for (final Option option : group.getOptions()) {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n            optionGroups.put(option.getKey(), group);\n        }\n        return this;\n    }", "docstring": "\nAdds the specified option group.\n\n@param group the OptionGroup that is to be added\n@return the resulting Options instance\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Options", "classes": []}, "name": "addOptionGroup", "params": [{"name": "group", "type": "OptionGroup"}], "body": "                                                           {\n        if (group.isRequired()) {\n            requiredOpts.add(group);\n        }\n        for (final Option option : group.getOptions()) {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n            optionGroups.put(option.getKey(), group);\n        }\n        return this;\n    }", "signature": "public Options addOptionGroup(final OptionGroup group)"}, {"syntax_pass": true, "original_string": "    public Options addOptions(final Options options) {\n        for (final Option opt : options.getOptions()) {\n            if (hasOption(opt.getKey())) {\n                throw new IllegalArgumentException(\"Duplicate key: \" + opt.getKey());\n            }\n            addOption(opt);\n        }\n        options.getOptionGroups().forEach(this::addOptionGroup);\n        return this;\n    }", "docstring": "\nAdds options to this option.  If any Option in {@code options} already exists\nin this Options an IllegalArgumentException is thrown\n\n@param options the options to add.\n@return The resulting Options instance.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Options", "classes": []}, "name": "addOptions", "params": [{"name": "options", "type": "Options"}], "body": "                                                     {\n        for (final Option opt : options.getOptions()) {\n            if (hasOption(opt.getKey())) {\n                throw new IllegalArgumentException(\"Duplicate key: \" + opt.getKey());\n            }\n            addOption(opt);\n        }\n        options.getOptionGroups().forEach(this::addOptionGroup);\n        return this;\n    }", "signature": "public Options addOptions(final Options options)"}, {"syntax_pass": true, "original_string": "    public Options addRequiredOption(final String opt, final String longOpt, final boolean hasArg, final String description) {\n        final Option option = new Option(opt, longOpt, hasArg, description);\n        option.setRequired(true);\n        addOption(option);\n        return this;\n    }", "docstring": "\nAdds an option that contains a short-name and a long-name.\n<p>\nThe added option is set as required. It may be specified as requiring an argument. This method is a shortcut for:\n</p>\n<pre>\n<code>\nOptions option = new Option(opt, longOpt, hasArg, description);\noption.setRequired(true);\noptions.add(option);\n</code>\n</pre>\n\n@param opt Short single-character name of the option.\n@param longOpt Long multi-character name of the option.\n@param hasArg flag signalling if an argument is required after this option\n@param description Self-documenting description\n@return the resulting Options instance\n@since 1.4\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Options", "classes": []}, "name": "addRequiredOption", "params": [{"name": "opt", "type": "String"}, {"name": "longOpt", "type": "String"}, {"name": "hasArg", "type": "boolean"}, {"name": "description", "type": "String"}], "body": "                                                                                                                             {\n        final Option option = new Option(opt, longOpt, hasArg, description);\n        option.setRequired(true);\n        addOption(option);\n        return this;\n    }", "signature": "public Options addRequiredOption(final String opt, final String longOpt, final boolean hasArg, final String description)"}, {"syntax_pass": true, "original_string": "    public List<String> getMatchingOptions(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        final List<String> matchingOpts = new ArrayList<>();\n        // for a perfect match return the single option only\n        if (longOpts.containsKey(clean)) {\n            return Collections.singletonList(clean);\n        }\n        for (final String longOpt : longOpts.keySet()) {\n            if (longOpt.startsWith(clean)) {\n                matchingOpts.add(longOpt);\n            }\n        }\n        return matchingOpts;\n    }", "docstring": "\nGets the options with a long name starting with the name specified.\n\n@param opt the partial name of the option\n@return the options matching the partial name specified, or an empty list if none matches\n@since 1.3\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getMatchingOptions", "params": [{"name": "opt", "type": "String"}], "body": "                                                             {\n        final String clean = Util.stripLeadingHyphens(opt);\n        final List<String> matchingOpts = new ArrayList<>();\n        // for a perfect match return the single option only\n        if (longOpts.containsKey(clean)) {\n            return Collections.singletonList(clean);\n        }\n        for (final String longOpt : longOpts.keySet()) {\n            if (longOpt.startsWith(clean)) {\n                matchingOpts.add(longOpt);\n            }\n        }\n        return matchingOpts;\n    }", "signature": "public List<String> getMatchingOptions(final String opt)"}, {"syntax_pass": true, "original_string": "    public Option getOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        final Option option = shortOpts.get(clean);\n        return option != null ? option : longOpts.get(clean);\n    }", "docstring": "\nGets the {@link Option} matching the long or short name specified.\n<p>\nThe leading hyphens in the name are ignored (up to 2).\n</p>\n\n@param opt short or long name of the {@link Option}\n@return the option represented by opt\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Option", "classes": []}, "name": "getOption", "params": [{"name": "opt", "type": "String"}], "body": "                                              {\n        final String clean = Util.stripLeadingHyphens(opt);\n        final Option option = shortOpts.get(clean);\n        return option != null ? option : longOpts.get(clean);\n    }", "signature": "public Option getOption(final String opt)"}, {"syntax_pass": true, "original_string": "    public OptionGroup getOptionGroup(final Option opt) {\n        return optionGroups.get(opt.getKey());\n    }", "docstring": "\nGets the OptionGroup the {@code opt} belongs to.\n\n@param opt the option whose OptionGroup is being queried.\n@return the OptionGroup if {@code opt} is part of an OptionGroup, otherwise return null\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OptionGroup", "classes": []}, "name": "getOptionGroup", "params": [{"name": "opt", "type": "Option"}], "body": "                                                        {\n        return optionGroups.get(opt.getKey());\n    }", "signature": "public OptionGroup getOptionGroup(final Option opt)"}, {"syntax_pass": true, "original_string": "    Collection<OptionGroup> getOptionGroups() {\n        /* The optionGroups map will have duplicates in the values() results.  We\n         * use the HashSet to filter out duplicates and return a collection of\n         * OpitonGroup.  The decision to return a Collection rather than a set\n         * was probably to keep symmetry with the getOptions() method.\n         */\n        return new HashSet<>(optionGroups.values());\n    }", "docstring": "\nGets the OptionGroups that are members of this Options instance.\n\n@return a Collection of OptionGroup instances.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Collection<OptionGroup>", "classes": []}, "name": "getOptionGroups", "params": [], "body": "                                              {\n        /* The optionGroups map will have duplicates in the values() results.  We\n         * use the HashSet to filter out duplicates and return a collection of\n         * OpitonGroup.  The decision to return a Collection rather than a set\n         * was probably to keep symmetry with the getOptions() method.\n         */\n        return new HashSet<>(optionGroups.values());\n    }", "signature": "Collection<OptionGroup> getOptionGroups()"}, {"syntax_pass": true, "original_string": "    public Collection<Option> getOptions() {\n        return Collections.unmodifiableCollection(helpOptions());\n    }", "docstring": "\nGets a read-only list of options in this set\n\n@return read-only Collection of {@link Option} objects in this descriptor\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<Option>", "classes": []}, "name": "getOptions", "params": [], "body": "                                           {\n        return Collections.unmodifiableCollection(helpOptions());\n    }", "signature": "public Collection<Option> getOptions()"}, {"syntax_pass": true, "original_string": "    public List<?> getRequiredOptions() {\n        return Collections.unmodifiableList(requiredOpts);\n    }", "docstring": "\nGets the required options.\n\n@return read-only List of required options\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<?>", "classes": []}, "name": "getRequiredOptions", "params": [], "body": "                                        {\n        return Collections.unmodifiableList(requiredOpts);\n    }", "signature": "public List<?> getRequiredOptions()"}, {"syntax_pass": true, "original_string": "    public boolean hasLongOption(final String opt) {\n        return longOpts.containsKey(Util.stripLeadingHyphens(opt));\n    }", "docstring": "\nTests whether the named {@link Option} is a member of this {@link Options}.\n\n@param opt long name of the {@link Option}\n@return true if the named {@link Option} is a member of this {@link Options}\n@since 1.3\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasLongOption", "params": [{"name": "opt", "type": "String"}], "body": "                                                   {\n        return longOpts.containsKey(Util.stripLeadingHyphens(opt));\n    }", "signature": "public boolean hasLongOption(final String opt)"}, {"syntax_pass": true, "original_string": "    public boolean hasOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        return shortOpts.containsKey(clean) || longOpts.containsKey(clean);\n    }", "docstring": "\nTests whether the named {@link Option} is a member of this {@link Options}.\n\n@param opt short or long name of the {@link Option}\n@return true if the named {@link Option} is a member of this {@link Options}\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasOption", "params": [{"name": "opt", "type": "String"}], "body": "                                               {\n        final String clean = Util.stripLeadingHyphens(opt);\n        return shortOpts.containsKey(clean) || longOpts.containsKey(clean);\n    }", "signature": "public boolean hasOption(final String opt)"}, {"syntax_pass": true, "original_string": "    public boolean hasShortOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        return shortOpts.containsKey(clean);\n    }", "docstring": "\nTests whether the named {@link Option} is a member of this {@link Options}.\n\n@param opt short name of the {@link Option}\n@return true if the named {@link Option} is a member of this {@link Options}\n@since 1.3\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasShortOption", "params": [{"name": "opt", "type": "String"}], "body": "                                                    {\n        final String clean = Util.stripLeadingHyphens(opt);\n        return shortOpts.containsKey(clean);\n    }", "signature": "public boolean hasShortOption(final String opt)"}, {"syntax_pass": true, "original_string": "    List<Option> helpOptions() {\n        return new ArrayList<>(shortOpts.values());\n    }", "docstring": "\nReturns the Options for use by the HelpFormatter.\n\n@return the List of Options\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Option>", "classes": []}, "name": "helpOptions", "params": [], "body": "                               {\n        return new ArrayList<>(shortOpts.values());\n    }", "signature": "List<Option> helpOptions()"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder();\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n        return buf.toString();\n    }", "docstring": "\nDump state, suitable for debugging.\n\n@return Stringified form of this object\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        final StringBuilder buf = new StringBuilder();\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n        return buf.toString();\n    }", "signature": "@Override\n    public String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/PatternOptionBuilder.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.net.URL;\nimport java.util.Date;\nimport java.util.Map;\n\n/**\n * Allows Options to be created from a single String. The pattern contains various single character flags and via an\n * optional punctuation character, their expected type.\n *\n * <table border=\"1\">\n * <caption>Overview of PatternOptionBuilder patterns</caption>\n * <tr>\n * <td>a</td>\n * <td>-a flag</td>\n * </tr>\n * <tr>\n * <td>b@</td>\n * <td>-b [class name]</td>\n * </tr>\n * <tr>\n * <td>c&gt;</td>\n * <td>-c [file name]</td>\n * </tr>\n * <tr>\n * <td>d+</td>\n * <td>-d [class name] (creates object via empty constructor)</td>\n * </tr>\n * <tr>\n * <td>e%</td>\n * <td>-e [number] (creates Double/Long instance depending on existing of a '.')</td>\n * </tr>\n * <tr>\n * <td>f/</td>\n * <td>-f [URL]</td>\n * </tr>\n * <tr>\n * <td>g:</td>\n * <td>-g [string]</td>\n * </tr>\n * </table>\n *\n * <p>\n * For example, the following allows command line flags of '-v -p string-value -f /dir/file'. The exclamation mark\n * precede a mandatory option.\n * </p>\n *\n * <pre>\n * Options options = PatternOptionBuilder.parsePattern(\"vp:!f/\");\n * </pre>\n *\n * <p>\n * TODO These need to break out to OptionType and also to be pluggable.\n * </p>\n */\npublic class PatternOptionBuilder {\n\n    /** String class */\n    public static final Class<String> STRING_VALUE = String.class;\n\n    /** Object class */\n    public static final Class<Object> OBJECT_VALUE = Object.class;\n\n    /** Number class */\n    public static final Class<Number> NUMBER_VALUE = Number.class;\n\n    /** Date class */\n    public static final Class<Date> DATE_VALUE = Date.class;\n\n    /** Class class */\n    public static final Class<?> CLASS_VALUE = Class.class;\n\n    /// can we do this one??\n    // is meant to check that the file exists, else it errors.\n    // ie) it's for reading not writing.\n\n    /** FileInputStream class */\n    public static final Class<FileInputStream> EXISTING_FILE_VALUE = FileInputStream.class;\n\n    /** File class */\n    public static final Class<File> FILE_VALUE = File.class;\n\n    /** File array class */\n    public static final Class<File[]> FILES_VALUE = File[].class;\n\n    /** URL class */\n    public static final Class<URL> URL_VALUE = URL.class;\n\n    /** The converter to use for Unimplemented data types */\n    private static final Converter<?, UnsupportedOperationException> UNSUPPORTED = s -> {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    };\n\n    /**\n     * Retrieve the class that {@code ch} represents.\n     *\n     * @param ch the specified character\n     * @return The class that {@code ch} represents\n     * @deprecated use {@link #getValueType(char)}\n     */\n    @Deprecated // since=\"1.7.0\"\n    public static Object getValueClass(final char ch) {\n        return getValueType(ch);\n    }\n\n    /**\n     * Retrieve the class that {@code ch} represents.\n     *\n     * @param ch the specified character\n     * @return The class that {@code ch} represents\n     * @since 1.7.0\n     */\n    public static Class<?> getValueType(final char ch) {\n        switch (ch) {\n        case '@':\n            return OBJECT_VALUE;\n        case ':':\n            return STRING_VALUE;\n        case '%':\n            return NUMBER_VALUE;\n        case '+':\n            return CLASS_VALUE;\n        case '#':\n            return DATE_VALUE;\n        case '<':\n            return EXISTING_FILE_VALUE;\n        case '>':\n            return FILE_VALUE;\n        case '*':\n            return FILES_VALUE;\n        case '/':\n            return URL_VALUE;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns whether {@code ch} is a value code, i.e. whether it represents a class in a pattern.\n     *\n     * @param ch the specified character\n     * @return true if {@code ch} is a value code, otherwise false.\n     */\n    public static boolean isValueCode(final char ch) {\n        return ch == '@' || ch == ':' || ch == '%' || ch == '+' || ch == '#' || ch == '<' || ch == '>' || ch == '*' || ch == '/' || ch == '!';\n    }\n\n    /**\n     * Returns the {@link Options} instance represented by {@code pattern}.\n     *\n     * @param pattern the pattern string\n     * @return The {@link Options} instance\n     */\n    public static Options parsePattern(final String pattern) {\n        char opt = Char.SP;\n        boolean required = false;\n        Class<?> type = null;\n        Converter<?, ?> converter = Converter.DEFAULT;\n\n        final Options options = new Options();\n\n        for (int i = 0; i < pattern.length(); i++) {\n            final char ch = pattern.charAt(i);\n\n            // a value code comes after an option and specifies\n            // details about it\n            if (!isValueCode(ch)) {\n                if (opt != Char.SP) {\n                    // @formatter:off\n                    final Option option = Option.builder(String.valueOf(opt))\n                            .hasArg(type != null)\n                            .required(required)\n                            .type(type)\n                            .converter(converter)\n                            .build();\n                    // @formatter:on\n                    // we have a previous one to deal with\n                    options.addOption(option);\n                    required = false;\n                    type = null;\n                    converter = Converter.DEFAULT;\n                }\n\n                opt = ch;\n            } else if (ch == '!') {\n                required = true;\n            } else {\n                type = getValueType(ch);\n                final Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();\n                // Backward compatibility (probably).\n                map.put(FILES_VALUE, unsupported());\n                converter = new TypeHandler(map).getConverter(getValueType(ch));\n            }\n        }\n\n        if (opt != Char.SP) {\n            final Option option = Option.builder(String.valueOf(opt)).hasArg(type != null).required(required).type(type).build();\n\n            // we have a final one to deal with\n            options.addOption(option);\n        }\n\n        return options;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <T> T unsupported() {\n        return (T) UNSUPPORTED;\n    }\n}\n", "file_hash": "ad26418b5bbe6771e6e73b47418c1e9cd58f43edcf69738c42628ca8d97367b3", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.io.File;", "import java.io.FileInputStream;", "import java.net.URL;", "import java.util.Date;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "public class PatternOptionBuilder {\n\n    /** String class */\n    public static final Class<String> STRING_VALUE = String.class;\n\n    /** Object class */\n    public static final Class<Object> OBJECT_VALUE = Object.class;\n\n    /** Number class */\n    public static final Class<Number> NUMBER_VALUE = Number.class;\n\n    /** Date class */\n    public static final Class<Date> DATE_VALUE = Date.class;\n\n    /** Class class */\n    public static final Class<?> CLASS_VALUE = Class.class;\n\n    /// can we do this one??\n    // is meant to check that the file exists, else it errors.\n    // ie) it's for reading not writing.\n\n    /** FileInputStream class */\n    public static final Class<FileInputStream> EXISTING_FILE_VALUE = FileInputStream.class;\n\n    /** File class */\n    public static final Class<File> FILE_VALUE = File.class;\n\n    /** File array class */\n    public static final Class<File[]> FILES_VALUE = File[].class;\n\n    /** URL class */\n    public static final Class<URL> URL_VALUE = URL.class;\n\n    /** The converter to use for Unimplemented data types */\n    private static final Converter<?, UnsupportedOperationException> UNSUPPORTED = s -> {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    };\n\n    /**\n     * Retrieve the class that {@code ch} represents.\n     *\n     * @param ch the specified character\n     * @return The class that {@code ch} represents\n     * @deprecated use {@link #getValueType(char)}\n     */\n    @Deprecated // since=\"1.7.0\"\n    public static Object getValueClass(final char ch) {\n        return getValueType(ch);\n    }\n\n    /**\n     * Retrieve the class that {@code ch} represents.\n     *\n     * @param ch the specified character\n     * @return The class that {@code ch} represents\n     * @since 1.7.0\n     */\n    public static Class<?> getValueType(final char ch) {\n        switch (ch) {\n        case '@':\n            return OBJECT_VALUE;\n        case ':':\n            return STRING_VALUE;\n        case '%':\n            return NUMBER_VALUE;\n        case '+':\n            return CLASS_VALUE;\n        case '#':\n            return DATE_VALUE;\n        case '<':\n            return EXISTING_FILE_VALUE;\n        case '>':\n            return FILE_VALUE;\n        case '*':\n            return FILES_VALUE;\n        case '/':\n            return URL_VALUE;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns whether {@code ch} is a value code, i.e. whether it represents a class in a pattern.\n     *\n     * @param ch the specified character\n     * @return true if {@code ch} is a value code, otherwise false.\n     */\n    public static boolean isValueCode(final char ch) {\n        return ch == '@' || ch == ':' || ch == '%' || ch == '+' || ch == '#' || ch == '<' || ch == '>' || ch == '*' || ch == '/' || ch == '!';\n    }\n\n    /**\n     * Returns the {@link Options} instance represented by {@code pattern}.\n     *\n     * @param pattern the pattern string\n     * @return The {@link Options} instance\n     */\n    public static Options parsePattern(final String pattern) {\n        char opt = Char.SP;\n        boolean required = false;\n        Class<?> type = null;\n        Converter<?, ?> converter = Converter.DEFAULT;\n\n        final Options options = new Options();\n\n        for (int i = 0; i < pattern.length(); i++) {\n            final char ch = pattern.charAt(i);\n\n            // a value code comes after an option and specifies\n            // details about it\n            if (!isValueCode(ch)) {\n                if (opt != Char.SP) {\n                    // @formatter:off\n                    final Option option = Option.builder(String.valueOf(opt))\n                            .hasArg(type != null)\n                            .required(required)\n                            .type(type)\n                            .converter(converter)\n                            .build();\n                    // @formatter:on\n                    // we have a previous one to deal with\n                    options.addOption(option);\n                    required = false;\n                    type = null;\n                    converter = Converter.DEFAULT;\n                }\n\n                opt = ch;\n            } else if (ch == '!') {\n                required = true;\n            } else {\n                type = getValueType(ch);\n                final Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();\n                // Backward compatibility (probably).\n                map.put(FILES_VALUE, unsupported());\n                converter = new TypeHandler(map).getConverter(getValueType(ch));\n            }\n        }\n\n        if (opt != Char.SP) {\n            final Option option = Option.builder(String.valueOf(opt)).hasArg(type != null).required(required).type(type).build();\n\n            // we have a final one to deal with\n            options.addOption(option);\n        }\n\n        return options;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <T> T unsupported() {\n        return (T) UNSUPPORTED;\n    }\n}", "definition": "public class PatternOptionBuilder", "class_docstring": "\nAllows Options to be created from a single String. The pattern contains various single character flags and via an\noptional punctuation character, their expected type.\n\n<table border=\"1\">\n<caption>Overview of PatternOptionBuilder patterns</caption>\n<tr>\n<td>a</td>\n<td>-a flag</td>\n</tr>\n<tr>\n<td>b@</td>\n<td>-b [class name]</td>\n</tr>\n<tr>\n<td>c&gt;</td>\n<td>-c [file name]</td>\n</tr>\n<tr>\n<td>d+</td>\n<td>-d [class name] (creates object via empty constructor)</td>\n</tr>\n<tr>\n<td>e%</td>\n<td>-e [number] (creates Double/Long instance depending on existing of a '.')</td>\n</tr>\n<tr>\n<td>f/</td>\n<td>-f [URL]</td>\n</tr>\n<tr>\n<td>g:</td>\n<td>-g [string]</td>\n</tr>\n</table>\n\n<p>\nFor example, the following allows command line flags of '-v -p string-value -f /dir/file'. The exclamation mark\nprecede a mandatory option.\n</p>\n\n<pre>\nOptions options = PatternOptionBuilder.parsePattern(\"vp:!f/\");\n</pre>\n\n<p>\nTODO These need to break out to OptionType and also to be pluggable.\n</p>\n", "name": "PatternOptionBuilder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "public static final Class<String> STRING_VALUE = String.class;", "docstring": " String class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<String>", "name": "STRING_VALUE = String.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<Object> OBJECT_VALUE = Object.class;", "docstring": " Object class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<Object>", "name": "OBJECT_VALUE = Object.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<Number> NUMBER_VALUE = Number.class;", "docstring": " Number class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<Number>", "name": "NUMBER_VALUE = Number.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<Date> DATE_VALUE = Date.class;", "docstring": " Date class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<Date>", "name": "DATE_VALUE = Date.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<?> CLASS_VALUE = Class.class;", "docstring": " Class class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<?>", "name": "CLASS_VALUE = Class.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<FileInputStream> EXISTING_FILE_VALUE = FileInputStream.class;", "docstring": " FileInputStream class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<FileInputStream>", "name": "EXISTING_FILE_VALUE = FileInputStream.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<File> FILE_VALUE = File.class;", "docstring": " File class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<File>", "name": "FILE_VALUE = File.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<File[]> FILES_VALUE = File[].class;", "docstring": " File array class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<File[]>", "name": "FILES_VALUE = File[].class", "syntax_pass": true}, {"attribute_expression": "public static final Class<URL> URL_VALUE = URL.class;", "docstring": " URL class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<URL>", "name": "URL_VALUE = URL.class", "syntax_pass": true}, {"attribute_expression": "private static final Converter<?, UnsupportedOperationException> UNSUPPORTED = s -> {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    };", "docstring": " The converter to use for Unimplemented data types", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Converter<?, UnsupportedOperationException>", "name": "UNSUPPORTED = s -> {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Deprecated // since=\"1.7.0\"\n    public static Object getValueClass(final char ch) {\n        return getValueType(ch);\n    }", "docstring": "\nRetrieve the class that {@code ch} represents.\n\n@param ch the specified character\n@return The class that {@code ch} represents\n@deprecated use {@link #getValueType(char)}\n", "attributes": {"modifiers": "@Deprecated // since=\"1.7.0\"\n    public static", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public", "static"], "comments": ["// since=\"1.7.0\""], "return_type": "Object", "classes": []}, "name": "getValueClass", "params": [{"name": "ch", "type": "char"}], "body": "                                                      {\n        return getValueType(ch);\n    }", "signature": "@Deprecated // since=\"1.7.0\"\n    public static Object getValueClass(final char ch)"}, {"syntax_pass": true, "original_string": "    public static Class<?> getValueType(final char ch) {\n        switch (ch) {\n        case '@':\n            return OBJECT_VALUE;\n        case ':':\n            return STRING_VALUE;\n        case '%':\n            return NUMBER_VALUE;\n        case '+':\n            return CLASS_VALUE;\n        case '#':\n            return DATE_VALUE;\n        case '<':\n            return EXISTING_FILE_VALUE;\n        case '>':\n            return FILE_VALUE;\n        case '*':\n            return FILES_VALUE;\n        case '/':\n            return URL_VALUE;\n        }\n\n        return null;\n    }", "docstring": "\nRetrieve the class that {@code ch} represents.\n\n@param ch the specified character\n@return The class that {@code ch} represents\n@since 1.7.0\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Class<?>", "classes": []}, "name": "getValueType", "params": [{"name": "ch", "type": "char"}], "body": "                                                       {\n        switch (ch) {\n        case '@':\n            return OBJECT_VALUE;\n        case ':':\n            return STRING_VALUE;\n        case '%':\n            return NUMBER_VALUE;\n        case '+':\n            return CLASS_VALUE;\n        case '#':\n            return DATE_VALUE;\n        case '<':\n            return EXISTING_FILE_VALUE;\n        case '>':\n            return FILE_VALUE;\n        case '*':\n            return FILES_VALUE;\n        case '/':\n            return URL_VALUE;\n        }\n\n        return null;\n    }", "signature": "public static Class<?> getValueType(final char ch)"}, {"syntax_pass": true, "original_string": "    public static boolean isValueCode(final char ch) {\n        return ch == '@' || ch == ':' || ch == '%' || ch == '+' || ch == '#' || ch == '<' || ch == '>' || ch == '*' || ch == '/' || ch == '!';\n    }", "docstring": "\nReturns whether {@code ch} is a value code, i.e. whether it represents a class in a pattern.\n\n@param ch the specified character\n@return true if {@code ch} is a value code, otherwise false.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isValueCode", "params": [{"name": "ch", "type": "char"}], "body": "                                                     {\n        return ch == '@' || ch == ':' || ch == '%' || ch == '+' || ch == '#' || ch == '<' || ch == '>' || ch == '*' || ch == '/' || ch == '!';\n    }", "signature": "public static boolean isValueCode(final char ch)"}, {"syntax_pass": true, "original_string": "    public static Options parsePattern(final String pattern) {\n        char opt = Char.SP;\n        boolean required = false;\n        Class<?> type = null;\n        Converter<?, ?> converter = Converter.DEFAULT;\n\n        final Options options = new Options();\n\n        for (int i = 0; i < pattern.length(); i++) {\n            final char ch = pattern.charAt(i);\n\n            // a value code comes after an option and specifies\n            // details about it\n            if (!isValueCode(ch)) {\n                if (opt != Char.SP) {\n                    // @formatter:off\n                    final Option option = Option.builder(String.valueOf(opt))\n                            .hasArg(type != null)\n                            .required(required)\n                            .type(type)\n                            .converter(converter)\n                            .build();\n                    // @formatter:on\n                    // we have a previous one to deal with\n                    options.addOption(option);\n                    required = false;\n                    type = null;\n                    converter = Converter.DEFAULT;\n                }\n\n                opt = ch;\n            } else if (ch == '!') {\n                required = true;\n            } else {\n                type = getValueType(ch);\n                final Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();\n                // Backward compatibility (probably).\n                map.put(FILES_VALUE, unsupported());\n                converter = new TypeHandler(map).getConverter(getValueType(ch));\n            }\n        }\n\n        if (opt != Char.SP) {\n            final Option option = Option.builder(String.valueOf(opt)).hasArg(type != null).required(required).type(type).build();\n\n            // we have a final one to deal with\n            options.addOption(option);\n        }\n\n        return options;\n    }", "docstring": "\nReturns the {@link Options} instance represented by {@code pattern}.\n\n@param pattern the pattern string\n@return The {@link Options} instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Options", "classes": []}, "name": "parsePattern", "params": [{"name": "pattern", "type": "String"}], "body": "                                                             {\n        char opt = Char.SP;\n        boolean required = false;\n        Class<?> type = null;\n        Converter<?, ?> converter = Converter.DEFAULT;\n\n        final Options options = new Options();\n\n        for (int i = 0; i < pattern.length(); i++) {\n            final char ch = pattern.charAt(i);\n\n            // a value code comes after an option and specifies\n            // details about it\n            if (!isValueCode(ch)) {\n                if (opt != Char.SP) {\n                    // @formatter:off\n                    final Option option = Option.builder(String.valueOf(opt))\n                            .hasArg(type != null)\n                            .required(required)\n                            .type(type)\n                            .converter(converter)\n                            .build();\n                    // @formatter:on\n                    // we have a previous one to deal with\n                    options.addOption(option);\n                    required = false;\n                    type = null;\n                    converter = Converter.DEFAULT;\n                }\n\n                opt = ch;\n            } else if (ch == '!') {\n                required = true;\n            } else {\n                type = getValueType(ch);\n                final Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();\n                // Backward compatibility (probably).\n                map.put(FILES_VALUE, unsupported());\n                converter = new TypeHandler(map).getConverter(getValueType(ch));\n            }\n        }\n\n        if (opt != Char.SP) {\n            final Option option = Option.builder(String.valueOf(opt)).hasArg(type != null).required(required).type(type).build();\n\n            // we have a final one to deal with\n            options.addOption(option);\n        }\n\n        return options;\n    }", "signature": "public static Options parsePattern(final String pattern)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    static <T> T unsupported() {\n        return (T) UNSUPPORTED;\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "static"], "comments": [], "return_type": "T", "classes": []}, "name": "unsupported", "params": [], "body": "                               {\n        return (T) UNSUPPORTED;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    static <T> T unsupported()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/Char.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Package-private character constants.\n */\nfinal class Char {\n\n    /** Apostrophe */\n    static final char APOS = '\\'';\n\n    /** Carriage return. */\n    static final char CR = '\\r';\n\n    /** Equal sign. */\n    static final char EQUAL = '=';\n\n    /** Line feed. */\n    static final char LF = '\\n';\n\n    /** Space. */\n    static final char SP = ' ';\n\n    /** Tab. */\n    static final char TAB = '\\t';\n\n    private Char() {\n        // empty\n    }\n}\n", "file_hash": "2564cd386cdc88a70012b6260cf12daa9959c5082d689636398398d28b80e00d", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;"], "methods": [], "classes": [{"original_string": "final class Char {\n\n    /** Apostrophe */\n    static final char APOS = '\\'';\n\n    /** Carriage return. */\n    static final char CR = '\\r';\n\n    /** Equal sign. */\n    static final char EQUAL = '=';\n\n    /** Line feed. */\n    static final char LF = '\\n';\n\n    /** Space. */\n    static final char SP = ' ';\n\n    /** Tab. */\n    static final char TAB = '\\t';\n\n    private Char() {\n        // empty\n    }\n}", "definition": "final class Char", "class_docstring": "\nPackage-private character constants.\n", "name": "Char", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "static final char APOS = '\\'';", "docstring": " Apostrophe", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "APOS = '\\''", "syntax_pass": true}, {"attribute_expression": "static final char CR = '\\r';", "docstring": " Carriage return.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "CR = '\\r'", "syntax_pass": true}, {"attribute_expression": "static final char EQUAL = '=';", "docstring": " Equal sign.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "EQUAL = '='", "syntax_pass": true}, {"attribute_expression": "static final char LF = '\\n';", "docstring": " Line feed.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "LF = '\\n'", "syntax_pass": true}, {"attribute_expression": "static final char SP = ' ';", "docstring": " Space.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "SP = ' '", "syntax_pass": true}, {"attribute_expression": "static final char TAB = '\\t';", "docstring": " Tab.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "TAB = '\\t'", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private Char() {\n        // empty\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Char", "params": [], "body": "                   {\n        // empty\n    }", "signature": "private Char()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/CommandLine.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\n/**\n * Represents list of arguments parsed against a {@link Options} descriptor.\n * <p>\n * It allows querying of a boolean {@link #hasOption(String opt)}, in addition to retrieving the\n * {@link #getOptionValue(String opt)} for options requiring arguments.\n * </p>\n * <p>\n * Additionally, any left-over or unrecognized arguments, are available for further processing.\n * </p>\n */\npublic class CommandLine implements Serializable {\n\n    /**\n     * A nested builder class to create {@code CommandLine} instance using descriptive methods.\n     *\n     * @since 1.4\n     */\n    public static final class Builder {\n\n        /**\n         * Prints an Option to {@link System#out}.\n         */\n        static final Consumer<Option> DEPRECATED_HANDLER = o -> System.out.println(o.toDeprecatedString());\n\n        /** The unrecognized options/arguments */\n        private final List<String> args = new LinkedList<>();\n\n        /** The processed options */\n        private final List<Option> options = new ArrayList<>();\n\n        /**\n         * Deprecated Option handler.\n         */\n        private Consumer<Option> deprecatedHandler = DEPRECATED_HANDLER;\n\n        /**\n         * Adds left-over unrecognized option/argument.\n         *\n         * @param arg the unrecognized option/argument.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addArg(final String arg) {\n            if (arg != null) {\n                args.add(arg);\n            }\n            return this;\n        }\n\n        /**\n         * Adds an option to the command line. The values of the option are stored.\n         *\n         * @param opt the processed option.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addOption(final Option opt) {\n            if (opt != null) {\n                options.add(opt);\n            }\n            return this;\n        }\n\n        /**\n         * Creates the new instance.\n         *\n         * @return the new instance.\n         */\n        public CommandLine build() {\n            return new CommandLine(args, options, deprecatedHandler);\n        }\n\n        /**\n         * Sets the deprecated option handler.\n         *\n         * @param deprecatedHandler the deprecated option handler.\n         * @return {@code this} instance.\n         * @since 1.7.0\n         */\n        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }\n    }\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Creates a new builder.\n     *\n     * @return a new builder.\n     * @since 1.7.0\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    /** The unrecognized options/arguments */\n    private final List<String> args;\n\n    /** The processed options */\n    private final List<Option> options;\n\n    /**\n     * The deprecated option handler.\n     * <p>\n     * If you want to serialize this field, use a serialization proxy.\n     * </p>\n     */\n    private final transient Consumer<Option> deprecatedHandler;\n\n    /**\n     * Creates a command line.\n     */\n    protected CommandLine() {\n        this(new LinkedList<>(), new ArrayList<>(), Builder.DEPRECATED_HANDLER);\n    }\n\n    /**\n     * Creates a command line.\n     */\n    private CommandLine(final List<String> args, final List<Option> options, final Consumer<Option> deprecatedHandler) {\n        this.args = Objects.requireNonNull(args, \"args\");\n        this.options = Objects.requireNonNull(options, \"options\");\n        this.deprecatedHandler = deprecatedHandler;\n    }\n\n    /**\n     * Adds left-over unrecognized option/argument.\n     *\n     * @param arg the unrecognized option/argument.\n     */\n    protected void addArg(final String arg) {\n        if (arg != null) {\n            args.add(arg);\n        }\n    }\n\n    /**\n     * Adds an option to the command line. The values of the option are stored.\n     *\n     * @param opt the processed option.\n     */\n    protected void addOption(final Option opt) {\n        if (opt != null) {\n            options.add(opt);\n        }\n    }\n\n    private <T> T get(final Supplier<T> supplier) {\n        return supplier == null ? null : supplier.get();\n    }\n\n    /**\n     * Gets any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as a {@code List}.\n     */\n    public List<String> getArgList() {\n        return args;\n    }\n\n    /**\n     * Gets any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as an array.\n     */\n    public String[] getArgs() {\n        return args.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Gets the {@code Object} type of this {@code Option}.\n     *\n     * @deprecated due to System.err message. Instead use getParsedOptionValue(char)\n     * @param opt the name of the option.\n     * @return the type of opt.\n     */\n    @Deprecated\n    public Object getOptionObject(final char opt) {\n        return getOptionObject(String.valueOf(opt));\n    }\n\n    /**\n     * Gets the {@code Object} type of this {@code Option}.\n     *\n     * @param opt the name of the option.\n     * @return the type of this {@code Option}.\n     * @deprecated due to System.err message. Instead use getParsedOptionValue(String)\n     */\n    @Deprecated\n    public Object getOptionObject(final String opt) {\n        try {\n            return getParsedOptionValue(opt);\n        } catch (final ParseException pe) {\n            System.err.println(\"Exception found converting \" + opt + \" to desired type: \" + pe.getMessage());\n            return null;\n        }\n    }\n\n    /**\n     * Gets the map of values associated to the option. This is convenient for options specifying Java properties like\n     * <code>-Dparam1=value1\n     * -Dparam2=value2</code>. All odd numbered values are property keys\n     * and even numbered values are property values.  If there are an odd number of values\n     * the last value is assumed to be a boolean flag and the value is \"true\".\n     *\n     * @param option name of the option.\n     * @return The Properties mapped by the option, never {@code null} even if the option doesn't exists.\n     * @since 1.5.0\n     */\n    public Properties getOptionProperties(final Option option) {\n        final Properties props = new Properties();\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                processPropertiesFromValues(props, processedOption.getValuesList());\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Gets the map of values associated to the option. This is convenient for options specifying Java properties like\n     * <code>-Dparam1=value1\n     * -Dparam2=value2</code>. The first argument of the option is the key, and the 2nd argument is the value. If the option\n     * has only one argument ({@code -Dfoo}) it is considered as a boolean flag and the value is {@code \"true\"}.\n     *\n     * @param opt name of the option.\n     * @return The Properties mapped by the option, never {@code null} even if the option doesn't exists.\n     * @since 1.2\n     */\n    public Properties getOptionProperties(final String opt) {\n        final Properties props = new Properties();\n        for (final Option option : options) {\n            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt())) {\n                processPropertiesFromValues(props, option.getValuesList());\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Gets an array of the processed {@link Option}s.\n     *\n     * @return an array of the processed {@link Option}s.\n     */\n    public Option[] getOptions() {\n        return options.toArray(Option.EMPTY_ARRAY);\n    }\n\n    /**\n     * Gets the first argument, if any, of this option.\n     *\n     * @param opt the character name of the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String getOptionValue(final char opt) {\n        return getOptionValue(String.valueOf(opt));\n    }\n\n    /**\n     * Gets the argument, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     */\n    public String getOptionValue(final char opt, final String defaultValue) {\n        return getOptionValue(String.valueOf(opt), () -> defaultValue);\n    }\n\n    /**\n     * Gets the argument, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @param defaultValue is a supplier for the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.7.0\n     */\n    public String getOptionValue(final char opt, final Supplier<String> defaultValue) {\n        return getOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of this option.\n     *\n     * @param option the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     * @since 1.5.0\n     */\n    public String getOptionValue(final Option option) {\n        final String[] values = getOptionValues(option);\n        return values == null ? null : values[0];\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param option the option.\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.5.0\n     */\n    public String getOptionValue(final Option option, final String defaultValue) {\n        return getOptionValue(option, () -> defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param option the option.\n     * @param defaultValue is a supplier for the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.7.0\n     */\n    public String getOptionValue(final Option option, final Supplier<String> defaultValue) {\n        final String answer = getOptionValue(option);\n        return answer != null ? answer : get(defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of this option group.\n     *\n     * @param optionGroup the option group.\n     * @return Value of the argument if option group is selected, and has an argument, otherwise null.\n     * @since 1.9.0\n     */\n    public String getOptionValue(final OptionGroup optionGroup) {\n        final String[] values = getOptionValues(optionGroup);\n        return values == null ? null : values[0];\n    }\n\n    /**\n     * Gets the first argument, if any, of an option group.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue is the default value to be returned if the option group is not selected.\n     * @return Value of the argument if option group is selected, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.9.0\n     */\n    public String getOptionValue(final OptionGroup optionGroup, final String defaultValue) {\n        return getOptionValue(optionGroup, () -> defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of an option group.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue is a supplier for the default value to be returned if the option group is not selected.\n     * @return Value of the argument if option group is selected, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.9.0\n     */\n    public String getOptionValue(final OptionGroup optionGroup, final Supplier<String> defaultValue) {\n        final String answer = getOptionValue(optionGroup);\n        return answer != null ? answer : get(defaultValue);\n    }\n\n\n    /**\n     * Gets the first argument, if any, of this option.\n     *\n     * @param opt the name of the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String getOptionValue(final String opt) {\n        return getOptionValue(resolveOption(opt));\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param opt name of the option.\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     */\n    public String getOptionValue(final String opt, final String defaultValue) {\n        return getOptionValue(resolveOption(opt), () -> defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param opt name of the option.\n     * @param defaultValue is a supplier for the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.7.0\n     */\n    public String getOptionValue(final String opt, final Supplier<String> defaultValue) {\n        return getOptionValue(resolveOption(opt), defaultValue);\n    }\n\n\n    /**\n     * Gets the array of values, if any, of an option.\n     *\n     * @param opt character name of the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String[] getOptionValues(final char opt) {\n        return getOptionValues(String.valueOf(opt));\n    }\n\n    /**\n     * Gets the array of values, if any, of an option.\n     *\n     * @param option the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     * @since 1.5.0\n     */\n    public String[] getOptionValues(final Option option) {\n        if (option == null) {\n            return null;\n        }\n        final List<String> values = new ArrayList<>();\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                if (option.isDeprecated()) {\n                    handleDeprecated(option);\n                }\n                values.addAll(processedOption.getValuesList());\n            }\n        }\n        return values.isEmpty() ? null : values.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Gets the array of values, if any, of an option group.\n     *\n     * @param optionGroup the option group.\n     * @return Values of the argument if option group is selected, and has an argument, otherwise null.\n     * @since 1.9.0\n     */\n    public String[] getOptionValues(final OptionGroup optionGroup) {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return null;\n        }\n        return getOptionValues(optionGroup.getSelected());\n    }\n\n    /**\n     * Gets the array of values, if any, of an option.\n     *\n     * @param opt string name of the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String[] getOptionValues(final String opt) {\n        return getOptionValues(resolveOption(opt));\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.5.0\n     */\n    public <T> T getParsedOptionValue(final char opt) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt));\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final char opt, final Supplier<T> defaultValue) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final char opt, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param option the option.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.5.0\n     */\n    public <T> T getParsedOptionValue(final Option option) throws ParseException {\n        return getParsedOptionValue(option, () -> null);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param option the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getParsedOptionValue(final Option option, final Supplier<T> defaultValue) throws ParseException {\n        if (option == null) {\n            return get(defaultValue);\n        }\n        final String res = getOptionValue(option);\n        try {\n            if (res == null) {\n                return get(defaultValue);\n            }\n            return (T) option.getConverter().apply(res);\n        } catch (final Throwable e) {\n            throw ParseException.wrap(e);\n        }\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param option the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final Option option, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(option, () -> defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code OptionGroup} converted to a particular type.\n     *\n     * @param optionGroup the option group.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the selected option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.9.0\n     */\n    public <T> T getParsedOptionValue(final OptionGroup optionGroup) throws ParseException {\n        return getParsedOptionValue(optionGroup, () -> null);\n    }\n\n    /**\n     * Gets a version of this {@code OptionGroup} converted to a particular type.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the selected option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.9.0\n     */\n    public <T> T getParsedOptionValue(final OptionGroup optionGroup, final Supplier<T> defaultValue) throws ParseException {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return get(defaultValue);\n        }\n        return getParsedOptionValue(optionGroup.getSelected(), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code OptionGroup} converted to a particular type.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue the default value to return if an option is not selected.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.9.0\n     */\n    public <T> T getParsedOptionValue(final OptionGroup optionGroup, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(optionGroup, () -> defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.2\n     */\n    public <T> T getParsedOptionValue(final String opt) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt));\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final String opt, final Supplier<T> defaultValue) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final String opt, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt), defaultValue);\n    }\n\n    /**\n     * Handles deprecated options.\n     *\n     * @param option a deprecated option.\n     */\n    private void handleDeprecated(final Option option) {\n        if (deprecatedHandler != null) {\n            deprecatedHandler.accept(option);\n        }\n    }\n\n    /**\n     * jkeyes - commented out until it is implemented properly\n     * <p>\n     * Dump state, suitable for debugging.\n     * </p>\n     *\n     * @return Stringified form of this object.\n     */\n\n    /*\n     * public String toString() { StringBuilder buf = new StringBuilder();\n     *\n     * buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \");\n     * buf.append(args.toString()); buf.append(\" ] ]\");\n     *\n     * return buf.toString(); }\n     */\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt character name of the option.\n     * @return true if set, false if not.\n     */\n    public boolean hasOption(final char opt) {\n        return hasOption(String.valueOf(opt));\n    }\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt the option to check.\n     * @return true if set, false if not.\n     * @since 1.5.0\n     */\n    public boolean hasOption(final Option opt) {\n        final boolean result = options.contains(opt);\n        if (result && opt.isDeprecated()) {\n            handleDeprecated(opt);\n        }\n        return result;\n    }\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param optionGroup the option group to check.\n     * @return true if set, false if not.\n     * @since 1.9.0\n     */\n    public boolean hasOption(final OptionGroup optionGroup) {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return false;\n        }\n        return hasOption(optionGroup.getSelected());\n    }\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt Short name of the option.\n     * @return true if set, false if not.\n     */\n    public boolean hasOption(final String opt) {\n        return hasOption(resolveOption(opt));\n    }\n\n    /**\n     * Returns an iterator over the Option members of CommandLine.\n     *\n     * @return an {@code Iterator} over the processed {@link Option} members of this {@link CommandLine}.\n     */\n    public Iterator<Option> iterator() {\n        return options.iterator();\n    }\n\n    /**\n     * Parses a list of values as properties.  All odd numbered values are property keys\n     * and even numbered values are property values.  If there are an odd number of values\n     * the last value is assumed to be a boolean with a value of \"true\".\n     * @param props the properties to update.\n     * @param values the list of values to parse.\n     */\n    private void processPropertiesFromValues(final Properties props, final List<String> values) {\n        for (int i = 0; i < values.size(); i += 2) {\n            if (i + 1 < values.size()) {\n                props.put(values.get(i), values.get(i + 1));\n            } else {\n                props.put(values.get(i), \"true\");\n            }\n        }\n    }\n\n    /**\n     * Retrieves the option object given the long or short option as a String\n     *\n     * @param opt short or long name of the option, may be null.\n     * @return Canonicalized option.\n     */\n    private Option resolveOption(final String opt) {\n        final String actual = Util.stripLeadingHyphens(opt);\n        if (actual != null) {\n            for (final Option option : options) {\n                if (actual.equals(option.getOpt()) || actual.equals(option.getLongOpt())) {\n                    return option;\n                }\n            }\n        }\n        return null;\n    }\n}\n", "file_hash": "cd001b32b09ab20573935a215d9b3d76a12a77d6b925d4da8196119548d6ef4a", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.io.Serializable;", "import java.util.ArrayList;", "import java.util.Iterator;", "import java.util.LinkedList;", "import java.util.List;", "import java.util.Objects;", "import java.util.Properties;", "import java.util.function.Consumer;", "import java.util.function.Supplier;"], "methods": [], "classes": [{"original_string": "public class CommandLine implements Serializable {\n\n    /**\n     * A nested builder class to create {@code CommandLine} instance using descriptive methods.\n     *\n     * @since 1.4\n     */\n    public static final class Builder {\n\n        /**\n         * Prints an Option to {@link System#out}.\n         */\n        static final Consumer<Option> DEPRECATED_HANDLER = o -> System.out.println(o.toDeprecatedString());\n\n        /** The unrecognized options/arguments */\n        private final List<String> args = new LinkedList<>();\n\n        /** The processed options */\n        private final List<Option> options = new ArrayList<>();\n\n        /**\n         * Deprecated Option handler.\n         */\n        private Consumer<Option> deprecatedHandler = DEPRECATED_HANDLER;\n\n        /**\n         * Adds left-over unrecognized option/argument.\n         *\n         * @param arg the unrecognized option/argument.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addArg(final String arg) {\n            if (arg != null) {\n                args.add(arg);\n            }\n            return this;\n        }\n\n        /**\n         * Adds an option to the command line. The values of the option are stored.\n         *\n         * @param opt the processed option.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addOption(final Option opt) {\n            if (opt != null) {\n                options.add(opt);\n            }\n            return this;\n        }\n\n        /**\n         * Creates the new instance.\n         *\n         * @return the new instance.\n         */\n        public CommandLine build() {\n            return new CommandLine(args, options, deprecatedHandler);\n        }\n\n        /**\n         * Sets the deprecated option handler.\n         *\n         * @param deprecatedHandler the deprecated option handler.\n         * @return {@code this} instance.\n         * @since 1.7.0\n         */\n        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }\n    }\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Creates a new builder.\n     *\n     * @return a new builder.\n     * @since 1.7.0\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    /** The unrecognized options/arguments */\n    private final List<String> args;\n\n    /** The processed options */\n    private final List<Option> options;\n\n    /**\n     * The deprecated option handler.\n     * <p>\n     * If you want to serialize this field, use a serialization proxy.\n     * </p>\n     */\n    private final transient Consumer<Option> deprecatedHandler;\n\n    /**\n     * Creates a command line.\n     */\n    protected CommandLine() {\n        this(new LinkedList<>(), new ArrayList<>(), Builder.DEPRECATED_HANDLER);\n    }\n\n    /**\n     * Creates a command line.\n     */\n    private CommandLine(final List<String> args, final List<Option> options, final Consumer<Option> deprecatedHandler) {\n        this.args = Objects.requireNonNull(args, \"args\");\n        this.options = Objects.requireNonNull(options, \"options\");\n        this.deprecatedHandler = deprecatedHandler;\n    }\n\n    /**\n     * Adds left-over unrecognized option/argument.\n     *\n     * @param arg the unrecognized option/argument.\n     */\n    protected void addArg(final String arg) {\n        if (arg != null) {\n            args.add(arg);\n        }\n    }\n\n    /**\n     * Adds an option to the command line. The values of the option are stored.\n     *\n     * @param opt the processed option.\n     */\n    protected void addOption(final Option opt) {\n        if (opt != null) {\n            options.add(opt);\n        }\n    }\n\n    private <T> T get(final Supplier<T> supplier) {\n        return supplier == null ? null : supplier.get();\n    }\n\n    /**\n     * Gets any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as a {@code List}.\n     */\n    public List<String> getArgList() {\n        return args;\n    }\n\n    /**\n     * Gets any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as an array.\n     */\n    public String[] getArgs() {\n        return args.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Gets the {@code Object} type of this {@code Option}.\n     *\n     * @deprecated due to System.err message. Instead use getParsedOptionValue(char)\n     * @param opt the name of the option.\n     * @return the type of opt.\n     */\n    @Deprecated\n    public Object getOptionObject(final char opt) {\n        return getOptionObject(String.valueOf(opt));\n    }\n\n    /**\n     * Gets the {@code Object} type of this {@code Option}.\n     *\n     * @param opt the name of the option.\n     * @return the type of this {@code Option}.\n     * @deprecated due to System.err message. Instead use getParsedOptionValue(String)\n     */\n    @Deprecated\n    public Object getOptionObject(final String opt) {\n        try {\n            return getParsedOptionValue(opt);\n        } catch (final ParseException pe) {\n            System.err.println(\"Exception found converting \" + opt + \" to desired type: \" + pe.getMessage());\n            return null;\n        }\n    }\n\n    /**\n     * Gets the map of values associated to the option. This is convenient for options specifying Java properties like\n     * <code>-Dparam1=value1\n     * -Dparam2=value2</code>. All odd numbered values are property keys\n     * and even numbered values are property values.  If there are an odd number of values\n     * the last value is assumed to be a boolean flag and the value is \"true\".\n     *\n     * @param option name of the option.\n     * @return The Properties mapped by the option, never {@code null} even if the option doesn't exists.\n     * @since 1.5.0\n     */\n    public Properties getOptionProperties(final Option option) {\n        final Properties props = new Properties();\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                processPropertiesFromValues(props, processedOption.getValuesList());\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Gets the map of values associated to the option. This is convenient for options specifying Java properties like\n     * <code>-Dparam1=value1\n     * -Dparam2=value2</code>. The first argument of the option is the key, and the 2nd argument is the value. If the option\n     * has only one argument ({@code -Dfoo}) it is considered as a boolean flag and the value is {@code \"true\"}.\n     *\n     * @param opt name of the option.\n     * @return The Properties mapped by the option, never {@code null} even if the option doesn't exists.\n     * @since 1.2\n     */\n    public Properties getOptionProperties(final String opt) {\n        final Properties props = new Properties();\n        for (final Option option : options) {\n            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt())) {\n                processPropertiesFromValues(props, option.getValuesList());\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Gets an array of the processed {@link Option}s.\n     *\n     * @return an array of the processed {@link Option}s.\n     */\n    public Option[] getOptions() {\n        return options.toArray(Option.EMPTY_ARRAY);\n    }\n\n    /**\n     * Gets the first argument, if any, of this option.\n     *\n     * @param opt the character name of the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String getOptionValue(final char opt) {\n        return getOptionValue(String.valueOf(opt));\n    }\n\n    /**\n     * Gets the argument, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     */\n    public String getOptionValue(final char opt, final String defaultValue) {\n        return getOptionValue(String.valueOf(opt), () -> defaultValue);\n    }\n\n    /**\n     * Gets the argument, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @param defaultValue is a supplier for the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.7.0\n     */\n    public String getOptionValue(final char opt, final Supplier<String> defaultValue) {\n        return getOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of this option.\n     *\n     * @param option the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     * @since 1.5.0\n     */\n    public String getOptionValue(final Option option) {\n        final String[] values = getOptionValues(option);\n        return values == null ? null : values[0];\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param option the option.\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.5.0\n     */\n    public String getOptionValue(final Option option, final String defaultValue) {\n        return getOptionValue(option, () -> defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param option the option.\n     * @param defaultValue is a supplier for the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.7.0\n     */\n    public String getOptionValue(final Option option, final Supplier<String> defaultValue) {\n        final String answer = getOptionValue(option);\n        return answer != null ? answer : get(defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of this option group.\n     *\n     * @param optionGroup the option group.\n     * @return Value of the argument if option group is selected, and has an argument, otherwise null.\n     * @since 1.9.0\n     */\n    public String getOptionValue(final OptionGroup optionGroup) {\n        final String[] values = getOptionValues(optionGroup);\n        return values == null ? null : values[0];\n    }\n\n    /**\n     * Gets the first argument, if any, of an option group.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue is the default value to be returned if the option group is not selected.\n     * @return Value of the argument if option group is selected, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.9.0\n     */\n    public String getOptionValue(final OptionGroup optionGroup, final String defaultValue) {\n        return getOptionValue(optionGroup, () -> defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of an option group.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue is a supplier for the default value to be returned if the option group is not selected.\n     * @return Value of the argument if option group is selected, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.9.0\n     */\n    public String getOptionValue(final OptionGroup optionGroup, final Supplier<String> defaultValue) {\n        final String answer = getOptionValue(optionGroup);\n        return answer != null ? answer : get(defaultValue);\n    }\n\n\n    /**\n     * Gets the first argument, if any, of this option.\n     *\n     * @param opt the name of the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String getOptionValue(final String opt) {\n        return getOptionValue(resolveOption(opt));\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param opt name of the option.\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     */\n    public String getOptionValue(final String opt, final String defaultValue) {\n        return getOptionValue(resolveOption(opt), () -> defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param opt name of the option.\n     * @param defaultValue is a supplier for the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.7.0\n     */\n    public String getOptionValue(final String opt, final Supplier<String> defaultValue) {\n        return getOptionValue(resolveOption(opt), defaultValue);\n    }\n\n\n    /**\n     * Gets the array of values, if any, of an option.\n     *\n     * @param opt character name of the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String[] getOptionValues(final char opt) {\n        return getOptionValues(String.valueOf(opt));\n    }\n\n    /**\n     * Gets the array of values, if any, of an option.\n     *\n     * @param option the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     * @since 1.5.0\n     */\n    public String[] getOptionValues(final Option option) {\n        if (option == null) {\n            return null;\n        }\n        final List<String> values = new ArrayList<>();\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                if (option.isDeprecated()) {\n                    handleDeprecated(option);\n                }\n                values.addAll(processedOption.getValuesList());\n            }\n        }\n        return values.isEmpty() ? null : values.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Gets the array of values, if any, of an option group.\n     *\n     * @param optionGroup the option group.\n     * @return Values of the argument if option group is selected, and has an argument, otherwise null.\n     * @since 1.9.0\n     */\n    public String[] getOptionValues(final OptionGroup optionGroup) {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return null;\n        }\n        return getOptionValues(optionGroup.getSelected());\n    }\n\n    /**\n     * Gets the array of values, if any, of an option.\n     *\n     * @param opt string name of the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String[] getOptionValues(final String opt) {\n        return getOptionValues(resolveOption(opt));\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.5.0\n     */\n    public <T> T getParsedOptionValue(final char opt) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt));\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final char opt, final Supplier<T> defaultValue) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final char opt, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param option the option.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.5.0\n     */\n    public <T> T getParsedOptionValue(final Option option) throws ParseException {\n        return getParsedOptionValue(option, () -> null);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param option the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getParsedOptionValue(final Option option, final Supplier<T> defaultValue) throws ParseException {\n        if (option == null) {\n            return get(defaultValue);\n        }\n        final String res = getOptionValue(option);\n        try {\n            if (res == null) {\n                return get(defaultValue);\n            }\n            return (T) option.getConverter().apply(res);\n        } catch (final Throwable e) {\n            throw ParseException.wrap(e);\n        }\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param option the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final Option option, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(option, () -> defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code OptionGroup} converted to a particular type.\n     *\n     * @param optionGroup the option group.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the selected option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.9.0\n     */\n    public <T> T getParsedOptionValue(final OptionGroup optionGroup) throws ParseException {\n        return getParsedOptionValue(optionGroup, () -> null);\n    }\n\n    /**\n     * Gets a version of this {@code OptionGroup} converted to a particular type.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the selected option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.9.0\n     */\n    public <T> T getParsedOptionValue(final OptionGroup optionGroup, final Supplier<T> defaultValue) throws ParseException {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return get(defaultValue);\n        }\n        return getParsedOptionValue(optionGroup.getSelected(), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code OptionGroup} converted to a particular type.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue the default value to return if an option is not selected.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.9.0\n     */\n    public <T> T getParsedOptionValue(final OptionGroup optionGroup, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(optionGroup, () -> defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.2\n     */\n    public <T> T getParsedOptionValue(final String opt) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt));\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final String opt, final Supplier<T> defaultValue) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final String opt, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt), defaultValue);\n    }\n\n    /**\n     * Handles deprecated options.\n     *\n     * @param option a deprecated option.\n     */\n    private void handleDeprecated(final Option option) {\n        if (deprecatedHandler != null) {\n            deprecatedHandler.accept(option);\n        }\n    }\n\n    /**\n     * jkeyes - commented out until it is implemented properly\n     * <p>\n     * Dump state, suitable for debugging.\n     * </p>\n     *\n     * @return Stringified form of this object.\n     */\n\n    /*\n     * public String toString() { StringBuilder buf = new StringBuilder();\n     *\n     * buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \");\n     * buf.append(args.toString()); buf.append(\" ] ]\");\n     *\n     * return buf.toString(); }\n     */\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt character name of the option.\n     * @return true if set, false if not.\n     */\n    public boolean hasOption(final char opt) {\n        return hasOption(String.valueOf(opt));\n    }\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt the option to check.\n     * @return true if set, false if not.\n     * @since 1.5.0\n     */\n    public boolean hasOption(final Option opt) {\n        final boolean result = options.contains(opt);\n        if (result && opt.isDeprecated()) {\n            handleDeprecated(opt);\n        }\n        return result;\n    }\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param optionGroup the option group to check.\n     * @return true if set, false if not.\n     * @since 1.9.0\n     */\n    public boolean hasOption(final OptionGroup optionGroup) {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return false;\n        }\n        return hasOption(optionGroup.getSelected());\n    }\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt Short name of the option.\n     * @return true if set, false if not.\n     */\n    public boolean hasOption(final String opt) {\n        return hasOption(resolveOption(opt));\n    }\n\n    /**\n     * Returns an iterator over the Option members of CommandLine.\n     *\n     * @return an {@code Iterator} over the processed {@link Option} members of this {@link CommandLine}.\n     */\n    public Iterator<Option> iterator() {\n        return options.iterator();\n    }\n\n    /**\n     * Parses a list of values as properties.  All odd numbered values are property keys\n     * and even numbered values are property values.  If there are an odd number of values\n     * the last value is assumed to be a boolean with a value of \"true\".\n     * @param props the properties to update.\n     * @param values the list of values to parse.\n     */\n    private void processPropertiesFromValues(final Properties props, final List<String> values) {\n        for (int i = 0; i < values.size(); i += 2) {\n            if (i + 1 < values.size()) {\n                props.put(values.get(i), values.get(i + 1));\n            } else {\n                props.put(values.get(i), \"true\");\n            }\n        }\n    }\n\n    /**\n     * Retrieves the option object given the long or short option as a String\n     *\n     * @param opt short or long name of the option, may be null.\n     * @return Canonicalized option.\n     */\n    private Option resolveOption(final String opt) {\n        final String actual = Util.stripLeadingHyphens(opt);\n        if (actual != null) {\n            for (final Option option : options) {\n                if (actual.equals(option.getOpt()) || actual.equals(option.getLongOpt())) {\n                    return option;\n                }\n            }\n        }\n        return null;\n    }\n}", "definition": "public class CommandLine implements Serializable", "class_docstring": "\nRepresents list of arguments parsed against a {@link Options} descriptor.\n<p>\nIt allows querying of a boolean {@link #hasOption(String opt)}, in addition to retrieving the\n{@link #getOptionValue(String opt)} for options requiring arguments.\n</p>\n<p>\nAdditionally, any left-over or unrecognized arguments, are available for further processing.\n</p>\n", "name": "CommandLine", "super_interfaces": ["Serializable"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": " The serial version UID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final List<String> args;", "docstring": " The unrecognized options/arguments", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "args", "syntax_pass": true}, {"attribute_expression": "private final List<Option> options;", "docstring": " The processed options", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Option>", "name": "options", "syntax_pass": true}, {"attribute_expression": "private final transient Consumer<Option> deprecatedHandler;", "docstring": "\nThe deprecated option handler.\n<p>\nIf you want to serialize this field, use a serialization proxy.\n</p>\n", "modifiers": "private final transient", "marker_annotations": [], "non_marker_annotations": ["private", "final", "transient"], "comments": [], "type": "Consumer<Option>", "name": "deprecatedHandler", "syntax_pass": true}], "classes": [{"original_string": "    public static final class Builder {\n\n        /**\n         * Prints an Option to {@link System#out}.\n         */\n        static final Consumer<Option> DEPRECATED_HANDLER = o -> System.out.println(o.toDeprecatedString());\n\n        /** The unrecognized options/arguments */\n        private final List<String> args = new LinkedList<>();\n\n        /** The processed options */\n        private final List<Option> options = new ArrayList<>();\n\n        /**\n         * Deprecated Option handler.\n         */\n        private Consumer<Option> deprecatedHandler = DEPRECATED_HANDLER;\n\n        /**\n         * Adds left-over unrecognized option/argument.\n         *\n         * @param arg the unrecognized option/argument.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addArg(final String arg) {\n            if (arg != null) {\n                args.add(arg);\n            }\n            return this;\n        }\n\n        /**\n         * Adds an option to the command line. The values of the option are stored.\n         *\n         * @param opt the processed option.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addOption(final Option opt) {\n            if (opt != null) {\n                options.add(opt);\n            }\n            return this;\n        }\n\n        /**\n         * Creates the new instance.\n         *\n         * @return the new instance.\n         */\n        public CommandLine build() {\n            return new CommandLine(args, options, deprecatedHandler);\n        }\n\n        /**\n         * Sets the deprecated option handler.\n         *\n         * @param deprecatedHandler the deprecated option handler.\n         * @return {@code this} instance.\n         * @since 1.7.0\n         */\n        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }\n    }", "definition": "    public static final class Builder", "class_docstring": "\nA nested builder class to create {@code CommandLine} instance using descriptive methods.\n\n@since 1.4\n", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "static final Consumer<Option> DEPRECATED_HANDLER = o -> System.out.println(o.toDeprecatedString());", "docstring": "\nPrints an Option to {@link System#out}.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Consumer<Option>", "name": "DEPRECATED_HANDLER = o -> System.out.println(o.toDeprecatedString())", "syntax_pass": true}, {"attribute_expression": "private final List<String> args = new LinkedList<>();", "docstring": " The unrecognized options/arguments", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "args = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<Option> options = new ArrayList<>();", "docstring": " The processed options", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Option>", "name": "options = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private Consumer<Option> deprecatedHandler = DEPRECATED_HANDLER;", "docstring": "\nDeprecated Option handler.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Consumer<Option>", "name": "deprecatedHandler = DEPRECATED_HANDLER", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Builder addArg(final String arg) {\n            if (arg != null) {\n                args.add(arg);\n            }\n            return this;\n        }", "docstring": "\nAdds left-over unrecognized option/argument.\n\n@param arg the unrecognized option/argument.\n\n@return this Builder instance for method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "addArg", "params": [{"name": "arg", "type": "String"}], "body": "                                                {\n            if (arg != null) {\n                args.add(arg);\n            }\n            return this;\n        }", "signature": "public Builder addArg(final String arg)"}, {"syntax_pass": true, "original_string": "        public Builder addOption(final Option opt) {\n            if (opt != null) {\n                options.add(opt);\n            }\n            return this;\n        }", "docstring": "\nAdds an option to the command line. The values of the option are stored.\n\n@param opt the processed option.\n\n@return this Builder instance for method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "addOption", "params": [{"name": "opt", "type": "Option"}], "body": "                                                   {\n            if (opt != null) {\n                options.add(opt);\n            }\n            return this;\n        }", "signature": "public Builder addOption(final Option opt)"}, {"syntax_pass": true, "original_string": "        public CommandLine build() {\n            return new CommandLine(args, options, deprecatedHandler);\n        }", "docstring": "\nCreates the new instance.\n\n@return the new instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "build", "params": [], "body": "                                   {\n            return new CommandLine(args, options, deprecatedHandler);\n        }", "signature": "public CommandLine build()"}, {"syntax_pass": true, "original_string": "        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }", "docstring": "\nSets the deprecated option handler.\n\n@param deprecatedHandler the deprecated option handler.\n@return {@code this} instance.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setDeprecatedHandler", "params": [{"name": "deprecatedHandler", "type": "Consumer<Option>"}], "body": "                                                                                      {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }", "signature": "public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static Builder builder() {\n        return new Builder();\n    }", "docstring": "\nCreates a new builder.\n\n@return a new builder.\n@since 1.7.0\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "builder", "params": [], "body": "                                    {\n        return new Builder();\n    }", "signature": "public static Builder builder()"}, {"syntax_pass": true, "original_string": "    protected CommandLine() {\n        this(new LinkedList<>(), new ArrayList<>(), Builder.DEPRECATED_HANDLER);\n    }", "docstring": "\nCreates a command line.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "CommandLine", "params": [], "body": "                            {\n        this(new LinkedList<>(), new ArrayList<>(), Builder.DEPRECATED_HANDLER);\n    }", "signature": "protected CommandLine()"}, {"syntax_pass": true, "original_string": "    private CommandLine(final List<String> args, final List<Option> options, final Consumer<Option> deprecatedHandler) {\n        this.args = Objects.requireNonNull(args, \"args\");\n        this.options = Objects.requireNonNull(options, \"options\");\n        this.deprecatedHandler = deprecatedHandler;\n    }", "docstring": "\nCreates a command line.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "CommandLine", "params": [{"name": "args", "type": "List<String>"}, {"name": "options", "type": "List<Option>"}, {"name": "deprecatedHandler", "type": "Consumer<Option>"}], "body": "                                                                                                                       {\n        this.args = Objects.requireNonNull(args, \"args\");\n        this.options = Objects.requireNonNull(options, \"options\");\n        this.deprecatedHandler = deprecatedHandler;\n    }", "signature": "private CommandLine(final List<String> args, final List<Option> options, final Consumer<Option> deprecatedHandler)"}, {"syntax_pass": true, "original_string": "    protected void addArg(final String arg) {\n        if (arg != null) {\n            args.add(arg);\n        }\n    }", "docstring": "\nAdds left-over unrecognized option/argument.\n\n@param arg the unrecognized option/argument.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "addArg", "params": [{"name": "arg", "type": "String"}], "body": "                                            {\n        if (arg != null) {\n            args.add(arg);\n        }\n    }", "signature": "protected void addArg(final String arg)"}, {"syntax_pass": true, "original_string": "    protected void addOption(final Option opt) {\n        if (opt != null) {\n            options.add(opt);\n        }\n    }", "docstring": "\nAdds an option to the command line. The values of the option are stored.\n\n@param opt the processed option.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "addOption", "params": [{"name": "opt", "type": "Option"}], "body": "                                               {\n        if (opt != null) {\n            options.add(opt);\n        }\n    }", "signature": "protected void addOption(final Option opt)"}, {"syntax_pass": true, "original_string": "    private <T> T get(final Supplier<T> supplier) {\n        return supplier == null ? null : supplier.get();\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "T", "classes": []}, "name": "get", "params": [{"name": "supplier", "type": "Supplier<T>"}], "body": "                                                  {\n        return supplier == null ? null : supplier.get();\n    }", "signature": "private <T> T get(final Supplier<T> supplier)"}, {"syntax_pass": true, "original_string": "    public List<String> getArgList() {\n        return args;\n    }", "docstring": "\nGets any left-over non-recognized options and arguments\n\n@return remaining items passed in but not parsed as a {@code List}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getArgList", "params": [], "body": "                                     {\n        return args;\n    }", "signature": "public List<String> getArgList()"}, {"syntax_pass": true, "original_string": "    public String[] getArgs() {\n        return args.toArray(Util.EMPTY_STRING_ARRAY);\n    }", "docstring": "\nGets any left-over non-recognized options and arguments\n\n@return remaining items passed in but not parsed as an array.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String[]", "classes": []}, "name": "getArgs", "params": [], "body": "                              {\n        return args.toArray(Util.EMPTY_STRING_ARRAY);\n    }", "signature": "public String[] getArgs()"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public Object getOptionObject(final char opt) {\n        return getOptionObject(String.valueOf(opt));\n    }", "docstring": "\nGets the {@code Object} type of this {@code Option}.\n\n@deprecated due to System.err message. Instead use getParsedOptionValue(char)\n@param opt the name of the option.\n@return the type of opt.\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "getOptionObject", "params": [{"name": "opt", "type": "char"}], "body": "                                                  {\n        return getOptionObject(String.valueOf(opt));\n    }", "signature": "@Deprecated\n    public Object getOptionObject(final char opt)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public Object getOptionObject(final String opt) {\n        try {\n            return getParsedOptionValue(opt);\n        } catch (final ParseException pe) {\n            System.err.println(\"Exception found converting \" + opt + \" to desired type: \" + pe.getMessage());\n            return null;\n        }\n    }", "docstring": "\nGets the {@code Object} type of this {@code Option}.\n\n@param opt the name of the option.\n@return the type of this {@code Option}.\n@deprecated due to System.err message. Instead use getParsedOptionValue(String)\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "getOptionObject", "params": [{"name": "opt", "type": "String"}], "body": "                                                    {\n        try {\n            return getParsedOptionValue(opt);\n        } catch (final ParseException pe) {\n            System.err.println(\"Exception found converting \" + opt + \" to desired type: \" + pe.getMessage());\n            return null;\n        }\n    }", "signature": "@Deprecated\n    public Object getOptionObject(final String opt)"}, {"syntax_pass": true, "original_string": "    public Properties getOptionProperties(final Option option) {\n        final Properties props = new Properties();\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                processPropertiesFromValues(props, processedOption.getValuesList());\n            }\n        }\n        return props;\n    }", "docstring": "\nGets the map of values associated to the option. This is convenient for options specifying Java properties like\n<code>-Dparam1=value1\n-Dparam2=value2</code>. All odd numbered values are property keys\nand even numbered values are property values.  If there are an odd number of values\nthe last value is assumed to be a boolean flag and the value is \"true\".\n\n@param option name of the option.\n@return The Properties mapped by the option, never {@code null} even if the option doesn't exists.\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Properties", "classes": []}, "name": "getOptionProperties", "params": [{"name": "option", "type": "Option"}], "body": "                                                               {\n        final Properties props = new Properties();\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                processPropertiesFromValues(props, processedOption.getValuesList());\n            }\n        }\n        return props;\n    }", "signature": "public Properties getOptionProperties(final Option option)"}, {"syntax_pass": true, "original_string": "    public Properties getOptionProperties(final String opt) {\n        final Properties props = new Properties();\n        for (final Option option : options) {\n            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt())) {\n                processPropertiesFromValues(props, option.getValuesList());\n            }\n        }\n        return props;\n    }", "docstring": "\nGets the map of values associated to the option. This is convenient for options specifying Java properties like\n<code>-Dparam1=value1\n-Dparam2=value2</code>. The first argument of the option is the key, and the 2nd argument is the value. If the option\nhas only one argument ({@code -Dfoo}) it is considered as a boolean flag and the value is {@code \"true\"}.\n\n@param opt name of the option.\n@return The Properties mapped by the option, never {@code null} even if the option doesn't exists.\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Properties", "classes": []}, "name": "getOptionProperties", "params": [{"name": "opt", "type": "String"}], "body": "                                                            {\n        final Properties props = new Properties();\n        for (final Option option : options) {\n            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt())) {\n                processPropertiesFromValues(props, option.getValuesList());\n            }\n        }\n        return props;\n    }", "signature": "public Properties getOptionProperties(final String opt)"}, {"syntax_pass": true, "original_string": "    public Option[] getOptions() {\n        return options.toArray(Option.EMPTY_ARRAY);\n    }", "docstring": "\nGets an array of the processed {@link Option}s.\n\n@return an array of the processed {@link Option}s.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Option[]", "classes": []}, "name": "getOptions", "params": [], "body": "                                 {\n        return options.toArray(Option.EMPTY_ARRAY);\n    }", "signature": "public Option[] getOptions()"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final char opt) {\n        return getOptionValue(String.valueOf(opt));\n    }", "docstring": "\nGets the first argument, if any, of this option.\n\n@param opt the character name of the option.\n@return Value of the argument if option is set, and has an argument, otherwise null.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "opt", "type": "char"}], "body": "                                                 {\n        return getOptionValue(String.valueOf(opt));\n    }", "signature": "public String getOptionValue(final char opt)"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final char opt, final String defaultValue) {\n        return getOptionValue(String.valueOf(opt), () -> defaultValue);\n    }", "docstring": "\nGets the argument, if any, of an option.\n\n@param opt character name of the option\n@param defaultValue is the default value to be returned if the option is not specified.\n@return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "opt", "type": "char"}, {"name": "defaultValue", "type": "String"}], "body": "                                                                            {\n        return getOptionValue(String.valueOf(opt), () -> defaultValue);\n    }", "signature": "public String getOptionValue(final char opt, final String defaultValue)"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final char opt, final Supplier<String> defaultValue) {\n        return getOptionValue(String.valueOf(opt), defaultValue);\n    }", "docstring": "\nGets the argument, if any, of an option.\n\n@param opt character name of the option\n@param defaultValue is a supplier for the default value to be returned if the option is not specified.\n@return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "opt", "type": "char"}, {"name": "defaultValue", "type": "Supplier<String>"}], "body": "                                                                                      {\n        return getOptionValue(String.valueOf(opt), defaultValue);\n    }", "signature": "public String getOptionValue(final char opt, final Supplier<String> defaultValue)"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final Option option) {\n        final String[] values = getOptionValues(option);\n        return values == null ? null : values[0];\n    }", "docstring": "\nGets the first argument, if any, of this option.\n\n@param option the option.\n@return Value of the argument if option is set, and has an argument, otherwise null.\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "option", "type": "Option"}], "body": "                                                      {\n        final String[] values = getOptionValues(option);\n        return values == null ? null : values[0];\n    }", "signature": "public String getOptionValue(final Option option)"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final Option option, final String defaultValue) {\n        return getOptionValue(option, () -> defaultValue);\n    }", "docstring": "\nGets the first argument, if any, of an option.\n\n@param option the option.\n@param defaultValue is the default value to be returned if the option is not specified.\n@return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "option", "type": "Option"}, {"name": "defaultValue", "type": "String"}], "body": "                                                                                 {\n        return getOptionValue(option, () -> defaultValue);\n    }", "signature": "public String getOptionValue(final Option option, final String defaultValue)"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final Option option, final Supplier<String> defaultValue) {\n        final String answer = getOptionValue(option);\n        return answer != null ? answer : get(defaultValue);\n    }", "docstring": "\nGets the first argument, if any, of an option.\n\n@param option the option.\n@param defaultValue is a supplier for the default value to be returned if the option is not specified.\n@return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "option", "type": "Option"}, {"name": "defaultValue", "type": "Supplier<String>"}], "body": "                                                                                           {\n        final String answer = getOptionValue(option);\n        return answer != null ? answer : get(defaultValue);\n    }", "signature": "public String getOptionValue(final Option option, final Supplier<String> defaultValue)"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final OptionGroup optionGroup) {\n        final String[] values = getOptionValues(optionGroup);\n        return values == null ? null : values[0];\n    }", "docstring": "\nGets the first argument, if any, of this option group.\n\n@param optionGroup the option group.\n@return Value of the argument if option group is selected, and has an argument, otherwise null.\n@since 1.9.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "optionGroup", "type": "OptionGroup"}], "body": "                                                                {\n        final String[] values = getOptionValues(optionGroup);\n        return values == null ? null : values[0];\n    }", "signature": "public String getOptionValue(final OptionGroup optionGroup)"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final OptionGroup optionGroup, final String defaultValue) {\n        return getOptionValue(optionGroup, () -> defaultValue);\n    }", "docstring": "\nGets the first argument, if any, of an option group.\n\n@param optionGroup the option group.\n@param defaultValue is the default value to be returned if the option group is not selected.\n@return Value of the argument if option group is selected, and has an argument, otherwise {@code defaultValue}.\n@since 1.9.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "optionGroup", "type": "OptionGroup"}, {"name": "defaultValue", "type": "String"}], "body": "                                                                                           {\n        return getOptionValue(optionGroup, () -> defaultValue);\n    }", "signature": "public String getOptionValue(final OptionGroup optionGroup, final String defaultValue)"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final OptionGroup optionGroup, final Supplier<String> defaultValue) {\n        final String answer = getOptionValue(optionGroup);\n        return answer != null ? answer : get(defaultValue);\n    }", "docstring": "\nGets the first argument, if any, of an option group.\n\n@param optionGroup the option group.\n@param defaultValue is a supplier for the default value to be returned if the option group is not selected.\n@return Value of the argument if option group is selected, and has an argument, otherwise {@code defaultValue}.\n@since 1.9.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "optionGroup", "type": "OptionGroup"}, {"name": "defaultValue", "type": "Supplier<String>"}], "body": "                                                                                                     {\n        final String answer = getOptionValue(optionGroup);\n        return answer != null ? answer : get(defaultValue);\n    }", "signature": "public String getOptionValue(final OptionGroup optionGroup, final Supplier<String> defaultValue)"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final String opt) {\n        return getOptionValue(resolveOption(opt));\n    }", "docstring": "\nGets the first argument, if any, of this option.\n\n@param opt the name of the option.\n@return Value of the argument if option is set, and has an argument, otherwise null.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "opt", "type": "String"}], "body": "                                                   {\n        return getOptionValue(resolveOption(opt));\n    }", "signature": "public String getOptionValue(final String opt)"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final String opt, final String defaultValue) {\n        return getOptionValue(resolveOption(opt), () -> defaultValue);\n    }", "docstring": "\nGets the first argument, if any, of an option.\n\n@param opt name of the option.\n@param defaultValue is the default value to be returned if the option is not specified.\n@return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "opt", "type": "String"}, {"name": "defaultValue", "type": "String"}], "body": "                                                                              {\n        return getOptionValue(resolveOption(opt), () -> defaultValue);\n    }", "signature": "public String getOptionValue(final String opt, final String defaultValue)"}, {"syntax_pass": true, "original_string": "    public String getOptionValue(final String opt, final Supplier<String> defaultValue) {\n        return getOptionValue(resolveOption(opt), defaultValue);\n    }", "docstring": "\nGets the first argument, if any, of an option.\n\n@param opt name of the option.\n@param defaultValue is a supplier for the default value to be returned if the option is not specified.\n@return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptionValue", "params": [{"name": "opt", "type": "String"}, {"name": "defaultValue", "type": "Supplier<String>"}], "body": "                                                                                        {\n        return getOptionValue(resolveOption(opt), defaultValue);\n    }", "signature": "public String getOptionValue(final String opt, final Supplier<String> defaultValue)"}, {"syntax_pass": true, "original_string": "    public String[] getOptionValues(final char opt) {\n        return getOptionValues(String.valueOf(opt));\n    }", "docstring": "\nGets the array of values, if any, of an option.\n\n@param opt character name of the option.\n@return Values of the argument if option is set, and has an argument, otherwise null.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String[]", "classes": []}, "name": "getOptionValues", "params": [{"name": "opt", "type": "char"}], "body": "                                                    {\n        return getOptionValues(String.valueOf(opt));\n    }", "signature": "public String[] getOptionValues(final char opt)"}, {"syntax_pass": true, "original_string": "    public String[] getOptionValues(final Option option) {\n        if (option == null) {\n            return null;\n        }\n        final List<String> values = new ArrayList<>();\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                if (option.isDeprecated()) {\n                    handleDeprecated(option);\n                }\n                values.addAll(processedOption.getValuesList());\n            }\n        }\n        return values.isEmpty() ? null : values.toArray(Util.EMPTY_STRING_ARRAY);\n    }", "docstring": "\nGets the array of values, if any, of an option.\n\n@param option the option.\n@return Values of the argument if option is set, and has an argument, otherwise null.\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String[]", "classes": []}, "name": "getOptionValues", "params": [{"name": "option", "type": "Option"}], "body": "                                                         {\n        if (option == null) {\n            return null;\n        }\n        final List<String> values = new ArrayList<>();\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                if (option.isDeprecated()) {\n                    handleDeprecated(option);\n                }\n                values.addAll(processedOption.getValuesList());\n            }\n        }\n        return values.isEmpty() ? null : values.toArray(Util.EMPTY_STRING_ARRAY);\n    }", "signature": "public String[] getOptionValues(final Option option)"}, {"syntax_pass": true, "original_string": "    public String[] getOptionValues(final OptionGroup optionGroup) {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return null;\n        }\n        return getOptionValues(optionGroup.getSelected());\n    }", "docstring": "\nGets the array of values, if any, of an option group.\n\n@param optionGroup the option group.\n@return Values of the argument if option group is selected, and has an argument, otherwise null.\n@since 1.9.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String[]", "classes": []}, "name": "getOptionValues", "params": [{"name": "optionGroup", "type": "OptionGroup"}], "body": "                                                                   {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return null;\n        }\n        return getOptionValues(optionGroup.getSelected());\n    }", "signature": "public String[] getOptionValues(final OptionGroup optionGroup)"}, {"syntax_pass": true, "original_string": "    public String[] getOptionValues(final String opt) {\n        return getOptionValues(resolveOption(opt));\n    }", "docstring": "\nGets the array of values, if any, of an option.\n\n@param opt string name of the option.\n@return Values of the argument if option is set, and has an argument, otherwise null.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String[]", "classes": []}, "name": "getOptionValues", "params": [{"name": "opt", "type": "String"}], "body": "                                                      {\n        return getOptionValues(resolveOption(opt));\n    }", "signature": "public String[] getOptionValues(final String opt)"}, {"syntax_pass": true, "original_string": "    public <T> T getParsedOptionValue(final char opt) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt));\n    }", "docstring": "\nGets a version of this {@code Option} converted to a particular type.\n\n@param opt the name of the option.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the option value into the desired type\n@see PatternOptionBuilder\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "opt", "type": "char"}], "body": "                                                                            {\n        return getParsedOptionValue(String.valueOf(opt));\n    }", "signature": "public <T> T getParsedOptionValue(final char opt)"}, {"syntax_pass": true, "original_string": "    public <T> T getParsedOptionValue(final char opt, final Supplier<T> defaultValue) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt), defaultValue);\n    }", "docstring": "\nGets a version of this {@code Option} converted to a particular type.\n\n@param opt the name of the option.\n@param defaultValue the default value to return if opt is not set.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the option value into the desired type\n@see PatternOptionBuilder\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "opt", "type": "char"}, {"name": "defaultValue", "type": "Supplier<T>"}], "body": "                                                                                                            {\n        return getParsedOptionValue(String.valueOf(opt), defaultValue);\n    }", "signature": "public <T> T getParsedOptionValue(final char opt, final Supplier<T> defaultValue)"}, {"syntax_pass": true, "original_string": "    public <T> T getParsedOptionValue(final char opt, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt), defaultValue);\n    }", "docstring": "\nGets a version of this {@code Option} converted to a particular type.\n\n@param opt the name of the option.\n@param defaultValue the default value to return if opt is not set.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the option value into the desired type\n@see PatternOptionBuilder\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "opt", "type": "char"}, {"name": "defaultValue", "type": "T"}], "body": "                                                                                                  {\n        return getParsedOptionValue(String.valueOf(opt), defaultValue);\n    }", "signature": "public <T> T getParsedOptionValue(final char opt, final T defaultValue)"}, {"syntax_pass": true, "original_string": "    public <T> T getParsedOptionValue(final Option option) throws ParseException {\n        return getParsedOptionValue(option, () -> null);\n    }", "docstring": "\nGets a version of this {@code Option} converted to a particular type.\n\n@param option the option.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the option value into the desired type\n@see PatternOptionBuilder\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "option", "type": "Option"}], "body": "                                                                                 {\n        return getParsedOptionValue(option, () -> null);\n    }", "signature": "public <T> T getParsedOptionValue(final Option option)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    public <T> T getParsedOptionValue(final Option option, final Supplier<T> defaultValue) throws ParseException {\n        if (option == null) {\n            return get(defaultValue);\n        }\n        final String res = getOptionValue(option);\n        try {\n            if (res == null) {\n                return get(defaultValue);\n            }\n            return (T) option.getConverter().apply(res);\n        } catch (final Throwable e) {\n            throw ParseException.wrap(e);\n        }\n    }", "docstring": "\nGets a version of this {@code Option} converted to a particular type.\n\n@param option the option.\n@param defaultValue the default value to return if opt is not set.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the option value into the desired type\n@see PatternOptionBuilder\n@since 1.7.0\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "option", "type": "Option"}, {"name": "defaultValue", "type": "Supplier<T>"}], "body": "                                                                                                                 {\n        if (option == null) {\n            return get(defaultValue);\n        }\n        final String res = getOptionValue(option);\n        try {\n            if (res == null) {\n                return get(defaultValue);\n            }\n            return (T) option.getConverter().apply(res);\n        } catch (final Throwable e) {\n            throw ParseException.wrap(e);\n        }\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    public <T> T getParsedOptionValue(final Option option, final Supplier<T> defaultValue)"}, {"syntax_pass": true, "original_string": "    public <T> T getParsedOptionValue(final Option option, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(option, () -> defaultValue);\n    }", "docstring": "\nGets a version of this {@code Option} converted to a particular type.\n\n@param option the option.\n@param defaultValue the default value to return if opt is not set.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the option value into the desired type\n@see PatternOptionBuilder\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "option", "type": "Option"}, {"name": "defaultValue", "type": "T"}], "body": "                                                                                                       {\n        return getParsedOptionValue(option, () -> defaultValue);\n    }", "signature": "public <T> T getParsedOptionValue(final Option option, final T defaultValue)"}, {"syntax_pass": true, "original_string": "    public <T> T getParsedOptionValue(final OptionGroup optionGroup) throws ParseException {\n        return getParsedOptionValue(optionGroup, () -> null);\n    }", "docstring": "\nGets a version of this {@code OptionGroup} converted to a particular type.\n\n@param optionGroup the option group.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the selected option value into the desired type\n@see PatternOptionBuilder\n@since 1.9.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "optionGroup", "type": "OptionGroup"}], "body": "                                                                                           {\n        return getParsedOptionValue(optionGroup, () -> null);\n    }", "signature": "public <T> T getParsedOptionValue(final OptionGroup optionGroup)"}, {"syntax_pass": true, "original_string": "    public <T> T getParsedOptionValue(final OptionGroup optionGroup, final Supplier<T> defaultValue) throws ParseException {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return get(defaultValue);\n        }\n        return getParsedOptionValue(optionGroup.getSelected(), defaultValue);\n    }", "docstring": "\nGets a version of this {@code OptionGroup} converted to a particular type.\n\n@param optionGroup the option group.\n@param defaultValue the default value to return if opt is not set.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the selected option value into the desired type\n@see PatternOptionBuilder\n@since 1.9.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "optionGroup", "type": "OptionGroup"}, {"name": "defaultValue", "type": "Supplier<T>"}], "body": "                                                                                                                           {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return get(defaultValue);\n        }\n        return getParsedOptionValue(optionGroup.getSelected(), defaultValue);\n    }", "signature": "public <T> T getParsedOptionValue(final OptionGroup optionGroup, final Supplier<T> defaultValue)"}, {"syntax_pass": true, "original_string": "    public <T> T getParsedOptionValue(final OptionGroup optionGroup, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(optionGroup, () -> defaultValue);\n    }", "docstring": "\nGets a version of this {@code OptionGroup} converted to a particular type.\n\n@param optionGroup the option group.\n@param defaultValue the default value to return if an option is not selected.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the option value into the desired type\n@see PatternOptionBuilder\n@since 1.9.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "optionGroup", "type": "OptionGroup"}, {"name": "defaultValue", "type": "T"}], "body": "                                                                                                                 {\n        return getParsedOptionValue(optionGroup, () -> defaultValue);\n    }", "signature": "public <T> T getParsedOptionValue(final OptionGroup optionGroup, final T defaultValue)"}, {"syntax_pass": true, "original_string": "    public <T> T getParsedOptionValue(final String opt) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt));\n    }", "docstring": "\nGets a version of this {@code Option} converted to a particular type.\n\n@param opt the name of the option.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the option value into the desired type\n@see PatternOptionBuilder\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "opt", "type": "String"}], "body": "                                                                              {\n        return getParsedOptionValue(resolveOption(opt));\n    }", "signature": "public <T> T getParsedOptionValue(final String opt)"}, {"syntax_pass": true, "original_string": "    public <T> T getParsedOptionValue(final String opt, final Supplier<T> defaultValue) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt), defaultValue);\n    }", "docstring": "\nGets a version of this {@code Option} converted to a particular type.\n\n@param opt the name of the option.\n@param defaultValue the default value to return if opt is not set.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the option value into the desired type\n@see PatternOptionBuilder\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "opt", "type": "String"}, {"name": "defaultValue", "type": "Supplier<T>"}], "body": "                                                                                                              {\n        return getParsedOptionValue(resolveOption(opt), defaultValue);\n    }", "signature": "public <T> T getParsedOptionValue(final String opt, final Supplier<T> defaultValue)"}, {"syntax_pass": true, "original_string": "    public <T> T getParsedOptionValue(final String opt, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt), defaultValue);\n    }", "docstring": "\nGets a version of this {@code Option} converted to a particular type.\n\n@param opt the name of the option.\n@param defaultValue the default value to return if opt is not set.\n@param <T> The return type for the method.\n@return the value parsed into a particular object.\n@throws ParseException if there are problems turning the option value into the desired type\n@see PatternOptionBuilder\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getParsedOptionValue", "params": [{"name": "opt", "type": "String"}, {"name": "defaultValue", "type": "T"}], "body": "                                                                                                    {\n        return getParsedOptionValue(resolveOption(opt), defaultValue);\n    }", "signature": "public <T> T getParsedOptionValue(final String opt, final T defaultValue)"}, {"syntax_pass": true, "original_string": "    private void handleDeprecated(final Option option) {\n        if (deprecatedHandler != null) {\n            deprecatedHandler.accept(option);\n        }\n    }", "docstring": "\nHandles deprecated options.\n\n@param option a deprecated option.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "handleDeprecated", "params": [{"name": "option", "type": "Option"}], "body": "                                                       {\n        if (deprecatedHandler != null) {\n            deprecatedHandler.accept(option);\n        }\n    }", "signature": "private void handleDeprecated(final Option option)"}, {"syntax_pass": true, "original_string": "    public boolean hasOption(final char opt) {\n        return hasOption(String.valueOf(opt));\n    }", "docstring": "\nTests to see if an option has been set.\n\n@param opt character name of the option.\n@return true if set, false if not.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasOption", "params": [{"name": "opt", "type": "char"}], "body": "                                             {\n        return hasOption(String.valueOf(opt));\n    }", "signature": "public boolean hasOption(final char opt)"}, {"syntax_pass": true, "original_string": "    public boolean hasOption(final Option opt) {\n        final boolean result = options.contains(opt);\n        if (result && opt.isDeprecated()) {\n            handleDeprecated(opt);\n        }\n        return result;\n    }", "docstring": "\nTests to see if an option has been set.\n\n@param opt the option to check.\n@return true if set, false if not.\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasOption", "params": [{"name": "opt", "type": "Option"}], "body": "                                               {\n        final boolean result = options.contains(opt);\n        if (result && opt.isDeprecated()) {\n            handleDeprecated(opt);\n        }\n        return result;\n    }", "signature": "public boolean hasOption(final Option opt)"}, {"syntax_pass": true, "original_string": "    public boolean hasOption(final OptionGroup optionGroup) {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return false;\n        }\n        return hasOption(optionGroup.getSelected());\n    }", "docstring": "\nTests to see if an option has been set.\n\n@param optionGroup the option group to check.\n@return true if set, false if not.\n@since 1.9.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasOption", "params": [{"name": "optionGroup", "type": "OptionGroup"}], "body": "                                                            {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return false;\n        }\n        return hasOption(optionGroup.getSelected());\n    }", "signature": "public boolean hasOption(final OptionGroup optionGroup)"}, {"syntax_pass": true, "original_string": "    public boolean hasOption(final String opt) {\n        return hasOption(resolveOption(opt));\n    }", "docstring": "\nTests to see if an option has been set.\n\n@param opt Short name of the option.\n@return true if set, false if not.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasOption", "params": [{"name": "opt", "type": "String"}], "body": "                                               {\n        return hasOption(resolveOption(opt));\n    }", "signature": "public boolean hasOption(final String opt)"}, {"syntax_pass": true, "original_string": "    public Iterator<Option> iterator() {\n        return options.iterator();\n    }", "docstring": "\nReturns an iterator over the Option members of CommandLine.\n\n@return an {@code Iterator} over the processed {@link Option} members of this {@link CommandLine}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Option>", "classes": []}, "name": "iterator", "params": [], "body": "                                       {\n        return options.iterator();\n    }", "signature": "public Iterator<Option> iterator()"}, {"syntax_pass": true, "original_string": "    private void processPropertiesFromValues(final Properties props, final List<String> values) {\n        for (int i = 0; i < values.size(); i += 2) {\n            if (i + 1 < values.size()) {\n                props.put(values.get(i), values.get(i + 1));\n            } else {\n                props.put(values.get(i), \"true\");\n            }\n        }\n    }", "docstring": "\nParses a list of values as properties.  All odd numbered values are property keys\nand even numbered values are property values.  If there are an odd number of values\nthe last value is assumed to be a boolean with a value of \"true\".\n@param props the properties to update.\n@param values the list of values to parse.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "processPropertiesFromValues", "params": [{"name": "props", "type": "Properties"}, {"name": "values", "type": "List<String>"}], "body": "                                                                                                {\n        for (int i = 0; i < values.size(); i += 2) {\n            if (i + 1 < values.size()) {\n                props.put(values.get(i), values.get(i + 1));\n            } else {\n                props.put(values.get(i), \"true\");\n            }\n        }\n    }", "signature": "private void processPropertiesFromValues(final Properties props, final List<String> values)"}, {"syntax_pass": true, "original_string": "    private Option resolveOption(final String opt) {\n        final String actual = Util.stripLeadingHyphens(opt);\n        if (actual != null) {\n            for (final Option option : options) {\n                if (actual.equals(option.getOpt()) || actual.equals(option.getLongOpt())) {\n                    return option;\n                }\n            }\n        }\n        return null;\n    }", "docstring": "\nRetrieves the option object given the long or short option as a String\n\n@param opt short or long name of the option, may be null.\n@return Canonicalized option.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Option", "classes": []}, "name": "resolveOption", "params": [{"name": "opt", "type": "String"}], "body": "                                                   {\n        final String actual = Util.stripLeadingHyphens(opt);\n        if (actual != null) {\n            for (final Option option : options) {\n                if (actual.equals(option.getOpt()) || actual.equals(option.getLongOpt())) {\n                    return option;\n                }\n            }\n        }\n        return null;\n    }", "signature": "private Option resolveOption(final String opt)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/DeprecatedAttributes.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.function.Supplier;\n\n/**\n * Deprecated attributes.\n * <p>\n * Note: This class isn't called \"Deprecated\" to avoid clashing with \"java.lang.Deprecated\".\n * </p>\n * <p>\n * If you want to serialize this class, use a serialization proxy.\n * </p>\n *\n * @since 1.7.0\n * @see Deprecated\n */\npublic final class DeprecatedAttributes {\n\n    /**\n     * Builds {@link DeprecatedAttributes}.\n     */\n    public static class Builder implements Supplier<DeprecatedAttributes> {\n\n        /** The description. */\n        private String description;\n\n        /**\n         * Whether this option is subject to removal in a future version.\n         *\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n         */\n        private boolean forRemoval;\n\n        /**\n         * The version in which the option became deprecated.\n         *\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.since</a>\n         */\n        private String since;\n\n        @Override\n        public DeprecatedAttributes get() {\n            return new DeprecatedAttributes(description, since, forRemoval);\n        }\n\n        /**\n         * Sets the description.\n         *\n         * @param description the description.\n         * @return {@code this} instance.\n         */\n        public Builder setDescription(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Whether this option is subject to removal in a future version.\n         *\n         * @param forRemoval whether this is subject to removal in a future version.\n         * @return {@code this} instance.\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n         */\n        public Builder setForRemoval(final boolean forRemoval) {\n            this.forRemoval = forRemoval;\n            return this;\n        }\n\n        /**\n         * Sets the version in which the option became deprecated.\n         *\n         * @param since the version in which the option became deprecated.\n         * @return {@code this} instance.\n         */\n        public Builder setSince(final String since) {\n            this.since = since;\n            return this;\n        }\n    }\n\n    /**\n     * The default value for a DeprecatedAttributes.\n     */\n    static final DeprecatedAttributes DEFAULT = new DeprecatedAttributes(\"\", \"\", false);\n\n    /**\n     * The empty string.\n     */\n    private static final String EMPTY_STRING = \"\";\n\n    /**\n     * Creates a new builder.\n     *\n     * @return a new builder.\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    /** The description. */\n    private final String description;\n\n    /** Whether this option will be removed. */\n    private final boolean forRemoval;\n\n    /** The version label for removal. */\n    private final String since;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param description The description.\n     * @param since       The version label for removal.\n     * @param forRemoval  Whether this option will be removed.\n     */\n    private DeprecatedAttributes(final String description, final String since, final boolean forRemoval) {\n        this.description = toEmpty(description);\n        this.since = toEmpty(since);\n        this.forRemoval = forRemoval;\n    }\n\n    /**\n     * Gets the descriptions.\n     *\n     * @return the descriptions.\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Gets version in which the option became deprecated.\n     *\n     * @return the version in which the option became deprecated.\n     */\n    public String getSince() {\n        return since;\n    }\n\n    /**\n     * Tests whether this option is subject to removal in a future version.\n     *\n     * @return whether this option is subject to removal in a future version.\n     */\n    public boolean isForRemoval() {\n        return forRemoval;\n    }\n\n    private String toEmpty(final String since) {\n        return since != null ? since : EMPTY_STRING;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder builder = new StringBuilder(\"Deprecated\");\n        if (forRemoval) {\n            builder.append(\" for removal\");\n        }\n        if (!since.isEmpty()) {\n            builder.append(\" since \");\n            builder.append(since);\n        }\n        if (!description.isEmpty()) {\n            builder.append(\": \");\n            builder.append(description);\n        }\n        return builder.toString();\n    }\n}\n", "file_hash": "6935881a67ef10a48082bd0e1778be4db7b7387944f9e3a30673c4af696e7d45", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.util.function.Supplier;"], "methods": [], "classes": [{"original_string": "public final class DeprecatedAttributes {\n\n    /**\n     * Builds {@link DeprecatedAttributes}.\n     */\n    public static class Builder implements Supplier<DeprecatedAttributes> {\n\n        /** The description. */\n        private String description;\n\n        /**\n         * Whether this option is subject to removal in a future version.\n         *\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n         */\n        private boolean forRemoval;\n\n        /**\n         * The version in which the option became deprecated.\n         *\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.since</a>\n         */\n        private String since;\n\n        @Override\n        public DeprecatedAttributes get() {\n            return new DeprecatedAttributes(description, since, forRemoval);\n        }\n\n        /**\n         * Sets the description.\n         *\n         * @param description the description.\n         * @return {@code this} instance.\n         */\n        public Builder setDescription(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Whether this option is subject to removal in a future version.\n         *\n         * @param forRemoval whether this is subject to removal in a future version.\n         * @return {@code this} instance.\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n         */\n        public Builder setForRemoval(final boolean forRemoval) {\n            this.forRemoval = forRemoval;\n            return this;\n        }\n\n        /**\n         * Sets the version in which the option became deprecated.\n         *\n         * @param since the version in which the option became deprecated.\n         * @return {@code this} instance.\n         */\n        public Builder setSince(final String since) {\n            this.since = since;\n            return this;\n        }\n    }\n\n    /**\n     * The default value for a DeprecatedAttributes.\n     */\n    static final DeprecatedAttributes DEFAULT = new DeprecatedAttributes(\"\", \"\", false);\n\n    /**\n     * The empty string.\n     */\n    private static final String EMPTY_STRING = \"\";\n\n    /**\n     * Creates a new builder.\n     *\n     * @return a new builder.\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    /** The description. */\n    private final String description;\n\n    /** Whether this option will be removed. */\n    private final boolean forRemoval;\n\n    /** The version label for removal. */\n    private final String since;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param description The description.\n     * @param since       The version label for removal.\n     * @param forRemoval  Whether this option will be removed.\n     */\n    private DeprecatedAttributes(final String description, final String since, final boolean forRemoval) {\n        this.description = toEmpty(description);\n        this.since = toEmpty(since);\n        this.forRemoval = forRemoval;\n    }\n\n    /**\n     * Gets the descriptions.\n     *\n     * @return the descriptions.\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Gets version in which the option became deprecated.\n     *\n     * @return the version in which the option became deprecated.\n     */\n    public String getSince() {\n        return since;\n    }\n\n    /**\n     * Tests whether this option is subject to removal in a future version.\n     *\n     * @return whether this option is subject to removal in a future version.\n     */\n    public boolean isForRemoval() {\n        return forRemoval;\n    }\n\n    private String toEmpty(final String since) {\n        return since != null ? since : EMPTY_STRING;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder builder = new StringBuilder(\"Deprecated\");\n        if (forRemoval) {\n            builder.append(\" for removal\");\n        }\n        if (!since.isEmpty()) {\n            builder.append(\" since \");\n            builder.append(since);\n        }\n        if (!description.isEmpty()) {\n            builder.append(\": \");\n            builder.append(description);\n        }\n        return builder.toString();\n    }\n}", "definition": "public final class DeprecatedAttributes", "class_docstring": "\nDeprecated attributes.\n<p>\nNote: This class isn't called \"Deprecated\" to avoid clashing with \"java.lang.Deprecated\".\n</p>\n<p>\nIf you want to serialize this class, use a serialization proxy.\n</p>\n\n@since 1.7.0\n@see Deprecated\n", "name": "DeprecatedAttributes", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "static final DeprecatedAttributes DEFAULT = new DeprecatedAttributes(\"\", \"\", false);", "docstring": "\nThe default value for a DeprecatedAttributes.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "DeprecatedAttributes", "name": "DEFAULT = new DeprecatedAttributes(\"\", \"\", false)", "syntax_pass": true}, {"attribute_expression": "private static final String EMPTY_STRING = \"\";", "docstring": "\nThe empty string.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "EMPTY_STRING = \"\"", "syntax_pass": true}, {"attribute_expression": "private final String description;", "docstring": " The description.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "description", "syntax_pass": true}, {"attribute_expression": "private final boolean forRemoval;", "docstring": " Whether this option will be removed.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "forRemoval", "syntax_pass": true}, {"attribute_expression": "private final String since;", "docstring": " The version label for removal.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "since", "syntax_pass": true}], "classes": [{"original_string": "    public static class Builder implements Supplier<DeprecatedAttributes> {\n\n        /** The description. */\n        private String description;\n\n        /**\n         * Whether this option is subject to removal in a future version.\n         *\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n         */\n        private boolean forRemoval;\n\n        /**\n         * The version in which the option became deprecated.\n         *\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.since</a>\n         */\n        private String since;\n\n        @Override\n        public DeprecatedAttributes get() {\n            return new DeprecatedAttributes(description, since, forRemoval);\n        }\n\n        /**\n         * Sets the description.\n         *\n         * @param description the description.\n         * @return {@code this} instance.\n         */\n        public Builder setDescription(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Whether this option is subject to removal in a future version.\n         *\n         * @param forRemoval whether this is subject to removal in a future version.\n         * @return {@code this} instance.\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n         */\n        public Builder setForRemoval(final boolean forRemoval) {\n            this.forRemoval = forRemoval;\n            return this;\n        }\n\n        /**\n         * Sets the version in which the option became deprecated.\n         *\n         * @param since the version in which the option became deprecated.\n         * @return {@code this} instance.\n         */\n        public Builder setSince(final String since) {\n            this.since = since;\n            return this;\n        }\n    }", "definition": "    public static class Builder implements Supplier<DeprecatedAttributes>", "class_docstring": "\nBuilds {@link DeprecatedAttributes}.\n", "name": "Builder", "super_interfaces": ["Supplier<DeprecatedAttributes>"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private String description;", "docstring": " The description.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "description", "syntax_pass": true}, {"attribute_expression": "private boolean forRemoval;", "docstring": "\nWhether this option is subject to removal in a future version.\n\n@see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "forRemoval", "syntax_pass": true}, {"attribute_expression": "private String since;", "docstring": "\nThe version in which the option became deprecated.\n\n@see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.since</a>\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "since", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public DeprecatedAttributes get() {\n            return new DeprecatedAttributes(description, since, forRemoval);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeprecatedAttributes", "classes": []}, "name": "get", "params": [], "body": "                                          {\n            return new DeprecatedAttributes(description, since, forRemoval);\n        }", "signature": "@Override\n        public DeprecatedAttributes get()"}, {"syntax_pass": true, "original_string": "        public Builder setDescription(final String description) {\n            this.description = description;\n            return this;\n        }", "docstring": "\nSets the description.\n\n@param description the description.\n@return {@code this} instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setDescription", "params": [{"name": "description", "type": "String"}], "body": "                                                                {\n            this.description = description;\n            return this;\n        }", "signature": "public Builder setDescription(final String description)"}, {"syntax_pass": true, "original_string": "        public Builder setForRemoval(final boolean forRemoval) {\n            this.forRemoval = forRemoval;\n            return this;\n        }", "docstring": "\nWhether this option is subject to removal in a future version.\n\n@param forRemoval whether this is subject to removal in a future version.\n@return {@code this} instance.\n@see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setForRemoval", "params": [{"name": "forRemoval", "type": "boolean"}], "body": "                                                               {\n            this.forRemoval = forRemoval;\n            return this;\n        }", "signature": "public Builder setForRemoval(final boolean forRemoval)"}, {"syntax_pass": true, "original_string": "        public Builder setSince(final String since) {\n            this.since = since;\n            return this;\n        }", "docstring": "\nSets the version in which the option became deprecated.\n\n@param since the version in which the option became deprecated.\n@return {@code this} instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setSince", "params": [{"name": "since", "type": "String"}], "body": "                                                    {\n            this.since = since;\n            return this;\n        }", "signature": "public Builder setSince(final String since)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static Builder builder() {\n        return new Builder();\n    }", "docstring": "\nCreates a new builder.\n\n@return a new builder.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "builder", "params": [], "body": "                                    {\n        return new Builder();\n    }", "signature": "public static Builder builder()"}, {"syntax_pass": true, "original_string": "    private DeprecatedAttributes(final String description, final String since, final boolean forRemoval) {\n        this.description = toEmpty(description);\n        this.since = toEmpty(since);\n        this.forRemoval = forRemoval;\n    }", "docstring": "\nConstructs a new instance.\n\n@param description The description.\n@param since       The version label for removal.\n@param forRemoval  Whether this option will be removed.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "DeprecatedAttributes", "params": [{"name": "description", "type": "String"}, {"name": "since", "type": "String"}, {"name": "forRemoval", "type": "boolean"}], "body": "                                                                                                         {\n        this.description = toEmpty(description);\n        this.since = toEmpty(since);\n        this.forRemoval = forRemoval;\n    }", "signature": "private DeprecatedAttributes(final String description, final String since, final boolean forRemoval)"}, {"syntax_pass": true, "original_string": "    public String getDescription() {\n        return description;\n    }", "docstring": "\nGets the descriptions.\n\n@return the descriptions.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getDescription", "params": [], "body": "                                   {\n        return description;\n    }", "signature": "public String getDescription()"}, {"syntax_pass": true, "original_string": "    public String getSince() {\n        return since;\n    }", "docstring": "\nGets version in which the option became deprecated.\n\n@return the version in which the option became deprecated.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getSince", "params": [], "body": "                             {\n        return since;\n    }", "signature": "public String getSince()"}, {"syntax_pass": true, "original_string": "    public boolean isForRemoval() {\n        return forRemoval;\n    }", "docstring": "\nTests whether this option is subject to removal in a future version.\n\n@return whether this option is subject to removal in a future version.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isForRemoval", "params": [], "body": "                                  {\n        return forRemoval;\n    }", "signature": "public boolean isForRemoval()"}, {"syntax_pass": true, "original_string": "    private String toEmpty(final String since) {\n        return since != null ? since : EMPTY_STRING;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "toEmpty", "params": [{"name": "since", "type": "String"}], "body": "                                               {\n        return since != null ? since : EMPTY_STRING;\n    }", "signature": "private String toEmpty(final String since)"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        final StringBuilder builder = new StringBuilder(\"Deprecated\");\n        if (forRemoval) {\n            builder.append(\" for removal\");\n        }\n        if (!since.isEmpty()) {\n            builder.append(\" since \");\n            builder.append(since);\n        }\n        if (!description.isEmpty()) {\n            builder.append(\": \");\n            builder.append(description);\n        }\n        return builder.toString();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        final StringBuilder builder = new StringBuilder(\"Deprecated\");\n        if (forRemoval) {\n            builder.append(\" for removal\");\n        }\n        if (!since.isEmpty()) {\n            builder.append(\" since \");\n            builder.append(since);\n        }\n        if (!description.isEmpty()) {\n            builder.append(\": \");\n            builder.append(description);\n        }\n        return builder.toString();\n    }", "signature": "@Override\n    public String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/OptionBuilder.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * OptionBuilder allows the user to create Options using descriptive methods.\n * <p>\n * Details on the Builder pattern can be found at\n * <a href=\"https://c2.com/cgi-bin/wiki?BuilderPattern\">https://c2.com/cgi-bin/wiki?BuilderPattern</a>.\n * <p>\n * This class is NOT thread safe. See <a href=\"https://issues.apache.org/jira/browse/CLI-209\">CLI-209</a>\n *\n * @since 1.0\n * @deprecated since 1.3, use {@link Option#builder(String)} instead\n */\n@Deprecated\npublic final class OptionBuilder {\n\n    /** Long option */\n    private static String longOption;\n\n    /** Option description */\n    private static String description;\n\n    /** Argument name */\n    private static String argName;\n\n    /** Is required? */\n    private static boolean required;\n\n    /** The number of arguments */\n    private static int argCount = Option.UNINITIALIZED;\n\n    /** Option type */\n    private static Class<?> type;\n\n    /** Option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** Value separator for argument value */\n    private static char valueSeparator;\n\n    /** Option builder instance */\n    private static final OptionBuilder INSTANCE = new OptionBuilder();\n\n    static {\n        // ensure the consistency of the initial values\n        reset();\n    }\n\n    /**\n     * Creates an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code longOpt} has not been set.\n     */\n    public static Option create() throws IllegalArgumentException {\n        if (longOption == null) {\n            reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Creates an Option using the current settings and with the specified Option {@code char}.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code opt} is not a valid character. See Option.\n     */\n    public static Option create(final char opt) throws IllegalArgumentException {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Creates an Option using the current settings and with the specified Option {@code char}.\n     *\n     * @param opt the {@code String} representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code opt} is not a valid character. See Option.\n     */\n    public static Option create(final String opt) throws IllegalArgumentException {\n        Option option;\n        try {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longOption);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(argCount);\n            option.setType(type);\n            option.setConverter(TypeHandler.getDefault().getConverter(type));\n            option.setValueSeparator(valueSeparator);\n            option.setArgName(argName);\n        } finally {\n            // reset the OptionBuilder properties\n            reset();\n        }\n\n        // return the Option instance\n        return option;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg() {\n        argCount = 1;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will require an argument value if {@code hasArg} is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(final boolean hasArg) {\n        argCount = hasArg ? 1 : Option.UNINITIALIZED;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs() {\n        argCount = Option.UNLIMITED_VALUES;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created can have {@code num} argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(final int num) {\n        argCount = num;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg() {\n        argCount = 1;\n        optionalArg = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs() {\n        argCount = Option.UNLIMITED_VALUES;\n        optionalArg = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs   the maximum number of optional arguments the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(final int numArgs) {\n        argCount = numArgs;\n        optionalArg = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired() {\n        required = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will be required if {@code required} is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(final boolean newRequired) {\n        required = newRequired;\n        return INSTANCE;\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset() {\n        description = null;\n        argName = null;\n        longOption = null;\n        type = String.class;\n        required = false;\n        argCount = Option.UNINITIALIZED;\n        optionalArg = false;\n        valueSeparator = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(final String name) {\n        argName = name;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(final String newDescription) {\n        description = newDescription;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(final String newLongopt) {\n        longOption = newLongopt;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance of {@code type}.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     * @since 1.3\n     */\n    public static OptionBuilder withType(final Class<?> newType) {\n        type = newType;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance of {@code type}.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class}\n     * object.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     * @deprecated since 1.3, use {@link #withType(Class)} instead\n     */\n    @Deprecated\n    public static OptionBuilder withType(final Object newType) {\n        return withType((Class<?>) newType);\n    }\n\n    /**\n     * The next Option created uses '{@code =}' as a means to separate argument values.\n     *\n     * <b>Example:</b>\n     *\n     * <pre>\n     * Option opt = withValueSeparator().create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator() {\n        valueSeparator = Char.EQUAL;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created uses {@code sep} as a means to separate argument values.\n     * <p>\n     * <b>Example:</b>\n     *\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator('=').create('D');\n     *\n     * String args = \"-Dkey=value\";\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0); // will be \"key\"\n     * String propertyValue = opt.getValue(1); // will be \"value\"\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(final char sep) {\n        valueSeparator = sep;\n        return INSTANCE;\n    }\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder() {\n        // hide the constructor\n    }\n}\n", "file_hash": "38ae95ea8fc6b1b7f80a7cbc172dff6043d230fa7edc4278af969d4521b13d18", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;"], "methods": [], "classes": [{"original_string": "@Deprecated\npublic final class OptionBuilder {\n\n    /** Long option */\n    private static String longOption;\n\n    /** Option description */\n    private static String description;\n\n    /** Argument name */\n    private static String argName;\n\n    /** Is required? */\n    private static boolean required;\n\n    /** The number of arguments */\n    private static int argCount = Option.UNINITIALIZED;\n\n    /** Option type */\n    private static Class<?> type;\n\n    /** Option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** Value separator for argument value */\n    private static char valueSeparator;\n\n    /** Option builder instance */\n    private static final OptionBuilder INSTANCE = new OptionBuilder();\n\n    static {\n        // ensure the consistency of the initial values\n        reset();\n    }\n\n    /**\n     * Creates an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code longOpt} has not been set.\n     */\n    public static Option create() throws IllegalArgumentException {\n        if (longOption == null) {\n            reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Creates an Option using the current settings and with the specified Option {@code char}.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code opt} is not a valid character. See Option.\n     */\n    public static Option create(final char opt) throws IllegalArgumentException {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Creates an Option using the current settings and with the specified Option {@code char}.\n     *\n     * @param opt the {@code String} representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code opt} is not a valid character. See Option.\n     */\n    public static Option create(final String opt) throws IllegalArgumentException {\n        Option option;\n        try {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longOption);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(argCount);\n            option.setType(type);\n            option.setConverter(TypeHandler.getDefault().getConverter(type));\n            option.setValueSeparator(valueSeparator);\n            option.setArgName(argName);\n        } finally {\n            // reset the OptionBuilder properties\n            reset();\n        }\n\n        // return the Option instance\n        return option;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg() {\n        argCount = 1;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will require an argument value if {@code hasArg} is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(final boolean hasArg) {\n        argCount = hasArg ? 1 : Option.UNINITIALIZED;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs() {\n        argCount = Option.UNLIMITED_VALUES;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created can have {@code num} argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(final int num) {\n        argCount = num;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg() {\n        argCount = 1;\n        optionalArg = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs() {\n        argCount = Option.UNLIMITED_VALUES;\n        optionalArg = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs   the maximum number of optional arguments the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(final int numArgs) {\n        argCount = numArgs;\n        optionalArg = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired() {\n        required = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will be required if {@code required} is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(final boolean newRequired) {\n        required = newRequired;\n        return INSTANCE;\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset() {\n        description = null;\n        argName = null;\n        longOption = null;\n        type = String.class;\n        required = false;\n        argCount = Option.UNINITIALIZED;\n        optionalArg = false;\n        valueSeparator = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(final String name) {\n        argName = name;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(final String newDescription) {\n        description = newDescription;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(final String newLongopt) {\n        longOption = newLongopt;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance of {@code type}.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     * @since 1.3\n     */\n    public static OptionBuilder withType(final Class<?> newType) {\n        type = newType;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance of {@code type}.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class}\n     * object.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     * @deprecated since 1.3, use {@link #withType(Class)} instead\n     */\n    @Deprecated\n    public static OptionBuilder withType(final Object newType) {\n        return withType((Class<?>) newType);\n    }\n\n    /**\n     * The next Option created uses '{@code =}' as a means to separate argument values.\n     *\n     * <b>Example:</b>\n     *\n     * <pre>\n     * Option opt = withValueSeparator().create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator() {\n        valueSeparator = Char.EQUAL;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created uses {@code sep} as a means to separate argument values.\n     * <p>\n     * <b>Example:</b>\n     *\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator('=').create('D');\n     *\n     * String args = \"-Dkey=value\";\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0); // will be \"key\"\n     * String propertyValue = opt.getValue(1); // will be \"value\"\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(final char sep) {\n        valueSeparator = sep;\n        return INSTANCE;\n    }\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder() {\n        // hide the constructor\n    }\n}", "definition": "@Deprecated\npublic final class OptionBuilder", "class_docstring": "\nOptionBuilder allows the user to create Options using descriptive methods.\n<p>\nDetails on the Builder pattern can be found at\n<a href=\"https://c2.com/cgi-bin/wiki?BuilderPattern\">https://c2.com/cgi-bin/wiki?BuilderPattern</a>.\n<p>\nThis class is NOT thread safe. See <a href=\"https://issues.apache.org/jira/browse/CLI-209\">CLI-209</a>\n\n@since 1.0\n@deprecated since 1.3, use {@link Option#builder(String)} instead\n", "name": "OptionBuilder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@Deprecated\npublic final", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private static String longOption;", "docstring": " Long option", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "longOption", "syntax_pass": true}, {"attribute_expression": "private static String description;", "docstring": " Option description", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "description", "syntax_pass": true}, {"attribute_expression": "private static String argName;", "docstring": " Argument name", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "argName", "syntax_pass": true}, {"attribute_expression": "private static boolean required;", "docstring": " Is required?", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "boolean", "name": "required", "syntax_pass": true}, {"attribute_expression": "private static int argCount = Option.UNINITIALIZED;", "docstring": " The number of arguments", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "int", "name": "argCount = Option.UNINITIALIZED", "syntax_pass": true}, {"attribute_expression": "private static Class<?> type;", "docstring": " Option type", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Class<?>", "name": "type", "syntax_pass": true}, {"attribute_expression": "private static boolean optionalArg;", "docstring": " Option can have an optional argument value", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "boolean", "name": "optionalArg", "syntax_pass": true}, {"attribute_expression": "private static char valueSeparator;", "docstring": " Value separator for argument value", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "char", "name": "valueSeparator", "syntax_pass": true}, {"attribute_expression": "private static final OptionBuilder INSTANCE = new OptionBuilder();", "docstring": " Option builder instance", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "OptionBuilder", "name": "INSTANCE = new OptionBuilder()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static Option create() throws IllegalArgumentException {\n        if (longOption == null) {\n            reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }", "docstring": "\nCreates an Option using the current settings\n\n@return the Option instance\n@throws IllegalArgumentException if {@code longOpt} has not been set.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Option", "classes": []}, "name": "create", "params": [], "body": "                                                                  {\n        if (longOption == null) {\n            reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }", "signature": "public static Option create()"}, {"syntax_pass": true, "original_string": "    public static Option create(final char opt) throws IllegalArgumentException {\n        return create(String.valueOf(opt));\n    }", "docstring": "\nCreates an Option using the current settings and with the specified Option {@code char}.\n\n@param opt the character representation of the Option\n@return the Option instance\n@throws IllegalArgumentException if {@code opt} is not a valid character. See Option.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Option", "classes": []}, "name": "create", "params": [{"name": "opt", "type": "char"}], "body": "                                                                                {\n        return create(String.valueOf(opt));\n    }", "signature": "public static Option create(final char opt)"}, {"syntax_pass": true, "original_string": "    public static Option create(final String opt) throws IllegalArgumentException {\n        Option option;\n        try {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longOption);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(argCount);\n            option.setType(type);\n            option.setConverter(TypeHandler.getDefault().getConverter(type));\n            option.setValueSeparator(valueSeparator);\n            option.setArgName(argName);\n        } finally {\n            // reset the OptionBuilder properties\n            reset();\n        }\n\n        // return the Option instance\n        return option;\n    }", "docstring": "\nCreates an Option using the current settings and with the specified Option {@code char}.\n\n@param opt the {@code String} representation of the Option\n@return the Option instance\n@throws IllegalArgumentException if {@code opt} is not a valid character. See Option.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Option", "classes": []}, "name": "create", "params": [{"name": "opt", "type": "String"}], "body": "                                                                                  {\n        Option option;\n        try {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longOption);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(argCount);\n            option.setType(type);\n            option.setConverter(TypeHandler.getDefault().getConverter(type));\n            option.setValueSeparator(valueSeparator);\n            option.setArgName(argName);\n        } finally {\n            // reset the OptionBuilder properties\n            reset();\n        }\n\n        // return the Option instance\n        return option;\n    }", "signature": "public static Option create(final String opt)"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder hasArg() {\n        argCount = 1;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created will require an argument value.\n\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "hasArg", "params": [], "body": "                                         {\n        argCount = 1;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder hasArg()"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder hasArg(final boolean hasArg) {\n        argCount = hasArg ? 1 : Option.UNINITIALIZED;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created will require an argument value if {@code hasArg} is true.\n\n@param hasArg if true then the Option has an argument value\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "hasArg", "params": [{"name": "hasArg", "type": "boolean"}], "body": "                                                             {\n        argCount = hasArg ? 1 : Option.UNINITIALIZED;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder hasArg(final boolean hasArg)"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder hasArgs() {\n        argCount = Option.UNLIMITED_VALUES;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created can have unlimited argument values.\n\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "hasArgs", "params": [], "body": "                                          {\n        argCount = Option.UNLIMITED_VALUES;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder hasArgs()"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder hasArgs(final int num) {\n        argCount = num;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created can have {@code num} argument values.\n\n@param num the number of args that the option can have\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "hasArgs", "params": [{"name": "num", "type": "int"}], "body": "                                                       {\n        argCount = num;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder hasArgs(final int num)"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder hasOptionalArg() {\n        argCount = 1;\n        optionalArg = true;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option can have an optional argument.\n\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "hasOptionalArg", "params": [], "body": "                                                 {\n        argCount = 1;\n        optionalArg = true;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder hasOptionalArg()"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder hasOptionalArgs() {\n        argCount = Option.UNLIMITED_VALUES;\n        optionalArg = true;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option can have an unlimited number of optional arguments.\n\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "hasOptionalArgs", "params": [], "body": "                                                  {\n        argCount = Option.UNLIMITED_VALUES;\n        optionalArg = true;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder hasOptionalArgs()"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder hasOptionalArgs(final int numArgs) {\n        argCount = numArgs;\n        optionalArg = true;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option can have the specified number of optional arguments.\n\n@param numArgs   the maximum number of optional arguments the next Option created can have.\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "hasOptionalArgs", "params": [{"name": "numArgs", "type": "int"}], "body": "                                                                   {\n        argCount = numArgs;\n        optionalArg = true;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder hasOptionalArgs(final int numArgs)"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder isRequired() {\n        required = true;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created will be required.\n\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "isRequired", "params": [], "body": "                                             {\n        required = true;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder isRequired()"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder isRequired(final boolean newRequired) {\n        required = newRequired;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created will be required if {@code required} is true.\n\n@param newRequired if true then the Option is required\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "isRequired", "params": [{"name": "newRequired", "type": "boolean"}], "body": "                                                                      {\n        required = newRequired;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder isRequired(final boolean newRequired)"}, {"syntax_pass": true, "original_string": "    private static void reset() {\n        description = null;\n        argName = null;\n        longOption = null;\n        type = String.class;\n        required = false;\n        argCount = Option.UNINITIALIZED;\n        optionalArg = false;\n        valueSeparator = (char) 0;\n    }", "docstring": "\nResets the member variables to their default values.\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "                                {\n        description = null;\n        argName = null;\n        longOption = null;\n        type = String.class;\n        required = false;\n        argCount = Option.UNINITIALIZED;\n        optionalArg = false;\n        valueSeparator = (char) 0;\n    }", "signature": "private static void reset()"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder withArgName(final String name) {\n        argName = name;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created will have the specified argument value name.\n\n@param name the name for the argument value\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "withArgName", "params": [{"name": "name", "type": "String"}], "body": "                                                               {\n        argName = name;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder withArgName(final String name)"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder withDescription(final String newDescription) {\n        description = newDescription;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created will have the specified description\n\n@param newDescription a description of the Option's purpose\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "withDescription", "params": [{"name": "newDescription", "type": "String"}], "body": "                                                                             {\n        description = newDescription;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder withDescription(final String newDescription)"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder withLongOpt(final String newLongopt) {\n        longOption = newLongopt;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created will have the following long option value.\n\n@param newLongopt the long option value\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "withLongOpt", "params": [{"name": "newLongopt", "type": "String"}], "body": "                                                                     {\n        longOption = newLongopt;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder withLongOpt(final String newLongopt)"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder withType(final Class<?> newType) {\n        type = newType;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created will have a value that will be an instance of {@code type}.\n\n@param newType the type of the Options argument value\n@return the OptionBuilder instance\n@since 1.3\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "withType", "params": [{"name": "newType", "type": "Class<?>"}], "body": "                                                                 {\n        type = newType;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder withType(final Class<?> newType)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public static OptionBuilder withType(final Object newType) {\n        return withType((Class<?>) newType);\n    }", "docstring": "\nThe next Option created will have a value that will be an instance of {@code type}.\n<p>\n<b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class}\nobject.\n\n@param newType the type of the Options argument value\n@return the OptionBuilder instance\n@deprecated since 1.3, use {@link #withType(Class)} instead\n", "attributes": {"modifiers": "@Deprecated\n    public static", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "withType", "params": [{"name": "newType", "type": "Object"}], "body": "                                                               {\n        return withType((Class<?>) newType);\n    }", "signature": "@Deprecated\n    public static OptionBuilder withType(final Object newType)"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder withValueSeparator() {\n        valueSeparator = Char.EQUAL;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created uses '{@code =}' as a means to separate argument values.\n\n<b>Example:</b>\n\n<pre>\nOption opt = withValueSeparator().create('D');\n\nCommandLine line = parser.parse(args);\nString propertyName = opt.getValue(0);\nString propertyValue = opt.getValue(1);\n</pre>\n\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "withValueSeparator", "params": [], "body": "                                                     {\n        valueSeparator = Char.EQUAL;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder withValueSeparator()"}, {"syntax_pass": true, "original_string": "    public static OptionBuilder withValueSeparator(final char sep) {\n        valueSeparator = sep;\n        return INSTANCE;\n    }", "docstring": "\nThe next Option created uses {@code sep} as a means to separate argument values.\n<p>\n<b>Example:</b>\n\n<pre>\nOption opt = OptionBuilder.withValueSeparator('=').create('D');\n\nString args = \"-Dkey=value\";\nCommandLine line = parser.parse(args);\nString propertyName = opt.getValue(0); // will be \"key\"\nString propertyValue = opt.getValue(1); // will be \"value\"\n</pre>\n\n@param sep The value separator to be used for the argument values.\n\n@return the OptionBuilder instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "OptionBuilder", "classes": []}, "name": "withValueSeparator", "params": [{"name": "sep", "type": "char"}], "body": "                                                                   {\n        valueSeparator = sep;\n        return INSTANCE;\n    }", "signature": "public static OptionBuilder withValueSeparator(final char sep)"}, {"syntax_pass": true, "original_string": "    private OptionBuilder() {\n        // hide the constructor\n    }", "docstring": "\nprivate constructor to prevent instances being created\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "OptionBuilder", "params": [], "body": "                            {\n        // hide the constructor\n    }", "signature": "private OptionBuilder()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/HelpFormatter.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.io.StringReader;\nimport java.io.UncheckedIOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\n/**\n * A formatter of help messages for command line options.\n * <p>\n * Example:\n * </p>\n * <pre>\n * Options options = new Options();\n * options.addOption(OptionBuilder.withLongOpt(\"file\").withDescription(\"The file to be processed\").hasArg().withArgName(\"FILE\").isRequired().create('f'));\n * options.addOption(OptionBuilder.withLongOpt(\"version\").withDescription(\"Print the version of the application\").create('v'));\n * options.addOption(OptionBuilder.withLongOpt(\"help\").create('h'));\n *\n * String header = \"Do something useful with an input file\\n\\n\";\n * String footer = \"\\nPlease report issues at https://example.com/issues\";\n *\n * HelpFormatter formatter = new HelpFormatter();\n * formatter.printHelp(\"myapp\", header, options, footer, true);\n * </pre>\n * <p>\n * This produces the following output:\n * </p>\n * <pre>\n * usage: myapp -f &lt;FILE&gt; [-h] [-v]\n * Do something useful with an input file\n *\n *  -f,--file &lt;FILE&gt;   The file to be processed\n *  -h,--help\n *  -v,--version       Print the version of the application\n *\n * Please report issues at https://example.com/issues\n * </pre>\n */\npublic class HelpFormatter {\n\n    /**\n     * Builds {@link HelpFormatter}.\n     *\n     * @since 1.7.0\n     */\n    public static class Builder implements Supplier<HelpFormatter> {\n        // TODO All other instance HelpFormatter instance variables.\n        // Make HelpFormatter immutable for 2.0\n\n        /**\n         * A function to convert a description (not null) and a deprecated Option (not null) to help description\n         */\n        private static final Function<Option, String> DEFAULT_DEPRECATED_FORMAT = o -> \"[Deprecated] \" + getDescription(o);\n\n        /**\n         * Formatter for deprecated options.\n         */\n        private Function<Option, String> deprecatedFormatFunction = DEFAULT_DEPRECATED_FORMAT;\n\n        /**\n         * The output PrintWriter, defaults to wrapping {@link System#out}.\n         */\n        private PrintWriter printStream = createDefaultPrintWriter();\n\n        /** The flag to determine if the since values should be dispalyed */\n        private boolean showSince;\n\n        @Override\n        public HelpFormatter get() {\n            return new HelpFormatter(deprecatedFormatFunction, printStream, showSince);\n        }\n\n        /**\n         * Sets the output PrintWriter, defaults to wrapping {@link System#out}.\n         *\n         * @param printWriter the output PrintWriter, not null.\n         * @return {@code this} instance.\n         */\n        public Builder setPrintWriter(final PrintWriter printWriter) {\n            this.printStream = Objects.requireNonNull(printWriter, \"printWriter\");\n            return this;\n        }\n\n        /**\n         * Sets whether to show deprecated options.\n         *\n         * @param useDefaultFormat if {@code true} use the default format, otherwise clear the formatter.\n         * @return {@code this} instance.\n         */\n        public Builder setShowDeprecated(final boolean useDefaultFormat) {\n            return setShowDeprecated(useDefaultFormat ? DEFAULT_DEPRECATED_FORMAT : null);\n        }\n\n        /**\n         * Sets whether to show deprecated options.\n         *\n         * @param deprecatedFormatFunction Specify the format for the deprecated options.\n         * @return {@code this} instance.\n         * @since 1.8.0\n         */\n        public Builder setShowDeprecated(final Function<Option, String> deprecatedFormatFunction) {\n            this.deprecatedFormatFunction = deprecatedFormatFunction;\n            return this;\n        }\n\n        /**\n         * Sets whether to show the date the option was first added.\n         * @param showSince if @{code true} the date the options was first added will be shown.\n         * @return this builder.\n         * @since 1.9.0\n         */\n        public Builder setShowSince(final boolean showSince) {\n            this.showSince = showSince;\n            return this;\n        }\n    }\n\n    /**\n     * This class implements the {@code Comparator} interface for comparing Options.\n     */\n    private static final class OptionComparator implements Comparator<Option>, Serializable {\n\n        /** The serial version UID. */\n        private static final long serialVersionUID = 5305467873966684014L;\n\n        /**\n         * Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param opt1 The first Option to be compared.\n         * @param opt2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than\n         *         the second.\n         */\n        @Override\n        public int compare(final Option opt1, final Option opt2) {\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n    /** \"Options\" text for options header */\n    private static final String HEADER_OPTIONS = \"Options\";\n\n    /** \"Since\" text for options header */\n    private static final String HEADER_SINCE = \"Since\";\n\n    /** \"Description\" test for options header */\n    private static final String HEADER_DESCRIPTION = \"Description\";\n\n    /** Default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** Default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /** Number of space characters to be prefixed to each description line */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** The string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** Default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** Default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /**\n     * Default separator displayed between a long Option and its value\n     *\n     * @since 1.3\n     */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** Default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    /**\n     * Creates a new builder.\n     *\n     * @return a new builder.\n     * @since 1.7.0\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    private static PrintWriter createDefaultPrintWriter() {\n        return new PrintWriter(System.out);\n    }\n\n    /**\n     * Gets the option description or an empty string if the description is {@code null}.\n     * @param option The option to get the description from.\n     * @return the option description or an empty string if the description is {@code null}.\n     * @since 1.8.0\n     */\n    public static String getDescription(final Option option) {\n        final String desc = option.getDescription();\n        return desc == null ? \"\" : desc;\n    }\n\n    /**\n     * Number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setWidth methods instead.\n     */\n    @Deprecated\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * Amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setLeftPadding methods instead.\n     */\n    @Deprecated\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * The number of characters of padding to be prefixed to each description line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setDescPadding methods instead.\n     */\n    @Deprecated\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * The string to display at the beginning of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version - use get/setSyntaxPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * The new line string\n     *\n     * @deprecated Scope will be made private for next major version - use get/setNewLine methods instead.\n     */\n    @Deprecated\n    public String defaultNewLine = System.lineSeparator();\n\n    /**\n     * The shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version - use get/setOptPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * The long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version - use get/setLongOptPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * The name of the argument\n     *\n     * @deprecated Scope will be made private for next major version - use get/setArgName methods instead.\n     */\n    @Deprecated\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     *\n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator<Option> optionComparator = new OptionComparator();\n\n    /**\n     * Function to format the description for a deprecated option.\n     */\n    private final Function<Option, String> deprecatedFormatFunction;\n\n    /**\n     * Where to print help.\n     */\n    private final PrintWriter printWriter;\n\n    /** Flag to determine if since field should be displayed */\n    private final boolean showSince;\n\n    /**\n     * The separator displayed between the long option and its value.\n     */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * Constructs a new instance.\n     */\n    public HelpFormatter() {\n        this(null, createDefaultPrintWriter(), false);\n    }\n\n    /**\n     * Constructs a new instance.\n     * @param printWriter TODO\n     */\n    private HelpFormatter(final Function<Option, String> deprecatedFormatFunction, final PrintWriter printWriter, final boolean showSince) {\n        // TODO All other instance HelpFormatter instance variables.\n        // Make HelpFormatter immutable for 2.0\n        this.deprecatedFormatFunction = deprecatedFormatFunction;\n        this.printWriter = printWriter;\n        this.showSince = showSince;\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.\n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuilder buff, final Option option, final boolean required) {\n        if (!required) {\n            buff.append(\"[\");\n        }\n        if (option.getOpt() != null) {\n            buff.append(\"-\").append(option.getOpt());\n        } else {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || !option.getArgName().isEmpty())) {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        // if the Option is not a required option\n        if (!required) {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer. The clause is wrapped in square brackets if the group\n     * is required. The display of the options is handled by appendOption\n     *\n     * @param buff the StringBuilder to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuilder,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuilder buff, final OptionGroup group) {\n        if (!group.isRequired()) {\n            buff.append(\"[\");\n        }\n        final List<Option> optList = new ArrayList<>(group.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // for each option in the OptionGroup\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, it.next(), true);\n\n            if (it.hasNext()) {\n                buff.append(\" | \");\n            }\n        }\n        if (!group.isRequired()) {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Renders the specified Options and return the rendered Options in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     * @return the StringBuffer with the rendered Options contents.\n     * @throws IOException if an I/O error occurs.\n     */\n    <A extends Appendable> A appendOptions(final A sb, final int width, final Options options, final int leftPad, final int descPad) throws IOException {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n        // first create list containing only <lpad>-a,--aaa where\n        // -a is opt and --aaa is long opt; in parallel look for\n        // the longest opt string this list will be then used to\n        // sort options ascending\n        int max = 0;\n        final int maxSince = showSince ? determineMaxSinceLength(options) + leftPad : 0;\n        final List<StringBuilder> prefixList = new ArrayList<>();\n        final List<Option> optList = options.helpOptions();\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        for (final Option option : optList) {\n            final StringBuilder optBuf = new StringBuilder();\n            if (option.getOpt() == null) {\n                optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\n            } else {\n                optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());\n                if (option.hasLongOpt()) {\n                    optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());\n                }\n            }\n            if (option.hasArg()) {\n                final String argName = option.getArgName();\n                if (argName != null && argName.isEmpty()) {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                } else {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = Math.max(optBuf.length() + maxSince, max);\n        }\n        final int nextLineTabStop = max + descPad;\n        if (showSince) {\n            final StringBuilder optHeader = new StringBuilder(HEADER_OPTIONS).append(createPadding(max - maxSince - HEADER_OPTIONS.length() + leftPad))\n                    .append(HEADER_SINCE);\n            optHeader.append(createPadding(max - optHeader.length())).append(lpad).append(HEADER_DESCRIPTION);\n            appendWrappedText(sb, width, nextLineTabStop, optHeader.toString());\n            sb.append(getNewLine());\n        }\n\n        int x = 0;\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            final Option option = it.next();\n            final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\n            if (optBuf.length() < max) {\n                optBuf.append(createPadding(max - maxSince - optBuf.length()));\n                if (showSince) {\n                    optBuf.append(lpad).append(option.getSince() == null ? \"-\" : option.getSince());\n                }\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n            optBuf.append(dpad);\n\n            if (deprecatedFormatFunction != null && option.isDeprecated()) {\n                optBuf.append(deprecatedFormatFunction.apply(option).trim());\n            } else if (option.getDescription() != null) {\n                optBuf.append(option.getDescription());\n            }\n            appendWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n            if (it.hasNext()) {\n                sb.append(getNewLine());\n            }\n        }\n        return sb;\n    }\n\n    /**\n     * Renders the specified text and return the rendered Options in a StringBuffer.\n     *\n     * @param <A> The Appendable implementation.\n     * @param appendable The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     * @return the StringBuffer with the rendered Options contents.\n     * @throws IOException if an I/O error occurs.\n     */\n    <A extends Appendable> A appendWrappedText(final A appendable, final int width, final int nextLineTabStop, final String text) throws IOException {\n        String render = text;\n        int nextLineTabStopPos = nextLineTabStop;\n        int pos = findWrapPos(render, width, 0);\n        if (pos == -1) {\n            appendable.append(rtrim(render));\n            return appendable;\n        }\n        appendable.append(rtrim(render.substring(0, pos))).append(getNewLine());\n        if (nextLineTabStopPos >= width) {\n            // stops infinite loop happening\n            nextLineTabStopPos = 1;\n        }\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStopPos);\n        while (true) {\n            render = padding + render.substring(pos).trim();\n            pos = findWrapPos(render, width, 0);\n            if (pos == -1) {\n                appendable.append(render);\n                return appendable;\n            }\n            if (render.length() > width && pos == nextLineTabStopPos - 1) {\n                pos = width;\n            }\n            appendable.append(rtrim(render.substring(0, pos))).append(getNewLine());\n        }\n    }\n\n    /**\n     * Creates a String of padding of length {@code len}.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(final int len) {\n        final char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        return new String(padding);\n    }\n\n    private int determineMaxSinceLength(final Options options) {\n        final int minLen = HEADER_SINCE.length();\n        final int len = options.getOptions().stream().map(o -> o.getSince() == null ? minLen : o.getSince().length()).max(Integer::compareTo).orElse(minLen);\n        return len < minLen ? minLen : len;\n    }\n\n    /**\n     * Finds the next text wrap position after {@code startPos} for the text in {@code text} with the column width\n     * {@code width}. The wrap point is the last position before startPos+width having a whitespace character (space,\n     * \\n, \\r). If there is no whitespace character before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace character\n     * @return position on which the text must be wrapped or -1 if the wrap position is at the end of the text\n     */\n    protected int findWrapPos(final String text, final int width, final int startPos) {\n        // the line ends before the max wrap pos or a new line char found\n        int pos = text.indexOf(Char.LF, startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n        pos = text.indexOf(Char.TAB, startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n        if (startPos + width >= text.length()) {\n            return -1;\n        }\n        // look for the last whitespace character before startPos+width\n        for (pos = startPos + width; pos >= startPos; --pos) {\n            final char c = text.charAt(pos);\n            if (c == Char.SP || c == Char.LF || c == Char.CR) {\n                break;\n            }\n        }\n        // if we found it - just return\n        if (pos > startPos) {\n            return pos;\n        }\n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Gets the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName() {\n        return defaultArgName;\n    }\n\n    /**\n     * Gets the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding() {\n        return defaultDescPad;\n    }\n\n    /**\n     * Gets the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding() {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Gets the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix() {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Gets the separator displayed between a long option and its value.\n     *\n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator() {\n        return longOptSeparator;\n    }\n\n    /**\n     * Gets the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine() {\n        return defaultNewLine;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text. Defaults to case-insensitive alphabetical sorting\n     * by option key.\n     *\n     * @return the {@link Comparator} currently in use to sort the options\n     * @since 1.2\n     */\n    public Comparator<Option> getOptionComparator() {\n        return optionComparator;\n    }\n\n    /**\n     * Gets the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix() {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Gets the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix() {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Gets the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth() {\n        return defaultWidth;\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to  {@link System#out}  by default.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer,\n        final boolean autoUsage) {\n        final PrintWriter pw = new PrintWriter(printWriter);\n        printHelp(pw, width, cmdLineSyntax, header, options, getLeftPadding(), getDescPadding(), footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer) {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer, final boolean autoUsage) {\n        if (Util.isEmpty(cmdLineSyntax)) {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n        if (autoUsage) {\n            printUsage(pw, width, cmdLineSyntax, options);\n        } else {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n        if (header != null && !header.isEmpty()) {\n            printWrapped(pw, width, header);\n        }\n        printOptions(pw, width, options, leftPad, descPad);\n        if (footer != null && !footer.isEmpty()) {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(final String cmdLineSyntax, final Options options) {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage) {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage) {\n        printHelp(getWidth(), cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Prints the help for the specified Options to the specified writer, using the specified width, left padding and\n     * description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     */\n    public void printOptions(final PrintWriter pw, final int width, final Options options, final int leftPad, final int descPad) {\n        try {\n            pw.println(appendOptions(new StringBuilder(), width, options, leftPad, descPad));\n        } catch (final IOException e) {\n            // Cannot happen\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Prints the cmdLineSyntax to the specified writer, using the specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax) {\n        final int argPos = cmdLineSyntax.indexOf(' ') + 1;\n        printWrapped(pw, width, getSyntaxPrefix().length() + argPos, getSyntaxPrefix() + cmdLineSyntax);\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement\n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(final PrintWriter pw, final int width, final String app, final Options options) {\n        // initialize the string buffer\n        final StringBuilder buff = new StringBuilder(getSyntaxPrefix()).append(app).append(Char.SP);\n        // create a list for processed option groups\n        final Collection<OptionGroup> processedGroups = new ArrayList<>();\n        final List<Option> optList = new ArrayList<>(options.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // iterate over the options\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // get the next Option\n            final Option option = it.next();\n            // check if the option is part of an OptionGroup\n            final OptionGroup group = options.getOptionGroup(option);\n            // if the option is part of a group\n            if (group != null) {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group)) {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n            // if the Option is not part of an OptionGroup\n            else {\n                appendOption(buff, option, option.isRequired());\n            }\n            if (it.hasNext()) {\n                buff.append(Char.SP);\n            }\n        }\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Prints the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text) {\n        pw.println(renderWrappedTextBlock(new StringBuilder(text.length()), width, nextLineTabStop, text));\n    }\n\n    /**\n     * Prints the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(final PrintWriter pw, final int width, final String text) {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Renders the specified Options and return the rendered Options in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad) {\n        try {\n            return appendOptions(sb, width, options, leftPad, descPad);\n        } catch (final IOException e) {\n            // Cannot happen\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Renders the specified text and return the rendered Options in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(final StringBuffer sb, final int width, final int nextLineTabStop, final String text) {\n        try {\n            return appendWrappedText(sb, width, nextLineTabStop, text);\n        } catch (final IOException e) {\n            // Cannot happen.\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Renders the specified text width a maximum width. This method differs from renderWrappedText by not removing leading\n     * spaces after a new line.\n     *\n     * @param appendable The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     */\n    private <A extends Appendable> A renderWrappedTextBlock(final A appendable, final int width, final int nextLineTabStop, final String text) {\n        try {\n            final BufferedReader in = new BufferedReader(new StringReader(text));\n            String line;\n            boolean firstLine = true;\n            while ((line = in.readLine()) != null) {\n                if (!firstLine) {\n                    appendable.append(getNewLine());\n                } else {\n                    firstLine = false;\n                }\n                appendWrappedText(appendable, width, nextLineTabStop, line);\n            }\n        } catch (final IOException e) { // NOPMD\n            // cannot happen\n        }\n        return appendable;\n    }\n\n    /**\n     * Removes the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(final String s) {\n        if (Util.isEmpty(s)) {\n            return s;\n        }\n        int pos = s.length();\n        while (pos > 0 && Character.isWhitespace(s.charAt(pos - 1))) {\n            --pos;\n        }\n        return s.substring(0, pos);\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(final String name) {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(final int padding) {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(final int padding) {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(final String prefix) {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Sets the separator displayed between a long option and its value. Ensure that the separator specified is supported by\n     * the parser used, typically ' ' or '='.\n     *\n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(final String longOptSeparator) {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(final String newline) {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Sets the comparator used to sort the options when they output in help text. Passing in a null comparator will keep the\n     * options in the order they were declared.\n     *\n     * @param comparator the {@link Comparator} to use for sorting the options\n     * @since 1.2\n     */\n    public void setOptionComparator(final Comparator<Option> comparator) {\n        this.optionComparator = comparator;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(final String prefix) {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(final String prefix) {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(final int width) {\n        this.defaultWidth = width;\n    }\n\n}\n", "file_hash": "967617d5182b21f772bd88d991c5bf0e75229b2a9efffbbb63ccb7337e2f5b8e", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.io.BufferedReader;", "import java.io.IOException;", "import java.io.PrintWriter;", "import java.io.Serializable;", "import java.io.StringReader;", "import java.io.UncheckedIOException;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.Comparator;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Objects;", "import java.util.function.Function;", "import java.util.function.Supplier;"], "methods": [], "classes": [{"original_string": "public class HelpFormatter {\n\n    /**\n     * Builds {@link HelpFormatter}.\n     *\n     * @since 1.7.0\n     */\n    public static class Builder implements Supplier<HelpFormatter> {\n        // TODO All other instance HelpFormatter instance variables.\n        // Make HelpFormatter immutable for 2.0\n\n        /**\n         * A function to convert a description (not null) and a deprecated Option (not null) to help description\n         */\n        private static final Function<Option, String> DEFAULT_DEPRECATED_FORMAT = o -> \"[Deprecated] \" + getDescription(o);\n\n        /**\n         * Formatter for deprecated options.\n         */\n        private Function<Option, String> deprecatedFormatFunction = DEFAULT_DEPRECATED_FORMAT;\n\n        /**\n         * The output PrintWriter, defaults to wrapping {@link System#out}.\n         */\n        private PrintWriter printStream = createDefaultPrintWriter();\n\n        /** The flag to determine if the since values should be dispalyed */\n        private boolean showSince;\n\n        @Override\n        public HelpFormatter get() {\n            return new HelpFormatter(deprecatedFormatFunction, printStream, showSince);\n        }\n\n        /**\n         * Sets the output PrintWriter, defaults to wrapping {@link System#out}.\n         *\n         * @param printWriter the output PrintWriter, not null.\n         * @return {@code this} instance.\n         */\n        public Builder setPrintWriter(final PrintWriter printWriter) {\n            this.printStream = Objects.requireNonNull(printWriter, \"printWriter\");\n            return this;\n        }\n\n        /**\n         * Sets whether to show deprecated options.\n         *\n         * @param useDefaultFormat if {@code true} use the default format, otherwise clear the formatter.\n         * @return {@code this} instance.\n         */\n        public Builder setShowDeprecated(final boolean useDefaultFormat) {\n            return setShowDeprecated(useDefaultFormat ? DEFAULT_DEPRECATED_FORMAT : null);\n        }\n\n        /**\n         * Sets whether to show deprecated options.\n         *\n         * @param deprecatedFormatFunction Specify the format for the deprecated options.\n         * @return {@code this} instance.\n         * @since 1.8.0\n         */\n        public Builder setShowDeprecated(final Function<Option, String> deprecatedFormatFunction) {\n            this.deprecatedFormatFunction = deprecatedFormatFunction;\n            return this;\n        }\n\n        /**\n         * Sets whether to show the date the option was first added.\n         * @param showSince if @{code true} the date the options was first added will be shown.\n         * @return this builder.\n         * @since 1.9.0\n         */\n        public Builder setShowSince(final boolean showSince) {\n            this.showSince = showSince;\n            return this;\n        }\n    }\n\n    /**\n     * This class implements the {@code Comparator} interface for comparing Options.\n     */\n    private static final class OptionComparator implements Comparator<Option>, Serializable {\n\n        /** The serial version UID. */\n        private static final long serialVersionUID = 5305467873966684014L;\n\n        /**\n         * Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param opt1 The first Option to be compared.\n         * @param opt2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than\n         *         the second.\n         */\n        @Override\n        public int compare(final Option opt1, final Option opt2) {\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n    /** \"Options\" text for options header */\n    private static final String HEADER_OPTIONS = \"Options\";\n\n    /** \"Since\" text for options header */\n    private static final String HEADER_SINCE = \"Since\";\n\n    /** \"Description\" test for options header */\n    private static final String HEADER_DESCRIPTION = \"Description\";\n\n    /** Default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** Default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /** Number of space characters to be prefixed to each description line */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** The string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** Default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** Default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /**\n     * Default separator displayed between a long Option and its value\n     *\n     * @since 1.3\n     */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** Default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    /**\n     * Creates a new builder.\n     *\n     * @return a new builder.\n     * @since 1.7.0\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    private static PrintWriter createDefaultPrintWriter() {\n        return new PrintWriter(System.out);\n    }\n\n    /**\n     * Gets the option description or an empty string if the description is {@code null}.\n     * @param option The option to get the description from.\n     * @return the option description or an empty string if the description is {@code null}.\n     * @since 1.8.0\n     */\n    public static String getDescription(final Option option) {\n        final String desc = option.getDescription();\n        return desc == null ? \"\" : desc;\n    }\n\n    /**\n     * Number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setWidth methods instead.\n     */\n    @Deprecated\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * Amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setLeftPadding methods instead.\n     */\n    @Deprecated\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * The number of characters of padding to be prefixed to each description line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setDescPadding methods instead.\n     */\n    @Deprecated\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * The string to display at the beginning of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version - use get/setSyntaxPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * The new line string\n     *\n     * @deprecated Scope will be made private for next major version - use get/setNewLine methods instead.\n     */\n    @Deprecated\n    public String defaultNewLine = System.lineSeparator();\n\n    /**\n     * The shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version - use get/setOptPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * The long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version - use get/setLongOptPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * The name of the argument\n     *\n     * @deprecated Scope will be made private for next major version - use get/setArgName methods instead.\n     */\n    @Deprecated\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     *\n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator<Option> optionComparator = new OptionComparator();\n\n    /**\n     * Function to format the description for a deprecated option.\n     */\n    private final Function<Option, String> deprecatedFormatFunction;\n\n    /**\n     * Where to print help.\n     */\n    private final PrintWriter printWriter;\n\n    /** Flag to determine if since field should be displayed */\n    private final boolean showSince;\n\n    /**\n     * The separator displayed between the long option and its value.\n     */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * Constructs a new instance.\n     */\n    public HelpFormatter() {\n        this(null, createDefaultPrintWriter(), false);\n    }\n\n    /**\n     * Constructs a new instance.\n     * @param printWriter TODO\n     */\n    private HelpFormatter(final Function<Option, String> deprecatedFormatFunction, final PrintWriter printWriter, final boolean showSince) {\n        // TODO All other instance HelpFormatter instance variables.\n        // Make HelpFormatter immutable for 2.0\n        this.deprecatedFormatFunction = deprecatedFormatFunction;\n        this.printWriter = printWriter;\n        this.showSince = showSince;\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.\n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuilder buff, final Option option, final boolean required) {\n        if (!required) {\n            buff.append(\"[\");\n        }\n        if (option.getOpt() != null) {\n            buff.append(\"-\").append(option.getOpt());\n        } else {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || !option.getArgName().isEmpty())) {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        // if the Option is not a required option\n        if (!required) {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer. The clause is wrapped in square brackets if the group\n     * is required. The display of the options is handled by appendOption\n     *\n     * @param buff the StringBuilder to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuilder,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuilder buff, final OptionGroup group) {\n        if (!group.isRequired()) {\n            buff.append(\"[\");\n        }\n        final List<Option> optList = new ArrayList<>(group.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // for each option in the OptionGroup\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, it.next(), true);\n\n            if (it.hasNext()) {\n                buff.append(\" | \");\n            }\n        }\n        if (!group.isRequired()) {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Renders the specified Options and return the rendered Options in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     * @return the StringBuffer with the rendered Options contents.\n     * @throws IOException if an I/O error occurs.\n     */\n    <A extends Appendable> A appendOptions(final A sb, final int width, final Options options, final int leftPad, final int descPad) throws IOException {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n        // first create list containing only <lpad>-a,--aaa where\n        // -a is opt and --aaa is long opt; in parallel look for\n        // the longest opt string this list will be then used to\n        // sort options ascending\n        int max = 0;\n        final int maxSince = showSince ? determineMaxSinceLength(options) + leftPad : 0;\n        final List<StringBuilder> prefixList = new ArrayList<>();\n        final List<Option> optList = options.helpOptions();\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        for (final Option option : optList) {\n            final StringBuilder optBuf = new StringBuilder();\n            if (option.getOpt() == null) {\n                optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\n            } else {\n                optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());\n                if (option.hasLongOpt()) {\n                    optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());\n                }\n            }\n            if (option.hasArg()) {\n                final String argName = option.getArgName();\n                if (argName != null && argName.isEmpty()) {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                } else {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = Math.max(optBuf.length() + maxSince, max);\n        }\n        final int nextLineTabStop = max + descPad;\n        if (showSince) {\n            final StringBuilder optHeader = new StringBuilder(HEADER_OPTIONS).append(createPadding(max - maxSince - HEADER_OPTIONS.length() + leftPad))\n                    .append(HEADER_SINCE);\n            optHeader.append(createPadding(max - optHeader.length())).append(lpad).append(HEADER_DESCRIPTION);\n            appendWrappedText(sb, width, nextLineTabStop, optHeader.toString());\n            sb.append(getNewLine());\n        }\n\n        int x = 0;\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            final Option option = it.next();\n            final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\n            if (optBuf.length() < max) {\n                optBuf.append(createPadding(max - maxSince - optBuf.length()));\n                if (showSince) {\n                    optBuf.append(lpad).append(option.getSince() == null ? \"-\" : option.getSince());\n                }\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n            optBuf.append(dpad);\n\n            if (deprecatedFormatFunction != null && option.isDeprecated()) {\n                optBuf.append(deprecatedFormatFunction.apply(option).trim());\n            } else if (option.getDescription() != null) {\n                optBuf.append(option.getDescription());\n            }\n            appendWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n            if (it.hasNext()) {\n                sb.append(getNewLine());\n            }\n        }\n        return sb;\n    }\n\n    /**\n     * Renders the specified text and return the rendered Options in a StringBuffer.\n     *\n     * @param <A> The Appendable implementation.\n     * @param appendable The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     * @return the StringBuffer with the rendered Options contents.\n     * @throws IOException if an I/O error occurs.\n     */\n    <A extends Appendable> A appendWrappedText(final A appendable, final int width, final int nextLineTabStop, final String text) throws IOException {\n        String render = text;\n        int nextLineTabStopPos = nextLineTabStop;\n        int pos = findWrapPos(render, width, 0);\n        if (pos == -1) {\n            appendable.append(rtrim(render));\n            return appendable;\n        }\n        appendable.append(rtrim(render.substring(0, pos))).append(getNewLine());\n        if (nextLineTabStopPos >= width) {\n            // stops infinite loop happening\n            nextLineTabStopPos = 1;\n        }\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStopPos);\n        while (true) {\n            render = padding + render.substring(pos).trim();\n            pos = findWrapPos(render, width, 0);\n            if (pos == -1) {\n                appendable.append(render);\n                return appendable;\n            }\n            if (render.length() > width && pos == nextLineTabStopPos - 1) {\n                pos = width;\n            }\n            appendable.append(rtrim(render.substring(0, pos))).append(getNewLine());\n        }\n    }\n\n    /**\n     * Creates a String of padding of length {@code len}.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(final int len) {\n        final char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        return new String(padding);\n    }\n\n    private int determineMaxSinceLength(final Options options) {\n        final int minLen = HEADER_SINCE.length();\n        final int len = options.getOptions().stream().map(o -> o.getSince() == null ? minLen : o.getSince().length()).max(Integer::compareTo).orElse(minLen);\n        return len < minLen ? minLen : len;\n    }\n\n    /**\n     * Finds the next text wrap position after {@code startPos} for the text in {@code text} with the column width\n     * {@code width}. The wrap point is the last position before startPos+width having a whitespace character (space,\n     * \\n, \\r). If there is no whitespace character before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace character\n     * @return position on which the text must be wrapped or -1 if the wrap position is at the end of the text\n     */\n    protected int findWrapPos(final String text, final int width, final int startPos) {\n        // the line ends before the max wrap pos or a new line char found\n        int pos = text.indexOf(Char.LF, startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n        pos = text.indexOf(Char.TAB, startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n        if (startPos + width >= text.length()) {\n            return -1;\n        }\n        // look for the last whitespace character before startPos+width\n        for (pos = startPos + width; pos >= startPos; --pos) {\n            final char c = text.charAt(pos);\n            if (c == Char.SP || c == Char.LF || c == Char.CR) {\n                break;\n            }\n        }\n        // if we found it - just return\n        if (pos > startPos) {\n            return pos;\n        }\n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Gets the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName() {\n        return defaultArgName;\n    }\n\n    /**\n     * Gets the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding() {\n        return defaultDescPad;\n    }\n\n    /**\n     * Gets the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding() {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Gets the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix() {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Gets the separator displayed between a long option and its value.\n     *\n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator() {\n        return longOptSeparator;\n    }\n\n    /**\n     * Gets the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine() {\n        return defaultNewLine;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text. Defaults to case-insensitive alphabetical sorting\n     * by option key.\n     *\n     * @return the {@link Comparator} currently in use to sort the options\n     * @since 1.2\n     */\n    public Comparator<Option> getOptionComparator() {\n        return optionComparator;\n    }\n\n    /**\n     * Gets the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix() {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Gets the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix() {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Gets the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth() {\n        return defaultWidth;\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to  {@link System#out}  by default.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer,\n        final boolean autoUsage) {\n        final PrintWriter pw = new PrintWriter(printWriter);\n        printHelp(pw, width, cmdLineSyntax, header, options, getLeftPadding(), getDescPadding(), footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer) {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer, final boolean autoUsage) {\n        if (Util.isEmpty(cmdLineSyntax)) {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n        if (autoUsage) {\n            printUsage(pw, width, cmdLineSyntax, options);\n        } else {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n        if (header != null && !header.isEmpty()) {\n            printWrapped(pw, width, header);\n        }\n        printOptions(pw, width, options, leftPad, descPad);\n        if (footer != null && !footer.isEmpty()) {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(final String cmdLineSyntax, final Options options) {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage) {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage) {\n        printHelp(getWidth(), cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Prints the help for the specified Options to the specified writer, using the specified width, left padding and\n     * description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     */\n    public void printOptions(final PrintWriter pw, final int width, final Options options, final int leftPad, final int descPad) {\n        try {\n            pw.println(appendOptions(new StringBuilder(), width, options, leftPad, descPad));\n        } catch (final IOException e) {\n            // Cannot happen\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Prints the cmdLineSyntax to the specified writer, using the specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax) {\n        final int argPos = cmdLineSyntax.indexOf(' ') + 1;\n        printWrapped(pw, width, getSyntaxPrefix().length() + argPos, getSyntaxPrefix() + cmdLineSyntax);\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement\n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(final PrintWriter pw, final int width, final String app, final Options options) {\n        // initialize the string buffer\n        final StringBuilder buff = new StringBuilder(getSyntaxPrefix()).append(app).append(Char.SP);\n        // create a list for processed option groups\n        final Collection<OptionGroup> processedGroups = new ArrayList<>();\n        final List<Option> optList = new ArrayList<>(options.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // iterate over the options\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // get the next Option\n            final Option option = it.next();\n            // check if the option is part of an OptionGroup\n            final OptionGroup group = options.getOptionGroup(option);\n            // if the option is part of a group\n            if (group != null) {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group)) {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n            // if the Option is not part of an OptionGroup\n            else {\n                appendOption(buff, option, option.isRequired());\n            }\n            if (it.hasNext()) {\n                buff.append(Char.SP);\n            }\n        }\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Prints the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text) {\n        pw.println(renderWrappedTextBlock(new StringBuilder(text.length()), width, nextLineTabStop, text));\n    }\n\n    /**\n     * Prints the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(final PrintWriter pw, final int width, final String text) {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Renders the specified Options and return the rendered Options in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad) {\n        try {\n            return appendOptions(sb, width, options, leftPad, descPad);\n        } catch (final IOException e) {\n            // Cannot happen\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Renders the specified text and return the rendered Options in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(final StringBuffer sb, final int width, final int nextLineTabStop, final String text) {\n        try {\n            return appendWrappedText(sb, width, nextLineTabStop, text);\n        } catch (final IOException e) {\n            // Cannot happen.\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Renders the specified text width a maximum width. This method differs from renderWrappedText by not removing leading\n     * spaces after a new line.\n     *\n     * @param appendable The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     */\n    private <A extends Appendable> A renderWrappedTextBlock(final A appendable, final int width, final int nextLineTabStop, final String text) {\n        try {\n            final BufferedReader in = new BufferedReader(new StringReader(text));\n            String line;\n            boolean firstLine = true;\n            while ((line = in.readLine()) != null) {\n                if (!firstLine) {\n                    appendable.append(getNewLine());\n                } else {\n                    firstLine = false;\n                }\n                appendWrappedText(appendable, width, nextLineTabStop, line);\n            }\n        } catch (final IOException e) { // NOPMD\n            // cannot happen\n        }\n        return appendable;\n    }\n\n    /**\n     * Removes the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(final String s) {\n        if (Util.isEmpty(s)) {\n            return s;\n        }\n        int pos = s.length();\n        while (pos > 0 && Character.isWhitespace(s.charAt(pos - 1))) {\n            --pos;\n        }\n        return s.substring(0, pos);\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(final String name) {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(final int padding) {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(final int padding) {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(final String prefix) {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Sets the separator displayed between a long option and its value. Ensure that the separator specified is supported by\n     * the parser used, typically ' ' or '='.\n     *\n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(final String longOptSeparator) {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(final String newline) {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Sets the comparator used to sort the options when they output in help text. Passing in a null comparator will keep the\n     * options in the order they were declared.\n     *\n     * @param comparator the {@link Comparator} to use for sorting the options\n     * @since 1.2\n     */\n    public void setOptionComparator(final Comparator<Option> comparator) {\n        this.optionComparator = comparator;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(final String prefix) {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(final String prefix) {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(final int width) {\n        this.defaultWidth = width;\n    }\n\n}", "definition": "public class HelpFormatter", "class_docstring": "\nA formatter of help messages for command line options.\n<p>\nExample:\n</p>\n<pre>\nOptions options = new Options();\noptions.addOption(OptionBuilder.withLongOpt(\"file\").withDescription(\"The file to be processed\").hasArg().withArgName(\"FILE\").isRequired().create('f'));\noptions.addOption(OptionBuilder.withLongOpt(\"version\").withDescription(\"Print the version of the application\").create('v'));\noptions.addOption(OptionBuilder.withLongOpt(\"help\").create('h'));\n\nString header = \"Do something useful with an input file\\n\\n\";\nString footer = \"\\nPlease report issues at https://example.com/issues\";\n\nHelpFormatter formatter = new HelpFormatter();\nformatter.printHelp(\"myapp\", header, options, footer, true);\n</pre>\n<p>\nThis produces the following output:\n</p>\n<pre>\nusage: myapp -f &lt;FILE&gt; [-h] [-v]\nDo something useful with an input file\n\n -f,--file &lt;FILE&gt;   The file to be processed\n -h,--help\n -v,--version       Print the version of the application\n\nPlease report issues at https://example.com/issues\n</pre>\n", "name": "HelpFormatter", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final String HEADER_OPTIONS = \"Options\";", "docstring": " \"Options\" text for options header", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "HEADER_OPTIONS = \"Options\"", "syntax_pass": true}, {"attribute_expression": "private static final String HEADER_SINCE = \"Since\";", "docstring": " \"Since\" text for options header", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "HEADER_SINCE = \"Since\"", "syntax_pass": true}, {"attribute_expression": "private static final String HEADER_DESCRIPTION = \"Description\";", "docstring": " \"Description\" test for options header", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "HEADER_DESCRIPTION = \"Description\"", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_WIDTH = 74;", "docstring": " Default number of characters per line", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_WIDTH = 74", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_LEFT_PAD = 1;", "docstring": " Default padding to the left of each line", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_LEFT_PAD = 1", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_DESC_PAD = 3;", "docstring": " Number of space characters to be prefixed to each description line", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_DESC_PAD = 3", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";", "docstring": " The string to display at the beginning of the usage statement", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_SYNTAX_PREFIX = \"usage: \"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_OPT_PREFIX = \"-\";", "docstring": " Default prefix for shortOpts", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_OPT_PREFIX = \"-\"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";", "docstring": " Default prefix for long Option", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_LONG_OPT_PREFIX = \"--\"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";", "docstring": "\nDefault separator displayed between a long Option and its value\n\n@since 1.3\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_LONG_OPT_SEPARATOR = \" \"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_ARG_NAME = \"arg\";", "docstring": " Default name for an argument", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_ARG_NAME = \"arg\"", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public int defaultWidth = DEFAULT_WIDTH;", "docstring": "\nNumber of characters per line\n\n@deprecated Scope will be made private for next major version - use get/setWidth methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "defaultWidth = DEFAULT_WIDTH", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;", "docstring": "\nAmount of padding to the left of each line\n\n@deprecated Scope will be made private for next major version - use get/setLeftPadding methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "defaultLeftPad = DEFAULT_LEFT_PAD", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public int defaultDescPad = DEFAULT_DESC_PAD;", "docstring": "\nThe number of characters of padding to be prefixed to each description line\n\n@deprecated Scope will be made private for next major version - use get/setDescPadding methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "defaultDescPad = DEFAULT_DESC_PAD", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;", "docstring": "\nThe string to display at the beginning of the usage statement\n\n@deprecated Scope will be made private for next major version - use get/setSyntaxPrefix methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public String defaultNewLine = System.lineSeparator();", "docstring": "\nThe new line string\n\n@deprecated Scope will be made private for next major version - use get/setNewLine methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "defaultNewLine = System.lineSeparator()", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;", "docstring": "\nThe shortOpt prefix\n\n@deprecated Scope will be made private for next major version - use get/setOptPrefix methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "defaultOptPrefix = DEFAULT_OPT_PREFIX", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;", "docstring": "\nThe long Opt prefix\n\n@deprecated Scope will be made private for next major version - use get/setLongOptPrefix methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public String defaultArgName = DEFAULT_ARG_NAME;", "docstring": "\nThe name of the argument\n\n@deprecated Scope will be made private for next major version - use get/setArgName methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "defaultArgName = DEFAULT_ARG_NAME", "syntax_pass": true}, {"attribute_expression": "protected Comparator<Option> optionComparator = new OptionComparator();", "docstring": "\nComparator used to sort the options when they output in help text\n\nDefaults to case-insensitive alphabetical sorting by option key\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Comparator<Option>", "name": "optionComparator = new OptionComparator()", "syntax_pass": true}, {"attribute_expression": "private final Function<Option, String> deprecatedFormatFunction;", "docstring": "\nFunction to format the description for a deprecated option.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Function<Option, String>", "name": "deprecatedFormatFunction", "syntax_pass": true}, {"attribute_expression": "private final PrintWriter printWriter;", "docstring": "\nWhere to print help.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PrintWriter", "name": "printWriter", "syntax_pass": true}, {"attribute_expression": "private final boolean showSince;", "docstring": " Flag to determine if since field should be displayed", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "showSince", "syntax_pass": true}, {"attribute_expression": "private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;", "docstring": "\nThe separator displayed between the long option and its value.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR", "syntax_pass": true}], "classes": [{"original_string": "    public static class Builder implements Supplier<HelpFormatter> {\n        // TODO All other instance HelpFormatter instance variables.\n        // Make HelpFormatter immutable for 2.0\n\n        /**\n         * A function to convert a description (not null) and a deprecated Option (not null) to help description\n         */\n        private static final Function<Option, String> DEFAULT_DEPRECATED_FORMAT = o -> \"[Deprecated] \" + getDescription(o);\n\n        /**\n         * Formatter for deprecated options.\n         */\n        private Function<Option, String> deprecatedFormatFunction = DEFAULT_DEPRECATED_FORMAT;\n\n        /**\n         * The output PrintWriter, defaults to wrapping {@link System#out}.\n         */\n        private PrintWriter printStream = createDefaultPrintWriter();\n\n        /** The flag to determine if the since values should be dispalyed */\n        private boolean showSince;\n\n        @Override\n        public HelpFormatter get() {\n            return new HelpFormatter(deprecatedFormatFunction, printStream, showSince);\n        }\n\n        /**\n         * Sets the output PrintWriter, defaults to wrapping {@link System#out}.\n         *\n         * @param printWriter the output PrintWriter, not null.\n         * @return {@code this} instance.\n         */\n        public Builder setPrintWriter(final PrintWriter printWriter) {\n            this.printStream = Objects.requireNonNull(printWriter, \"printWriter\");\n            return this;\n        }\n\n        /**\n         * Sets whether to show deprecated options.\n         *\n         * @param useDefaultFormat if {@code true} use the default format, otherwise clear the formatter.\n         * @return {@code this} instance.\n         */\n        public Builder setShowDeprecated(final boolean useDefaultFormat) {\n            return setShowDeprecated(useDefaultFormat ? DEFAULT_DEPRECATED_FORMAT : null);\n        }\n\n        /**\n         * Sets whether to show deprecated options.\n         *\n         * @param deprecatedFormatFunction Specify the format for the deprecated options.\n         * @return {@code this} instance.\n         * @since 1.8.0\n         */\n        public Builder setShowDeprecated(final Function<Option, String> deprecatedFormatFunction) {\n            this.deprecatedFormatFunction = deprecatedFormatFunction;\n            return this;\n        }\n\n        /**\n         * Sets whether to show the date the option was first added.\n         * @param showSince if @{code true} the date the options was first added will be shown.\n         * @return this builder.\n         * @since 1.9.0\n         */\n        public Builder setShowSince(final boolean showSince) {\n            this.showSince = showSince;\n            return this;\n        }\n    }", "definition": "    public static class Builder implements Supplier<HelpFormatter>", "class_docstring": "\nBuilds {@link HelpFormatter}.\n\n@since 1.7.0\n", "name": "Builder", "super_interfaces": ["Supplier<HelpFormatter>"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final Function<Option, String> DEFAULT_DEPRECATED_FORMAT = o -> \"[Deprecated] \" + getDescription(o);", "docstring": "\nA function to convert a description (not null) and a deprecated Option (not null) to help description\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Function<Option, String>", "name": "DEFAULT_DEPRECATED_FORMAT = o -> \"[Deprecated] \" + getDescription(o)", "syntax_pass": true}, {"attribute_expression": "private Function<Option, String> deprecatedFormatFunction = DEFAULT_DEPRECATED_FORMAT;", "docstring": "\nFormatter for deprecated options.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Function<Option, String>", "name": "deprecatedFormatFunction = DEFAULT_DEPRECATED_FORMAT", "syntax_pass": true}, {"attribute_expression": "private PrintWriter printStream = createDefaultPrintWriter();", "docstring": "\nThe output PrintWriter, defaults to wrapping {@link System#out}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PrintWriter", "name": "printStream = createDefaultPrintWriter()", "syntax_pass": true}, {"attribute_expression": "private boolean showSince;", "docstring": " The flag to determine if the since values should be dispalyed", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "showSince", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public HelpFormatter get() {\n            return new HelpFormatter(deprecatedFormatFunction, printStream, showSince);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "HelpFormatter", "classes": []}, "name": "get", "params": [], "body": "                                   {\n            return new HelpFormatter(deprecatedFormatFunction, printStream, showSince);\n        }", "signature": "@Override\n        public HelpFormatter get()"}, {"syntax_pass": true, "original_string": "        public Builder setPrintWriter(final PrintWriter printWriter) {\n            this.printStream = Objects.requireNonNull(printWriter, \"printWriter\");\n            return this;\n        }", "docstring": "\nSets the output PrintWriter, defaults to wrapping {@link System#out}.\n\n@param printWriter the output PrintWriter, not null.\n@return {@code this} instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setPrintWriter", "params": [{"name": "printWriter", "type": "PrintWriter"}], "body": "                                                                     {\n            this.printStream = Objects.requireNonNull(printWriter, \"printWriter\");\n            return this;\n        }", "signature": "public Builder setPrintWriter(final PrintWriter printWriter)"}, {"syntax_pass": true, "original_string": "        public Builder setShowDeprecated(final boolean useDefaultFormat) {\n            return setShowDeprecated(useDefaultFormat ? DEFAULT_DEPRECATED_FORMAT : null);\n        }", "docstring": "\nSets whether to show deprecated options.\n\n@param useDefaultFormat if {@code true} use the default format, otherwise clear the formatter.\n@return {@code this} instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setShowDeprecated", "params": [{"name": "useDefaultFormat", "type": "boolean"}], "body": "                                                                         {\n            return setShowDeprecated(useDefaultFormat ? DEFAULT_DEPRECATED_FORMAT : null);\n        }", "signature": "public Builder setShowDeprecated(final boolean useDefaultFormat)"}, {"syntax_pass": true, "original_string": "        public Builder setShowDeprecated(final Function<Option, String> deprecatedFormatFunction) {\n            this.deprecatedFormatFunction = deprecatedFormatFunction;\n            return this;\n        }", "docstring": "\nSets whether to show deprecated options.\n\n@param deprecatedFormatFunction Specify the format for the deprecated options.\n@return {@code this} instance.\n@since 1.8.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setShowDeprecated", "params": [{"name": "deprecatedFormatFunction", "type": "Function<Option, String>"}], "body": "                                                                                                  {\n            this.deprecatedFormatFunction = deprecatedFormatFunction;\n            return this;\n        }", "signature": "public Builder setShowDeprecated(final Function<Option, String> deprecatedFormatFunction)"}, {"syntax_pass": true, "original_string": "        public Builder setShowSince(final boolean showSince) {\n            this.showSince = showSince;\n            return this;\n        }", "docstring": "\nSets whether to show the date the option was first added.\n@param showSince if @{code true} the date the options was first added will be shown.\n@return this builder.\n@since 1.9.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setShowSince", "params": [{"name": "showSince", "type": "boolean"}], "body": "                                                             {\n            this.showSince = showSince;\n            return this;\n        }", "signature": "public Builder setShowSince(final boolean showSince)"}]}, {"original_string": "    private static final class OptionComparator implements Comparator<Option>, Serializable {\n\n        /** The serial version UID. */\n        private static final long serialVersionUID = 5305467873966684014L;\n\n        /**\n         * Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param opt1 The first Option to be compared.\n         * @param opt2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than\n         *         the second.\n         */\n        @Override\n        public int compare(final Option opt1, final Option opt2) {\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }", "definition": "    private static final class OptionComparator implements Comparator<Option>, Serializable", "class_docstring": "\nThis class implements the {@code Comparator} interface for comparing Options.\n", "name": "OptionComparator", "super_interfaces": ["Comparator<Option>", "Serializable"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5305467873966684014L;", "docstring": " The serial version UID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5305467873966684014L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public int compare(final Option opt1, final Option opt2) {\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }", "docstring": "\nCompares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument\nis less than, equal to, or greater than the second.\n\n@param opt1 The first Option to be compared.\n@param opt2 The second Option to be compared.\n@return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than\n        the second.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "opt1", "type": "Option"}, {"name": "opt2", "type": "Option"}], "body": "                                                                 {\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }", "signature": "@Override\n        public int compare(final Option opt1, final Option opt2)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static Builder builder() {\n        return new Builder();\n    }", "docstring": "\nCreates a new builder.\n\n@return a new builder.\n@since 1.7.0\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "builder", "params": [], "body": "                                    {\n        return new Builder();\n    }", "signature": "public static Builder builder()"}, {"syntax_pass": true, "original_string": "    private static PrintWriter createDefaultPrintWriter() {\n        return new PrintWriter(System.out);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "PrintWriter", "classes": []}, "name": "createDefaultPrintWriter", "params": [], "body": "                                                          {\n        return new PrintWriter(System.out);\n    }", "signature": "private static PrintWriter createDefaultPrintWriter()"}, {"syntax_pass": true, "original_string": "    public static String getDescription(final Option option) {\n        final String desc = option.getDescription();\n        return desc == null ? \"\" : desc;\n    }", "docstring": "\nGets the option description or an empty string if the description is {@code null}.\n@param option The option to get the description from.\n@return the option description or an empty string if the description is {@code null}.\n@since 1.8.0\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "getDescription", "params": [{"name": "option", "type": "Option"}], "body": "                                                             {\n        final String desc = option.getDescription();\n        return desc == null ? \"\" : desc;\n    }", "signature": "public static String getDescription(final Option option)"}, {"syntax_pass": true, "original_string": "    public HelpFormatter() {\n        this(null, createDefaultPrintWriter(), false);\n    }", "docstring": "\nConstructs a new instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "HelpFormatter", "params": [], "body": "                           {\n        this(null, createDefaultPrintWriter(), false);\n    }", "signature": "public HelpFormatter()"}, {"syntax_pass": true, "original_string": "    private HelpFormatter(final Function<Option, String> deprecatedFormatFunction, final PrintWriter printWriter, final boolean showSince) {\n        // TODO All other instance HelpFormatter instance variables.\n        // Make HelpFormatter immutable for 2.0\n        this.deprecatedFormatFunction = deprecatedFormatFunction;\n        this.printWriter = printWriter;\n        this.showSince = showSince;\n    }", "docstring": "\nConstructs a new instance.\n@param printWriter TODO\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "HelpFormatter", "params": [{"name": "deprecatedFormatFunction", "type": "Function<Option, String>"}, {"name": "printWriter", "type": "PrintWriter"}, {"name": "showSince", "type": "boolean"}], "body": "                                                                                                                                           {\n        // TODO All other instance HelpFormatter instance variables.\n        // Make HelpFormatter immutable for 2.0\n        this.deprecatedFormatFunction = deprecatedFormatFunction;\n        this.printWriter = printWriter;\n        this.showSince = showSince;\n    }", "signature": "private HelpFormatter(final Function<Option, String> deprecatedFormatFunction, final PrintWriter printWriter, final boolean showSince)"}, {"syntax_pass": true, "original_string": "    private void appendOption(final StringBuilder buff, final Option option, final boolean required) {\n        if (!required) {\n            buff.append(\"[\");\n        }\n        if (option.getOpt() != null) {\n            buff.append(\"-\").append(option.getOpt());\n        } else {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || !option.getArgName().isEmpty())) {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        // if the Option is not a required option\n        if (!required) {\n            buff.append(\"]\");\n        }\n    }", "docstring": "\nAppends the usage clause for an Option to a StringBuffer.\n\n@param buff the StringBuffer to append to\n@param option the Option to append\n@param required whether the Option is required or not\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "appendOption", "params": [{"name": "buff", "type": "StringBuilder"}, {"name": "option", "type": "Option"}, {"name": "required", "type": "boolean"}], "body": "                                                                                                     {\n        if (!required) {\n            buff.append(\"[\");\n        }\n        if (option.getOpt() != null) {\n            buff.append(\"-\").append(option.getOpt());\n        } else {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || !option.getArgName().isEmpty())) {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        // if the Option is not a required option\n        if (!required) {\n            buff.append(\"]\");\n        }\n    }", "signature": "private void appendOption(final StringBuilder buff, final Option option, final boolean required)"}, {"syntax_pass": true, "original_string": "    private void appendOptionGroup(final StringBuilder buff, final OptionGroup group) {\n        if (!group.isRequired()) {\n            buff.append(\"[\");\n        }\n        final List<Option> optList = new ArrayList<>(group.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // for each option in the OptionGroup\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, it.next(), true);\n\n            if (it.hasNext()) {\n                buff.append(\" | \");\n            }\n        }\n        if (!group.isRequired()) {\n            buff.append(\"]\");\n        }\n    }", "docstring": "\nAppends the usage clause for an OptionGroup to a StringBuffer. The clause is wrapped in square brackets if the group\nis required. The display of the options is handled by appendOption\n\n@param buff the StringBuilder to append to\n@param group the group to append\n@see #appendOption(StringBuilder,Option,boolean)\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "appendOptionGroup", "params": [{"name": "buff", "type": "StringBuilder"}, {"name": "group", "type": "OptionGroup"}], "body": "                                                                                      {\n        if (!group.isRequired()) {\n            buff.append(\"[\");\n        }\n        final List<Option> optList = new ArrayList<>(group.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // for each option in the OptionGroup\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, it.next(), true);\n\n            if (it.hasNext()) {\n                buff.append(\" | \");\n            }\n        }\n        if (!group.isRequired()) {\n            buff.append(\"]\");\n        }\n    }", "signature": "private void appendOptionGroup(final StringBuilder buff, final OptionGroup group)"}, {"syntax_pass": true, "original_string": "    <A extends Appendable> A appendOptions(final A sb, final int width, final Options options, final int leftPad, final int descPad) throws IOException {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n        // first create list containing only <lpad>-a,--aaa where\n        // -a is opt and --aaa is long opt; in parallel look for\n        // the longest opt string this list will be then used to\n        // sort options ascending\n        int max = 0;\n        final int maxSince = showSince ? determineMaxSinceLength(options) + leftPad : 0;\n        final List<StringBuilder> prefixList = new ArrayList<>();\n        final List<Option> optList = options.helpOptions();\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        for (final Option option : optList) {\n            final StringBuilder optBuf = new StringBuilder();\n            if (option.getOpt() == null) {\n                optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\n            } else {\n                optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());\n                if (option.hasLongOpt()) {\n                    optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());\n                }\n            }\n            if (option.hasArg()) {\n                final String argName = option.getArgName();\n                if (argName != null && argName.isEmpty()) {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                } else {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = Math.max(optBuf.length() + maxSince, max);\n        }\n        final int nextLineTabStop = max + descPad;\n        if (showSince) {\n            final StringBuilder optHeader = new StringBuilder(HEADER_OPTIONS).append(createPadding(max - maxSince - HEADER_OPTIONS.length() + leftPad))\n                    .append(HEADER_SINCE);\n            optHeader.append(createPadding(max - optHeader.length())).append(lpad).append(HEADER_DESCRIPTION);\n            appendWrappedText(sb, width, nextLineTabStop, optHeader.toString());\n            sb.append(getNewLine());\n        }\n\n        int x = 0;\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            final Option option = it.next();\n            final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\n            if (optBuf.length() < max) {\n                optBuf.append(createPadding(max - maxSince - optBuf.length()));\n                if (showSince) {\n                    optBuf.append(lpad).append(option.getSince() == null ? \"-\" : option.getSince());\n                }\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n            optBuf.append(dpad);\n\n            if (deprecatedFormatFunction != null && option.isDeprecated()) {\n                optBuf.append(deprecatedFormatFunction.apply(option).trim());\n            } else if (option.getDescription() != null) {\n                optBuf.append(option.getDescription());\n            }\n            appendWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n            if (it.hasNext()) {\n                sb.append(getNewLine());\n            }\n        }\n        return sb;\n    }", "docstring": "\nRenders the specified Options and return the rendered Options in a StringBuffer.\n\n@param sb The StringBuffer to place the rendered Options into.\n@param width The number of characters to display per line\n@param options The command line Options\n@param leftPad the number of characters of padding to be prefixed to each line\n@param descPad the number of characters of padding to be prefixed to each description line\n@return the StringBuffer with the rendered Options contents.\n@throws IOException if an I/O error occurs.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "A", "classes": []}, "name": "appendOptions", "params": [{"name": "sb", "type": "A"}, {"name": "width", "type": "int"}, {"name": "options", "type": "Options"}, {"name": "leftPad", "type": "int"}, {"name": "descPad", "type": "int"}], "body": "                                                                                                                                                        {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n        // first create list containing only <lpad>-a,--aaa where\n        // -a is opt and --aaa is long opt; in parallel look for\n        // the longest opt string this list will be then used to\n        // sort options ascending\n        int max = 0;\n        final int maxSince = showSince ? determineMaxSinceLength(options) + leftPad : 0;\n        final List<StringBuilder> prefixList = new ArrayList<>();\n        final List<Option> optList = options.helpOptions();\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        for (final Option option : optList) {\n            final StringBuilder optBuf = new StringBuilder();\n            if (option.getOpt() == null) {\n                optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\n            } else {\n                optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());\n                if (option.hasLongOpt()) {\n                    optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());\n                }\n            }\n            if (option.hasArg()) {\n                final String argName = option.getArgName();\n                if (argName != null && argName.isEmpty()) {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                } else {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = Math.max(optBuf.length() + maxSince, max);\n        }\n        final int nextLineTabStop = max + descPad;\n        if (showSince) {\n            final StringBuilder optHeader = new StringBuilder(HEADER_OPTIONS).append(createPadding(max - maxSince - HEADER_OPTIONS.length() + leftPad))\n                    .append(HEADER_SINCE);\n            optHeader.append(createPadding(max - optHeader.length())).append(lpad).append(HEADER_DESCRIPTION);\n            appendWrappedText(sb, width, nextLineTabStop, optHeader.toString());\n            sb.append(getNewLine());\n        }\n\n        int x = 0;\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            final Option option = it.next();\n            final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\n            if (optBuf.length() < max) {\n                optBuf.append(createPadding(max - maxSince - optBuf.length()));\n                if (showSince) {\n                    optBuf.append(lpad).append(option.getSince() == null ? \"-\" : option.getSince());\n                }\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n            optBuf.append(dpad);\n\n            if (deprecatedFormatFunction != null && option.isDeprecated()) {\n                optBuf.append(deprecatedFormatFunction.apply(option).trim());\n            } else if (option.getDescription() != null) {\n                optBuf.append(option.getDescription());\n            }\n            appendWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n            if (it.hasNext()) {\n                sb.append(getNewLine());\n            }\n        }\n        return sb;\n    }", "signature": "<A extends Appendable> A appendOptions(final A sb, final int width, final Options options, final int leftPad, final int descPad)"}, {"syntax_pass": true, "original_string": "    <A extends Appendable> A appendWrappedText(final A appendable, final int width, final int nextLineTabStop, final String text) throws IOException {\n        String render = text;\n        int nextLineTabStopPos = nextLineTabStop;\n        int pos = findWrapPos(render, width, 0);\n        if (pos == -1) {\n            appendable.append(rtrim(render));\n            return appendable;\n        }\n        appendable.append(rtrim(render.substring(0, pos))).append(getNewLine());\n        if (nextLineTabStopPos >= width) {\n            // stops infinite loop happening\n            nextLineTabStopPos = 1;\n        }\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStopPos);\n        while (true) {\n            render = padding + render.substring(pos).trim();\n            pos = findWrapPos(render, width, 0);\n            if (pos == -1) {\n                appendable.append(render);\n                return appendable;\n            }\n            if (render.length() > width && pos == nextLineTabStopPos - 1) {\n                pos = width;\n            }\n            appendable.append(rtrim(render.substring(0, pos))).append(getNewLine());\n        }\n    }", "docstring": "\nRenders the specified text and return the rendered Options in a StringBuffer.\n\n@param <A> The Appendable implementation.\n@param appendable The StringBuffer to place the rendered text into.\n@param width The number of characters to display per line\n@param nextLineTabStop The position on the next line for the first tab.\n@param text The text to be rendered.\n@return the StringBuffer with the rendered Options contents.\n@throws IOException if an I/O error occurs.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "A", "classes": []}, "name": "appendWrappedText", "params": [{"name": "appendable", "type": "A"}, {"name": "width", "type": "int"}, {"name": "nextLineTabStop", "type": "int"}, {"name": "text", "type": "String"}], "body": "                                                                                                                                                     {\n        String render = text;\n        int nextLineTabStopPos = nextLineTabStop;\n        int pos = findWrapPos(render, width, 0);\n        if (pos == -1) {\n            appendable.append(rtrim(render));\n            return appendable;\n        }\n        appendable.append(rtrim(render.substring(0, pos))).append(getNewLine());\n        if (nextLineTabStopPos >= width) {\n            // stops infinite loop happening\n            nextLineTabStopPos = 1;\n        }\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStopPos);\n        while (true) {\n            render = padding + render.substring(pos).trim();\n            pos = findWrapPos(render, width, 0);\n            if (pos == -1) {\n                appendable.append(render);\n                return appendable;\n            }\n            if (render.length() > width && pos == nextLineTabStopPos - 1) {\n                pos = width;\n            }\n            appendable.append(rtrim(render.substring(0, pos))).append(getNewLine());\n        }\n    }", "signature": "<A extends Appendable> A appendWrappedText(final A appendable, final int width, final int nextLineTabStop, final String text)"}, {"syntax_pass": true, "original_string": "    protected String createPadding(final int len) {\n        final char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        return new String(padding);\n    }", "docstring": "\nCreates a String of padding of length {@code len}.\n\n@param len The length of the String of padding to create.\n\n@return The String of padding\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "createPadding", "params": [{"name": "len", "type": "int"}], "body": "                                                  {\n        final char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        return new String(padding);\n    }", "signature": "protected String createPadding(final int len)"}, {"syntax_pass": true, "original_string": "    private int determineMaxSinceLength(final Options options) {\n        final int minLen = HEADER_SINCE.length();\n        final int len = options.getOptions().stream().map(o -> o.getSince() == null ? minLen : o.getSince().length()).max(Integer::compareTo).orElse(minLen);\n        return len < minLen ? minLen : len;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "determineMaxSinceLength", "params": [{"name": "options", "type": "Options"}], "body": "                                                               {\n        final int minLen = HEADER_SINCE.length();\n        final int len = options.getOptions().stream().map(o -> o.getSince() == null ? minLen : o.getSince().length()).max(Integer::compareTo).orElse(minLen);\n        return len < minLen ? minLen : len;\n    }", "signature": "private int determineMaxSinceLength(final Options options)"}, {"syntax_pass": true, "original_string": "    protected int findWrapPos(final String text, final int width, final int startPos) {\n        // the line ends before the max wrap pos or a new line char found\n        int pos = text.indexOf(Char.LF, startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n        pos = text.indexOf(Char.TAB, startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n        if (startPos + width >= text.length()) {\n            return -1;\n        }\n        // look for the last whitespace character before startPos+width\n        for (pos = startPos + width; pos >= startPos; --pos) {\n            final char c = text.charAt(pos);\n            if (c == Char.SP || c == Char.LF || c == Char.CR) {\n                break;\n            }\n        }\n        // if we found it - just return\n        if (pos > startPos) {\n            return pos;\n        }\n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        return pos == text.length() ? -1 : pos;\n    }", "docstring": "\nFinds the next text wrap position after {@code startPos} for the text in {@code text} with the column width\n{@code width}. The wrap point is the last position before startPos+width having a whitespace character (space,\n\\n, \\r). If there is no whitespace character before startPos+width, it will return startPos+width.\n\n@param text The text being searched for the wrap position\n@param width width of the wrapped text\n@param startPos position from which to start the lookup whitespace character\n@return position on which the text must be wrapped or -1 if the wrap position is at the end of the text\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "findWrapPos", "params": [{"name": "text", "type": "String"}, {"name": "width", "type": "int"}, {"name": "startPos", "type": "int"}], "body": "                                                                                      {\n        // the line ends before the max wrap pos or a new line char found\n        int pos = text.indexOf(Char.LF, startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n        pos = text.indexOf(Char.TAB, startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n        if (startPos + width >= text.length()) {\n            return -1;\n        }\n        // look for the last whitespace character before startPos+width\n        for (pos = startPos + width; pos >= startPos; --pos) {\n            final char c = text.charAt(pos);\n            if (c == Char.SP || c == Char.LF || c == Char.CR) {\n                break;\n            }\n        }\n        // if we found it - just return\n        if (pos > startPos) {\n            return pos;\n        }\n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        return pos == text.length() ? -1 : pos;\n    }", "signature": "protected int findWrapPos(final String text, final int width, final int startPos)"}, {"syntax_pass": true, "original_string": "    public String getArgName() {\n        return defaultArgName;\n    }", "docstring": "\nGets the 'argName'.\n\n@return the 'argName'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getArgName", "params": [], "body": "                               {\n        return defaultArgName;\n    }", "signature": "public String getArgName()"}, {"syntax_pass": true, "original_string": "    public int getDescPadding() {\n        return defaultDescPad;\n    }", "docstring": "\nGets the 'descPadding'.\n\n@return the 'descPadding'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getDescPadding", "params": [], "body": "                                {\n        return defaultDescPad;\n    }", "signature": "public int getDescPadding()"}, {"syntax_pass": true, "original_string": "    public int getLeftPadding() {\n        return defaultLeftPad;\n    }", "docstring": "\nGets the 'leftPadding'.\n\n@return the 'leftPadding'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getLeftPadding", "params": [], "body": "                                {\n        return defaultLeftPad;\n    }", "signature": "public int getLeftPadding()"}, {"syntax_pass": true, "original_string": "    public String getLongOptPrefix() {\n        return defaultLongOptPrefix;\n    }", "docstring": "\nGets the 'longOptPrefix'.\n\n@return the 'longOptPrefix'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getLongOptPrefix", "params": [], "body": "                                     {\n        return defaultLongOptPrefix;\n    }", "signature": "public String getLongOptPrefix()"}, {"syntax_pass": true, "original_string": "    public String getLongOptSeparator() {\n        return longOptSeparator;\n    }", "docstring": "\nGets the separator displayed between a long option and its value.\n\n@return the separator\n@since 1.3\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getLongOptSeparator", "params": [], "body": "                                        {\n        return longOptSeparator;\n    }", "signature": "public String getLongOptSeparator()"}, {"syntax_pass": true, "original_string": "    public String getNewLine() {\n        return defaultNewLine;\n    }", "docstring": "\nGets the 'newLine'.\n\n@return the 'newLine'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getNewLine", "params": [], "body": "                               {\n        return defaultNewLine;\n    }", "signature": "public String getNewLine()"}, {"syntax_pass": true, "original_string": "    public Comparator<Option> getOptionComparator() {\n        return optionComparator;\n    }", "docstring": "\nComparator used to sort the options when they output in help text. Defaults to case-insensitive alphabetical sorting\nby option key.\n\n@return the {@link Comparator} currently in use to sort the options\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Comparator<Option>", "classes": []}, "name": "getOptionComparator", "params": [], "body": "                                                    {\n        return optionComparator;\n    }", "signature": "public Comparator<Option> getOptionComparator()"}, {"syntax_pass": true, "original_string": "    public String getOptPrefix() {\n        return defaultOptPrefix;\n    }", "docstring": "\nGets the 'optPrefix'.\n\n@return the 'optPrefix'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOptPrefix", "params": [], "body": "                                 {\n        return defaultOptPrefix;\n    }", "signature": "public String getOptPrefix()"}, {"syntax_pass": true, "original_string": "    public String getSyntaxPrefix() {\n        return defaultSyntaxPrefix;\n    }", "docstring": "\nGets the 'syntaxPrefix'.\n\n@return the 'syntaxPrefix'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getSyntaxPrefix", "params": [], "body": "                                    {\n        return defaultSyntaxPrefix;\n    }", "signature": "public String getSyntaxPrefix()"}, {"syntax_pass": true, "original_string": "    public int getWidth() {\n        return defaultWidth;\n    }", "docstring": "\nGets the 'width'.\n\n@return the 'width'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getWidth", "params": [], "body": "                          {\n        return defaultWidth;\n    }", "signature": "public int getWidth()"}, {"syntax_pass": true, "original_string": "    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }", "docstring": "\nPrints the help for {@code options} with the specified command line syntax. This method prints help information\nto  {@link System#out}  by default.\n\n@param width the number of characters to be displayed on each line\n@param cmdLineSyntax the syntax for this application\n@param header the banner to display at the beginning of the help\n@param options the Options instance\n@param footer the banner to display at the end of the help\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printHelp", "params": [{"name": "width", "type": "int"}, {"name": "cmdLineSyntax", "type": "String"}, {"name": "header", "type": "String"}, {"name": "options", "type": "Options"}, {"name": "footer", "type": "String"}], "body": "                                                                                                                                        {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }", "signature": "public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer)"}, {"syntax_pass": true, "original_string": "    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer,\n        final boolean autoUsage) {\n        final PrintWriter pw = new PrintWriter(printWriter);\n        printHelp(pw, width, cmdLineSyntax, header, options, getLeftPadding(), getDescPadding(), footer, autoUsage);\n        pw.flush();\n    }", "docstring": "\nPrints the help for {@code options} with the specified command line syntax. This method prints help information\nto {@link System#out} by default.\n\n@param width the number of characters to be displayed on each line\n@param cmdLineSyntax the syntax for this application\n@param header the banner to display at the beginning of the help\n@param options the Options instance\n@param footer the banner to display at the end of the help\n@param autoUsage whether to print an automatically generated usage statement\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printHelp", "params": [{"name": "width", "type": "int"}, {"name": "cmdLineSyntax", "type": "String"}, {"name": "header", "type": "String"}, {"name": "options", "type": "Options"}, {"name": "footer", "type": "String"}, {"name": "autoUsage", "type": "boolean"}], "body": "                                 {\n        final PrintWriter pw = new PrintWriter(printWriter);\n        printHelp(pw, width, cmdLineSyntax, header, options, getLeftPadding(), getDescPadding(), footer, autoUsage);\n        pw.flush();\n    }", "signature": "public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer,\n        final boolean autoUsage)"}, {"syntax_pass": true, "original_string": "    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer) {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }", "docstring": "\nPrints the help for {@code options} with the specified command line syntax.\n\n@param pw the writer to which the help will be written\n@param width the number of characters to be displayed on each line\n@param cmdLineSyntax the syntax for this application\n@param header the banner to display at the beginning of the help\n@param options the Options instance\n@param leftPad the number of characters of padding to be prefixed to each line\n@param descPad the number of characters of padding to be prefixed to each description line\n@param footer the banner to display at the end of the help\n\n@throws IllegalStateException if there is no room to print a line\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printHelp", "params": [{"name": "pw", "type": "PrintWriter"}, {"name": "width", "type": "int"}, {"name": "cmdLineSyntax", "type": "String"}, {"name": "header", "type": "String"}, {"name": "options", "type": "Options"}, {"name": "leftPad", "type": "int"}, {"name": "descPad", "type": "int"}, {"name": "footer", "type": "String"}], "body": "                                                {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }", "signature": "public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer)"}, {"syntax_pass": true, "original_string": "    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer, final boolean autoUsage) {\n        if (Util.isEmpty(cmdLineSyntax)) {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n        if (autoUsage) {\n            printUsage(pw, width, cmdLineSyntax, options);\n        } else {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n        if (header != null && !header.isEmpty()) {\n            printWrapped(pw, width, header);\n        }\n        printOptions(pw, width, options, leftPad, descPad);\n        if (footer != null && !footer.isEmpty()) {\n            printWrapped(pw, width, footer);\n        }\n    }", "docstring": "\nPrints the help for {@code options} with the specified command line syntax.\n\n@param pw the writer to which the help will be written\n@param width the number of characters to be displayed on each line\n@param cmdLineSyntax the syntax for this application\n@param header the banner to display at the beginning of the help\n@param options the Options instance\n@param leftPad the number of characters of padding to be prefixed to each line\n@param descPad the number of characters of padding to be prefixed to each description line\n@param footer the banner to display at the end of the help\n@param autoUsage whether to print an automatically generated usage statement\n@throws IllegalStateException if there is no room to print a line\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printHelp", "params": [{"name": "pw", "type": "PrintWriter"}, {"name": "width", "type": "int"}, {"name": "cmdLineSyntax", "type": "String"}, {"name": "header", "type": "String"}, {"name": "options", "type": "Options"}, {"name": "leftPad", "type": "int"}, {"name": "descPad", "type": "int"}, {"name": "footer", "type": "String"}, {"name": "autoUsage", "type": "boolean"}], "body": "                                                                         {\n        if (Util.isEmpty(cmdLineSyntax)) {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n        if (autoUsage) {\n            printUsage(pw, width, cmdLineSyntax, options);\n        } else {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n        if (header != null && !header.isEmpty()) {\n            printWrapped(pw, width, header);\n        }\n        printOptions(pw, width, options, leftPad, descPad);\n        if (footer != null && !footer.isEmpty()) {\n            printWrapped(pw, width, footer);\n        }\n    }", "signature": "public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer, final boolean autoUsage)"}, {"syntax_pass": true, "original_string": "    public void printHelp(final String cmdLineSyntax, final Options options) {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, false);\n    }", "docstring": "\nPrints the help for {@code options} with the specified command line syntax. This method prints help information\nto {@link System#out} by default.\n\n@param cmdLineSyntax the syntax for this application\n@param options the Options instance\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printHelp", "params": [{"name": "cmdLineSyntax", "type": "String"}, {"name": "options", "type": "Options"}], "body": "                                                                             {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, false);\n    }", "signature": "public void printHelp(final String cmdLineSyntax, final Options options)"}, {"syntax_pass": true, "original_string": "    public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage) {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, autoUsage);\n    }", "docstring": "\nPrints the help for {@code options} with the specified command line syntax. This method prints help information\nto {@link System#out} by default.\n\n@param cmdLineSyntax the syntax for this application\n@param options the Options instance\n@param autoUsage whether to print an automatically generated usage statement\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printHelp", "params": [{"name": "cmdLineSyntax", "type": "String"}, {"name": "options", "type": "Options"}, {"name": "autoUsage", "type": "boolean"}], "body": "                                                                                                      {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, autoUsage);\n    }", "signature": "public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage)"}, {"syntax_pass": true, "original_string": "    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }", "docstring": "\nPrints the help for {@code options} with the specified command line syntax. This method prints help information\nto {@link System#out} by default.\n\n@param cmdLineSyntax the syntax for this application\n@param header the banner to display at the beginning of the help\n@param options the Options instance\n@param footer the banner to display at the end of the help\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printHelp", "params": [{"name": "cmdLineSyntax", "type": "String"}, {"name": "header", "type": "String"}, {"name": "options", "type": "Options"}, {"name": "footer", "type": "String"}], "body": "                                                                                                                       {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }", "signature": "public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer)"}, {"syntax_pass": true, "original_string": "    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage) {\n        printHelp(getWidth(), cmdLineSyntax, header, options, footer, autoUsage);\n    }", "docstring": "\nPrints the help for {@code options} with the specified command line syntax. This method prints help information\nto {@link System#out} by default.\n\n@param cmdLineSyntax the syntax for this application\n@param header the banner to display at the beginning of the help\n@param options the Options instance\n@param footer the banner to display at the end of the help\n@param autoUsage whether to print an automatically generated usage statement\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printHelp", "params": [{"name": "cmdLineSyntax", "type": "String"}, {"name": "header", "type": "String"}, {"name": "options", "type": "Options"}, {"name": "footer", "type": "String"}, {"name": "autoUsage", "type": "boolean"}], "body": "                                                                                                                                                {\n        printHelp(getWidth(), cmdLineSyntax, header, options, footer, autoUsage);\n    }", "signature": "public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage)"}, {"syntax_pass": true, "original_string": "    public void printOptions(final PrintWriter pw, final int width, final Options options, final int leftPad, final int descPad) {\n        try {\n            pw.println(appendOptions(new StringBuilder(), width, options, leftPad, descPad));\n        } catch (final IOException e) {\n            // Cannot happen\n            throw new UncheckedIOException(e);\n        }\n    }", "docstring": "\nPrints the help for the specified Options to the specified writer, using the specified width, left padding and\ndescription padding.\n\n@param pw The printWriter to write the help to\n@param width The number of characters to display per line\n@param options The command line Options\n@param leftPad the number of characters of padding to be prefixed to each line\n@param descPad the number of characters of padding to be prefixed to each description line\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printOptions", "params": [{"name": "pw", "type": "PrintWriter"}, {"name": "width", "type": "int"}, {"name": "options", "type": "Options"}, {"name": "leftPad", "type": "int"}, {"name": "descPad", "type": "int"}], "body": "                                                                                                                                 {\n        try {\n            pw.println(appendOptions(new StringBuilder(), width, options, leftPad, descPad));\n        } catch (final IOException e) {\n            // Cannot happen\n            throw new UncheckedIOException(e);\n        }\n    }", "signature": "public void printOptions(final PrintWriter pw, final int width, final Options options, final int leftPad, final int descPad)"}, {"syntax_pass": true, "original_string": "    public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax) {\n        final int argPos = cmdLineSyntax.indexOf(' ') + 1;\n        printWrapped(pw, width, getSyntaxPrefix().length() + argPos, getSyntaxPrefix() + cmdLineSyntax);\n    }", "docstring": "\nPrints the cmdLineSyntax to the specified writer, using the specified width.\n\n@param pw The printWriter to write the help to\n@param width The number of characters per line for the usage statement.\n@param cmdLineSyntax The usage statement.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printUsage", "params": [{"name": "pw", "type": "PrintWriter"}, {"name": "width", "type": "int"}, {"name": "cmdLineSyntax", "type": "String"}], "body": "                                                                                              {\n        final int argPos = cmdLineSyntax.indexOf(' ') + 1;\n        printWrapped(pw, width, getSyntaxPrefix().length() + argPos, getSyntaxPrefix() + cmdLineSyntax);\n    }", "signature": "public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax)"}, {"syntax_pass": true, "original_string": "    public void printUsage(final PrintWriter pw, final int width, final String app, final Options options) {\n        // initialize the string buffer\n        final StringBuilder buff = new StringBuilder(getSyntaxPrefix()).append(app).append(Char.SP);\n        // create a list for processed option groups\n        final Collection<OptionGroup> processedGroups = new ArrayList<>();\n        final List<Option> optList = new ArrayList<>(options.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // iterate over the options\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // get the next Option\n            final Option option = it.next();\n            // check if the option is part of an OptionGroup\n            final OptionGroup group = options.getOptionGroup(option);\n            // if the option is part of a group\n            if (group != null) {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group)) {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n            // if the Option is not part of an OptionGroup\n            else {\n                appendOption(buff, option, option.isRequired());\n            }\n            if (it.hasNext()) {\n                buff.append(Char.SP);\n            }\n        }\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }", "docstring": "\nPrints the usage statement for the specified application.\n\n@param pw The PrintWriter to print the usage statement\n@param width The number of characters to display per line\n@param app The application name\n@param options The command line Options\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printUsage", "params": [{"name": "pw", "type": "PrintWriter"}, {"name": "width", "type": "int"}, {"name": "app", "type": "String"}, {"name": "options", "type": "Options"}], "body": "                                                                                                           {\n        // initialize the string buffer\n        final StringBuilder buff = new StringBuilder(getSyntaxPrefix()).append(app).append(Char.SP);\n        // create a list for processed option groups\n        final Collection<OptionGroup> processedGroups = new ArrayList<>();\n        final List<Option> optList = new ArrayList<>(options.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // iterate over the options\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // get the next Option\n            final Option option = it.next();\n            // check if the option is part of an OptionGroup\n            final OptionGroup group = options.getOptionGroup(option);\n            // if the option is part of a group\n            if (group != null) {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group)) {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n            // if the Option is not part of an OptionGroup\n            else {\n                appendOption(buff, option, option.isRequired());\n            }\n            if (it.hasNext()) {\n                buff.append(Char.SP);\n            }\n        }\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }", "signature": "public void printUsage(final PrintWriter pw, final int width, final String app, final Options options)"}, {"syntax_pass": true, "original_string": "    public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text) {\n        pw.println(renderWrappedTextBlock(new StringBuilder(text.length()), width, nextLineTabStop, text));\n    }", "docstring": "\nPrints the specified text to the specified PrintWriter.\n\n@param pw The printWriter to write the help to\n@param width The number of characters to display per line\n@param nextLineTabStop The position on the next line for the first tab.\n@param text The text to be written to the PrintWriter\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printWrapped", "params": [{"name": "pw", "type": "PrintWriter"}, {"name": "width", "type": "int"}, {"name": "nextLineTabStop", "type": "int"}, {"name": "text", "type": "String"}], "body": "                                                                                                                  {\n        pw.println(renderWrappedTextBlock(new StringBuilder(text.length()), width, nextLineTabStop, text));\n    }", "signature": "public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text)"}, {"syntax_pass": true, "original_string": "    public void printWrapped(final PrintWriter pw, final int width, final String text) {\n        printWrapped(pw, width, 0, text);\n    }", "docstring": "\nPrints the specified text to the specified PrintWriter.\n\n@param pw The printWriter to write the help to\n@param width The number of characters to display per line\n@param text The text to be written to the PrintWriter\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "printWrapped", "params": [{"name": "pw", "type": "PrintWriter"}, {"name": "width", "type": "int"}, {"name": "text", "type": "String"}], "body": "                                                                                       {\n        printWrapped(pw, width, 0, text);\n    }", "signature": "public void printWrapped(final PrintWriter pw, final int width, final String text)"}, {"syntax_pass": true, "original_string": "    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad) {\n        try {\n            return appendOptions(sb, width, options, leftPad, descPad);\n        } catch (final IOException e) {\n            // Cannot happen\n            throw new UncheckedIOException(e);\n        }\n    }", "docstring": "\nRenders the specified Options and return the rendered Options in a StringBuffer.\n\n@param sb The StringBuffer to place the rendered Options into.\n@param width The number of characters to display per line\n@param options The command line Options\n@param leftPad the number of characters of padding to be prefixed to each line\n@param descPad the number of characters of padding to be prefixed to each description line\n\n@return the StringBuffer with the rendered Options contents.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "StringBuffer", "classes": []}, "name": "renderOptions", "params": [{"name": "sb", "type": "StringBuffer"}, {"name": "width", "type": "int"}, {"name": "options", "type": "Options"}, {"name": "leftPad", "type": "int"}, {"name": "descPad", "type": "int"}], "body": "                                                                                                                                              {\n        try {\n            return appendOptions(sb, width, options, leftPad, descPad);\n        } catch (final IOException e) {\n            // Cannot happen\n            throw new UncheckedIOException(e);\n        }\n    }", "signature": "protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad)"}, {"syntax_pass": true, "original_string": "    protected StringBuffer renderWrappedText(final StringBuffer sb, final int width, final int nextLineTabStop, final String text) {\n        try {\n            return appendWrappedText(sb, width, nextLineTabStop, text);\n        } catch (final IOException e) {\n            // Cannot happen.\n            throw new UncheckedIOException(e);\n        }\n    }", "docstring": "\nRenders the specified text and return the rendered Options in a StringBuffer.\n\n@param sb The StringBuffer to place the rendered text into.\n@param width The number of characters to display per line\n@param nextLineTabStop The position on the next line for the first tab.\n@param text The text to be rendered.\n\n@return the StringBuffer with the rendered Options contents.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "StringBuffer", "classes": []}, "name": "renderWrappedText", "params": [{"name": "sb", "type": "StringBuffer"}, {"name": "width", "type": "int"}, {"name": "nextLineTabStop", "type": "int"}, {"name": "text", "type": "String"}], "body": "                                                                                                                                   {\n        try {\n            return appendWrappedText(sb, width, nextLineTabStop, text);\n        } catch (final IOException e) {\n            // Cannot happen.\n            throw new UncheckedIOException(e);\n        }\n    }", "signature": "protected StringBuffer renderWrappedText(final StringBuffer sb, final int width, final int nextLineTabStop, final String text)"}, {"syntax_pass": true, "original_string": "    private <A extends Appendable> A renderWrappedTextBlock(final A appendable, final int width, final int nextLineTabStop, final String text) {\n        try {\n            final BufferedReader in = new BufferedReader(new StringReader(text));\n            String line;\n            boolean firstLine = true;\n            while ((line = in.readLine()) != null) {\n                if (!firstLine) {\n                    appendable.append(getNewLine());\n                } else {\n                    firstLine = false;\n                }\n                appendWrappedText(appendable, width, nextLineTabStop, line);\n            }\n        } catch (final IOException e) { // NOPMD\n            // cannot happen\n        }\n        return appendable;\n    }", "docstring": "\nRenders the specified text width a maximum width. This method differs from renderWrappedText by not removing leading\nspaces after a new line.\n\n@param appendable The StringBuffer to place the rendered text into.\n@param width The number of characters to display per line\n@param nextLineTabStop The position on the next line for the first tab.\n@param text The text to be rendered.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "A", "classes": []}, "name": "renderWrappedTextBlock", "params": [{"name": "appendable", "type": "A"}, {"name": "width", "type": "int"}, {"name": "nextLineTabStop", "type": "int"}, {"name": "text", "type": "String"}], "body": "                                                                                                                                               {\n        try {\n            final BufferedReader in = new BufferedReader(new StringReader(text));\n            String line;\n            boolean firstLine = true;\n            while ((line = in.readLine()) != null) {\n                if (!firstLine) {\n                    appendable.append(getNewLine());\n                } else {\n                    firstLine = false;\n                }\n                appendWrappedText(appendable, width, nextLineTabStop, line);\n            }\n        } catch (final IOException e) { // NOPMD\n            // cannot happen\n        }\n        return appendable;\n    }", "signature": "private <A extends Appendable> A renderWrappedTextBlock(final A appendable, final int width, final int nextLineTabStop, final String text)"}, {"syntax_pass": true, "original_string": "    protected String rtrim(final String s) {\n        if (Util.isEmpty(s)) {\n            return s;\n        }\n        int pos = s.length();\n        while (pos > 0 && Character.isWhitespace(s.charAt(pos - 1))) {\n            --pos;\n        }\n        return s.substring(0, pos);\n    }", "docstring": "\nRemoves the trailing whitespace from the specified String.\n\n@param s The String to remove the trailing padding from.\n@return The String of without the trailing padding\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "rtrim", "params": [{"name": "s", "type": "String"}], "body": "                                           {\n        if (Util.isEmpty(s)) {\n            return s;\n        }\n        int pos = s.length();\n        while (pos > 0 && Character.isWhitespace(s.charAt(pos - 1))) {\n            --pos;\n        }\n        return s.substring(0, pos);\n    }", "signature": "protected String rtrim(final String s)"}, {"syntax_pass": true, "original_string": "    public void setArgName(final String name) {\n        this.defaultArgName = name;\n    }", "docstring": "\nSets the 'argName'.\n\n@param name the new value of 'argName'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setArgName", "params": [{"name": "name", "type": "String"}], "body": "                                              {\n        this.defaultArgName = name;\n    }", "signature": "public void setArgName(final String name)"}, {"syntax_pass": true, "original_string": "    public void setDescPadding(final int padding) {\n        this.defaultDescPad = padding;\n    }", "docstring": "\nSets the 'descPadding'.\n\n@param padding the new value of 'descPadding'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setDescPadding", "params": [{"name": "padding", "type": "int"}], "body": "                                                  {\n        this.defaultDescPad = padding;\n    }", "signature": "public void setDescPadding(final int padding)"}, {"syntax_pass": true, "original_string": "    public void setLeftPadding(final int padding) {\n        this.defaultLeftPad = padding;\n    }", "docstring": "\nSets the 'leftPadding'.\n\n@param padding the new value of 'leftPadding'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setLeftPadding", "params": [{"name": "padding", "type": "int"}], "body": "                                                  {\n        this.defaultLeftPad = padding;\n    }", "signature": "public void setLeftPadding(final int padding)"}, {"syntax_pass": true, "original_string": "    public void setLongOptPrefix(final String prefix) {\n        this.defaultLongOptPrefix = prefix;\n    }", "docstring": "\nSets the 'longOptPrefix'.\n\n@param prefix the new value of 'longOptPrefix'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setLongOptPrefix", "params": [{"name": "prefix", "type": "String"}], "body": "                                                      {\n        this.defaultLongOptPrefix = prefix;\n    }", "signature": "public void setLongOptPrefix(final String prefix)"}, {"syntax_pass": true, "original_string": "    public void setLongOptSeparator(final String longOptSeparator) {\n        this.longOptSeparator = longOptSeparator;\n    }", "docstring": "\nSets the separator displayed between a long option and its value. Ensure that the separator specified is supported by\nthe parser used, typically ' ' or '='.\n\n@param longOptSeparator the separator, typically ' ' or '='.\n@since 1.3\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setLongOptSeparator", "params": [{"name": "longOptSeparator", "type": "String"}], "body": "                                                                   {\n        this.longOptSeparator = longOptSeparator;\n    }", "signature": "public void setLongOptSeparator(final String longOptSeparator)"}, {"syntax_pass": true, "original_string": "    public void setNewLine(final String newline) {\n        this.defaultNewLine = newline;\n    }", "docstring": "\nSets the 'newLine'.\n\n@param newline the new value of 'newLine'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNewLine", "params": [{"name": "newline", "type": "String"}], "body": "                                                 {\n        this.defaultNewLine = newline;\n    }", "signature": "public void setNewLine(final String newline)"}, {"syntax_pass": true, "original_string": "    public void setOptionComparator(final Comparator<Option> comparator) {\n        this.optionComparator = comparator;\n    }", "docstring": "\nSets the comparator used to sort the options when they output in help text. Passing in a null comparator will keep the\noptions in the order they were declared.\n\n@param comparator the {@link Comparator} to use for sorting the options\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setOptionComparator", "params": [{"name": "comparator", "type": "Comparator<Option>"}], "body": "                                                                         {\n        this.optionComparator = comparator;\n    }", "signature": "public void setOptionComparator(final Comparator<Option> comparator)"}, {"syntax_pass": true, "original_string": "    public void setOptPrefix(final String prefix) {\n        this.defaultOptPrefix = prefix;\n    }", "docstring": "\nSets the 'optPrefix'.\n\n@param prefix the new value of 'optPrefix'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setOptPrefix", "params": [{"name": "prefix", "type": "String"}], "body": "                                                  {\n        this.defaultOptPrefix = prefix;\n    }", "signature": "public void setOptPrefix(final String prefix)"}, {"syntax_pass": true, "original_string": "    public void setSyntaxPrefix(final String prefix) {\n        this.defaultSyntaxPrefix = prefix;\n    }", "docstring": "\nSets the 'syntaxPrefix'.\n\n@param prefix the new value of 'syntaxPrefix'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setSyntaxPrefix", "params": [{"name": "prefix", "type": "String"}], "body": "                                                     {\n        this.defaultSyntaxPrefix = prefix;\n    }", "signature": "public void setSyntaxPrefix(final String prefix)"}, {"syntax_pass": true, "original_string": "    public void setWidth(final int width) {\n        this.defaultWidth = width;\n    }", "docstring": "\nSets the 'width'.\n\n@param width the new value of 'width'\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setWidth", "params": [{"name": "width", "type": "int"}], "body": "                                          {\n        this.defaultWidth = width;\n    }", "signature": "public void setWidth(final int width)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/AmbiguousOptionException.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * Exception thrown when an option can't be identified from a partial name.\n *\n * @since 1.3\n */\npublic class AmbiguousOptionException extends UnrecognizedOptionException {\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 5829816121277947229L;\n\n    /**\n     * Build the exception message from the specified list of options.\n     *\n     * @param option\n     * @param matchingOptions\n     * @return\n     */\n    private static String createMessage(final String option, final Collection<String> matchingOptions) {\n        final StringBuilder buf = new StringBuilder(\"Ambiguous option: '\");\n        buf.append(option);\n        buf.append(\"'  (could be: \");\n\n        final Iterator<String> it = matchingOptions.iterator();\n        while (it.hasNext()) {\n            buf.append(Char.APOS);\n            buf.append(it.next());\n            buf.append(Char.APOS);\n            if (it.hasNext()) {\n                buf.append(\", \");\n            }\n        }\n        buf.append(\")\");\n\n        return buf.toString();\n    }\n\n    /** The list of options matching the partial name specified */\n    private final Collection<String> matchingOptions;\n\n    /**\n     * Constructs a new AmbiguousOptionException.\n     *\n     * @param option the partial option name\n     * @param matchingOptions the options matching the name\n     */\n    public AmbiguousOptionException(final String option, final Collection<String> matchingOptions) {\n        super(createMessage(option, matchingOptions), option);\n        this.matchingOptions = matchingOptions;\n    }\n\n    /**\n     * Gets the options matching the partial name.\n     *\n     * @return a collection of options matching the name\n     */\n    public Collection<String> getMatchingOptions() {\n        return matchingOptions;\n    }\n}\n", "file_hash": "c9a2472415bf8e6bcc1e55f469230a89002e587c6a4574aa8bdeb4183fe8c4f4", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.util.Collection;", "import java.util.Iterator;"], "methods": [], "classes": [{"original_string": "public class AmbiguousOptionException extends UnrecognizedOptionException {\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 5829816121277947229L;\n\n    /**\n     * Build the exception message from the specified list of options.\n     *\n     * @param option\n     * @param matchingOptions\n     * @return\n     */\n    private static String createMessage(final String option, final Collection<String> matchingOptions) {\n        final StringBuilder buf = new StringBuilder(\"Ambiguous option: '\");\n        buf.append(option);\n        buf.append(\"'  (could be: \");\n\n        final Iterator<String> it = matchingOptions.iterator();\n        while (it.hasNext()) {\n            buf.append(Char.APOS);\n            buf.append(it.next());\n            buf.append(Char.APOS);\n            if (it.hasNext()) {\n                buf.append(\", \");\n            }\n        }\n        buf.append(\")\");\n\n        return buf.toString();\n    }\n\n    /** The list of options matching the partial name specified */\n    private final Collection<String> matchingOptions;\n\n    /**\n     * Constructs a new AmbiguousOptionException.\n     *\n     * @param option the partial option name\n     * @param matchingOptions the options matching the name\n     */\n    public AmbiguousOptionException(final String option, final Collection<String> matchingOptions) {\n        super(createMessage(option, matchingOptions), option);\n        this.matchingOptions = matchingOptions;\n    }\n\n    /**\n     * Gets the options matching the partial name.\n     *\n     * @return a collection of options matching the name\n     */\n    public Collection<String> getMatchingOptions() {\n        return matchingOptions;\n    }\n}", "definition": "public class AmbiguousOptionException extends UnrecognizedOptionException", "class_docstring": "\nException thrown when an option can't be identified from a partial name.\n\n@since 1.3\n", "name": "AmbiguousOptionException", "super_interfaces": [], "superclasses": "UnrecognizedOptionException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5829816121277947229L;", "docstring": "\nThis exception {@code serialVersionUID}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5829816121277947229L", "syntax_pass": true}, {"attribute_expression": "private final Collection<String> matchingOptions;", "docstring": " The list of options matching the partial name specified", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<String>", "name": "matchingOptions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static String createMessage(final String option, final Collection<String> matchingOptions) {\n        final StringBuilder buf = new StringBuilder(\"Ambiguous option: '\");\n        buf.append(option);\n        buf.append(\"'  (could be: \");\n\n        final Iterator<String> it = matchingOptions.iterator();\n        while (it.hasNext()) {\n            buf.append(Char.APOS);\n            buf.append(it.next());\n            buf.append(Char.APOS);\n            if (it.hasNext()) {\n                buf.append(\", \");\n            }\n        }\n        buf.append(\")\");\n\n        return buf.toString();\n    }", "docstring": "\nBuild the exception message from the specified list of options.\n\n@param option\n@param matchingOptions\n@return\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "createMessage", "params": [{"name": "option", "type": "String"}, {"name": "matchingOptions", "type": "Collection<String>"}], "body": "                                                                                                       {\n        final StringBuilder buf = new StringBuilder(\"Ambiguous option: '\");\n        buf.append(option);\n        buf.append(\"'  (could be: \");\n\n        final Iterator<String> it = matchingOptions.iterator();\n        while (it.hasNext()) {\n            buf.append(Char.APOS);\n            buf.append(it.next());\n            buf.append(Char.APOS);\n            if (it.hasNext()) {\n                buf.append(\", \");\n            }\n        }\n        buf.append(\")\");\n\n        return buf.toString();\n    }", "signature": "private static String createMessage(final String option, final Collection<String> matchingOptions)"}, {"syntax_pass": true, "original_string": "    public AmbiguousOptionException(final String option, final Collection<String> matchingOptions) {\n        super(createMessage(option, matchingOptions), option);\n        this.matchingOptions = matchingOptions;\n    }", "docstring": "\nConstructs a new AmbiguousOptionException.\n\n@param option the partial option name\n@param matchingOptions the options matching the name\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AmbiguousOptionException", "params": [{"name": "option", "type": "String"}, {"name": "matchingOptions", "type": "Collection<String>"}], "body": "                                                                                                   {\n        super(createMessage(option, matchingOptions), option);\n        this.matchingOptions = matchingOptions;\n    }", "signature": "public AmbiguousOptionException(final String option, final Collection<String> matchingOptions)"}, {"syntax_pass": true, "original_string": "    public Collection<String> getMatchingOptions() {\n        return matchingOptions;\n    }", "docstring": "\nGets the options matching the partial name.\n\n@return a collection of options matching the name\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<String>", "classes": []}, "name": "getMatchingOptions", "params": [], "body": "                                                   {\n        return matchingOptions;\n    }", "signature": "public Collection<String> getMatchingOptions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/PosixParser.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the {@link Parser#flatten(Options,String[],boolean) flatten}\n * method.\n *\n * @deprecated since 1.3, use the {@link DefaultParser} instead\n */\n@Deprecated\npublic class PosixParser extends Parser {\n    /** Holder for flattened tokens */\n    private final List<String> tokens = new ArrayList<>();\n\n    /** Specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** Holder for the current option */\n    private Option currentOption;\n\n    /** The command line Options */\n    private Options options;\n\n    /**\n     * Breaks {@code token} into its constituent parts using the following algorithm.\n     *\n     * <ul>\n     * <li>ignore the first character (\"<b>-</b>\")</li>\n     * <li>for each remaining character check if an {@link Option} exists with that id.</li>\n     * <li>if an {@link Option} does exist then add that character prepended with \"<b>-</b>\" to the list of processed\n     * tokens.</li>\n     * <li>if the {@link Option} can have an argument value and there are remaining characters in the token then add the\n     * remaining characters as a token to the list of processed tokens.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS</b> set then add the\n     * special token \"<b>--</b>\" followed by the remaining characters and also the remaining tokens directly to the\n     * processed tokens list.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS NOT</b> set then add\n     * that character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing at the first non-Option encountered.\n     */\n    protected void burstToken(final String token, final boolean stopAtNonOption) {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n\n            if (!options.hasOption(ch)) {\n                if (stopAtNonOption) {\n                    processNonOptionToken(token.substring(i), true);\n                } else {\n                    tokens.add(token);\n                }\n                break;\n            }\n            tokens.add(\"-\" + ch);\n            currentOption = options.getOption(ch);\n\n            if (currentOption.hasArg() && token.length() != i + 1) {\n                tokens.add(token.substring(i + 1));\n\n                break;\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * An implementation of {@link Parser}'s abstract {@link Parser#flatten(Options,String[],boolean) flatten} method.\n     * </p>\n     *\n     * <p>\n     * The following are the rules used by this flatten method.\n     * </p>\n     * <ol>\n     * <li>if {@code stopAtNonOption} is <b>true</b> then do not burst anymore of {@code arguments} entries, just\n     * add each successive entry without further processing. Otherwise, ignore {@code stopAtNonOption}.</li>\n     * <li>if the current {@code arguments} entry is \"<b>--</b>\" just add the entry to the list of processed\n     * tokens</li>\n     * <li>if the current {@code arguments} entry is \"<b>-</b>\" just add the entry to the list of processed tokens</li>\n     * <li>if the current {@code arguments} entry is two characters in length and the first character is \"<b>-</b>\"\n     * then check if this is a valid {@link Option} id. If it is a valid id, then add the entry to the list of processed\n     * tokens and set the current {@link Option} member. If it is not a valid id and {@code stopAtNonOption} is true,\n     * then the remaining entries are copied to the list of processed tokens. Otherwise, the current entry is ignored.</li>\n     * <li>if the current {@code arguments} entry is more than two characters in length and the first character is\n     * \"<b>-</b>\" then we need to burst the entry to determine its constituents. For more information on the bursting\n     * algorithm see {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     * <li>if the current {@code arguments} entry is not handled by any of the previous rules, then the entry is added\n     * to the list of processed tokens.</li>\n     * </ol>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening when an non option is found.\n     * @return The flattened {@code arguments} String array.\n     */\n    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        init();\n        this.options = options;\n        // an iterator for the command line tokens\n        final Iterator<String> iter = Arrays.asList(arguments).iterator();\n        // process each command line token\n        while (iter.hasNext()) {\n            // get the next command line token\n            final String token = iter.next();\n            if (token != null) {\n                // single or double hyphen\n                if (\"-\".equals(token) || \"--\".equals(token)) {\n                    tokens.add(token);\n                } else if (token.startsWith(\"--\")) {\n                    // handle long option --foo or --foo=bar\n                    final int pos = DefaultParser.indexOfEqual(token);\n                    final String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                    final List<String> matchingOpts = options.getMatchingOptions(opt);\n\n                    if (matchingOpts.isEmpty()) {\n                        processNonOptionToken(token, stopAtNonOption);\n                    } else if (matchingOpts.size() > 1) {\n                        throw new AmbiguousOptionException(opt, matchingOpts);\n                    } else {\n                        currentOption = options.getOption(matchingOpts.get(0));\n\n                        tokens.add(\"--\" + currentOption.getLongOpt());\n                        if (pos != -1) {\n                            tokens.add(token.substring(pos + 1));\n                        }\n                    }\n                } else if (token.startsWith(\"-\")) {\n                    if (token.length() == 2 || options.hasOption(token)) {\n                        processOptionToken(token, stopAtNonOption);\n                    } else if (!options.getMatchingOptions(token).isEmpty()) {\n                        final List<String> matchingOpts = options.getMatchingOptions(token);\n                        if (matchingOpts.size() > 1) {\n                            throw new AmbiguousOptionException(token, matchingOpts);\n                        }\n                        final Option opt = options.getOption(matchingOpts.get(0));\n                        processOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n                    }\n                    // requires bursting\n                    else {\n                        burstToken(token, stopAtNonOption);\n                    }\n                } else {\n                    processNonOptionToken(token, stopAtNonOption);\n                }\n            }\n            gobble(iter);\n        }\n        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(final Iterator<String> iter) {\n        if (eatTheRest) {\n            while (iter.hasNext()) {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * Resets the members to their original state i.e. remove all of {@code tokens} entries and set\n     * {@code eatTheRest} to false.\n     */\n    private void init() {\n        eatTheRest = false;\n        tokens.clear();\n    }\n\n    /**\n     * Add the special token \"<b>--</b>\" and the current {@code value} to the processed tokens list. Then add all the\n     * remaining {@code argument} values to the processed tokens list.\n     *\n     * @param value The current token\n     */\n    private void processNonOptionToken(final String value, final boolean stopAtNonOption) {\n        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg())) {\n            eatTheRest = true;\n            tokens.add(\"--\");\n        }\n\n        tokens.add(value);\n    }\n\n    /**\n     * <p>\n     * If an {@link Option} exists for {@code token} then add the token to the processed list.\n     * </p>\n     *\n     * <p>\n     * If an {@link Option} does not exist and {@code stopAtNonOption} is set then add the remaining tokens to the\n     * processed tokens list directly.\n     * </p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt at the first non option.\n     */\n    private void processOptionToken(final String token, final boolean stopAtNonOption) {\n        if (stopAtNonOption && !options.hasOption(token)) {\n            eatTheRest = true;\n        }\n\n        if (options.hasOption(token)) {\n            currentOption = options.getOption(token);\n        }\n\n        tokens.add(token);\n    }\n}\n", "file_hash": "227079354eae4cf01b1672e452965e8972324645ab12fdb7ca268f75fbaec22d", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Iterator;", "import java.util.List;"], "methods": [], "classes": [{"original_string": "@Deprecated\npublic class PosixParser extends Parser {\n    /** Holder for flattened tokens */\n    private final List<String> tokens = new ArrayList<>();\n\n    /** Specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** Holder for the current option */\n    private Option currentOption;\n\n    /** The command line Options */\n    private Options options;\n\n    /**\n     * Breaks {@code token} into its constituent parts using the following algorithm.\n     *\n     * <ul>\n     * <li>ignore the first character (\"<b>-</b>\")</li>\n     * <li>for each remaining character check if an {@link Option} exists with that id.</li>\n     * <li>if an {@link Option} does exist then add that character prepended with \"<b>-</b>\" to the list of processed\n     * tokens.</li>\n     * <li>if the {@link Option} can have an argument value and there are remaining characters in the token then add the\n     * remaining characters as a token to the list of processed tokens.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS</b> set then add the\n     * special token \"<b>--</b>\" followed by the remaining characters and also the remaining tokens directly to the\n     * processed tokens list.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS NOT</b> set then add\n     * that character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing at the first non-Option encountered.\n     */\n    protected void burstToken(final String token, final boolean stopAtNonOption) {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n\n            if (!options.hasOption(ch)) {\n                if (stopAtNonOption) {\n                    processNonOptionToken(token.substring(i), true);\n                } else {\n                    tokens.add(token);\n                }\n                break;\n            }\n            tokens.add(\"-\" + ch);\n            currentOption = options.getOption(ch);\n\n            if (currentOption.hasArg() && token.length() != i + 1) {\n                tokens.add(token.substring(i + 1));\n\n                break;\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * An implementation of {@link Parser}'s abstract {@link Parser#flatten(Options,String[],boolean) flatten} method.\n     * </p>\n     *\n     * <p>\n     * The following are the rules used by this flatten method.\n     * </p>\n     * <ol>\n     * <li>if {@code stopAtNonOption} is <b>true</b> then do not burst anymore of {@code arguments} entries, just\n     * add each successive entry without further processing. Otherwise, ignore {@code stopAtNonOption}.</li>\n     * <li>if the current {@code arguments} entry is \"<b>--</b>\" just add the entry to the list of processed\n     * tokens</li>\n     * <li>if the current {@code arguments} entry is \"<b>-</b>\" just add the entry to the list of processed tokens</li>\n     * <li>if the current {@code arguments} entry is two characters in length and the first character is \"<b>-</b>\"\n     * then check if this is a valid {@link Option} id. If it is a valid id, then add the entry to the list of processed\n     * tokens and set the current {@link Option} member. If it is not a valid id and {@code stopAtNonOption} is true,\n     * then the remaining entries are copied to the list of processed tokens. Otherwise, the current entry is ignored.</li>\n     * <li>if the current {@code arguments} entry is more than two characters in length and the first character is\n     * \"<b>-</b>\" then we need to burst the entry to determine its constituents. For more information on the bursting\n     * algorithm see {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     * <li>if the current {@code arguments} entry is not handled by any of the previous rules, then the entry is added\n     * to the list of processed tokens.</li>\n     * </ol>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening when an non option is found.\n     * @return The flattened {@code arguments} String array.\n     */\n    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        init();\n        this.options = options;\n        // an iterator for the command line tokens\n        final Iterator<String> iter = Arrays.asList(arguments).iterator();\n        // process each command line token\n        while (iter.hasNext()) {\n            // get the next command line token\n            final String token = iter.next();\n            if (token != null) {\n                // single or double hyphen\n                if (\"-\".equals(token) || \"--\".equals(token)) {\n                    tokens.add(token);\n                } else if (token.startsWith(\"--\")) {\n                    // handle long option --foo or --foo=bar\n                    final int pos = DefaultParser.indexOfEqual(token);\n                    final String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                    final List<String> matchingOpts = options.getMatchingOptions(opt);\n\n                    if (matchingOpts.isEmpty()) {\n                        processNonOptionToken(token, stopAtNonOption);\n                    } else if (matchingOpts.size() > 1) {\n                        throw new AmbiguousOptionException(opt, matchingOpts);\n                    } else {\n                        currentOption = options.getOption(matchingOpts.get(0));\n\n                        tokens.add(\"--\" + currentOption.getLongOpt());\n                        if (pos != -1) {\n                            tokens.add(token.substring(pos + 1));\n                        }\n                    }\n                } else if (token.startsWith(\"-\")) {\n                    if (token.length() == 2 || options.hasOption(token)) {\n                        processOptionToken(token, stopAtNonOption);\n                    } else if (!options.getMatchingOptions(token).isEmpty()) {\n                        final List<String> matchingOpts = options.getMatchingOptions(token);\n                        if (matchingOpts.size() > 1) {\n                            throw new AmbiguousOptionException(token, matchingOpts);\n                        }\n                        final Option opt = options.getOption(matchingOpts.get(0));\n                        processOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n                    }\n                    // requires bursting\n                    else {\n                        burstToken(token, stopAtNonOption);\n                    }\n                } else {\n                    processNonOptionToken(token, stopAtNonOption);\n                }\n            }\n            gobble(iter);\n        }\n        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(final Iterator<String> iter) {\n        if (eatTheRest) {\n            while (iter.hasNext()) {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * Resets the members to their original state i.e. remove all of {@code tokens} entries and set\n     * {@code eatTheRest} to false.\n     */\n    private void init() {\n        eatTheRest = false;\n        tokens.clear();\n    }\n\n    /**\n     * Add the special token \"<b>--</b>\" and the current {@code value} to the processed tokens list. Then add all the\n     * remaining {@code argument} values to the processed tokens list.\n     *\n     * @param value The current token\n     */\n    private void processNonOptionToken(final String value, final boolean stopAtNonOption) {\n        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg())) {\n            eatTheRest = true;\n            tokens.add(\"--\");\n        }\n\n        tokens.add(value);\n    }\n\n    /**\n     * <p>\n     * If an {@link Option} exists for {@code token} then add the token to the processed list.\n     * </p>\n     *\n     * <p>\n     * If an {@link Option} does not exist and {@code stopAtNonOption} is set then add the remaining tokens to the\n     * processed tokens list directly.\n     * </p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt at the first non option.\n     */\n    private void processOptionToken(final String token, final boolean stopAtNonOption) {\n        if (stopAtNonOption && !options.hasOption(token)) {\n            eatTheRest = true;\n        }\n\n        if (options.hasOption(token)) {\n            currentOption = options.getOption(token);\n        }\n\n        tokens.add(token);\n    }\n}", "definition": "@Deprecated\npublic class PosixParser extends Parser", "class_docstring": "\nThe class PosixParser provides an implementation of the {@link Parser#flatten(Options,String[],boolean) flatten}\nmethod.\n\n@deprecated since 1.3, use the {@link DefaultParser} instead\n", "name": "PosixParser", "super_interfaces": [], "superclasses": "Parser", "attributes": {"modifiers": "@Deprecated\npublic", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final List<String> tokens = new ArrayList<>();", "docstring": " Holder for flattened tokens", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "tokens = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private boolean eatTheRest;", "docstring": " Specifies if bursting should continue", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "eatTheRest", "syntax_pass": true}, {"attribute_expression": "private Option currentOption;", "docstring": " Holder for the current option", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "currentOption", "syntax_pass": true}, {"attribute_expression": "private Options options;", "docstring": " The command line Options", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected void burstToken(final String token, final boolean stopAtNonOption) {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n\n            if (!options.hasOption(ch)) {\n                if (stopAtNonOption) {\n                    processNonOptionToken(token.substring(i), true);\n                } else {\n                    tokens.add(token);\n                }\n                break;\n            }\n            tokens.add(\"-\" + ch);\n            currentOption = options.getOption(ch);\n\n            if (currentOption.hasArg() && token.length() != i + 1) {\n                tokens.add(token.substring(i + 1));\n\n                break;\n            }\n        }\n    }", "docstring": "\nBreaks {@code token} into its constituent parts using the following algorithm.\n\n<ul>\n<li>ignore the first character (\"<b>-</b>\")</li>\n<li>for each remaining character check if an {@link Option} exists with that id.</li>\n<li>if an {@link Option} does exist then add that character prepended with \"<b>-</b>\" to the list of processed\ntokens.</li>\n<li>if the {@link Option} can have an argument value and there are remaining characters in the token then add the\nremaining characters as a token to the list of processed tokens.</li>\n<li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS</b> set then add the\nspecial token \"<b>--</b>\" followed by the remaining characters and also the remaining tokens directly to the\nprocessed tokens list.</li>\n<li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS NOT</b> set then add\nthat character prepended with \"<b>-</b>\".</li>\n</ul>\n\n@param token The current token to be <b>burst</b>\n@param stopAtNonOption Specifies whether to stop processing at the first non-Option encountered.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "burstToken", "params": [{"name": "token", "type": "String"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "                                                                                 {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n\n            if (!options.hasOption(ch)) {\n                if (stopAtNonOption) {\n                    processNonOptionToken(token.substring(i), true);\n                } else {\n                    tokens.add(token);\n                }\n                break;\n            }\n            tokens.add(\"-\" + ch);\n            currentOption = options.getOption(ch);\n\n            if (currentOption.hasArg() && token.length() != i + 1) {\n                tokens.add(token.substring(i + 1));\n\n                break;\n            }\n        }\n    }", "signature": "protected void burstToken(final String token, final boolean stopAtNonOption)"}, {"syntax_pass": true, "original_string": "    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        init();\n        this.options = options;\n        // an iterator for the command line tokens\n        final Iterator<String> iter = Arrays.asList(arguments).iterator();\n        // process each command line token\n        while (iter.hasNext()) {\n            // get the next command line token\n            final String token = iter.next();\n            if (token != null) {\n                // single or double hyphen\n                if (\"-\".equals(token) || \"--\".equals(token)) {\n                    tokens.add(token);\n                } else if (token.startsWith(\"--\")) {\n                    // handle long option --foo or --foo=bar\n                    final int pos = DefaultParser.indexOfEqual(token);\n                    final String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                    final List<String> matchingOpts = options.getMatchingOptions(opt);\n\n                    if (matchingOpts.isEmpty()) {\n                        processNonOptionToken(token, stopAtNonOption);\n                    } else if (matchingOpts.size() > 1) {\n                        throw new AmbiguousOptionException(opt, matchingOpts);\n                    } else {\n                        currentOption = options.getOption(matchingOpts.get(0));\n\n                        tokens.add(\"--\" + currentOption.getLongOpt());\n                        if (pos != -1) {\n                            tokens.add(token.substring(pos + 1));\n                        }\n                    }\n                } else if (token.startsWith(\"-\")) {\n                    if (token.length() == 2 || options.hasOption(token)) {\n                        processOptionToken(token, stopAtNonOption);\n                    } else if (!options.getMatchingOptions(token).isEmpty()) {\n                        final List<String> matchingOpts = options.getMatchingOptions(token);\n                        if (matchingOpts.size() > 1) {\n                            throw new AmbiguousOptionException(token, matchingOpts);\n                        }\n                        final Option opt = options.getOption(matchingOpts.get(0));\n                        processOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n                    }\n                    // requires bursting\n                    else {\n                        burstToken(token, stopAtNonOption);\n                    }\n                } else {\n                    processNonOptionToken(token, stopAtNonOption);\n                }\n            }\n            gobble(iter);\n        }\n        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n    }", "docstring": "\n<p>\nAn implementation of {@link Parser}'s abstract {@link Parser#flatten(Options,String[],boolean) flatten} method.\n</p>\n\n<p>\nThe following are the rules used by this flatten method.\n</p>\n<ol>\n<li>if {@code stopAtNonOption} is <b>true</b> then do not burst anymore of {@code arguments} entries, just\nadd each successive entry without further processing. Otherwise, ignore {@code stopAtNonOption}.</li>\n<li>if the current {@code arguments} entry is \"<b>--</b>\" just add the entry to the list of processed\ntokens</li>\n<li>if the current {@code arguments} entry is \"<b>-</b>\" just add the entry to the list of processed tokens</li>\n<li>if the current {@code arguments} entry is two characters in length and the first character is \"<b>-</b>\"\nthen check if this is a valid {@link Option} id. If it is a valid id, then add the entry to the list of processed\ntokens and set the current {@link Option} member. If it is not a valid id and {@code stopAtNonOption} is true,\nthen the remaining entries are copied to the list of processed tokens. Otherwise, the current entry is ignored.</li>\n<li>if the current {@code arguments} entry is more than two characters in length and the first character is\n\"<b>-</b>\" then we need to burst the entry to determine its constituents. For more information on the bursting\nalgorithm see {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n<li>if the current {@code arguments} entry is not handled by any of the previous rules, then the entry is added\nto the list of processed tokens.</li>\n</ol>\n\n@param options The command line {@link Options}\n@param arguments The command line arguments to be parsed\n@param stopAtNonOption Specifies whether to stop flattening when an non option is found.\n@return The flattened {@code arguments} String array.\n", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String[]", "classes": []}, "name": "flatten", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "                                                                                                                                     {\n        init();\n        this.options = options;\n        // an iterator for the command line tokens\n        final Iterator<String> iter = Arrays.asList(arguments).iterator();\n        // process each command line token\n        while (iter.hasNext()) {\n            // get the next command line token\n            final String token = iter.next();\n            if (token != null) {\n                // single or double hyphen\n                if (\"-\".equals(token) || \"--\".equals(token)) {\n                    tokens.add(token);\n                } else if (token.startsWith(\"--\")) {\n                    // handle long option --foo or --foo=bar\n                    final int pos = DefaultParser.indexOfEqual(token);\n                    final String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                    final List<String> matchingOpts = options.getMatchingOptions(opt);\n\n                    if (matchingOpts.isEmpty()) {\n                        processNonOptionToken(token, stopAtNonOption);\n                    } else if (matchingOpts.size() > 1) {\n                        throw new AmbiguousOptionException(opt, matchingOpts);\n                    } else {\n                        currentOption = options.getOption(matchingOpts.get(0));\n\n                        tokens.add(\"--\" + currentOption.getLongOpt());\n                        if (pos != -1) {\n                            tokens.add(token.substring(pos + 1));\n                        }\n                    }\n                } else if (token.startsWith(\"-\")) {\n                    if (token.length() == 2 || options.hasOption(token)) {\n                        processOptionToken(token, stopAtNonOption);\n                    } else if (!options.getMatchingOptions(token).isEmpty()) {\n                        final List<String> matchingOpts = options.getMatchingOptions(token);\n                        if (matchingOpts.size() > 1) {\n                            throw new AmbiguousOptionException(token, matchingOpts);\n                        }\n                        final Option opt = options.getOption(matchingOpts.get(0));\n                        processOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n                    }\n                    // requires bursting\n                    else {\n                        burstToken(token, stopAtNonOption);\n                    }\n                } else {\n                    processNonOptionToken(token, stopAtNonOption);\n                }\n            }\n            gobble(iter);\n        }\n        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n    }", "signature": "@Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption)"}, {"syntax_pass": true, "original_string": "    private void gobble(final Iterator<String> iter) {\n        if (eatTheRest) {\n            while (iter.hasNext()) {\n                tokens.add(iter.next());\n            }\n        }\n    }", "docstring": "\nAdds the remaining tokens to the processed tokens list.\n\n@param iter An iterator over the remaining tokens\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "gobble", "params": [{"name": "iter", "type": "Iterator<String>"}], "body": "                                                     {\n        if (eatTheRest) {\n            while (iter.hasNext()) {\n                tokens.add(iter.next());\n            }\n        }\n    }", "signature": "private void gobble(final Iterator<String> iter)"}, {"syntax_pass": true, "original_string": "    private void init() {\n        eatTheRest = false;\n        tokens.clear();\n    }", "docstring": "\nResets the members to their original state i.e. remove all of {@code tokens} entries and set\n{@code eatTheRest} to false.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "init", "params": [], "body": "                        {\n        eatTheRest = false;\n        tokens.clear();\n    }", "signature": "private void init()"}, {"syntax_pass": true, "original_string": "    private void processNonOptionToken(final String value, final boolean stopAtNonOption) {\n        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg())) {\n            eatTheRest = true;\n            tokens.add(\"--\");\n        }\n\n        tokens.add(value);\n    }", "docstring": "\nAdd the special token \"<b>--</b>\" and the current {@code value} to the processed tokens list. Then add all the\nremaining {@code argument} values to the processed tokens list.\n\n@param value The current token\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "processNonOptionToken", "params": [{"name": "value", "type": "String"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "                                                                                          {\n        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg())) {\n            eatTheRest = true;\n            tokens.add(\"--\");\n        }\n\n        tokens.add(value);\n    }", "signature": "private void processNonOptionToken(final String value, final boolean stopAtNonOption)"}, {"syntax_pass": true, "original_string": "    private void processOptionToken(final String token, final boolean stopAtNonOption) {\n        if (stopAtNonOption && !options.hasOption(token)) {\n            eatTheRest = true;\n        }\n\n        if (options.hasOption(token)) {\n            currentOption = options.getOption(token);\n        }\n\n        tokens.add(token);\n    }", "docstring": "\n<p>\nIf an {@link Option} exists for {@code token} then add the token to the processed list.\n</p>\n\n<p>\nIf an {@link Option} does not exist and {@code stopAtNonOption} is set then add the remaining tokens to the\nprocessed tokens list directly.\n</p>\n\n@param token The current option token\n@param stopAtNonOption Specifies whether flattening should halt at the first non option.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "processOptionToken", "params": [{"name": "token", "type": "String"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "                                                                                       {\n        if (stopAtNonOption && !options.hasOption(token)) {\n            eatTheRest = true;\n        }\n\n        if (options.hasOption(token)) {\n            currentOption = options.getOption(token);\n        }\n\n        tokens.add(token);\n    }", "signature": "private void processOptionToken(final String token, final boolean stopAtNonOption)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/MissingOptionException.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * Thrown when a required option has not been provided.\n */\npublic class MissingOptionException extends ParseException {\n    /** This exception {@code serialVersionUID}. */\n    private static final long serialVersionUID = 8161889051578563249L;\n\n    /**\n     * Build the exception message from the specified list of options.\n     *\n     * @param missingOptions the list of missing options and groups\n     */\n    private static String createMessage(final List<?> missingOptions) {\n        final StringBuilder buf = new StringBuilder(\"Missing required option\");\n        buf.append(missingOptions.size() == 1 ? \"\" : \"s\");\n        buf.append(\": \");\n\n        final Iterator<?> it = missingOptions.iterator();\n        while (it.hasNext()) {\n            buf.append(it.next());\n            if (it.hasNext()) {\n                buf.append(\", \");\n            }\n        }\n\n        return buf.toString();\n    }\n\n    /** The list of missing options and groups */\n    private List missingOptions;\n\n    /**\n     * Constructs a new {@code MissingSelectedException} with the specified list of missing options.\n     *\n     * @param missingOptions the list of missing options and groups\n     * @since 1.2\n     */\n    public MissingOptionException(final List missingOptions) {\n        this(createMessage(missingOptions));\n        this.missingOptions = missingOptions;\n    }\n\n    /**\n     * Constructs a new {@code MissingSelectedException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public MissingOptionException(final String message) {\n        super(message);\n    }\n\n    /**\n     * Gets the list of options or option groups missing in the command line parsed.\n     *\n     * @return the missing options, consisting of String instances for simple options, and OptionGroup instances for\n     *         required option groups.\n     * @since 1.2\n     */\n    public List getMissingOptions() {\n        return missingOptions;\n    }\n}\n", "file_hash": "a0c2162f5d0a52d9d6693e4c2b2a929c6bf61ac58e65af860cb3441f357b6cd9", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.util.Iterator;", "import java.util.List;"], "methods": [], "classes": [{"original_string": "public class MissingOptionException extends ParseException {\n    /** This exception {@code serialVersionUID}. */\n    private static final long serialVersionUID = 8161889051578563249L;\n\n    /**\n     * Build the exception message from the specified list of options.\n     *\n     * @param missingOptions the list of missing options and groups\n     */\n    private static String createMessage(final List<?> missingOptions) {\n        final StringBuilder buf = new StringBuilder(\"Missing required option\");\n        buf.append(missingOptions.size() == 1 ? \"\" : \"s\");\n        buf.append(\": \");\n\n        final Iterator<?> it = missingOptions.iterator();\n        while (it.hasNext()) {\n            buf.append(it.next());\n            if (it.hasNext()) {\n                buf.append(\", \");\n            }\n        }\n\n        return buf.toString();\n    }\n\n    /** The list of missing options and groups */\n    private List missingOptions;\n\n    /**\n     * Constructs a new {@code MissingSelectedException} with the specified list of missing options.\n     *\n     * @param missingOptions the list of missing options and groups\n     * @since 1.2\n     */\n    public MissingOptionException(final List missingOptions) {\n        this(createMessage(missingOptions));\n        this.missingOptions = missingOptions;\n    }\n\n    /**\n     * Constructs a new {@code MissingSelectedException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public MissingOptionException(final String message) {\n        super(message);\n    }\n\n    /**\n     * Gets the list of options or option groups missing in the command line parsed.\n     *\n     * @return the missing options, consisting of String instances for simple options, and OptionGroup instances for\n     *         required option groups.\n     * @since 1.2\n     */\n    public List getMissingOptions() {\n        return missingOptions;\n    }\n}", "definition": "public class MissingOptionException extends ParseException", "class_docstring": "\nThrown when a required option has not been provided.\n", "name": "MissingOptionException", "super_interfaces": [], "superclasses": "ParseException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 8161889051578563249L;", "docstring": " This exception {@code serialVersionUID}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 8161889051578563249L", "syntax_pass": true}, {"attribute_expression": "private List missingOptions;", "docstring": " The list of missing options and groups", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List", "name": "missingOptions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static String createMessage(final List<?> missingOptions) {\n        final StringBuilder buf = new StringBuilder(\"Missing required option\");\n        buf.append(missingOptions.size() == 1 ? \"\" : \"s\");\n        buf.append(\": \");\n\n        final Iterator<?> it = missingOptions.iterator();\n        while (it.hasNext()) {\n            buf.append(it.next());\n            if (it.hasNext()) {\n                buf.append(\", \");\n            }\n        }\n\n        return buf.toString();\n    }", "docstring": "\nBuild the exception message from the specified list of options.\n\n@param missingOptions the list of missing options and groups\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "createMessage", "params": [{"name": "missingOptions", "type": "List<?>"}], "body": "                                                                      {\n        final StringBuilder buf = new StringBuilder(\"Missing required option\");\n        buf.append(missingOptions.size() == 1 ? \"\" : \"s\");\n        buf.append(\": \");\n\n        final Iterator<?> it = missingOptions.iterator();\n        while (it.hasNext()) {\n            buf.append(it.next());\n            if (it.hasNext()) {\n                buf.append(\", \");\n            }\n        }\n\n        return buf.toString();\n    }", "signature": "private static String createMessage(final List<?> missingOptions)"}, {"syntax_pass": true, "original_string": "    public MissingOptionException(final List missingOptions) {\n        this(createMessage(missingOptions));\n        this.missingOptions = missingOptions;\n    }", "docstring": "\nConstructs a new {@code MissingSelectedException} with the specified list of missing options.\n\n@param missingOptions the list of missing options and groups\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MissingOptionException", "params": [{"name": "missingOptions", "type": "List"}], "body": "                                                             {\n        this(createMessage(missingOptions));\n        this.missingOptions = missingOptions;\n    }", "signature": "public MissingOptionException(final List missingOptions)"}, {"syntax_pass": true, "original_string": "    public MissingOptionException(final String message) {\n        super(message);\n    }", "docstring": "\nConstructs a new {@code MissingSelectedException} with the specified detail message.\n\n@param message the detail message\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MissingOptionException", "params": [{"name": "message", "type": "String"}], "body": "                                                        {\n        super(message);\n    }", "signature": "public MissingOptionException(final String message)"}, {"syntax_pass": true, "original_string": "    public List getMissingOptions() {\n        return missingOptions;\n    }", "docstring": "\nGets the list of options or option groups missing in the command line parsed.\n\n@return the missing options, consisting of String instances for simple options, and OptionGroup instances for\n        required option groups.\n@since 1.2\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List", "classes": []}, "name": "getMissingOptions", "params": [], "body": "                                    {\n        return missingOptions;\n    }", "signature": "public List getMissingOptions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/CommandLineParser.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * A class that implements the {@code CommandLineParser} interface can parse a String array according to the\n * {@link Options} specified and return a {@link CommandLine}.\n */\npublic interface CommandLineParser {\n\n    /**\n     * Parses the arguments according to the specified options.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    CommandLine parse(Options options, String[] arguments) throws ParseException;\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    /*\n     * To maintain binary compatibility, this is commented out. It is still in the abstract Parser class, so most users will\n     * still reap the benefit. CommandLine parse(Options options, String[] arguments, Properties properties) throws\n     * ParseException;\n     */\n\n    /**\n     * Parses the arguments according to the specified options.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    /*\n     * To maintain binary compatibility, this is commented out. It is still in the abstract Parser class, so most users will\n     * still reap the benefit. CommandLine parse(Options options, String[] arguments, Properties properties, boolean\n     * stopAtNonOption) throws ParseException;\n     */\n}\n", "file_hash": "9140e6db56b49ac1be8c18636b8f21b3e3bc3f24eeb9496ef371bc31c195e35b", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface CommandLineParser {\n\n    /**\n     * Parses the arguments according to the specified options.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    CommandLine parse(Options options, String[] arguments) throws ParseException;\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    /*\n     * To maintain binary compatibility, this is commented out. It is still in the abstract Parser class, so most users will\n     * still reap the benefit. CommandLine parse(Options options, String[] arguments, Properties properties) throws\n     * ParseException;\n     */\n\n    /**\n     * Parses the arguments according to the specified options.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    /*\n     * To maintain binary compatibility, this is commented out. It is still in the abstract Parser class, so most users will\n     * still reap the benefit. CommandLine parse(Options options, String[] arguments, Properties properties, boolean\n     * stopAtNonOption) throws ParseException;\n     */\n}", "definition": "public interface CommandLineParser", "interface_docstring": "\nA class that implements the {@code CommandLineParser} interface can parse a String array according to the\n{@link Options} specified and return a {@link CommandLine}.\n", "name": "CommandLineParser", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    CommandLine parse(Options options, String[] arguments) throws ParseException;", "docstring": "\nParses the arguments according to the specified options.\n\n@param options the specified Options\n@param arguments the command line arguments\n@return the list of atomic option and value tokens\n\n@throws ParseException if there are any problems encountered while parsing the command line tokens.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "parse", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}], "body": "", "signature": "CommandLine parse(Options options, String[] arguments)"}, {"syntax_pass": true, "original_string": "    CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException;", "docstring": "\nParses the arguments according to the specified options.\n\n@param options the specified Options\n@param arguments the command line arguments\n@param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n       are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n       ParseException.\n\n@return the list of atomic option and value tokens\n@throws ParseException if there are any problems encountered while parsing the command line tokens.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "parse", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "", "signature": "CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption)"}]}], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/GnuParser.java", "original_string": "/*\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The class GnuParser provides an implementation of the {@link Parser#flatten(Options, String[], boolean) flatten}\n * method.\n *\n * @deprecated since 1.3, use the {@link DefaultParser} instead\n */\n@Deprecated\npublic class GnuParser extends Parser {\n    /**\n     * This flatten method does so using the following rules:\n     * <ol>\n     * <li>If an {@link Option} exists for the first character of the {@code arguments} entry <b>AND</b> an\n     * {@link Option} does not exist for the whole {@code argument} then add the first character as an option to the\n     * processed tokens list e.g. \"-D\" and add the rest of the entry to the also.</li>\n     * <li>Otherwise just add the token to the processed tokens list.</li>\n     * </ol>\n     *\n     * @param options The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) {\n        final List<String> tokens = new ArrayList<>();\n        boolean eatTheRest = false;\n        for (int i = 0; i < arguments.length; i++) {\n            final String arg = arguments[i];\n            if (arg != null) {\n                if (\"--\".equals(arg)) {\n                    eatTheRest = true;\n                    tokens.add(\"--\");\n                } else if (\"-\".equals(arg)) {\n                    tokens.add(\"-\");\n                } else if (arg.startsWith(\"-\")) {\n                    final String opt = Util.stripLeadingHyphens(arg);\n                    if (options.hasOption(opt)) {\n                        tokens.add(arg);\n                    } else {\n                        final int equalPos = DefaultParser.indexOfEqual(opt);\n                        if (equalPos != -1 && options.hasOption(opt.substring(0, equalPos))) {\n                            // the format is --foo=value or -foo=value\n                            tokens.add(arg.substring(0, arg.indexOf(Char.EQUAL))); // --foo\n                            tokens.add(arg.substring(arg.indexOf(Char.EQUAL) + 1)); // value\n                        } else if (options.hasOption(arg.substring(0, 2))) {\n                            // the format is a special properties option (-Dproperty=value)\n                            tokens.add(arg.substring(0, 2)); // -D\n                            tokens.add(arg.substring(2)); // property=value\n                        } else {\n                            eatTheRest = stopAtNonOption;\n                            tokens.add(arg);\n                        }\n                    }\n                } else {\n                    tokens.add(arg);\n                }\n\n                if (eatTheRest) {\n                    for (i++; i < arguments.length; i++) { // NOPMD\n                        tokens.add(arguments[i]);\n                    }\n                }\n            }\n        }\n\n        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n}\n", "file_hash": "a181d1c88696e5d652adeba2a7f2e716fe8294799244541cedab4a378af759c6", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;", "import java.util.ArrayList;", "import java.util.List;"], "methods": [], "classes": [{"original_string": "@Deprecated\npublic class GnuParser extends Parser {\n    /**\n     * This flatten method does so using the following rules:\n     * <ol>\n     * <li>If an {@link Option} exists for the first character of the {@code arguments} entry <b>AND</b> an\n     * {@link Option} does not exist for the whole {@code argument} then add the first character as an option to the\n     * processed tokens list e.g. \"-D\" and add the rest of the entry to the also.</li>\n     * <li>Otherwise just add the token to the processed tokens list.</li>\n     * </ol>\n     *\n     * @param options The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) {\n        final List<String> tokens = new ArrayList<>();\n        boolean eatTheRest = false;\n        for (int i = 0; i < arguments.length; i++) {\n            final String arg = arguments[i];\n            if (arg != null) {\n                if (\"--\".equals(arg)) {\n                    eatTheRest = true;\n                    tokens.add(\"--\");\n                } else if (\"-\".equals(arg)) {\n                    tokens.add(\"-\");\n                } else if (arg.startsWith(\"-\")) {\n                    final String opt = Util.stripLeadingHyphens(arg);\n                    if (options.hasOption(opt)) {\n                        tokens.add(arg);\n                    } else {\n                        final int equalPos = DefaultParser.indexOfEqual(opt);\n                        if (equalPos != -1 && options.hasOption(opt.substring(0, equalPos))) {\n                            // the format is --foo=value or -foo=value\n                            tokens.add(arg.substring(0, arg.indexOf(Char.EQUAL))); // --foo\n                            tokens.add(arg.substring(arg.indexOf(Char.EQUAL) + 1)); // value\n                        } else if (options.hasOption(arg.substring(0, 2))) {\n                            // the format is a special properties option (-Dproperty=value)\n                            tokens.add(arg.substring(0, 2)); // -D\n                            tokens.add(arg.substring(2)); // property=value\n                        } else {\n                            eatTheRest = stopAtNonOption;\n                            tokens.add(arg);\n                        }\n                    }\n                } else {\n                    tokens.add(arg);\n                }\n\n                if (eatTheRest) {\n                    for (i++; i < arguments.length; i++) { // NOPMD\n                        tokens.add(arguments[i]);\n                    }\n                }\n            }\n        }\n\n        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n}", "definition": "@Deprecated\npublic class GnuParser extends Parser", "class_docstring": "\nThe class GnuParser provides an implementation of the {@link Parser#flatten(Options, String[], boolean) flatten}\nmethod.\n\n@deprecated since 1.3, use the {@link DefaultParser} instead\n", "name": "GnuParser", "super_interfaces": [], "superclasses": "Parser", "attributes": {"modifiers": "@Deprecated\npublic", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) {\n        final List<String> tokens = new ArrayList<>();\n        boolean eatTheRest = false;\n        for (int i = 0; i < arguments.length; i++) {\n            final String arg = arguments[i];\n            if (arg != null) {\n                if (\"--\".equals(arg)) {\n                    eatTheRest = true;\n                    tokens.add(\"--\");\n                } else if (\"-\".equals(arg)) {\n                    tokens.add(\"-\");\n                } else if (arg.startsWith(\"-\")) {\n                    final String opt = Util.stripLeadingHyphens(arg);\n                    if (options.hasOption(opt)) {\n                        tokens.add(arg);\n                    } else {\n                        final int equalPos = DefaultParser.indexOfEqual(opt);\n                        if (equalPos != -1 && options.hasOption(opt.substring(0, equalPos))) {\n                            // the format is --foo=value or -foo=value\n                            tokens.add(arg.substring(0, arg.indexOf(Char.EQUAL))); // --foo\n                            tokens.add(arg.substring(arg.indexOf(Char.EQUAL) + 1)); // value\n                        } else if (options.hasOption(arg.substring(0, 2))) {\n                            // the format is a special properties option (-Dproperty=value)\n                            tokens.add(arg.substring(0, 2)); // -D\n                            tokens.add(arg.substring(2)); // property=value\n                        } else {\n                            eatTheRest = stopAtNonOption;\n                            tokens.add(arg);\n                        }\n                    }\n                } else {\n                    tokens.add(arg);\n                }\n\n                if (eatTheRest) {\n                    for (i++; i < arguments.length; i++) { // NOPMD\n                        tokens.add(arguments[i]);\n                    }\n                }\n            }\n        }\n\n        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n    }", "docstring": "\nThis flatten method does so using the following rules:\n<ol>\n<li>If an {@link Option} exists for the first character of the {@code arguments} entry <b>AND</b> an\n{@link Option} does not exist for the whole {@code argument} then add the first character as an option to the\nprocessed tokens list e.g. \"-D\" and add the rest of the entry to the also.</li>\n<li>Otherwise just add the token to the processed tokens list.</li>\n</ol>\n\n@param options The Options to parse the arguments by.\n@param arguments The arguments that have to be flattened.\n@param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n@return a String array of the flattened arguments\n", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String[]", "classes": []}, "name": "flatten", "params": [{"name": "options", "type": "Options"}, {"name": "arguments", "type": "String[]"}, {"name": "stopAtNonOption", "type": "boolean"}], "body": "                                                                                                               {\n        final List<String> tokens = new ArrayList<>();\n        boolean eatTheRest = false;\n        for (int i = 0; i < arguments.length; i++) {\n            final String arg = arguments[i];\n            if (arg != null) {\n                if (\"--\".equals(arg)) {\n                    eatTheRest = true;\n                    tokens.add(\"--\");\n                } else if (\"-\".equals(arg)) {\n                    tokens.add(\"-\");\n                } else if (arg.startsWith(\"-\")) {\n                    final String opt = Util.stripLeadingHyphens(arg);\n                    if (options.hasOption(opt)) {\n                        tokens.add(arg);\n                    } else {\n                        final int equalPos = DefaultParser.indexOfEqual(opt);\n                        if (equalPos != -1 && options.hasOption(opt.substring(0, equalPos))) {\n                            // the format is --foo=value or -foo=value\n                            tokens.add(arg.substring(0, arg.indexOf(Char.EQUAL))); // --foo\n                            tokens.add(arg.substring(arg.indexOf(Char.EQUAL) + 1)); // value\n                        } else if (options.hasOption(arg.substring(0, 2))) {\n                            // the format is a special properties option (-Dproperty=value)\n                            tokens.add(arg.substring(0, 2)); // -D\n                            tokens.add(arg.substring(2)); // property=value\n                        } else {\n                            eatTheRest = stopAtNonOption;\n                            tokens.add(arg);\n                        }\n                    }\n                } else {\n                    tokens.add(arg);\n                }\n\n                if (eatTheRest) {\n                    for (i++; i < arguments.length; i++) { // NOPMD\n                        tokens.add(arguments[i]);\n                    }\n                }\n            }\n        }\n\n        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n    }", "signature": "@Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/cli/package-info.java", "original_string": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Apache Commons CLI provides a simple API for presenting, processing, and validating a Command Line Interface.\n */\npackage org.apache.commons.cli;\n", "file_hash": "1f7da548b9dc557bad0736506713426e12b1201f9b00646eb70d6d525c72e896", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.cli;"], "methods": [], "classes": [], "interfaces": [], "records": []}]