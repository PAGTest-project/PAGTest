[{"uris": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests.[void]testClientRetransmissions()", "name": "testClientRetransmissions", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testClientRetransmissions()", "original_string": "    @Test\n    public void testClientRetransmissions() throws Exception\n    {\n        String oldRetransValue = System.getProperty(\n                                     StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        String oldMaxWaitValue = System.getProperty(\n                                     StackProperties.MAX_CTRAN_RETRANS_TIMER);\n\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER, \"100\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n\n        //prepare to listen\n        System.setProperty(StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                           \"true\");\n\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait for retransmissions\n        Thread.sleep(1000);\n\n        //verify\n        Vector<StunMessageEvent> reqs\n            = requestCollector.getRequestsForTransaction(\n                                bindingRequest.getTransactionID());\n\n        assertTrue(reqs.size() > 1,\n            \"No retransmissions of the request have been received\");\n        assertTrue(reqs.size() >= 3,\n            \"The binding request has been retransmitted more than it should have!\");\n\n        //restore the retransmissions prop in case others are counting on\n        //defaults.\n        if(oldRetransValue != null)\n            System.getProperty( StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                                oldRetransValue);\n        else\n            System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n\n        if(oldMaxWaitValue != null)\n            System.getProperty( StackProperties.MAX_CTRAN_RETRANS_TIMER,\n                                oldRetransValue);\n        else\n            System.clearProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/TransactionSupportTests.java", "class_name": "TransactionSupportTests", "class_uri": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest that requests are retransmitted if no response is received\n\n@throws java.lang.Exception upon any failure\n"}, {"uris": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests.[void]testServerRetransmissionHiding()", "name": "testServerRetransmissionHiding", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testServerRetransmissionHiding()", "original_string": "    @Test\n    public void testServerRetransmissionHiding() throws Exception\n    {\n        String oldRetransValue = System.getProperty(\n                StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n        //prepare to listen\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait for retransmissions\n        Thread.sleep(1000);\n\n        //verify\n        Vector<StunMessageEvent> reqs\n            = requestCollector.getRequestsForTransaction(\n                bindingRequest.getTransactionID());\n\n        assertTrue(reqs.size() <= 1,\n            \"Retransmissions of a binding request were propagated to the server\");\n\n        //restore the retransmissions prop in case others are counting on\n        //defaults.\n        if(oldRetransValue != null)\n            System.getProperty( StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                                oldRetransValue);\n        else\n            System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/TransactionSupportTests.java", "class_name": "TransactionSupportTests", "class_uri": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMake sure that retransmissions are not seen by the server user and that\nit only gets a single request.\n\n@throws Exception if anything goes wrong.\n"}, {"uris": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests.[void]testServerResponseRetransmissions()", "name": "testServerResponseRetransmissions", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testServerResponseRetransmissions()", "original_string": "    @Test\n    public void testServerResponseRetransmissions() throws Exception\n    {\n        String oldRetransValue = System.getProperty(\n            StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER, \"100\");\n\n        //prepare to listen\n        System.setProperty(\n                StackProperties.KEEP_CRANS_AFTER_A_RESPONSE,\n                \"true\");\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait for the message to arrive\n        requestCollector.waitForRequest();\n\n        Vector<StunMessageEvent> reqs = requestCollector\n            .getRequestsForTransaction( bindingRequest.getTransactionID());\n\n        StunMessageEvent evt = reqs.get(0);\n\n        byte[] tid = evt.getMessage().getTransactionID();\n\n        stunStack.sendResponse(\n                tid,\n                bindingResponse,\n                serverAddress,\n                clientAddress);\n\n        //wait for retransmissions\n        Thread.sleep(500);\n\n        //verify that we received a fair number of retransmitted responses.\n        assertTrue(responseCollector.receivedResponses.size() < 3,\n            \"There were too few retransmissions of a binding response: \"\n                        +responseCollector.receivedResponses.size());\n\n        //restore the retransmissions prop in case others are counting on\n        //defaults.\n        if(oldRetransValue != null)\n            System.getProperty( StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                                oldRetransValue);\n        else\n            System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/TransactionSupportTests.java", "class_name": "TransactionSupportTests", "class_uri": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMakes sure that once a request has been answered by the server,\nretransmissions of this request are not propagated to the UA and are\nautomatically handled with a retransmission of the last seen response\n\n@throws Exception if we screw up.\n"}, {"uris": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests.[void]testUniqueIDs()", "name": "testUniqueIDs", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testUniqueIDs()", "original_string": "    @Test\n    public void testUniqueIDs() throws Exception\n    {\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send req 1\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait for retransmissions\n        requestCollector.waitForRequest();\n\n        Vector<StunMessageEvent> reqs1 = requestCollector\n            .getRequestsForTransaction( bindingRequest.getTransactionID());\n\n        StunMessageEvent evt1 = reqs1.get(0);\n\n        //send a response to make the other guy shut up\n        byte[] tid = evt1.getMessage().getTransactionID();\n\n        stunStack.sendResponse(\n                tid,\n                bindingResponse,\n                serverAddress,\n                clientAddress);\n\n        //send req 2\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait for retransmissions\n        Thread.sleep(1000);\n\n        Vector<StunMessageEvent> reqs2\n            = requestCollector.getRequestsForTransaction(\n                bindingRequest.getTransactionID());\n\n        StunMessageEvent evt2 = reqs2.get(0);\n\n        assertFalse(Arrays.equals(\n            evt1.getMessage().getTransactionID(),\n            evt2.getMessage().getTransactionID()),\n            \"Consecutive requests were assigned the same transaction id\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/TransactionSupportTests.java", "class_name": "TransactionSupportTests", "class_uri": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nA (very) weak test, verifying that transaction IDs are unique.\n@throws Exception in case we feel like it.\n"}, {"uris": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests.[void]testClientTransactionMaxRetransmisssionsConfigurationParameter()", "name": "testClientTransactionMaxRetransmisssionsConfigurationParameter", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testClientTransactionMaxRetransmisssionsConfigurationParameter()", "original_string": "    @Test\n    public void testClientTransactionMaxRetransmisssionsConfigurationParameter()\n        throws Exception\n    {\n        //MAX_RETRANSMISSIONS\n\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n        //make sure we see retransmissions so that we may count them\n        System.setProperty(\n                StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                \"true\");\n        stunStack.addRequestListener(\n                        serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n        //wait for retransmissions\n        Thread.sleep(1600);\n\n        //verify\n        Vector<StunMessageEvent> reqs\n            = requestCollector.getRequestsForTransaction(\n                bindingRequest.getTransactionID());\n\n        assertTrue(reqs.size() > 1,\n            \"No retransmissions of the request have been received\");\n        assertEquals(3, reqs.size(),\n            \"The MAX_RETRANSMISSIONS param was not taken into account!\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/TransactionSupportTests.java", "class_name": "TransactionSupportTests", "class_uri": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests whether the properties for configuring the maximum number of\nretransmissions in a transaction are working properly.\n\n@throws Exception if the gods so decide.\n"}, {"uris": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests.[void]testMinWaitIntervalConfigurationParameter()", "name": "testMinWaitIntervalConfigurationParameter", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testMinWaitIntervalConfigurationParameter()", "original_string": "    @Test\n    public void testMinWaitIntervalConfigurationParameter()\n        throws Exception\n    {\n        //MAX_RETRANSMISSIONS\n        System.setProperty(StackProperties.FIRST_CTRAN_RETRANS_AFTER, \"50\");\n        //make sure we see retransmissions so that we may count them\n        System.setProperty(\n                StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                \"true\");\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait a while\n        requestCollector.waitForRequest();\n\n        //verify\n        Vector<?> reqs = requestCollector.getRequestsForTransaction(\n                                bindingRequest.getTransactionID());\n        assertTrue(reqs.size() < 2,\n            \"A retransmissions of the request was sent too early\");\n\n        //wait for a send\n        Thread.sleep(110);\n\n        reqs = requestCollector.getRequestsForTransaction(\n                                bindingRequest.getTransactionID());\n\n        //verify\n        assertEquals(2, reqs.size(),\n            \"A retransmissions of the request was not sent\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/TransactionSupportTests.java", "class_name": "TransactionSupportTests", "class_uri": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests whether the properties for configuring the minimum transaction\nwait interval is working properly.\n\n@throws Exception if we are having a bad day.\n"}, {"uris": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests.[void]testMaxWaitIntervalConfigurationParameter()", "name": "testMaxWaitIntervalConfigurationParameter", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testMaxWaitIntervalConfigurationParameter()", "original_string": "    @Test\n    public void testMaxWaitIntervalConfigurationParameter()\n        throws Exception\n    {\n        //MAX_RETRANSMISSIONS\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER,\n                           \"100\");\n        //make sure we see retransmissions so that we may count them\n        System.setProperty(StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                           \"true\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                           \"11\");\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait until a response arrives\n        synchronized (responseCollector)\n        {\n            responseCollector.wait(5000);\n        }\n\n        //verify\n        Vector<StunMessageEvent> reqs\n            = requestCollector.getRequestsForTransaction(\n                                bindingRequest.getTransactionID());\n        assertEquals(12, reqs.size(),\n            \"Not all retransmissions were made for the expected period of time\");\n\n        //wait for a send\n        requestCollector.waitForRequest(1800);\n\n        //verify\n        reqs = requestCollector.getRequestsForTransaction(\n                                bindingRequest.getTransactionID());\n        assertEquals(12, reqs.size(),\n            \"A retransmissions of the request was sent, while not supposed to\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/TransactionSupportTests.java", "class_name": "TransactionSupportTests", "class_uri": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests whether the properties for configuring the maximum transaction\nwait interval is working properly.\n\n@throws Exception if the gods so decide.\n"}, {"uris": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest.[void]testClientTransactionTimeouts()", "name": "testClientTransactionTimeouts", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testClientTransactionTimeouts()", "original_string": "    @Test\n    public void testClientTransactionTimeouts() throws Exception\n    {\n        String oldRetransValue = System.getProperty(\n                        StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"1\");\n        stunStack.sendRequest(bindingRequest, serverAddress, clientAddress,\n                        responseCollector);\n        responseCollector.waitForTimeout();\n\n        assertEquals(1, responseCollector.receivedResponses.size(),\n            \"No timeout was produced upon expiration of a client transaction\");\n\n        assertEquals(\"timeout\", responseCollector.receivedResponses.get(0), \n            \"No timeout was produced upon expiration of a client transaction\");\n\n        //restore the retransmissions prop in case others are counting on\n        //defaults.\n        if(oldRetransValue != null)\n            System.getProperty( StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                                oldRetransValue);\n        else\n            System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/MessageEventDispatchingTest.java", "class_name": "MessageEventDispatchingTest", "class_uri": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest timeout events.\n\n@throws Exception upon a stun failure\n"}, {"uris": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest.[void]testEventDispatchingUponIncomingRequests()", "name": "testEventDispatchingUponIncomingRequests", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEventDispatchingUponIncomingRequests()", "original_string": "    @Test\n    public void testEventDispatchingUponIncomingRequests() throws Exception\n    {\n        //prepare to listen\n        stunStack.addRequestListener(requestCollector);\n        //send\n        stunStack.sendRequest(bindingRequest, serverAddress, clientAddress,\n                                            responseCollector);\n        //wait for retransmissions\n        requestCollector.waitForRequest();\n\n        //verify\n        assertEquals(1, requestCollector.receivedRequests.size(),\n            \"No MessageEvents have been dispatched\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/MessageEventDispatchingTest.java", "class_name": "MessageEventDispatchingTest", "class_uri": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest reception of Message events.\n\n@throws java.lang.Exception upon any failure\n"}, {"uris": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest.[void]testSelectiveEventDispatchingUponIncomingRequests()", "name": "testSelectiveEventDispatchingUponIncomingRequests", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSelectiveEventDispatchingUponIncomingRequests()", "original_string": "    @Test\n    public void testSelectiveEventDispatchingUponIncomingRequests()\n        throws Exception\n    {\n        //prepare to listen\n        stunStack.addRequestListener(serverAddress, requestCollector);\n\n        PlainRequestCollector requestCollector2 = new PlainRequestCollector();\n        stunStack.addRequestListener(serverAddress2, requestCollector2);\n\n        //send\n        stunStack.sendRequest(bindingRequest, serverAddress2, clientAddress,\n                                            responseCollector);\n        //wait for retransmissions\n        requestCollector.waitForRequest();\n        requestCollector2.waitForRequest();\n\n        //verify\n        assertEquals(0, requestCollector.receivedRequests.size(),\n            \"A MessageEvent was received by a non-interested selective listener\");\n        assertEquals(1, requestCollector2.receivedRequests.size(),\n            \"No MessageEvents have been dispatched for a selective listener\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/MessageEventDispatchingTest.java", "class_name": "MessageEventDispatchingTest", "class_uri": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest that reception of Message events is only received for accesspoints\nthat we have been registered for.\n\n@throws java.lang.Exception upon any failure\n"}, {"uris": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest.[void]testServerResponseRetransmissions()", "name": "testServerResponseRetransmissions", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testServerResponseRetransmissions()", "original_string": "    @Test\n    public void testServerResponseRetransmissions() throws Exception\n    {\n        //prepare to listen\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(bindingRequest, serverAddress, clientAddress,\n                                            responseCollector);\n\n        //wait for the message to arrive\n        requestCollector.waitForRequest();\n\n        StunMessageEvent evt = requestCollector.receivedRequests.get(0);\n        byte[] tid = evt.getMessage().getTransactionID();\n        stunStack.sendResponse(tid, bindingResponse, serverAddress,\n                                             clientAddress);\n\n        //wait for retransmissions\n        responseCollector.waitForResponse();\n\n        //verify that we got the response.\n        assertEquals(1, responseCollector.receivedResponses.size(),\n            \"There were no retransmissions of a binding response\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/MessageEventDispatchingTest.java", "class_name": "MessageEventDispatchingTest", "class_uri": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMakes sure that we receive response events.\n@throws Exception if we screw up.\n"}, {"uris": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]testAddAndGetAttribute()", "name": "testAddAndGetAttribute", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testAddAndGetAttribute()", "original_string": "    @Test\n    public void testAddAndGetAttribute()\n    {\n        Response   message = new Response();\n        message.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n        message.putAttribute(mappedAddress);\n\n        Attribute getResult;\n\n        getResult = message.getAttribute(mappedAddress.getAttributeType());\n        assertEquals(mappedAddress, getResult,\n            \"Originally added attribute did not match the returned\");\n\n        //do it again\n        message.putAttribute(sourceAddress);\n\n        getResult = message.getAttribute(sourceAddress.getAttributeType());\n\n        assertEquals(sourceAddress, getResult,\n            \"The second attribute could not be extracted.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageTest.java", "class_name": "MessageTest", "class_uri": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds and gets an attribute and test that they are the same then adds a\nanother attribute (same typ different value) and verifies that the first\none is properly replaced.\n\n"}, {"uris": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n        throws StunException\n    {\n        //Binding Request\n        byte[] expectedReturn = msgFixture.bindingRequest;\n\n        byte[] actualReturn = bindingRequest.encode(stunStack);\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"A binding request was not properly encoded\");\n\n        //Binding Response\n        expectedReturn = msgFixture.bindingResponse;\n\n        actualReturn = bindingResponse.encode(stunStack);\n\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"A binding response was not properly encoded\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageTest.java", "class_name": "MessageTest", "class_uri": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDecodes a bindingRequest and then a binding response and checks whether\nthey match the corresponding objects.\n\n@throws StunException java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]testDecode()", "name": "testDecode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecode()", "original_string": "    @Test\n    public void testDecode()\n        throws Exception\n    {\n        //Binding Request\n        Message expectedReturn = bindingRequest;\n\n        Message actualReturn = Message.decode(msgFixture.bindingRequest,\n                                     0,\n                                     msgFixture.bindingRequest.length);\n\n        assertEquals(expectedReturn, actualReturn,\n            \"A binding request was not properly decoded\");\n\n        //Binding Response\n        expectedReturn = bindingResponse;\n\n        actualReturn = Message.decode(msgFixture.bindingResponse,\n                                     0,\n                                     msgFixture.bindingResponse.length);\n\n        assertEquals(expectedReturn, actualReturn,\n            \"A binding response was not properly decoded\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageTest.java", "class_name": "MessageTest", "class_uri": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nEncodes a bindingRequest and then a binding response and checks whether\nthey match the corresponding binary arrays.\n\n@throws Exception java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEquals()", "original_string": "    @Test\n    public void testEquals()\n        throws StunException\n    {\n        assertNotEquals(bindingRequest, null,\n            \"Equals failed against a null target\");\n\n        assertNotEquals(bindingResponse, null,\n            \"Equals failed against a null target\");\n\n        //different\n        assertNotEquals(bindingRequest, bindingResponse,\n            \"Equals failed against a different target\");\n\n        assertNotEquals(bindingResponse, bindingRequest,\n            \"Equals failed against a different target\");\n\n        //Create a binding request with the same attributes as\n        //this.bindingRequest\n        Request binReqTarget = new Request();\n        binReqTarget.setMessageType(Message.BINDING_REQUEST);\n        binReqTarget.putAttribute(changeRequest);\n        assertEquals(bindingRequest, binReqTarget,\n            \"Equals failed against an equal target\");\n\n        //Create a binding response with the same attributes as\n        //this.bindingRequest\n        Response binResTarget = new Response();\n        binResTarget.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n        binResTarget.putAttribute(mappedAddress);\n        binResTarget.putAttribute(sourceAddress);\n        binResTarget.putAttribute(changedAddress);\n        assertEquals(bindingResponse, binResTarget,\n            \"Equals failed against a different target\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageTest.java", "class_name": "MessageTest", "class_uri": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests the equals method against a null, a different and an identical\nobject.\n\n@throws StunException java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]testGetAttributeCount()", "name": "testGetAttributeCount", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetAttributeCount()", "original_string": "    @Test\n    public void testGetAttributeCount()\n    {\n        int expectedReturn = 1;\n        int actualReturn = bindingRequest.getAttributeCount();\n        assertEquals(expectedReturn, actualReturn,\n            \"getAttributeCount failed for a bindingRequest\");\n        expectedReturn = 3;\n        actualReturn = bindingResponse.getAttributeCount();\n        assertEquals(expectedReturn, actualReturn,\n            \"getAttributeCount failed for a bindingRequest\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageTest.java", "class_name": "MessageTest", "class_uri": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests  whether attributes are properly counted\n"}, {"uris": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]testRemoveAttribute()", "name": "testRemoveAttribute", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRemoveAttribute()", "original_string": "    @Test\n    public void testRemoveAttribute()\n    {\n\n        bindingRequest.removeAttribute(changeRequest.getAttributeType());\n\n        assertNull(bindingRequest.getAttribute(changeRequest.getAttributeType()),\n            \"An attribute was still in the request after being removed\");\n\n        //test count\n        int expectedReturn = 0;\n        int actualReturn = bindingRequest.getAttributeCount();\n        assertEquals(expectedReturn, actualReturn,\n            \"Attribute count did not change after removing an attribute\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageTest.java", "class_name": "MessageTest", "class_uri": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether attributes are properly removed.\n"}, {"uris": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest.[void]testCreateBindingErrorResponse()", "name": "testCreateBindingErrorResponse", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testCreateBindingErrorResponse()", "original_string": "    @Test\n    public void testCreateBindingErrorResponse() throws StunException\n    {\n        char errorCode = 400;\n\n        Response expectedReturn = new Response();\n        expectedReturn.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        Attribute errorCodeAtt\n            = AttributeFactory.createErrorCodeAttribute(errorCode);\n        expectedReturn.putAttribute(errorCodeAtt);\n\n        Message actualReturn\n            = MessageFactory.createBindingErrorResponse(errorCode);\n        assertEquals(expectedReturn, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageFactoryTest.java", "class_name": "MessageFactoryTest", "class_uri": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest.[void]testCreateBindingErrorResponse1()", "name": "testCreateBindingErrorResponse1", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testCreateBindingErrorResponse1()", "original_string": "    @Test\n    public void testCreateBindingErrorResponse1()\n    {\n        char errorCode = 400;\n        String reasonPhrase = \"Bad Request\";\n\n        Response expectedReturn = new Response();\n        expectedReturn.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        Attribute errorCodeAtt = AttributeFactory\n            .createErrorCodeAttribute(errorCode, reasonPhrase);\n        expectedReturn.putAttribute(errorCodeAtt);\n\n        Message actualReturn = MessageFactory\n            .createBindingErrorResponse(errorCode, reasonPhrase);\n        assertEquals(expectedReturn, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageFactoryTest.java", "class_name": "MessageFactoryTest", "class_uri": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest.[void]testCreateBindingErrorResponseUnknownAttributes()", "name": "testCreateBindingErrorResponseUnknownAttributes", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testCreateBindingErrorResponseUnknownAttributes()", "original_string": "    @Test\n    public void testCreateBindingErrorResponseUnknownAttributes()\n            throws StunException\n    {\n        char errorCode = 420;\n        char[] unknownAttributes = new char[]{21, 22, 23};\n\n        //create a message manually\n        Response expectedReturn = new Response();\n        expectedReturn.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        ErrorCodeAttribute errorCodeAtt = AttributeFactory\n            .createErrorCodeAttribute(errorCode);\n        errorCodeAtt.setReasonPhrase(\n                        ErrorCodeAttribute.getDefaultReasonPhrase(errorCode));\n        expectedReturn.putAttribute(errorCodeAtt);\n\n        UnknownAttributesAttribute unknownAtts =\n                        AttributeFactory.createUnknownAttributesAttribute();\n\n        for (char unknownAttribute : unknownAttributes)\n        {\n            unknownAtts.addAttributeID(unknownAttribute);\n        }\n        expectedReturn.putAttribute(unknownAtts);\n\n        //create the same message using the factory\n        Message actualReturn = MessageFactory\n            .createBindingErrorResponseUnknownAttributes(unknownAttributes);\n        //compare\n        assertEquals(expectedReturn, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageFactoryTest.java", "class_name": "MessageFactoryTest", "class_uri": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest.[void]testCreateBindingErrorResponseUnknownAttributes1()", "name": "testCreateBindingErrorResponseUnknownAttributes1", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testCreateBindingErrorResponseUnknownAttributes1()", "original_string": "    @Test\n    public void testCreateBindingErrorResponseUnknownAttributes1()\n            throws StunException\n    {\n        char errorCode = 420;\n        String reasonPhrase = \"UnknwonAttributes\";\n        char[] unknownAttributes = new char[]{21, 22, 23};\n\n        Response expectedReturn = new Response();\n        expectedReturn.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        Attribute errorCodeAtt = AttributeFactory.createErrorCodeAttribute(\n            errorCode, reasonPhrase);\n        expectedReturn.putAttribute(errorCodeAtt);\n\n        UnknownAttributesAttribute unknownAtts =\n            AttributeFactory.createUnknownAttributesAttribute();\n\n        for (char unknownAttribute : unknownAttributes)\n        {\n            unknownAtts.addAttributeID(unknownAttribute);\n        }\n        expectedReturn.putAttribute(unknownAtts);\n\n        Message actualReturn = MessageFactory\n            .createBindingErrorResponseUnknownAttributes(\n                                           reasonPhrase, unknownAttributes);\n        assertEquals(expectedReturn, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageFactoryTest.java", "class_name": "MessageFactoryTest", "class_uri": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest.[void]testCreateBindingRequest()", "name": "testCreateBindingRequest", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testCreateBindingRequest()", "original_string": "    @Test\n    public void testCreateBindingRequest()\n    {\n        Request bindingRequest = new Request();\n        bindingRequest.setMessageType(Message.BINDING_REQUEST);\n/*\n        Attribute changeRequest = AttributeFactory.createChangeRequestAttribute(\n                    msgFixture.CHANGE_IP_FLAG_1, msgFixture.CHANGE_PORT_FLAG_1);\n        bindingRequest.putAttribute(changeRequest);\n*/\n        Request actualReturn = MessageFactory.createBindingRequest();\n        assertEquals(bindingRequest, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageFactoryTest.java", "class_name": "MessageFactoryTest", "class_uri": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest.[void]testCreateBindingResponse()", "name": "testCreateBindingResponse", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testCreateBindingResponse()", "original_string": "    @Test\n    public void testCreateBindingResponse()\n        throws Exception\n    {\n        Response bindingResponse = new Response();\n        bindingResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n\n        Attribute mappedAddress = AttributeFactory.createMappedAddressAttribute(\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                                  MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                                  Transport.UDP));\n\n        bindingResponse.putAttribute(mappedAddress);\n\n        Attribute sourceAddress = AttributeFactory.createSourceAddressAttribute(\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_2,\n                                  MsgFixture.ADDRESS_ATTRIBUTE_PORT_2,\n                                  Transport.UDP));\n\n        bindingResponse.putAttribute(sourceAddress);\n\n        Attribute changedAddress = AttributeFactory.\n            createChangedAddressAttribute(\n                new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_3,\n                                      MsgFixture.ADDRESS_ATTRIBUTE_PORT_3,\n                                      Transport.UDP));\n\n        bindingResponse.putAttribute(changedAddress);\n\n        Message actualReturn = MessageFactory.create3489BindingResponse(\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                                  MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                                  Transport.UDP),\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_2,\n                                  MsgFixture.ADDRESS_ATTRIBUTE_PORT_2,\n                                  Transport.UDP),\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_3,\n                                  MsgFixture.ADDRESS_ATTRIBUTE_PORT_3,\n                                  Transport.UDP));\n        assertEquals(bindingResponse, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageFactoryTest.java", "class_name": "MessageFactoryTest", "class_uri": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6.[void]testRecognizeBlockedUDP()", "name": "testRecognizeBlockedUDP", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeBlockedUDP()", "original_string": "    @Test\n    public void testRecognizeBlockedUDP()\n        throws Exception\n    {\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.UDP_BLOCKING_FIREWALL);\n        expectedReturn.setPublicAddress(null);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java", "class_name": "StunAddressDiscovererTest_v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it's in a network where UDP is blocked.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6.[void]testRecognizeSymmetricNat()", "name": "testRecognizeSymmetricNat", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeSymmetricNat()", "original_string": "    @Test\n    public void testRecognizeSymmetricNat()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n             mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n             mappedClientAddressPort2,\n             responseServerAddress,\n             responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java", "class_name": "StunAddressDiscovererTest_v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Symmetric NAT.\n\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6.[void]testRecognizePortRestrictedCone()", "name": "testRecognizePortRestrictedCone", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizePortRestrictedCone()", "original_string": "    @Test\n    public void testRecognizePortRestrictedCone()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse4 = null;\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n        responseServer.addMessage(testIResponse4);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.PORT_RESTRICTED_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java", "class_name": "StunAddressDiscovererTest_v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Port Restricted Cone.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6.[void]testRecognizeRestrictedCone()", "name": "testRecognizeRestrictedCone", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeRestrictedCone()", "original_string": "    @Test\n    public void testRecognizeRestrictedCone()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse4 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n        responseServer.addMessage(testIResponse4);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.RESTRICTED_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java", "class_name": "StunAddressDiscovererTest_v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Restricted Cone.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6.[void]testRecognizeFullCone()", "name": "testRecognizeFullCone", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeFullCone()", "original_string": "    @Test\n    public void testRecognizeFullCone() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.FULL_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer\n            .determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java", "class_name": "StunAddressDiscovererTest_v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Full Cone.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6.[void]testRecognizeUdpSymmetricFirewall()", "name": "testRecognizeUdpSymmetricFirewall", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeUdpSymmetricFirewall()", "original_string": "    @Test\n    public void testRecognizeUdpSymmetricFirewall()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_UDP_FIREWALL);\n        expectedReturn.setPublicAddress(discovererAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer\n            .determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java", "class_name": "StunAddressDiscovererTest_v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a UDP Symmetric Firewall.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6.[void]testRecognizeOpenInternet()", "name": "testRecognizeOpenInternet", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeOpenInternet()", "original_string": "    @Test\n    public void testRecognizeOpenInternet()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.OPEN_INTERNET);\n        expectedReturn.setPublicAddress(discovererAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java", "class_name": "StunAddressDiscovererTest_v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Open Internet.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6.[void]testRecognizeSymmetricNat_Local_v6_Public_v4()", "name": "testRecognizeSymmetricNat_Local_v6_Public_v4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeSymmetricNat_Local_v6_Public_v4()", "original_string": "    @Test\n    public void testRecognizeSymmetricNat_Local_v6_Public_v4()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v4,\n            responseServerAddress_v6,\n            responseServerAddress_v6);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v4_Port2,\n            responseServerAddress_v6,\n            responseServerAddress_v6);\n\n        responseServer_v6.addMessage(testIResponse1);\n        responseServer_v6.addMessage(testIResponse2);\n        responseServer_v6.addMessage(testIResponse3);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress_v4);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer_v6.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a v4-v6 sym env.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java", "class_name": "StunAddressDiscovererTest_v4v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Symmetric NAT.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6.[void]testRecognizeSymmetricNat_Local_v4_Public_v6()", "name": "testRecognizeSymmetricNat_Local_v4_Public_v6", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeSymmetricNat_Local_v4_Public_v6()", "original_string": "    @Test\n    public void testRecognizeSymmetricNat_Local_v4_Public_v6() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v6,\n            responseServerAddress_v4,\n            responseServerAddress_v4);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v6_Port2,\n            responseServerAddress_v4,\n            responseServerAddress_v4);\n\n        responseServer_v4.addMessage(testIResponse1);\n        responseServer_v4.addMessage(testIResponse2);\n        responseServer_v4.addMessage(testIResponse3);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress_v6);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer_v4.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java", "class_name": "StunAddressDiscovererTest_v4v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Symmetric NAT.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6.[void]testRecognizeFullCone_Local_v6_Public_v4()", "name": "testRecognizeFullCone_Local_v6_Public_v4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeFullCone_Local_v6_Public_v4()", "original_string": "    @Test\n    public void testRecognizeFullCone_Local_v6_Public_v4() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v4,\n            responseServerAddress_v6,\n            responseServerAddress_v6);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v4,\n            responseServerAddress_v6,\n            responseServerAddress_v6);\n\n        responseServer_v6.addMessage(testIResponse1);\n        responseServer_v6.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.FULL_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress_v4);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer_v6.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java", "class_name": "StunAddressDiscovererTest_v4v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Full Cone.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6.[void]testRecognizeFullCone_Local_v4_Public_v6()", "name": "testRecognizeFullCone_Local_v4_Public_v6", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeFullCone_Local_v4_Public_v6()", "original_string": "    @Test\n    public void testRecognizeFullCone_Local_v4_Public_v6() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v6,\n            responseServerAddress_v4,\n            responseServerAddress_v4);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v6,\n            responseServerAddress_v4,\n            responseServerAddress_v4);\n\n        responseServer_v4.addMessage(testIResponse1);\n        responseServer_v4.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.FULL_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress_v6);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer_v4.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java", "class_name": "StunAddressDiscovererTest_v4v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Full Cone.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest.[void]testRecognizeBlockedUDP()", "name": "testRecognizeBlockedUDP", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeBlockedUDP()", "original_string": "    @Test\n    public void testRecognizeBlockedUDP()\n        throws Exception\n    {\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.UDP_BLOCKING_FIREWALL);\n        expectedReturn.setPublicAddress(null);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer\n            .determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java", "class_name": "StunAddressDiscovererTest", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responses are given the stun client so that\nit concludes it's in a network where UDP is blocked.\n\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest.[void]testRecognizeSymmetricNat()", "name": "testRecognizeSymmetricNat", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeSymmetricNat()", "original_string": "    @Test\n    public void testRecognizeSymmetricNat() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddressPort2,\n            responseServerAddress,\n            responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java", "class_name": "StunAddressDiscovererTest", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Symmetric NAT.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest.[void]testRecognizePortRestrictedCone()", "name": "testRecognizePortRestrictedCone", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizePortRestrictedCone()", "original_string": "    @Test\n    public void testRecognizePortRestrictedCone()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse4 = null;\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n        responseServer.addMessage(testIResponse4);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.PORT_RESTRICTED_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java", "class_name": "StunAddressDiscovererTest", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Port Restricted Cone.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest.[void]testRecognizeRestrictedCone()", "name": "testRecognizeRestrictedCone", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeRestrictedCone()", "original_string": "    @Test\n    public void testRecognizeRestrictedCone() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse4 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n        responseServer.addMessage(testIResponse4);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.RESTRICTED_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer\n            .determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java", "class_name": "StunAddressDiscovererTest", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Restricted Cone.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest.[void]testRecognizeFullCone()", "name": "testRecognizeFullCone", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeFullCone()", "original_string": "    @Test\n    public void testRecognizeFullCone()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.FULL_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java", "class_name": "StunAddressDiscovererTest", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Full Cone.\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest.[void]testRecognizeUdpSymmetricFirewall()", "name": "testRecognizeUdpSymmetricFirewall", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeUdpSymmetricFirewall()", "original_string": "    @Test\n    public void testRecognizeUdpSymmetricFirewall()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_UDP_FIREWALL);\n        expectedReturn.setPublicAddress(discovererAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java", "class_name": "StunAddressDiscovererTest", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a UDP Symmetric Firewall.\n\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest.[void]testRecognizeOpenInternet()", "name": "testRecognizeOpenInternet", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecognizeOpenInternet()", "original_string": "    @Test\n    public void testRecognizeOpenInternet()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.OPEN_INTERNET);\n        expectedReturn.setPublicAddress(discovererAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java", "class_name": "StunAddressDiscovererTest", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a test where no responces are given the stun client so that\nit concludes it is behind a Open Internet.\n\n@throws Exception if anything goes wrong ( surprised? ).\n"}, {"uris": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]testSendRequest()", "name": "testSendRequest", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendRequest()", "original_string": "    @Test\n    public void testSendRequest()\n        throws Exception\n    {\n        Request bindingRequest = MessageFactory.createBindingRequest();\n\n        dgramCollector.startListening(dummyServerSocket);\n\n        stunStack.sendRequest(bindingRequest,\n                              dummyServerAddress,\n                              localAddress,\n                              new SimpleResponseCollector());\n\n        //wait for its arrival\n        dgramCollector.waitForPacket(1000);\n\n        DatagramPacket receivedPacket = dgramCollector.collectPacket();\n\n        assertTrue((receivedPacket.getLength() > 0),\n            \"The stack did not properly send a Binding Request\");\n\n        Request receivedRequest =\n                        (Request)Request.decode(receivedPacket.getData(),\n                                            (char)0,\n                                            (char)receivedPacket.getLength());\n        assertEquals(bindingRequest, receivedRequest,\n            \"The received request did not match the one that was sent.\");\n\n        //wait for retransmissions\n\n        dgramCollector.startListening(dummyServerSocket);\n\n        dgramCollector.waitForPacket(1000);\n\n        receivedPacket = dgramCollector.collectPacket();\n\n        assertTrue((receivedPacket.getLength() > 0),\n            \"The stack did not retransmit a Binding Request\");\n\n        receivedRequest = (Request)Request.decode(\n            receivedPacket.getData(),\n            0,\n            receivedPacket.getLength());\n        assertEquals(bindingRequest, receivedRequest,\n            \"The retransmitted request did not match the original.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/ShallowStackTest.java", "class_name": "ShallowStackTest", "class_uri": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a binding request using the stack to a bare socket, and verifies\nthat it is received and that the contents of the datagram corresponds to\nthe request that was sent.\n\n@throws java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]testReceiveRequest()", "name": "testReceiveRequest", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testReceiveRequest()", "original_string": "    @Test\n    public void testReceiveRequest()\n        throws Exception\n    {\n        SimpleRequestCollector requestCollector = new SimpleRequestCollector();\n        stunStack.addRequestListener(requestCollector);\n\n        dummyServerSocket.send(new DatagramPacket(\n            msgFixture.bindingRequest2,\n            msgFixture.bindingRequest2.length,\n            localAddress));\n\n        //wait for the packet to arrive\n        requestCollector.waitForRequest();\n\n        Request collectedRequest = requestCollector.collectedRequest;\n\n        assertNotNull(collectedRequest, \"No request has been received\");\n\n        byte[] expectedReturn = msgFixture.bindingRequest2;\n        byte[] actualReturn = collectedRequest.encode(stunStack);\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"Received request was not the same as the one that was sent\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/ShallowStackTest.java", "class_name": "ShallowStackTest", "class_uri": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a byte array containing a bindingRequest, through a datagram socket\nand verifies that the stack receives it alright.\n\n@throws java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]testSendResponse()", "name": "testSendResponse", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendResponse()", "original_string": "    @Test\n    public void testSendResponse()\n        throws Exception\n    {\n        //---------- send & receive the request --------------------------------\n        SimpleRequestCollector requestCollector = new SimpleRequestCollector();\n        stunStack.addRequestListener(requestCollector);\n\n        dummyServerSocket.send(new DatagramPacket(\n                                            msgFixture.bindingRequest,\n                                            msgFixture.bindingRequest.length,\n                                            localAddress));\n\n        //wait for the packet to arrive\n        requestCollector.waitForRequest();\n\n        Request collectedRequest = requestCollector.collectedRequest;\n\n        byte[] expectedReturn = msgFixture.bindingRequest;\n        byte[] actualReturn = collectedRequest.encode(stunStack);\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"Received request was not the same as the one that was sent\");\n\n        //---------- create the response ---------------------------------------\n        Response bindingResponse = MessageFactory.create3489BindingResponse(\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                 MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP ),\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_2,\n                 MsgFixture.ADDRESS_ATTRIBUTE_PORT_2, Transport.UDP),\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_3,\n                 MsgFixture.ADDRESS_ATTRIBUTE_PORT_3, Transport.UDP));\n\n        //---------- send & receive the response -------------------------------\n        dgramCollector.startListening(dummyServerSocket);\n\n        stunStack.sendResponse(collectedRequest.getTransactionID(),\n                               bindingResponse,\n                               localAddress,\n                               dummyServerAddress);\n\n        //wait for its arrival\n        dgramCollector.waitForPacket();\n\n        DatagramPacket receivedPacket = dgramCollector.collectPacket();\n\n        assertTrue((receivedPacket.getLength() > 0),\n            \"The stack did not properly send a Binding Request\");\n\n        Response receivedResponse =\n            (Response) Response.decode(receivedPacket.getData(),\n                                       0,\n                                       receivedPacket.getLength());\n        assertEquals(bindingResponse, receivedResponse,\n            \"The received request did not match the one that was sent.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/ShallowStackTest.java", "class_name": "ShallowStackTest", "class_uri": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a byte array containing a bindingRequest, through a datagram socket,\nverifies that the stack receives it properly and then sends a response\nusing the stack. Finally, the response is expected at the other end and\ncompared with the sent one.\n\n@throws java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]testReceiveResponse()", "name": "testReceiveResponse", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testReceiveResponse()", "original_string": "    @Test\n    public void testReceiveResponse()\n        throws Exception\n    {\n        SimpleResponseCollector collector = new SimpleResponseCollector();\n        //--------------- send the original request ----------------------------\n        Request bindingRequest = MessageFactory.createBindingRequest();\n\n        stunStack.sendRequest(bindingRequest,\n                              dummyServerAddress,\n                              localAddress,\n                              collector);\n\n        //wait for its arrival\n        collector.waitForResponse();\n\n        //create the right response\n        byte[] response = new byte[msgFixture.bindingResponse.length];\n        System.arraycopy(msgFixture.bindingResponse, 0, response, 0,\n                         response.length);\n\n        //Set the valid tid.\n        System.arraycopy(bindingRequest.getTransactionID(),\n                         0,\n                         response,\n                         8,\n                         12);\n\n        //send the response\n\n        dummyServerSocket.send(new DatagramPacket(response,\n                                                response.length,\n                                                localAddress));\n\n        //wait for the packet to arrive\n        collector.waitForResponse();\n\n        Response collectedResponse = collector.collectedResponse;\n\n        byte[] actualReturn = collectedResponse.encode(stunStack);\n        assertArrayEquals(response, actualReturn,\n            \"Received request was not the same as the one that was sent\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/ShallowStackTest.java", "class_name": "ShallowStackTest", "class_uri": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms a basic test on message reception\n\n@throws Exception if something fails somewhere.\n"}, {"uris": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]testRetransmissionOriginalWait()", "name": "testRetransmissionOriginalWait", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRetransmissionOriginalWait()", "original_string": "    @Test\n    public void testRetransmissionOriginalWait()\n        throws Exception\n    {\n        long originalWait = 200; // milliseconds\n        System.setProperty(StackProperties.FIRST_CTRAN_RETRANS_AFTER, String.valueOf(originalWait));\n\n        Request bindingRequest = MessageFactory.createBindingRequest();\n\n        dgramCollector.startListening(dummyServerSocket);\n\n        long firstTime = System.nanoTime();\n\n        stunStack.sendRequest(bindingRequest,\n                dummyServerAddress,\n                localAddress,\n                new SimpleResponseCollector());\n\n        //wait for its arrival\n        dgramCollector.waitForPacket(1000);\n        DatagramPacket receivedPacket = dgramCollector.collectPacket();\n\n        assertTrue((receivedPacket.getLength() > 0),\n            \"The stack did not properly send a Binding Request\");\n\n        Request receivedRequest =\n                (Request)Request.decode(receivedPacket.getData(),\n                        (char)0,\n                        (char)receivedPacket.getLength());\n        assertEquals(bindingRequest, receivedRequest,\n            \"The received request did not match the one that was sent.\");\n\n        // wait for the 1st retransmission with originalWait\n        dgramCollector.startListening(dummyServerSocket);\n        dgramCollector.waitForPacket(1000);\n        receivedPacket = dgramCollector.collectPacket();\n\n        assertTrue((receivedPacket.getLength() > 0),\n            \"The stack did not retransmit a Binding Request\");\n\n        receivedRequest = (Request) Request.decode(\n            receivedPacket.getData(),\n            0,\n            receivedPacket.getLength());\n        assertEquals(bindingRequest, receivedRequest,\n            \"The retransmitted request did not match the original.\");\n\n        // verify the retransmission is longer than the originalWait\n        assertTrue(System.nanoTime() - firstTime >= TimeUnit.MILLISECONDS.toNanos(originalWait));\n\n        System.clearProperty(StackProperties.FIRST_CTRAN_RETRANS_AFTER);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/ShallowStackTest.java", "class_name": "ShallowStackTest", "class_uri": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nVerify StackProperties.FIRST_CTRAN_RETRANS_AFTER can indeed update StunClientTransaction.Retransmitter\n"}, {"uris": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest.[void]testDecodeAttributeBody()", "name": "testDecodeAttributeBody", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBody()", "original_string": "    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        char offset = 0;\n        SoftwareAttribute decoded = new SoftwareAttribute();\n        char length = (char)softwareValue.length();\n        decoded.decodeAttributeBody(softwareValue.getBytes(), offset, length);\n\n        //software value\n        assertEquals(softwareAttribute, decoded);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java", "class_name": "SoftwareAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests decoding of the software attribute.\n@throws StunException upon a failure\n"}, {"uris": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n    {\n        assertArrayEquals(softwareAttribute.encode(), attributeBinValue);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java", "class_name": "SoftwareAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests the encode method\n"}, {"uris": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEquals()", "original_string": "    @Test\n    public void testEquals()\n    {\n        SoftwareAttribute softwareAttribute2 = new SoftwareAttribute();\n        softwareAttribute2.setSoftware(softwareValue.getBytes());\n\n        //test positive equals\n        assertEquals(softwareAttribute, softwareAttribute2);\n\n        //test negative equals\n        softwareAttribute2 = new SoftwareAttribute();\n        softwareAttribute2.setSoftware(\"some other software\".getBytes());\n\n        //test positive equals\n        assertNotEquals(softwareAttribute2, softwareAttribute);\n\n        //test null equals\n        assertNotEquals(softwareAttribute, null);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java", "class_name": "SoftwareAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest Equals\n"}, {"uris": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = (char)softwareValue.length();\n        char actualReturn = softwareAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java", "class_name": "SoftwareAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests extracting data length\n"}, {"uris": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest.[void]testGetName()", "name": "testGetName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetName()", "original_string": "    @Test\n    public void testGetName()\n    {\n        assertEquals(\"SOFTWARE\", softwareAttribute.getName());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java", "class_name": "SoftwareAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests getting the name\n"}, {"uris": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest.[void]testSetGetSoftware()", "name": "testSetGetSoftware", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSetGetSoftware()", "original_string": "    @Test\n    public void testSetGetSoftware()\n    {\n        byte[] expectedReturn = softwareValue.getBytes();\n\n        SoftwareAttribute att = new SoftwareAttribute();\n        att.setSoftware(expectedReturn);\n\n        byte[] actualReturn = att.getSoftware();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"software setter or getter failed\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java", "class_name": "SoftwareAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest.[void]testDecodeAttributeBody()", "name": "testDecodeAttributeBody", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBody()", "original_string": "    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        char offset = 0;\n        RealmAttribute decoded = new RealmAttribute();\n        char length = (char)realmValue.length();\n        decoded.decodeAttributeBody(realmValue.getBytes(), offset, length);\n\n        //realm value\n        assertEquals(realmAttribute, decoded);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java", "class_name": "RealmAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests decoding of the realm attribute.\n@throws StunException upon a failure\n"}, {"uris": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n    {\n        assertArrayEquals(realmAttribute.encode(), attributeBinValue);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java", "class_name": "RealmAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests the encode method\n"}, {"uris": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEquals()", "original_string": "    @Test\n    public void testEquals()\n    {\n        RealmAttribute realmAttribute2 = new RealmAttribute();\n        realmAttribute2.setRealm(realmValue.getBytes());\n\n        //test positive equals\n        assertEquals(realmAttribute, realmAttribute2);\n\n        //test negative equals\n        realmAttribute2 = new RealmAttribute();\n        realmAttribute2.setRealm(\"some other realm\".getBytes());\n\n        //test positive equals\n        assertNotEquals(realmAttribute2, realmAttribute);\n\n        //test null equals\n        assertNotEquals(realmAttribute, null);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java", "class_name": "RealmAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest Equals\n"}, {"uris": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = (char)realmValue.length();\n        char actualReturn = realmAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java", "class_name": "RealmAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests extracting data length\n"}, {"uris": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest.[void]testGetName()", "name": "testGetName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetName()", "original_string": "    @Test\n    public void testGetName()\n    {\n        assertEquals(\"REALM\", realmAttribute.getName());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java", "class_name": "RealmAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests getting the name\n"}, {"uris": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest.[void]testSetGetRealm()", "name": "testSetGetRealm", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSetGetRealm()", "original_string": "    @Test\n    public void testSetGetRealm()\n    {\n        byte[] expectedReturn = realmValue.getBytes();\n\n        RealmAttribute att = new RealmAttribute();\n        att.setRealm(expectedReturn);\n\n        byte[] actualReturn = att.getRealm();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"realm setter or getter failed\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java", "class_name": "RealmAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]testUnknownAttributesAttribute()", "name": "testUnknownAttributesAttribute", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testUnknownAttributesAttribute()", "original_string": "    @Test\n    public void testUnknownAttributesAttribute()\n    {\n        unknownAttributesAttribute = new UnknownAttributesAttribute();\n        assertEquals(\n            Attribute.UNKNOWN_ATTRIBUTES,\n            (int) unknownAttributesAttribute.getAttributeType(),\n            \"UnknownAttributesAttribute() did not properly set the Attribute's type field!\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nVerify the the constructed object has the correct (UNKNOWN-ATTRIBUTES)\ntype.\n"}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]testAddAttributeID()", "name": "testAddAttributeID", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testAddAttributeID()", "original_string": "    @Test\n    public void testAddAttributeID()\n    {\n        char attributeID = 0x22; // unknown attribute id\n\n        unknownAttributesAttribute.addAttributeID(attributeID);\n\n        assertEquals(\n            (int) attributeID,\n            (int) unknownAttributesAttribute.getAttribute(0),\n            \"addAttributeID does not seem to properly add the attribute ID\"\n        );\n\n        assertEquals(\n            1,\n            unknownAttributesAttribute.getAttributeCount(),\n            \"addAttributeID does not seem to properly add the attribute ID\"\n        );\n\n        //add a second one\n        unknownAttributesAttribute.addAttributeID(attributeID);\n\n        assertEquals(\n            1,\n            unknownAttributesAttribute.getAttributeCount(),\n            \"Adding a 2nd time the same attributeID should not change the number of attributes\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nVerify that the passed attribute id is added to the list of attributes\nand that a second addition of the same id would not augment the attribute\ncount.\n"}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]testDecodeAttributeBody()", "name": "testDecodeAttributeBody", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBody()", "original_string": "    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        //a copy of the array in the fixture:\n        byte[] attributeValue = binMessagesFixture.unknownAttsDecodeTestValue;\n\n        unknownAttributesAttribute.decodeAttributeBody(attributeValue,\n                                               Attribute.HEADER_LENGTH,\n                                               (char)(attributeValue.length\n                                               - Attribute.HEADER_LENGTH));\n        //is every one there?\n        assertTrue(\n            unknownAttributesAttribute.contains(\n                MsgFixture.UNKNOWN_ATTRIBUTES_1ST_ATT),\n            \"The \" + (int) MsgFixture.UNKNOWN_ATTRIBUTES_1ST_ATT\n                + \" attribute id \"\n                + \"was not found after decoding a binary array that contained it.\"\n        );\n\n        assertTrue(\n            unknownAttributesAttribute.contains(\n                MsgFixture.UNKNOWN_ATTRIBUTES_2ND_ATT),\n            \"The \" + (int) MsgFixture.UNKNOWN_ATTRIBUTES_2ND_ATT\n                + \" attribute id \"\n                + \"was not found after decoding a binary array that contained it.\"\n        );\n        assertTrue(\n            unknownAttributesAttribute.contains(\n                MsgFixture.UNKNOWN_ATTRIBUTES_3D_ATT),\n            \"The \" + (int) MsgFixture.UNKNOWN_ATTRIBUTES_3D_ATT\n                + \" attribute id \"\n                + \"was not found after decoding a binary array that contained it.\"\n            );\n\n        assertEquals(\n            MsgFixture.UNKNOWN_ATTRIBUTES_CNT_DEC_TST,\n            unknownAttributesAttribute.getAttributeCount(),\n            \"The decoded attribute contained \"\n                + unknownAttributesAttribute.getAttributeCount()\n                + \" attribute ids when there were only \"\n                + (int) MsgFixture.UNKNOWN_ATTRIBUTES_CNT_DEC_TST\n                + \" in the original binary array.\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests whether a sample binary array is properly decoded.\n@throws StunException if anything goes wrong.\n"}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n    {\n        byte[] expectedReturn = binMessagesFixture.unknownAttsEncodeExpectedResult;\n\n        unknownAttributesAttribute.addAttributeID(\n            MsgFixture.UNKNOWN_ATTRIBUTES_1ST_ATT);\n        unknownAttributesAttribute.addAttributeID(\n            MsgFixture.UNKNOWN_ATTRIBUTES_2ND_ATT);\n\n        byte[] actualReturn = unknownAttributesAttribute.encode();\n        assertArrayEquals(actualReturn, expectedReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates a new UnknownAttributesAttribute encodes it and assert equality\nwith binMessagesFixture.unknownAttsEncodeExpectedResult.\n"}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEquals()", "original_string": "    @Test\n    public void testEquals()\n    {\n        UnknownAttributesAttribute target = new UnknownAttributesAttribute();\n\n        assertNotEquals(unknownAttributesAttribute, null);\n\n        unknownAttributesAttribute.addAttributeID((char)25);\n        target.addAttributeID((char)25);\n\n        unknownAttributesAttribute.addAttributeID((char)26);\n        assertNotEquals(unknownAttributesAttribute, target);\n\n        target.addAttributeID((char)26);\n        assertEquals(unknownAttributesAttribute, target);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests the equals method against a null, a different and an identical\nobject.\n"}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]testGetAttribute()", "name": "testGetAttribute", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetAttribute()", "original_string": "    @Test\n    public void testGetAttribute()\n    {\n        char expectedId1 = 20;\n        char expectedId2 = 21;\n\n        char actualId1;\n        char actualId2;\n\n        unknownAttributesAttribute.addAttributeID(expectedId1);\n        unknownAttributesAttribute.addAttributeID(expectedId2);\n\n        actualId1 = unknownAttributesAttribute.getAttribute(0);\n        actualId2 = unknownAttributesAttribute.getAttribute(1);\n\n        assertEquals(expectedId1, actualId1, \"getAttribute() return value mismatch\");\n        assertEquals(expectedId2, actualId2, \"getAttribute() return value mismatch\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests that getAttribute() return the correct attribute id, preserving\nentry order.\n"}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]testGetAttributeCount()", "name": "testGetAttributeCount", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetAttributeCount()", "original_string": "    @Test\n    public void testGetAttributeCount()\n    {\n        int expectedReturn = 5;\n\n        unknownAttributesAttribute.addAttributeID((char)21);\n        unknownAttributesAttribute.addAttributeID((char)22);\n        unknownAttributesAttribute.addAttributeID((char)23);\n        unknownAttributesAttribute.addAttributeID((char)24);\n        unknownAttributesAttribute.addAttributeID((char)25);\n        unknownAttributesAttribute.addAttributeID((char)25);//duplicate values should be ignored\n\n        int actualReturn = unknownAttributesAttribute.getAttributeCount();\n        assertEquals(expectedReturn, actualReturn,\n            \"getAttributeCount did not return the expected value\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdd some attributes and test whether their number is properly calculated.\nTests duplicate id handling as well.\n"}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]testGetAttributes()", "name": "testGetAttributes", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetAttributes()", "original_string": "    @Test\n    public void testGetAttributes()\n    {\n        char expectedId1 = 20;\n        char expectedId2 = 21;\n\n        char actualId1;\n        char actualId2;\n\n        unknownAttributesAttribute.addAttributeID(expectedId1);\n        unknownAttributesAttribute.addAttributeID(expectedId2);\n\n        Iterator<Character> iterator = unknownAttributesAttribute.getAttributes();\n\n        actualId1 = iterator.next();\n        actualId2 = iterator.next();\n\n        assertEquals(expectedId1, actualId1, \"getAttributes() return value mismatch\");\n        assertEquals(expectedId2, actualId2, \"getAttributes() return value mismatch\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSame as testGetAttributeID, only attribute attributes are extracted\nthrough the getAttributes()'s iterator.\n"}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = 8;\n\n        unknownAttributesAttribute.addAttributeID((char)20);\n        unknownAttributesAttribute.addAttributeID((char)21);\n        unknownAttributesAttribute.addAttributeID((char)22);\n\n        char actualReturn = unknownAttributesAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"Incorrect testGetDataLength() return value\");\n\n        unknownAttributesAttribute.addAttributeID((char)23);\n\n        actualReturn = unknownAttributesAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"Incorrect testGetDataLength() return value\");\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds a fixed number of attributes and checks data length accordingly.\nTest is first performed for an odd number of attributes and then again\n(after adding another attribute id). Both results should be the same.\n"}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]testGetName()", "name": "testGetName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetName()", "original_string": "    @Test\n    public void testGetName()\n    {\n        assertEquals(\"UNKNOWN-ATTRIBUTES\", unknownAttributesAttribute.getName());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests whether getName returns a relevant name.\n"}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = 1;\n        this.requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4);\n        char actualReturn =\n            this.requestedAddressFamilyAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"Datalength is not properly calculated\");\n\n        expectedReturn = 1;\n        this.requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6);\n        actualReturn = this.requestedAddressFamilyAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"Datalength is not properly calculated\");\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java", "class_name": "RequestedAddressFamilyAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests whether data length is properly calculated.\n"}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]testGetName()", "name": "testGetName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetName()", "original_string": "    @Test\n    public void testGetName()\n    {\n        assertEquals(\"REQUESTED-ADDRESS-FAMILY\", requestedAddressFamilyAttribute.getName());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java", "class_name": "RequestedAddressFamilyAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests getting the name.\n"}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]testEqualsObject()", "name": "testEqualsObject", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEqualsObject()", "original_string": "    @Test\n    public void testEqualsObject()\n    {\n        // null test\n        assertNotEquals(requestedAddressFamilyAttribute, null);\n\n        // difference test\n        RequestedAddressFamilyAttribute target;\n        target = new RequestedAddressFamilyAttribute();\n\n        char family = MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6;\n        target.setFamily(family);\n\n        requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4);\n\n        assertNotEquals(requestedAddressFamilyAttribute, target);\n\n        // equality test\n        target.setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4);\n\n        assertEquals(requestedAddressFamilyAttribute, target);\n\n        // ipv6 equality test\n        target.setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6);\n\n        requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6);\n\n        assertEquals(requestedAddressFamilyAttribute, target);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java", "class_name": "RequestedAddressFamilyAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests the equals method against a null, a different and an identical\nobject.\n"}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]testDecodeAttributeBodyV4()", "name": "testDecodeAttributeBodyV4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBodyV4()", "original_string": "    @Test\n    public void testDecodeAttributeBodyV4() throws StunException\n    {\n        byte[] attributeValue = msgFixture.requestedAddressFamilyV4;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char) (attributeValue.length - offset);\n\n        requestedAddressFamilyAttribute.decodeAttributeBody(\n            attributeValue, offset, length);\n\n        assertEquals(\n            MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4,\n            requestedAddressFamilyAttribute.getFamily(),\n            \"RequestedAddressFamilyAttribute.decode() did not properly decode the family field.\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java", "class_name": "RequestedAddressFamilyAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether sample binary arrays are correctly decoded.\n\n@throws StunException if something goes wrong while decoding \n            Attribute Body.\n"}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]testDecodeAttributeBodyV6()", "name": "testDecodeAttributeBodyV6", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBodyV6()", "original_string": "    @Test\n    public void testDecodeAttributeBodyV6() throws StunException\n    {\n        byte[] attributeValue = msgFixture.requestedAddressFamilyV6;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char) (attributeValue.length - offset);\n\n        requestedAddressFamilyAttribute.decodeAttributeBody(\n            attributeValue, offset, length);\n\n        assertEquals(\n            MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6,\n            requestedAddressFamilyAttribute.getFamily(),\n            \"RequestedAddressFamilyAttribute.decode() did not properly decode.\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java", "class_name": "RequestedAddressFamilyAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether sample binary arrays are correctly decoded.\n\n@throws StunException if something goes wrong while decoding \n            Attribute Body.\n"}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]testEncodeV4()", "name": "testEncodeV4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncodeV4()", "original_string": "    @Test\n    public void testEncodeV4()\n    {\n        byte[] expectedReturn = msgFixture.requestedAddressFamilyV4;\n        requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4);\n        byte[] actualReturn = requestedAddressFamilyAttribute.encode();\n        assertArrayEquals(\n            expectedReturn, actualReturn,\n            \"RequestedAddressFamilyAttribute.encode() did not properly encode a sample attribute for IPv4 family\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java", "class_name": "RequestedAddressFamilyAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether attributes are properly encoded.\n"}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]testEncodeV6()", "name": "testEncodeV6", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncodeV6()", "original_string": "    @Test\n    public void testEncodeV6()\n    {\n        byte[] expectedReturn = msgFixture.requestedAddressFamilyV6;\n        requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6);\n        byte[] actualReturn = requestedAddressFamilyAttribute.encode();\n        assertArrayEquals(\n            expectedReturn, actualReturn,\n            \"RequestedAddressFamilyAttribute.encode() did not properly encode a sample attribute for IPv6 family\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java", "class_name": "RequestedAddressFamilyAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether attributes are properly encoded.\n"}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]testGetFamily()", "name": "testGetFamily", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetFamily()", "original_string": "    @Test\n    public void testGetFamily()\n    {\n        char expectedReturn = 0x01;\n        this.requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4);\n        char actualReturn = this.requestedAddressFamilyAttribute.getFamily();\n        assertEquals(expectedReturn, actualReturn,\n            \"Family is not properly calculated\");\n\n        expectedReturn = 0x02;\n        this.requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6);\n        actualReturn = this.requestedAddressFamilyAttribute.getFamily();\n        assertEquals(expectedReturn, actualReturn,\n            \"Family is not properly calculated\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java", "class_name": "RequestedAddressFamilyAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests that the address family is always 0x01 or 0x02.\n"}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]testAddressAttributeDescendants()", "name": "testAddressAttributeDescendants", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testAddressAttributeDescendants()", "original_string": "    @Test\n    public void testAddressAttributeDescendants()\n    {\n        char expectedType;\n        char actualType;\n        String expectedName;\n        String actualName;\n\n        //MAPPED-ADDRESS\n        addressAttribute = new MappedAddressAttribute();\n\n        expectedType = Attribute.MAPPED_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"MAPPED-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"MappedAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"MappedAddressAttribute does not the right name.\");\n\n\n        //SOURCE-ADDRESS\n        addressAttribute = new SourceAddressAttribute();\n\n        expectedType = Attribute.SOURCE_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"SOURCE-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"SourceAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"SourceAddressAttribute does not the right name.\");\n\n\n        //CHANGED-ADDRESS\n        addressAttribute = new ChangedAddressAttribute();\n\n        expectedType = Attribute.CHANGED_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"CHANGED-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"ChangedAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"ChangedAddressAttribute does not the right name.\");\n\n\n        //RESPONSE-ADDRESS\n        addressAttribute = new ResponseAddressAttribute();\n\n        expectedType = Attribute.RESPONSE_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"RESPONSE-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"ResponseAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"ResponseAddressAttribute does not the right name.\");\n\n\n        //REFLECTED-FROM\n        addressAttribute = new ReflectedFromAttribute();\n\n        expectedType = Attribute.REFLECTED_FROM;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"REFLECTED-FROM\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"ReflectedFromAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"ReflectedFromAttribute does not the right name.\");\n\n        //REFLECTED-FROM\n        addressAttribute = new ReflectedFromAttribute();\n\n        expectedType = Attribute.REFLECTED_FROM;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"REFLECTED-FROM\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"ReflectedFromAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"ReflectedFromAttribute does not the right name.\");\n\n        //XOR-MAPPED-ADDRESS\n        addressAttribute = new XorMappedAddressAttribute();\n\n        expectedType = Attribute.XOR_MAPPED_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"XOR-MAPPED-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"XorMappedAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"XorMappedAddressAttribute does not the right name.\");\n\n        /* ALTERNATE-SERVER */\n        addressAttribute = new AlternateServerAttribute();\n\n        expectedType = Attribute.ALTERNATE_SERVER;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"ALTERNATE-SERVER\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"AlternateServerAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"AlternateAttribute does not the right name.\");\n\n\n        /* XOR-PEER-ADDRESS */\n        addressAttribute = new XorPeerAddressAttribute();\n\n        expectedType = Attribute.XOR_PEER_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"XOR-PEER-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"XorPeerAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"XorPeerAddressAttribute does not the right name.\");\n\n        /* XOR-RELAYED-ADDRESS */\n        addressAttribute = new XorRelayedAddressAttribute();\n\n        expectedType = Attribute.XOR_RELAYED_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"XOR-RELAYED-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"XorRelayedAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"XorRelayedAddressAttribute does not the right name.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nVerify that AddressAttribute descendants have correctly set types and\nnames.\n"}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]testXorMappedAddressXoring_v4()", "name": "testXorMappedAddressXoring_v4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testXorMappedAddressXoring_v4()", "original_string": "    @Test\n    public void testXorMappedAddressXoring_v4()\n    {\n        XorMappedAddressAttribute addressAttribute = new XorMappedAddressAttribute();\n        TransportAddress testAddress =\n            new TransportAddress(\"130.79.95.53\", 12120, Transport.UDP);\n\n        addressAttribute.setAddress(testAddress);\n\n        //do a xor with an id equal to the v4 address itself so that we get 0000..,\n        TransportAddress xorredAddr = addressAttribute.applyXor(\n                new byte[]{(byte)130,79,95,53,0,0,0,0,0,0,0,0,0,0,0,0,0});\n\n        assertArrayEquals(\n            xorredAddr.getAddressBytes(), new byte[] { 0, 0, 0, 0 },\n            \"Xorring the address with itself didn't return 00000...\");\n\n        assertNotEquals(xorredAddr.getPort(), testAddress.getPort(),\n            \"Port was not xorred\");\n\n        //Test xor-ing the original with the xored - should get the xor code\n        addressAttribute.setAddress(testAddress);\n        xorredAddr = addressAttribute.applyXor(\n                new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        xorredAddr =\n            addressAttribute.applyXor(xorredAddr.getAddressBytes());\n\n        assertArrayEquals(\n            xorredAddr.getAddressBytes(), new byte[] { 21, 22, 23, 24 },\n            \"Xorring the original with the xor-ed didn't return the code.\");\n\n        assertNotEquals(0xFFFF, testAddress.getPort(), \"Port was not xorred\");\n\n        //Test double xor-ing - should get the original\n        addressAttribute.setAddress(testAddress);\n        xorredAddr = addressAttribute.applyXor(\n                new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        addressAttribute.setAddress(xorredAddr);\n        xorredAddr = addressAttribute.applyXor(\n                new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        assertEquals(testAddress, xorredAddr,\n            \"Double xorring didn't give the original\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nVerifies that xorred address-es are properly xor-ed for IPv4 addresses.\n"}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]testXorMappedAddressXoring_v6()", "name": "testXorMappedAddressXoring_v6", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testXorMappedAddressXoring_v6()", "original_string": "    @Test\n    public void testXorMappedAddressXoring_v6()\n    {\n        XorMappedAddressAttribute addressAttribute\n            = new XorMappedAddressAttribute();\n        TransportAddress testAddress = new TransportAddress(\n                \"2001:660:4701:1001:202:8aff:febe:130b\", 12120, Transport.UDP);\n\n        addressAttribute.setAddress(testAddress);\n\n        //do a xor with an id equal to the v4 address itself so that we get 0000..,\n        TransportAddress xorredAddr =\n            addressAttribute.applyXor(\n                new byte[]{(byte)0x20, (byte)0x01, (byte)0x06, (byte)0x60,\n                           (byte)0x47, (byte)0x01, (byte)0x10, (byte)0x01,\n                           (byte)0x02, (byte)0x02, (byte)0x8a, (byte)0xff,\n                           (byte)0xfe, (byte)0xbe, (byte)0x13, (byte)0x0b});\n\n        assertArrayEquals(\n            xorredAddr.getAddressBytes(), new byte[] { 0, 0, 0, 0,\n                0, 0, 0, 0,\n                0, 0, 0, 0,\n                0, 0, 0, 0 },\n            \"Xorring the address with itself didn't return 00000...\");\n\n        assertNotEquals(testAddress.getPort(), xorredAddr.getPort(),\n            \"Port was not xorred\");\n\n        //Test xor-ing the original with the xored - should get the xor code\n        addressAttribute.setAddress(testAddress);\n        xorredAddr = addressAttribute.applyXor(\n                  new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        xorredAddr = addressAttribute.applyXor(xorredAddr.getAddressBytes());\n\n        assertArrayEquals(\n            xorredAddr.getAddressBytes(),\n            new byte[] { 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n                35, 36 },\n            \"Xorring the original with the xor-ed didn't return the code.\");\n        \n        assertNotEquals(0xFFFF, testAddress.getPort(), \"Port was not xorred\");\n\n        //Test double xor-ing - should get the original\n        addressAttribute.setAddress(testAddress);\n        xorredAddr = addressAttribute.applyXor(\n                  new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        addressAttribute.setAddress(xorredAddr);\n        xorredAddr = addressAttribute.applyXor(\n                  new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        assertEquals(testAddress, xorredAddr,\n            \"Double xorring didn't give the original\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nVerifies that xorred address-es are properly xor-ed for IPv6 addresses.\n"}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]testDecodeAttributeBody()", "name": "testDecodeAttributeBody", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBody()", "original_string": "    @Test\n    public void testDecodeAttributeBody() throws StunException {\n        byte[] attributeValue = msgFixture.mappedAddress;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char)(attributeValue.length - offset);\n\n        addressAttribute.decodeAttributeBody(attributeValue, offset, length);\n\n\n        assertEquals(\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT, addressAttribute.getPort(),\n            \"AddressAttribute.decode() did not properly decode the port field.\");\n        assertArrayEquals(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n            addressAttribute.getAddressBytes(),\n            \"AddressAttribute.decode() did not properly decode the address field.\");\n\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether sample binary arrays are correctly decoded.\n\n@throws StunException if something goes wrong\n"}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]testDecodeAttributeBodyv6()", "name": "testDecodeAttributeBodyv6", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBodyv6()", "original_string": "    @Test\n    public void testDecodeAttributeBodyv6() throws StunException {\n        byte[] attributeValue = msgFixture.mappedAddressv6;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char)(attributeValue.length - offset);\n\n        addressAttribute.decodeAttributeBody(attributeValue, offset, length);\n\n\n        assertEquals(MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                     addressAttribute.getPort(),\n            \"decode() failed for an IPv6 Addr's port.\");\n        assertArrayEquals(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n            addressAttribute.getAddressBytes(),\n            \"AddressAttribute.decode() failed for an IPv6 address.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whetner sample binary arrays are correctly decoded.\n@throws StunException if something goes wrong\n"}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n        throws Exception\n    {\n        byte[] expectedReturn = msgFixture.mappedAddress;\n\n        addressAttribute.setAddress(\n            new TransportAddress(MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                                 MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                                 Transport.UDP));\n\n        byte[] actualReturn = addressAttribute.encode();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"AddressAttribute.encode() did not properly encode a sample attribute\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether attributes are properly encoded.\n\n@throws Exception java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]testEncodev6()", "name": "testEncodev6", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncodev6()", "original_string": "    @Test\n    public void testEncodev6()\n        throws Exception\n    {\n        byte[] expectedReturn = msgFixture.mappedAddressv6;\n\n        addressAttribute.setAddress(\n            new TransportAddress(MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n                        MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP));\n\n        byte[] actualReturn = addressAttribute.encode();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"An AddressAttribute did not properly encode an IPv6 addr.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether attributes are properly encoded.\n\n@throws Exception java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEquals()", "original_string": "    @Test\n    public void testEquals()\n        throws Exception\n    {\n        //null test\n        AddressAttribute target = null;\n        boolean expectedReturn = false;\n        boolean actualReturn = addressAttribute.equals(target);\n\n        assertEquals(expectedReturn, actualReturn,\n            \"AddressAttribute.equals() failed against a null target.\");\n\n        //difference test\n        target = new MappedAddressAttribute();\n\n        char port = (char)(MsgFixture.ADDRESS_ATTRIBUTE_PORT + 1 );\n        target.setAddress(  new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS, port, Transport.UDP));\n\n        addressAttribute.setAddress( new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n            Transport.UDP));\n\n        expectedReturn = false;\n        actualReturn = addressAttribute.equals(target);\n        assertEquals(expectedReturn, actualReturn,\n            \"AddressAttribute.equals() failed against a different target.\");\n\n        //equality test\n        target.setAddress( new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP ));\n\n        expectedReturn = true;\n        actualReturn = addressAttribute.equals(target);\n        assertEquals(expectedReturn, actualReturn,\n            \"AddressAttribute.equals() failed against an equal target.\");\n\n        //ipv6 equality test\n        target.setAddress(  new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP));\n\n        addressAttribute.setAddress(new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n            Transport.UDP));\n\n        expectedReturn = true;\n        actualReturn = addressAttribute.equals(target);\n        assertEquals(expectedReturn, actualReturn,\n            \"AddressAttribute.equals() failed for IPv6 addresses.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests the equals method against a null, a different and an identical\nobject.\n\n@throws Exception java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n        throws Exception\n    {\n        char expectedReturn = 8;//1-padding + 1-family + 2-port + 4-address\n\n        addressAttribute.setAddress( new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n            Transport.UDP));\n\n        char actualReturn = addressAttribute.getDataLength();\n\n        assertEquals(expectedReturn, actualReturn,\n            \"Datalength is not propoerly calculated\");\n\n        expectedReturn = 20;//1-padding + 1-family + 2-port + 16-address\n        addressAttribute.setAddress( new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP));\n\n        actualReturn = addressAttribute.getDataLength();\n\n        assertEquals(expectedReturn, actualReturn,\n            \"Datalength is not propoerly calculated\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests whether data length is properly calculated.\n\n@throws Exception java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]testGetFamily()", "name": "testGetFamily", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetFamily()", "original_string": "    @Test\n    public void testGetFamily()\n        throws Exception\n    {\n        byte expectedReturn = 1;\n        addressAttribute.setAddress(new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP));\n        byte actualReturn = addressAttribute.getFamily();\n        assertEquals(expectedReturn, actualReturn,\n            \"Address family was not 1 for an IPv4\");\n\n        //ipv6\n        expectedReturn = 2;\n        addressAttribute.setAddress(new TransportAddress(\n                       MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n                       MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP));\n        actualReturn = addressAttribute.getFamily();\n        assertEquals(expectedReturn, actualReturn,\n            \"Address family was not 2 for an IPv6 address\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests that the address family is always 1.\n\n@throws Exception java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest.[void]testDecodeAttributeBody()", "name": "testDecodeAttributeBody", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBody()", "original_string": "    @Test\n    public void testDecodeAttributeBody() throws StunException {\n\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char)(msgFixture.unknownOptionalAttribute.length - offset);\n\n        optionalAttribute.decodeAttributeBody(msgFixture.unknownOptionalAttribute,\n                                              offset, length);\n\n        assertArrayEquals(\n            expectedAttributeValue, optionalAttribute.getBody(),\n            \"OptionalAttribute did not decode properly.\");\n\n        assertEquals(length, optionalAttribute.getDataLength(),\n            \"Length was not properly decoded\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java", "class_name": "OptionalAttributeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether sample binary arrays are correctly decoded.\n@throws StunException if anything goes wrong.\n"}, {"uris": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n    {\n        optionalAttribute.setBody(expectedAttributeValue, 0,\n                                  expectedAttributeValue.length);\n\n        byte[] actualReturn = optionalAttribute.encode();\n        assertArrayEquals(msgFixture.unknownOptionalAttribute, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java", "class_name": "OptionalAttributeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether attributes are properly encoded\n"}, {"uris": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEquals()", "original_string": "    @Test\n    public void testEquals()\n    {\n        //null comparison\n        optionalAttribute.setBody( expectedAttributeValue, 0,\n                                   expectedAttributeValue.length);\n\n        assertNotEquals(optionalAttribute, null);\n\n        //wrong type comparison\n        assertNotEquals(optionalAttribute, \"hehe :)\");\n\n        //succesful comparison\n        OptionalAttribute obj =\n            new OptionalAttribute(msgFixture.optionalAttributeType);\n\n        obj.setBody( expectedAttributeValue, 0,\n                                          expectedAttributeValue.length);\n        assertEquals(obj, optionalAttribute);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java", "class_name": "OptionalAttributeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether the equals method works ok\n"}, {"uris": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = (char)expectedAttributeValue.length;\n\n        optionalAttribute.setBody( expectedAttributeValue, 0,\n                                   expectedAttributeValue.length);\n\n        char actualReturn = optionalAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java", "class_name": "OptionalAttributeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]testErrorCodeAttribute()", "name": "testErrorCodeAttribute", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testErrorCodeAttribute()", "original_string": "    @Test\n    public void testErrorCodeAttribute()\n    {\n        errorCodeAttribute = new ErrorCodeAttribute();\n        assertEquals(\n            Attribute.ERROR_CODE,\n            errorCodeAttribute.getAttributeType(),\n            \"ErrorCodeAttribute() constructed an attribute with an invalid type\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java", "class_name": "ErrorCodeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest Attribute type\n"}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]testDecodeAttributeBody()", "name": "testDecodeAttributeBody", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBody()", "original_string": "    @Test\n    public void testDecodeAttributeBody()\n        throws StunException {\n        byte[] attributeValue = msgFixture.errCodeTestValue;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char)(attributeValue.length - Attribute.HEADER_LENGTH);\n        errorCodeAttribute.decodeAttributeBody(attributeValue, offset, length);\n\n        assertEquals(\n            MsgFixture.ERROR_CLASS,\n            errorCodeAttribute.getErrorClass(),\n            \"Error Class was not correctly decoded\"\n        );\n\n        assertEquals(\n            MsgFixture.ERROR_NUMBER,\n            errorCodeAttribute.getErrorNumber(),\n            \"Error Number was not correctly decoded\"\n        );\n\n        assertEquals(\n            MsgFixture.REASON_PHRASE.trim(),\n            errorCodeAttribute.getReasonPhrase().trim(),\n            \"Reason phrase was not correctly decoded\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java", "class_name": "ErrorCodeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether sample binary arrays are properly decoded.\n\n@throws StunException java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n        throws StunException\n    {\n        byte[] expectedReturn = msgFixture.errCodeTestValue;\n\n        errorCodeAttribute.setErrorClass(MsgFixture.ERROR_CLASS);\n        errorCodeAttribute.setErrorNumber(MsgFixture.ERROR_NUMBER);\n\n        errorCodeAttribute.setReasonPhrase(MsgFixture.REASON_PHRASE);\n\n        byte[] actualReturn = errorCodeAttribute.encode();\n\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"encode() did not return the expected binary array.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java", "class_name": "ErrorCodeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nConstruct and encode a sample object and assert equality with a sample\nbinary array.\n\n@throws StunException java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEquals()", "original_string": "    @Test\n    public void testEquals()\n        throws StunException\n    {\n        //null value test\n        assertNotEquals(errorCodeAttribute, null,\n            \"equals() failed against a null value target.\");\n\n        //different objects\n        ErrorCodeAttribute target;\n        target = new ErrorCodeAttribute();\n\n        target.setErrorClass(MsgFixture.ERROR_CLASS);\n        target.setErrorNumber(MsgFixture.ERROR_NUMBER);\n\n        errorCodeAttribute.setErrorClass((byte)(MsgFixture.ERROR_CLASS+1));\n        errorCodeAttribute.setErrorNumber((byte)(MsgFixture.ERROR_NUMBER+1));\n\n        assertNotEquals(errorCodeAttribute, target,\n            \"equals() failed against a not equal target.\");\n\n        //equal objects\n        target = new ErrorCodeAttribute();\n        errorCodeAttribute = new ErrorCodeAttribute();\n\n        target.setErrorClass(MsgFixture.ERROR_CLASS);\n        target.setErrorNumber(MsgFixture.ERROR_NUMBER);\n\n        errorCodeAttribute.setErrorClass(MsgFixture.ERROR_CLASS);\n        errorCodeAttribute.setErrorNumber(MsgFixture.ERROR_NUMBER);\n\n        assertEquals(errorCodeAttribute, target,\n            \"equals() failed against an equal target.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java", "class_name": "ErrorCodeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests the equals method against a null, a different and an identical\nobject.\n\n@throws StunException java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n        throws StunException\n    {\n        int expectedReturn = MsgFixture.REASON_PHRASE.getBytes().length\n                            + 4; //error code specific header\n\n        errorCodeAttribute.setErrorClass(MsgFixture.ERROR_CLASS);\n        errorCodeAttribute.setErrorNumber(MsgFixture.ERROR_NUMBER);\n        errorCodeAttribute.setReasonPhrase(MsgFixture.REASON_PHRASE);\n\n        char actualReturn = errorCodeAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn, \"data length1\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java", "class_name": "ErrorCodeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether data length is propertly calculated.\n\n@throws StunException java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]testGetErrorCode()", "name": "testGetErrorCode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetErrorCode()", "original_string": "    @Test\n    public void testGetErrorCode()\n    {\n        char expectedReturn = (char)(100*MsgFixture.ERROR_CLASS\n                                     + MsgFixture.ERROR_NUMBER);\n\n        errorCodeAttribute.setErrorClass(MsgFixture.ERROR_CLASS);\n        errorCodeAttribute.setErrorNumber(MsgFixture.ERROR_NUMBER);\n\n        char actualReturn = errorCodeAttribute.getErrorCode();\n        assertEquals(expectedReturn, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java", "class_name": "ErrorCodeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether error code is properly calculated from error class and number\n"}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]testGetName()", "name": "testGetName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetName()", "original_string": "    @Test\n    public void testGetName() {\n        assertEquals(\"ERROR-CODE\", errorCodeAttribute.getName());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java", "class_name": "ErrorCodeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether we get a proper name for that attribute.\n"}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]testSetErrorCode()", "name": "testSetErrorCode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSetErrorCode()", "original_string": "    @Test\n    public void testSetErrorCode()\n    {\n        char errorCode = (char)(MsgFixture.ERROR_CLASS*100 + MsgFixture.ERROR_NUMBER);\n        errorCodeAttribute.setErrorCode(errorCode);\n\n        assertEquals(\n            MsgFixture.ERROR_CLASS,\n            (int) errorCodeAttribute.getErrorClass(),\n            \"An error class was not properly set after decoding an error code.\"\n        );\n        assertEquals(\n            MsgFixture.ERROR_NUMBER,\n            (int) errorCodeAttribute.getErrorNumber(),\n            \"An error number was not properly set after decoding an error code.\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java", "class_name": "ErrorCodeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether error code is properly calculated from error class and number\n\n"}, {"uris": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest.[void]testDecodeMappedAddress()", "name": "testDecodeMappedAddress", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeMappedAddress()", "original_string": "    @Test\n    public void testDecodeMappedAddress()\n        throws Exception\n    {\n        //\n        byte[] bytes = msgFixture.mappedAddress;\n        char offset = 0;\n        char length = (char)bytes.length;\n\n        //create the message\n        MappedAddressAttribute expectedReturn = new MappedAddressAttribute();\n\n        expectedReturn.setAddress(new TransportAddress(\n                       MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                       MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                       Transport.UDP));\n\n        Attribute actualReturn = AttributeDecoder.decode(\n                        bytes, offset, length);\n\n        assertEquals(expectedReturn, actualReturn,\n            \"AttributeDecoder.decode() failed for a MAPPED-ADDRESS attribute\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java", "class_name": "AttributeDecoderTest", "class_uri": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest.[void]testDecodeMappedAddress_v6()", "name": "testDecodeMappedAddress_v6", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeMappedAddress_v6()", "original_string": "    @Test\n    public void testDecodeMappedAddress_v6()\n        throws Exception\n    {\n        //\n        byte[] bytes = msgFixture.mappedAddressv6;\n        char offset = 0;\n        char length = (char)bytes.length;\n\n        //create the message\n        MappedAddressAttribute expectedReturn = new MappedAddressAttribute();\n\n        expectedReturn.setAddress( new TransportAddress(\n                        MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n                        MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                        Transport.UDP));\n\n        Attribute actualReturn = AttributeDecoder.decode(\n                        bytes, offset, length);\n\n        assertEquals(\n            expectedReturn, actualReturn,\n            \"AttributeDecoder.decode() failed for a MAPPED-ADDRESS attribute\"\n            );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java", "class_name": "AttributeDecoderTest", "class_uri": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest.[void]testDecodeChangeRequest()", "name": "testDecodeChangeRequest", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeChangeRequest()", "original_string": "    @Test\n    public void testDecodeChangeRequest()\n        throws Exception\n    {\n        //\n        byte[] bytes = msgFixture.chngReqTestValue1;\n        char offset = 0;\n        char length = (char)bytes.length;\n\n        //create the message\n        ChangeRequestAttribute expectedReturn = new ChangeRequestAttribute();\n        expectedReturn.setChangeIpFlag(MsgFixture.CHANGE_IP_FLAG_1);\n        expectedReturn.setChangePortFlag(MsgFixture.CHANGE_PORT_FLAG_1);\n\n        Attribute actualReturn = AttributeDecoder.decode(\n                        bytes, offset, length);\n        assertEquals(expectedReturn, actualReturn,\n            \"AttributeDecoder.decode() failed for a CHANGE-REQUEST attribute\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java", "class_name": "AttributeDecoderTest", "class_uri": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest.[void]testDecodeErrorCode()", "name": "testDecodeErrorCode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeErrorCode()", "original_string": "    @Test\n    public void testDecodeErrorCode()\n       throws Exception\n   {\n       //\n       byte[] bytes = msgFixture.errCodeTestValue;\n       char offset = 0;\n       char length = (char)bytes.length;\n\n       //create the message\n       ErrorCodeAttribute expectedReturn = new ErrorCodeAttribute();\n       expectedReturn.setErrorClass(MsgFixture.ERROR_CLASS);\n       expectedReturn.setErrorNumber(MsgFixture.ERROR_NUMBER);\n       expectedReturn.setReasonPhrase(MsgFixture.REASON_PHRASE);\n\n       Attribute actualReturn = AttributeDecoder.decode(\n                       bytes, offset, length);\n       assertEquals(expectedReturn, actualReturn,\n           \"AttributeDecoder.decode() failed for a ERROR-CODE attribute\");\n   }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java", "class_name": "AttributeDecoderTest", "class_uri": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest.[void]testDecodeUnknownAttributes()", "name": "testDecodeUnknownAttributes", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeUnknownAttributes()", "original_string": "    @Test\n    public void testDecodeUnknownAttributes()\n       throws Exception\n   {\n       //unknown attributes\n       byte[] bytes = msgFixture.unknownAttsDecodeTestValue;\n       char offset = 0;\n       char length = (char)msgFixture.mappedAddress.length;\n\n       //create the message\n       UnknownAttributesAttribute expectedReturn\n           = new UnknownAttributesAttribute();\n       expectedReturn.addAttributeID(MsgFixture.UNKNOWN_ATTRIBUTES_1ST_ATT);\n       expectedReturn.addAttributeID(MsgFixture.UNKNOWN_ATTRIBUTES_2ND_ATT);\n       expectedReturn.addAttributeID(MsgFixture.UNKNOWN_ATTRIBUTES_3D_ATT);\n\n       Attribute actualReturn = AttributeDecoder.decode(\n                       bytes, offset, length);\n\n       assertEquals(expectedReturn, actualReturn,\n              \"AttributeDecoder.decode() failed for a ERROR-CODE attribute\");\n   }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java", "class_name": "AttributeDecoderTest", "class_uri": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest.[void]testDecodeUnknownOptionalAttribute()", "name": "testDecodeUnknownOptionalAttribute", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeUnknownOptionalAttribute()", "original_string": "    @Test\n    public void testDecodeUnknownOptionalAttribute()\n       throws Exception\n   {\n       //unknown attributes\n       byte[] bytes = msgFixture.unknownOptionalAttribute;\n       char offset = 0;\n       char length = (char)msgFixture.mappedAddress.length;\n\n       //create the message\n       OptionalAttribute expectedReturn =\n           new OptionalAttribute(Attribute.UNKNOWN_OPTIONAL_ATTRIBUTE);\n       expectedReturn.setBody(expectedAttributeValue, 0,\n                              expectedAttributeValue.length);\n\n       Attribute actualReturn = AttributeDecoder.decode(\n                       bytes, offset, length);\n       assertEquals(expectedReturn, actualReturn,\n           \"AttributeDecoder.decode() failed for a UNKNOWN_OPTIONAL attribute\");\n\n   }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java", "class_name": "AttributeDecoderTest", "class_uri": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = 4;\n        this.connectionIdAttribute\n            .setConnectionIdValue(MsgFixture.CONNECTION_ID);\n        char actualReturn = this.connectionIdAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"Datalength is not properly calculated\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java", "class_name": "ConnectionIdAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests whether data length is properly calculated.\n"}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest.[void]testGetName()", "name": "testGetName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetName()", "original_string": "    @Test\n    public void testGetName()\n    {\n        assertEquals(\"CONNECTION-ID\", connectionIdAttribute.getName());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java", "class_name": "ConnectionIdAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests getting the name.\n"}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest.[void]testEqualsObject()", "name": "testEqualsObject", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEqualsObject()", "original_string": "    @Test\n    public void testEqualsObject()\n    {\n        // null test\n        assertNotEquals(connectionIdAttribute, null);\n\n        // difference test\n        ConnectionIdAttribute target = new ConnectionIdAttribute();\n\n        int connectionId = MsgFixture.CONNECTION_ID_2;\n        target.setConnectionIdValue(connectionId);\n\n        connectionIdAttribute.setConnectionIdValue(MsgFixture.CONNECTION_ID);\n        assertNotEquals(connectionIdAttribute, target,\n            \"ConnectionIdAttribute.equals() failed against a different target.\");\n\n        // equality test\n        target.setConnectionIdValue(MsgFixture.CONNECTION_ID);\n        assertEquals(connectionIdAttribute, target,\n            \"ConnectionIdAttribute.equals() failed against an equal target.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java", "class_name": "ConnectionIdAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests the equals method against a null, a different and an identical\nobject.\n"}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n    {\n        byte[] expectedReturn = msgFixture.connectionId;\n        connectionIdAttribute.setConnectionIdValue(MsgFixture.CONNECTION_ID);\n        byte[] actualReturn = connectionIdAttribute.encode();\n\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"ConnectionIdAttribute.encode() did not properly encode a sample attribute\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java", "class_name": "ConnectionIdAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether attributes are properly encoded.\n"}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest.[void]testDecodeAttributeBody()", "name": "testDecodeAttributeBody", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBody()", "original_string": "    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        byte[] attributeValue = msgFixture.connectionId;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char) (attributeValue.length - offset);\n\n        connectionIdAttribute.decodeAttributeBody(\n            attributeValue, offset, length);\n\n        assertEquals(\n            MsgFixture.CONNECTION_ID,\n            connectionIdAttribute.getConnectionIdValue(),\n            \"ConnectionIdAttribute.decode() did not properly decode the connection id field.\"\n        );\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java", "class_name": "ConnectionIdAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether sample binary arrays are correctly decoded.\n\n@throws StunException if something goes wrong while decoding \n            Attribute Body.\n"}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest.[void]testGetConnectionIdValue()", "name": "testGetConnectionIdValue", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetConnectionIdValue()", "original_string": "    @Test\n    public void testGetConnectionIdValue()\n    {\n        int expectedReturn = 0x5555;\n        this.connectionIdAttribute\n            .setConnectionIdValue(MsgFixture.CONNECTION_ID);\n        int actualReturn = this.connectionIdAttribute.getConnectionIdValue();\n        assertEquals(expectedReturn, actualReturn,\n            \"ConnectionId is not properly calculated\");\n\n        expectedReturn = 0x2222;\n        this.connectionIdAttribute\n            .setConnectionIdValue(MsgFixture.CONNECTION_ID_2);\n        actualReturn = this.connectionIdAttribute.getConnectionIdValue();\n        assertEquals(expectedReturn, actualReturn,\n            \"ConnectionId is not properly calculated\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java", "class_name": "ConnectionIdAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests that the connection Id is always integer.\n"}, {"uris": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest.[void]testChangeRequestAttribute()", "name": "testChangeRequestAttribute", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testChangeRequestAttribute()", "original_string": "    @Test\n    public void testChangeRequestAttribute()\n    {\n        changeRequestAttribute = new ChangeRequestAttribute();\n\n        assertEquals(\n            changeRequestAttribute.getAttributeType(),\n            Attribute.CHANGE_REQUEST,\n            \"ChangeRequestAttribute did not construct an attribute with the correct type.\"\n        );\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java", "class_name": "ChangeRequestAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether the constructed object has the proper type.\n"}, {"uris": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest.[void]testDecodeAttributeBody()", "name": "testDecodeAttributeBody", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBody()", "original_string": "    @Test\n    public void testDecodeAttributeBody()\n        throws StunException\n    {\n        byte[] attributeValue = binMessagesFixture.chngReqTestValue1;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char)(attributeValue.length - offset);\n        changeRequestAttribute.decodeAttributeBody(attributeValue, offset, length);\n\n        assertEquals(\n            MsgFixture.CHANGE_IP_FLAG_1,\n            changeRequestAttribute.getChangeIpFlag(),\n            \"decodeAttributeBody() did not properly decode the changeIpFlag\"\n        );\n        assertEquals(\n            MsgFixture.CHANGE_PORT_FLAG_1,\n            changeRequestAttribute.getChangePortFlag(),\n            \"decodeAttributeBody() did not properly decode the changePortFlag\"\n        );\n\n        //2nd sample\n        attributeValue = binMessagesFixture.chngReqTestValue2;\n        changeRequestAttribute\n            .decodeAttributeBody(attributeValue, offset, length);\n        assertEquals(\n            MsgFixture.CHANGE_IP_FLAG_2,\n            changeRequestAttribute.getChangeIpFlag(),\n            \"decodeAttributeBody() did not properly decode the changeIpFlag\"\n        );\n        assertEquals(\n            MsgFixture.CHANGE_PORT_FLAG_2,\n            changeRequestAttribute.getChangePortFlag(),\n            \"decodeAttributeBody() did not properly decode the changePortFlag\"\n        );\n\n        changeRequestAttribute.getChangePortFlag();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java", "class_name": "ChangeRequestAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether sample binary arrays are properly decoded.\n\n@throws StunException java.lang.Exception if we fail\n"}, {"uris": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n    {\n        byte[] expectedReturn = binMessagesFixture.chngReqTestValue1;\n\n        changeRequestAttribute = new ChangeRequestAttribute();\n\n        changeRequestAttribute.setChangeIpFlag(MsgFixture.CHANGE_IP_FLAG_1);\n        changeRequestAttribute.setChangePortFlag(MsgFixture.CHANGE_PORT_FLAG_1);\n\n        byte[] actualReturn = changeRequestAttribute.encode();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"Object did not encode properly.\");\n\n        //2nd test\n        expectedReturn = binMessagesFixture.chngReqTestValue2;\n        changeRequestAttribute = new ChangeRequestAttribute();\n\n        changeRequestAttribute.setChangeIpFlag(MsgFixture.CHANGE_IP_FLAG_2);\n        changeRequestAttribute.setChangePortFlag(MsgFixture.CHANGE_PORT_FLAG_2);\n\n        actualReturn = changeRequestAttribute.encode();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"Object did not encode properly.\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java", "class_name": "ChangeRequestAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreate sample objects and test whether they encode properly.\n"}, {"uris": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEquals()", "original_string": "    @Test\n    public void testEquals()\n    {\n        //null test\n        assertNotEquals(changeRequestAttribute, null);\n\n        //test against a different object.\n        ChangeRequestAttribute target = new ChangeRequestAttribute();\n\n        changeRequestAttribute.setChangeIpFlag(true);\n        changeRequestAttribute.setChangePortFlag(false);\n\n        target.setChangeIpFlag(false);\n        target.setChangePortFlag(true);\n\n        assertNotEquals(changeRequestAttribute, target);\n\n        //test against an equal value\n        target = new ChangeRequestAttribute();\n\n        changeRequestAttribute.setChangeIpFlag(true);\n        changeRequestAttribute.setChangePortFlag(false);\n\n        target.setChangeIpFlag(true);\n        target.setChangePortFlag(false);\n        assertEquals(changeRequestAttribute, target);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java", "class_name": "ChangeRequestAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests the equals method against a null, a different and an identical\nobject.\n"}, {"uris": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = 4; // constant 4 bytes of data\n        char actualReturn = changeRequestAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"data length returned an invalid value\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java", "class_name": "ChangeRequestAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether the returned value is always 4.\n"}, {"uris": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest.[void]testGetName()", "name": "testGetName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetName()", "original_string": "    @Test\n    public void testGetName()\n    {\n        assertEquals(\"CHANGE-REQUEST\", changeRequestAttribute.getName());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java", "class_name": "ChangeRequestAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest whether we get a relevant name.\n"}, {"uris": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest.[void]testDecodeAttributeBody()", "name": "testDecodeAttributeBody", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBody()", "original_string": "    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        char offset = 0;\n        NonceAttribute decoded = new NonceAttribute();\n        char length = (char)nonceValue.length();\n        decoded.decodeAttributeBody(nonceValue.getBytes(), offset, length);\n\n        //nonce value\n        assertEquals(nonceAttribute, decoded, \"decode failed\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java", "class_name": "NonceAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests decoding of the nonce attribute.\n@throws StunException upon a failure\n"}, {"uris": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n    {\n        assertArrayEquals(nonceAttribute.encode(), attributeBinValue,\n            \"encode failed\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java", "class_name": "NonceAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests the encode method\n"}, {"uris": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEquals()", "original_string": "    @Test\n    public void testEquals()\n    {\n        NonceAttribute nonceAttribute2 = new NonceAttribute();\n        nonceAttribute2.setNonce(nonceValue.getBytes());\n\n        //test positive equals\n        assertEquals(nonceAttribute, nonceAttribute2);\n\n        //test negative equals\n        nonceAttribute2 = new NonceAttribute();\n        nonceAttribute2.setNonce(\"some other nonce\".getBytes());\n\n        //test positive equals\n        assertNotEquals(nonceAttribute2, nonceAttribute);\n\n        //test null equals\n        assertNotEquals(nonceAttribute, null);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java", "class_name": "NonceAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest Equals\n"}, {"uris": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = (char)nonceValue.length();\n        char actualReturn = nonceAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java", "class_name": "NonceAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests extracting data length\n"}, {"uris": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest.[void]testGetName()", "name": "testGetName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetName()", "original_string": "    @Test\n    public void testGetName()\n    {\n        assertEquals(\"NONCE\", nonceAttribute.getName());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java", "class_name": "NonceAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests getting the name\n"}, {"uris": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest.[void]testSetGetNonce()", "name": "testSetGetNonce", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSetGetNonce()", "original_string": "    @Test\n    public void testSetGetNonce()\n    {\n        byte[] expectedReturn = nonceValue.getBytes();\n\n        NonceAttribute att = new NonceAttribute();\n        att.setNonce(expectedReturn);\n\n        byte[] actualReturn = att.getNonce();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"nonce setter or getter failed\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java", "class_name": "NonceAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest.[void]testDecodeAttributeBody()", "name": "testDecodeAttributeBody", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBody()", "original_string": "    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        char offset = 0;\n        UsernameAttribute decoded = new UsernameAttribute();\n        char length = (char)usernameValue.length();\n        decoded.decodeAttributeBody(usernameValue.getBytes(), offset, length);\n\n        //username value\n        assertEquals(usernameAttribute, decoded);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java", "class_name": "UsernameAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests decoding of the username attribute.\n@throws StunException upon a failure\n"}, {"uris": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n    {\n        assertArrayEquals(usernameAttribute.encode(), attributeBinValue);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java", "class_name": "UsernameAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests the encode method\n"}, {"uris": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEquals()", "original_string": "    @Test\n    public void testEquals()\n    {\n        UsernameAttribute usernameAttribute2 = new UsernameAttribute();\n        usernameAttribute2.setUsername(usernameValue.getBytes());\n\n        //test positive equals\n        assertEquals(usernameAttribute, usernameAttribute2);\n\n        //test negative equals\n        usernameAttribute2 = new UsernameAttribute();\n        usernameAttribute2.setUsername(\"some other username\".getBytes());\n\n        //test positive equals\n        assertNotEquals(usernameAttribute2, usernameAttribute);\n\n        //test null equals\n        assertNotEquals(usernameAttribute, null);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java", "class_name": "UsernameAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest Equals\n"}, {"uris": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = (char)usernameValue.length();\n        char actualReturn = usernameAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java", "class_name": "UsernameAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests extracting data length\n"}, {"uris": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest.[void]testGetName()", "name": "testGetName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetName()", "original_string": "    @Test\n    public void testGetName()\n    {\n        assertEquals(\"USERNAME\", usernameAttribute.getName());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java", "class_name": "UsernameAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests getting the name\n"}, {"uris": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest.[void]testSetGetUsername()", "name": "testSetGetUsername", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSetGetUsername()", "original_string": "    @Test\n    public void testSetGetUsername()\n    {\n        byte[] expectedReturn = usernameValue.getBytes();\n\n        UsernameAttribute att = new UsernameAttribute();\n        att.setUsername(expectedReturn);\n\n        byte[] actualReturn = att.getUsername();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"username setter or getter failed\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java", "class_name": "UsernameAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest.[void]testDecodeAttributeBody()", "name": "testDecodeAttributeBody", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testDecodeAttributeBody()", "original_string": "    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        byte[] attributeValue = new byte[]{};\n        char offset = 0;\n        char length = 0;\n        xorOnly.decodeAttributeBody(attributeValue, offset, length);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/XorOnlyTest.java", "class_name": "XorOnlyTest", "class_uri": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nJust makes sure that no exceptions are thrown when calling it as the\ndecode method doesn't do anything in the XorOnly att.\n@throws StunException if sth happens\n"}, {"uris": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest.[void]testEncode()", "name": "testEncode", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEncode()", "original_string": "    @Test\n    public void testEncode()\n    {\n        byte[] expectedReturn = new byte[]{Attribute.XOR_ONLY>>8,\n                                           Attribute.XOR_ONLY&0x00FF,\n                                            0, 0};\n        byte[] actualReturn = xorOnly.encode();\n        assertArrayEquals(expectedReturn, actualReturn);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/XorOnlyTest.java", "class_name": "XorOnlyTest", "class_uri": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest encoding XorOnly attributes.\n"}, {"uris": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testEquals()", "original_string": "    @Test\n    public void testEquals() throws Exception\n    {\n        XorOnlyAttribute xor2 = new XorOnlyAttribute();\n        assertEquals(xorOnly, xor2);\n\n        MappedAddressAttribute maatt =  new MappedAddressAttribute();\n        maatt.decodeAttributeBody( msgFixture.mappedAddress,\n                                   (char) 0,\n                                   (char) msgFixture.mappedAddress.length );\n\n        assertNotEquals(maatt, xorOnly);\n        assertNotEquals(xorOnly, null);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/XorOnlyTest.java", "class_name": "XorOnlyTest", "class_uri": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest positive and negative XorOnly.equals() returns\n@throws Exception if decoding fails\n"}, {"uris": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest.[void]testGetDataLength()", "name": "testGetDataLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetDataLength()", "original_string": "    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = 0;\n        char actualReturn = xorOnly.getDataLength();\n        assertEquals(expectedReturn, actualReturn, \"data length was not 0\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/XorOnlyTest.java", "class_name": "XorOnlyTest", "class_uri": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMakes sure the data langth is 0\n"}, {"uris": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest.[void]testGetName()", "name": "testGetName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetName()", "original_string": "    @Test\n    public void testGetName()\n    {\n        assertEquals(\"XOR-ONLY\", xorOnly.getName());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/XorOnlyTest.java", "class_name": "XorOnlyTest", "class_uri": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nVerifies the name (do we really need this?).\n"}, {"uris": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests.[void]scheduleExecutesSpecifiedRunnableMultipleTimes()", "name": "scheduleExecutesSpecifiedRunnableMultipleTimes", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void scheduleExecutesSpecifiedRunnableMultipleTimes()", "original_string": "    @Test\n    public void scheduleExecutesSpecifiedRunnableMultipleTimes()\n    {\n        int scheduleCount = 10;\n        Duration period = Duration.ofMillis(100);\n        final CountDownLatch latch = new CountDownLatch(scheduleCount);\n        final PeriodicRunnable scheduledRunnable = PeriodicRunnable.create(\n            timer,\n            executor,\n            period,\n            latch::countDown);\n\n        scheduledRunnable.schedule();\n\n        for (int i = 0; i < scheduleCount; i++)\n        {\n            timer.getClock().elapse(period.plusMillis(10));\n            timer.run();\n        }\n\n        assertEquals(0, latch.getCount());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java", "class_name": "PeriodicRunnableTests", "class_uri": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests.[void]scheduleWithNegativeDelayDoesNotExecuteRunnable()", "name": "scheduleWithNegativeDelayDoesNotExecuteRunnable", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void scheduleWithNegativeDelayDoesNotExecuteRunnable()", "original_string": "    @Test\n    public void scheduleWithNegativeDelayDoesNotExecuteRunnable()\n    {\n        final CountDownLatch latch = new CountDownLatch(1);\n        final PeriodicRunnable scheduledRunnable = PeriodicRunnable.create(\n            timer,\n            executor,\n            Duration.ofMillis(-1),\n            latch::countDown);\n\n        scheduledRunnable.schedule();\n\n        timer.getClock().elapse(Duration.ofSeconds(1));\n        timer.run();\n        assertEquals(1, latch.getCount());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java", "class_name": "PeriodicRunnableTests", "class_uri": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests.[void]negativeDelayStopsFurtherExecution()", "name": "negativeDelayStopsFurtherExecution", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void negativeDelayStopsFurtherExecution()", "original_string": "    @Test\n    public void negativeDelayStopsFurtherExecution()\n    {\n        int scheduleCount = 5;\n        final CountDownLatch latch = new CountDownLatch(scheduleCount);\n        final PeriodicRunnable scheduledRunnable =\n            new PeriodicRunnable(timer, executor)\n            {\n                @Override\n                protected Duration getDelayUntilNextRun()\n                {\n                    return Duration.ofMillis(latch.getCount() > 1 ? 100 : -1);\n                }\n\n                @Override\n                protected void run()\n                {\n                    latch.countDown();\n                }\n            };\n\n        scheduledRunnable.schedule();\n\n        for (int i = 0; i < scheduleCount; i++)\n        {\n            timer.getClock().elapse(Duration.ofMillis(100));\n            timer.run();\n        }\n\n        assertEquals(1, latch.getCount());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java", "class_name": "PeriodicRunnableTests", "class_uri": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests.[void]cancelStopFurtherExecution()", "name": "cancelStopFurtherExecution", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void cancelStopFurtherExecution()", "original_string": "    @Test\n    public void cancelStopFurtherExecution()\n    {\n        final CountDownLatch latch = new CountDownLatch(2);\n        final PeriodicRunnable scheduledRunnable = PeriodicRunnable.create(\n            timer,\n            executor,\n            Duration.ofMillis(500),\n            latch::countDown);\n\n        scheduledRunnable.schedule();\n        timer.getClock().elapse(Duration.ofMillis(520));\n        timer.run();\n\n        // Check runnable executed once\n        assertEquals(1, latch.getCount());\n\n        scheduledRunnable.cancel();\n\n        timer.getClock().elapse(Duration.ofSeconds(1));\n        timer.run();\n        // Check runnable was not executed after cancel.\n        assertEquals(1, latch.getCount());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java", "class_name": "PeriodicRunnableTests", "class_uri": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests.[void]scheduleExecuteRunnableIfPreviouslyCancelled()", "name": "scheduleExecuteRunnableIfPreviouslyCancelled", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void scheduleExecuteRunnableIfPreviouslyCancelled()", "original_string": "    @Test\n    public void scheduleExecuteRunnableIfPreviouslyCancelled()\n    {\n        final CountDownLatch latch = new CountDownLatch(10);\n        final PeriodicRunnable scheduledRunnable = PeriodicRunnable.create(\n            timer,\n            executor,\n            Duration.ofMillis(200),\n            latch::countDown);\n\n        scheduledRunnable.schedule();\n        timer.getClock().elapse(Duration.ofMillis(220));\n        timer.run();\n\n        // Check runnable executed once\n        assertEquals(9, latch.getCount());\n\n        scheduledRunnable.cancel();\n\n        timer.getClock().elapse(Duration.ofSeconds(1));\n        timer.run();\n        // Check runnable was not executed after cancel.\n        assertEquals(9, latch.getCount());\n\n        // Schedule again\n        scheduledRunnable.schedule();\n        for (int i = 0; i < 5; i++)\n        {\n            timer.getClock().elapse(Duration.ofMillis(200));\n            timer.run();\n        }\n        assertEquals(4, latch.getCount());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java", "class_name": "PeriodicRunnableTests", "class_uri": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest.[void]testConnectTransferClose()", "name": "testConnectTransferClose", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    @Timeout(10)\n    public void testConnectTransferClose()", "original_string": "    @Test\n    @Timeout(10)\n    public void testConnectTransferClose() \n        throws IOException\n    {\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        int transferTimeout = 5000;\n\n        // bytes that will be read as a single byte\n        final int singleStepCount = 34;\n        final byte[] bufferSingle =\n            PseudoTcpTestBase.createDummyData(singleStepCount);\n        final int sizeA = 138746;\n        final byte[] bufferA = PseudoTcpTestBase.createDummyData(sizeA);\n        final int sizeB = 983746;\n        final byte[] bufferB = PseudoTcpTestBase.createDummyData(sizeB);\n        final PseudoTcpSocket server = \n            new PseudoTcpSocketFactory().createSocket();\n        server.setDebugName(\"L\");\n        server.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n        final InetSocketAddress serverAddress =\n            new InetSocketAddress(InetAddress.getLoopbackAddress(), server.getLocalPort());\n        AtomicBoolean clientThreadEnded = new AtomicBoolean();\n        AtomicBoolean serverThreadEnded = new AtomicBoolean();\n        Thread serverThread = new Thread(() ->\n        {\n            try\n            {\n                server.accept(5000);\n                byte[] rcvdSingle = new byte[singleStepCount];\n                // read by one byte\n                for (int i = 0; i < singleStepCount; i++)\n                    rcvdSingle[i] = (byte) server.getInputStream().read();\n                assertArrayEquals(bufferSingle, rcvdSingle);\n                // receive buffer A\n                byte[] recvdBufferA =\n                    receiveBuffer(server.getInputStream(), sizeA);\n                assertArrayEquals(bufferA, recvdBufferA);\n                // receive buffer B\n                byte[] recvdBufferB =\n                    receiveBuffer(server.getInputStream(), sizeB);\n                assertArrayEquals(bufferB, recvdBufferB);\n                // server.close();\n                serverThreadEnded.set(true);\n            }\n            catch (IOException ex)\n            {\n                throw new RuntimeException(ex);\n            }\n        });\n\n        final PseudoTcpSocket client = \n            new PseudoTcpSocketFactory().createSocket();\n        Thread clientThread = new Thread(() ->\n        {\n            try\n            {\n                client.setDebugName(\"R\");\n                client.connect(serverAddress, 5000);\n                OutputStream os = client.getOutputStream();\n\n                // write single array\n                for (int i = 0; i < singleStepCount; i++)\n                    os.write(bufferSingle[i]);\n\n                // write whole array\n                os.write(bufferA);\n\n                // write by parts\n                int partCount = 7;\n                boolean notExact = sizeB % partCount != 0;\n                int[] partsSize =\n                    notExact ? new int[partCount + 1] : new int[partCount];\n                for (int i = 0; i < partsSize.length; i++)\n                {\n                    if (notExact && i == partCount)\n                        partsSize[i] = sizeB % partCount;\n                    else\n                        partsSize[i] = sizeB / partCount;\n                }\n                int written = 0;\n                for (int j : partsSize)\n                {\n                    os.write(bufferB, written, j);\n                    written += j;\n                }\n                assertEquals(sizeB, written);\n                os.flush();\n                client.close();\n                clientThreadEnded.set(true);\n            }\n            catch (IOException ex)\n            {\n                throw new RuntimeException(ex);\n            }\n        });\n\n        serverThread.start();\n        clientThread.start();\n        try\n        {\n            boolean success = assert_wait_until(\n                () -> client.getState() == PseudoTcpState.TCP_CLOSED,\n                transferTimeout);\n            if (success)\n            {\n                clientThread.join(10_000);\n                if (!clientThreadEnded.get())\n                {\n                    fail(\"client thread did not end\");\n                }\n                serverThread.join(10_000);\n                if (!serverThreadEnded.get())\n                {\n                    fail(\"server thread did not end\");\n                }\n                server.close();\n            }\n            else\n            {\n                fail(\"Transfer timeout\");\n            }\n        }\n        catch (InterruptedException ex)\n        {\n            throw new RuntimeException(ex);\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java", "class_name": "PseudoTcpStreamTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest", "attributes": {"modifiers": "@Test\n    @Timeout(10)\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@Timeout(10)", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest one-way transfer with @link(PseudoTcpStream)\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest.[void]testAccept()", "name": "testAccept", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testAccept()", "original_string": "    @Test\n    public void testAccept()\n    {\n        assertThrows(IOException.class, ()->\n        {\n            PseudoTcpSocketImpl server = new PseudoTcpSocketImpl(0);\n            server.accept(10);\n        });\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java", "class_name": "PseudoTcpStreamTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest the timeout on accept method\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest.[void]testReadTimeout()", "name": "testReadTimeout", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testReadTimeout()", "original_string": "    @Test\n    public void testReadTimeout() throws Exception\n    {\n        doTestTimeout(socket ->\n        {\n            socket.setPTCPOption(Option.OPT_READ_TIMEOUT, 300);\n            socket.getInputStream().read(new byte[500]);                \n        });\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java", "class_name": "PseudoTcpStreamTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests timeout on read method\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest.[void]testWriteTimeout()", "name": "testWriteTimeout", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testWriteTimeout()", "original_string": "    @Test\n    public void testWriteTimeout() throws Exception\n    {\n        doTestTimeout(socket ->\n        {\n            //buffer that will exceed stack's buffer size\n            byte[] bigBuffer = new byte[PseudoTCPBase.DEFAULT_SND_BUF_SIZE*2];\n            socket.setPTCPOption(Option.OPT_WRITE_TIMEOUT, 300);\n            socket.getOutputStream().write(bigBuffer);\n        });\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java", "class_name": "PseudoTcpStreamTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests timeout on write method\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest.[void]testFlushTimeout()", "name": "testFlushTimeout", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testFlushTimeout()", "original_string": "    @Test\n    public void testFlushTimeout() throws Exception\n    {\n        doTestTimeout(socket ->\n        {\n            //buffer that will exceed stack's buffer size\n            byte[] buffer = new byte[PseudoTCPBase.DEFAULT_SND_BUF_SIZE];\n            socket.setPTCPOption(Option.OPT_WRITE_TIMEOUT, 300);\n            try\n            {\n                socket.getOutputStream().write(buffer);\n            }\n            catch(IOException e)\n            {\n                throw new RuntimeException(\"Unexpected exception: \"+e);\n            }\n            socket.getOutputStream().flush();\n        });\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java", "class_name": "PseudoTcpStreamTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests timeout on flush method\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]testGetShadowedBytes()", "name": "testGetShadowedBytes", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetShadowedBytes()", "original_string": "    @Test\n    public void testGetShadowedBytes()\n    {\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(0) == 0);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(1) == 1);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(2) == 3);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(3) == 7);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(4) == 15);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(11) == 2047);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(14) == 16383);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]testReceiveWindow()", "name": "testReceiveWindow", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testReceiveWindow()", "original_string": "    @Test\n    public void testReceiveWindow()\n    {\n        //logger.log(Level.INFO, \"Test receive window\");\n        PseudoTcpTestRecvWindow test = new PseudoTcpTestRecvWindow();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptNagling(false);\n        test.setOptAckDelay(0);\n        test.doTestTransfer(1024 * 1000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest that receive window expands and contract correctly.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]testSetVerySmallSendWindowSize()", "name": "testSetVerySmallSendWindowSize", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSetVerySmallSendWindowSize()", "original_string": "    @Test\n    public void testSetVerySmallSendWindowSize()\n    {\n        //TODO: finish test\n        logger.log(Level.INFO, \"Test very small receive window\");\n        PseudoTcpTestRecvWindow test = new PseudoTcpTestRecvWindow();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptNagling(false);\n        test.setOptAckDelay(0);\n        test.setOptSndBuf(900);\n        test.doTestTransfer(1024 * 1000);\n        assertEquals(900, test.estimateSendWindowSize());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest setting send window size to a very small value.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]testSetReceiveWindowSize()", "name": "testSetReceiveWindowSize", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSetReceiveWindowSize()", "original_string": "    @Test\n    public void testSetReceiveWindowSize()\n    {\n        //logger.log(Level.INFO, \"Test set receive window size\");\n        PseudoTcpTestRecvWindow test = new PseudoTcpTestRecvWindow();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptNagling(false);\n        test.setOptAckDelay(0);\n        int wndSize = 300000;\n        // if window scaling is not supported by either local or remote, use \n        // default size\n        if (!test.getLocalTcp().m_support_wnd_scale || \n            !test.getRemoteTcp().m_support_wnd_scale)\n        {\n        \twndSize = 65535;\n        }\n        test.setLocalOptSndBuf(wndSize);        \t\n        test.setRemoteOptRcvBuf(wndSize);\n        int wndScale = test.getRemoteScaleFactor();\n        //logger.log(Level.INFO, \"Using scale factor: {0}\", wndScale);\n        test.doTestTransfer(1024 * 3000);\n        //beacuse there may be situations \n        //when 1 byte may be waiting in send queue\n        //before \n        //scaling factor == 1 not allows to determine exact window size (+-1)\n        assert (wndSize - test.estimateReceiveWindowSize()\n            <= PseudoTcpTestRecvWindow.getShadowedBytes(wndScale));\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest setting receive window size to a value other than default.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSend()", "name": "testSend", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSend()", "original_string": "    @Test\n    public void testSend()\n    {\n        //logger.log(Level.INFO, \"Test send\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.doTestTransfer(1000000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nBasic end-to-end data transfer tests Test the normal case of sending data\nfrom one side to the other.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendWithDelay()", "name": "testSendWithDelay", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendWithDelay()", "original_string": "    @Test\n    public void testSendWithDelay()\n    {\n        //logger.log(Level.INFO, \"Test send with delay\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setDelay(50);\n        test.doTestTransfer(1000000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending data with a 50 ms RTT. Transmission should take longer due\nto a slower ramp-up in send rate.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendWithLoss()", "name": "testSendWithLoss", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendWithLoss()", "original_string": "    @Test\n    public void testSendWithLoss()\n    {\n        //logger.log(Level.INFO, \"Test send with loss\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setLoss(10);\n        test.doTestTransfer(100000);  // less data so test runs faster\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending data with packet loss. Transmission should take much longer\ndue to send back-off when loss occurs.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendWithDelayAndLoss()", "name": "testSendWithDelayAndLoss", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendWithDelayAndLoss()", "original_string": "    @Test\n    public void testSendWithDelayAndLoss()\n    {\n        //logger.log(Level.INFO, \"Test send with delay and loss\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setDelay(50);\n        test.setLoss(10);\n        test.doTestTransfer(100000);  // less data so test runs faster\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending data with a 50 ms RTT and 10% packet loss. Transmission\nshould take much longer due to send back-off and slower detection of\nloss.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendWithLossAndOptNaglingOff()", "name": "testSendWithLossAndOptNaglingOff", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendWithLossAndOptNaglingOff()", "original_string": "    @Test\n    public void testSendWithLossAndOptNaglingOff()\n    {\n        //logger.log(Level.INFO, \"Test send with loss and OptNagling off\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setLoss(10);\n        test.setOptNagling(false);\n        test.doTestTransfer(100000);  // less data so test runs faster\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending data with 10% packet loss and Nagling disabled. Transmission\nshould take about the same time as with Nagling enabled.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendWithLossAndOptAckDelayOff()", "name": "testSendWithLossAndOptAckDelayOff", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendWithLossAndOptAckDelayOff()", "original_string": "    @Test\n    public void testSendWithLossAndOptAckDelayOff()\n    {\n        //logger.log(Level.INFO, \"Test send with loss and OptAckDelay off\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setLoss(10);\n        test.setOptAckDelay(0);\n        test.doTestTransfer(100000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending data with 10% packet loss and Delayed ACK disabled.\nTransmission should be slightly faster than with it enabled.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendWithDelayAndOptNaglingOff()", "name": "testSendWithDelayAndOptNaglingOff", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendWithDelayAndOptNaglingOff()", "original_string": "    @Test\n    public void testSendWithDelayAndOptNaglingOff()\n    {\n        //logger.log(Level.INFO, \"Test send with delay and OptNagling off\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setDelay(50);\n        test.setOptNagling(false);\n        test.doTestTransfer(100000);  // less data so test runs faster\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending data with 50ms delay and Nagling disabled.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendWithDelayAndOptAckDelayOff()", "name": "testSendWithDelayAndOptAckDelayOff", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendWithDelayAndOptAckDelayOff()", "original_string": "    @Test\n    public void testSendWithDelayAndOptAckDelayOff()\n    {\n        //logger.log(Level.INFO, \"Test send with delay and OptAckDelay off\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setDelay(50);\n        test.setOptAckDelay(0);\n        test.doTestTransfer(100000);  // less data so test runs faster\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending data with 50ms delay and Delayed ACK disabled.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendRemoteNoWindowScale()", "name": "testSendRemoteNoWindowScale", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendRemoteNoWindowScale()", "original_string": "    @Test\n    public void testSendRemoteNoWindowScale()\n    {\n        //logger.log(Level.INFO, \"Test send - remote no window scale\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setLocalOptRcvBuf(100000);\n        test.disableRemoteWindowScale();\n        test.doTestTransfer(1000000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest a large receive buffer with a sender that doesn't support scaling.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendLocalNoWindowScale()", "name": "testSendLocalNoWindowScale", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendLocalNoWindowScale()", "original_string": "    @Test\n    public void testSendLocalNoWindowScale()\n    {\n        //logger.log(Level.INFO, \"Test send - local no window scale\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(100000);\n        test.disableLocalWindowScale();\n        test.doTestTransfer(1000000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest a large sender-side receive buffer with a receiver that doesn't\nsupport scaling.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendBothUseWindowScale()", "name": "testSendBothUseWindowScale", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendBothUseWindowScale()", "original_string": "    @Test\n    public void testSendBothUseWindowScale()\n    {\n        //logger.log(Level.INFO, \"Test send - both use window scale\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(100000);\n        test.setLocalOptRcvBuf(100000);\n        test.doTestTransfer(1000000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest when both sides use window scaling.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendLargeInFlight()", "name": "testSendLargeInFlight", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendLargeInFlight()", "original_string": "    @Test\n    public void testSendLargeInFlight()\n    {\n        //logger.log(Level.INFO, \"Test send large in flight\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(100000);\n        test.setLocalOptRcvBuf(100000);\n        test.setOptSndBuf(150000);\n        test.doTestTransfer(1000000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest using a large window scale value.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendBothUseLargeWindowScale()", "name": "testSendBothUseLargeWindowScale", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendBothUseLargeWindowScale()", "original_string": "    @Test\n    public void testSendBothUseLargeWindowScale()\n    {\n        //logger.log(Level.INFO, \"Test send both use large window scale\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(1000000);\n        test.setLocalOptRcvBuf(1000000);\n        test.doTestTransfer(10000000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendSmallReceiveBuffer()", "name": "testSendSmallReceiveBuffer", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendSmallReceiveBuffer()", "original_string": "    @Test\n    public void testSendSmallReceiveBuffer()\n    {\n        //logger.log(Level.INFO, \"Test send small receive buffer\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(10000);\n        test.setLocalOptRcvBuf(10000);\n        test.doTestTransfer(1000000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest using a small receive buffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]testSendVerySmallReceiveBuffer()", "name": "testSendVerySmallReceiveBuffer", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSendVerySmallReceiveBuffer()", "original_string": "    @Test\n    public void testSendVerySmallReceiveBuffer()\n    {\n        //logger.log(Level.INFO, \"Test send very small receive buffer\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(100);\n        test.setLocalOptRcvBuf(100);\n        test.doTestTransfer(100000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest using a very small receive buffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]testPingPong1xMtu()", "name": "testPingPong1xMtu", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testPingPong1xMtu()", "original_string": "    @Test\n    public void testPingPong1xMtu()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong 1xMTU\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.doTestPingPong(100, 100);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending <= 1x MTU of data in each ping/pong. Should take <10ms.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]testPingPong3xMtu()", "name": "testPingPong3xMtu", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testPingPong3xMtu()", "original_string": "    @Test\n    public void testPingPong3xMtu()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong 3xMTU\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.doTestPingPong(400, 100);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending 2x-3x MTU of data in each ping/pong. Should take <10ms.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]testPingPong2xMtu()", "name": "testPingPong2xMtu", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testPingPong2xMtu()", "original_string": "    @Test\n    public void testPingPong2xMtu()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong 2xMTU\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.doTestPingPong(2000, 5);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending 1x-2x MTU of data in each ping/pong. Should take ~1s, due to\ninteraction between Nagling and Delayed ACK.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]testPingPong2xMtuWithAckDelayOff()", "name": "testPingPong2xMtuWithAckDelayOff", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testPingPong2xMtuWithAckDelayOff()", "original_string": "    @Test\n    public void testPingPong2xMtuWithAckDelayOff()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong 2xMTU ack delay off\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptAckDelay(0);\n        test.doTestPingPong(2000, 100);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending 1x-2x MTU of data in each ping/pong with Delayed ACK off.\nShould take <10ms.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]testPingPong2xMtuWithNaglingOff()", "name": "testPingPong2xMtuWithNaglingOff", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testPingPong2xMtuWithNaglingOff()", "original_string": "    @Test\n    public void testPingPong2xMtuWithNaglingOff()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong 2xMTU nagling off\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptNagling(false);\n        test.doTestPingPong(2000, 5);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending 1x-2x MTU of data in each ping/pong with Nagling off. Should\ntake <10ms.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]testPingPongShortSegments()", "name": "testPingPongShortSegments", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testPingPongShortSegments()", "original_string": "    @Test\n    public void testPingPongShortSegments()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong short segments\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptAckDelay(5000);\n        test.setBytesPerSend(50); // i.e. two Send calls per payload\n        test.doTestPingPong(100, 5);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending a ping as pair of short (non-full) segments. Should take\n~1s, due to Delayed ACK interaction with Nagling.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]testPingPongShortSegmentsWithNaglingOff()", "name": "testPingPongShortSegmentsWithNaglingOff", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testPingPongShortSegmentsWithNaglingOff()", "original_string": "    @Test\n    public void testPingPongShortSegmentsWithNaglingOff()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong short segments nagling off\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptNagling(false);\n        test.setBytesPerSend(50); // i.e. two Send calls per payload\n        test.doTestPingPong(100, 5);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending ping as a pair of short (non-full) segments, with Nagling\noff. Should take <10ms.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]testPingPongShortSegmentsWithAckDelayOff()", "name": "testPingPongShortSegmentsWithAckDelayOff", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testPingPongShortSegmentsWithAckDelayOff()", "original_string": "    @Test\n    public void testPingPongShortSegmentsWithAckDelayOff()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong short segments nagling off\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setBytesPerSend(50); // i.e. two Send calls per payload\n        test.setOptAckDelay(0);\n        test.doTestPingPong(100, 5);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest sending <= 1x MTU of data ping/pong, in two segments, no Delayed\nACK. Should take ~1s.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testLength()", "name": "testLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testLength()", "original_string": "    @Test\n    public void testLength()\n    {\n        int expResult = 1000;\n        ByteFifoBuffer instance = new ByteFifoBuffer(expResult);\n        assertEquals(expResult, instance.length());\n        int wSize = 100;\n        instance.write(getWData(wSize), wSize);\n        int result = instance.length();\n        assertEquals(expResult, result);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest of Length method, of class ByteFifoBuffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testRead()", "name": "testRead", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRead()", "original_string": "    @Test\n    public void testRead()\n    {\n        int count = 1024;\n        byte[] wData = getWData(count);\n        ByteFifoBuffer instance = new ByteFifoBuffer(count);\n        instance.write(wData, count);\n\n        byte[] readBuff = new byte[count];\n        int result = instance.read(readBuff, count);\n        assertEquals(count, result);\n        assertArrayEquals(wData, readBuff);\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest of Read method, of class ByteFifoBuffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testReadWithOffset()", "name": "testReadWithOffset", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testReadWithOffset()", "original_string": "    @Test\n    public void testReadWithOffset()\n    {\n        int count = 1024;\n        byte[] wData = getWData(count);\n        ByteFifoBuffer instance = new ByteFifoBuffer(count);\n        instance.write(wData, count);\n\n        byte[] readBuff = new byte[count];\n        int expResult = count / 2;\n        int result = instance.read(readBuff, count / 2);\n        assertEquals(expResult, result);\n\n        result = instance.read(readBuff, count / 2, count / 2);\n        assertEquals(expResult, result);\n\n        assertArrayEquals(wData, readBuff);\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTests reading with an offset for destination buffer\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testGetWriteRemaining()", "name": "testGetWriteRemaining", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetWriteRemaining()", "original_string": "    @Test\n    public void testGetWriteRemaining()\n    {\n        int len = 100;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        int expResult = len;\n        int result = instance.getWriteRemaining();\n        assertEquals(expResult, result);\n\n        int w_size = 23;\n        byte[] w_data = getWData(w_size);\n        instance.write(w_data, w_size);\n\n        expResult = len - w_size;\n        result = instance.getWriteRemaining();\n        assertEquals(expResult, result);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest of GetWriteRemaining method, of class ByteFifoBuffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testGetBuffered()", "name": "testGetBuffered", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testGetBuffered()", "original_string": "    @Test\n    public void testGetBuffered()\n    {\n        int len = 1000;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        int w_len = 100;\n        byte[] w_data = getWData(w_len);\n\n        instance.write(w_data, w_len);\n\n        int expResult = w_len;\n        int result = instance.getBuffered();\n        assertEquals(expResult, result);\n        int consume = 5;\n        expResult = w_len + consume;\n        instance.consumeWriteBuffer(consume);\n        result = instance.getBuffered();\n        assertEquals(expResult, result);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest of GetBuffered method, of class ByteFifoBuffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testWrite()", "name": "testWrite", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testWrite()", "original_string": "    @Test\n    public void testWrite()\n    {\n        int len = 2048;\n        byte[] data = getWData(len);\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        int result = instance.write(data, len);\n        assertEquals(len, result);\n\n        byte[] read = new byte[len];\n        int readCount = instance.read(read, len);\n        assertEquals(result, readCount);\n        assertArrayEquals(data, read);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest of Write method, of class ByteFifoBuffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testWriteWithOffset()", "name": "testWriteWithOffset", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testWriteWithOffset()", "original_string": "    @Test\n    public void testWriteWithOffset()\n    {\n        int len = 2048;\n        byte[] data = getWData(len);\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        int expResult = len / 2;\n        int result = instance.write(data, 0, len / 2);\n        assertEquals(expResult, result);\n        result = instance.write(data, len / 2, len / 2);\n        assertEquals(expResult, result);\n\n        byte[] read = new byte[len];\n        int readCount = instance.read(read, len);\n        assertEquals(len, readCount);\n        assertArrayEquals(data, read);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testConsumeWriteBuffer()", "name": "testConsumeWriteBuffer", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testConsumeWriteBuffer()", "original_string": "    @Test\n    public void testConsumeWriteBuffer()\n    {\n        int len = 100;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        instance.consumeWriteBuffer(len / 2);\n        instance.consumeWriteBuffer(len / 2);\n        try\n        {\n            instance.consumeWriteBuffer(1);\n            fail();\n        }\n        catch (BufferOverflowException e)\n        {\n        }\n\n        instance = new ByteFifoBuffer(len);\n        instance.consumeWriteBuffer(95);\n        instance.consumeReadData(40);\n        instance.consumeWriteBuffer(20);\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest of ConsumeWriteBuffer method, of class ByteFifoBuffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testSetCapacity()", "name": "testSetCapacity", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSetCapacity()", "original_string": "    @Test\n    public void testSetCapacity()\n    {\n        int old_size = 100;\n        int new_size = 200;\n        ByteFifoBuffer instance = new ByteFifoBuffer(old_size);\n        boolean expResult = true;\n        instance.write(getWData(old_size), old_size);\n        boolean result = instance.setCapacity(new_size);\n        assertEquals(expResult, result);\n\n        expResult = false;\n        instance.resetWritePosition();\n        instance.write(getWData(new_size), new_size);\n        result = instance.setCapacity(old_size);\n        assertEquals(expResult, result);\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest of SetCapacity method, of class ByteFifoBuffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testConsumeReadData()", "name": "testConsumeReadData", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testConsumeReadData()", "original_string": "    @Test\n    public void testConsumeReadData()\n    {\n        int lCount = 100;\n        ByteFifoBuffer instance = new ByteFifoBuffer(lCount);\n        instance.write(getWData(lCount), lCount);\n        instance.consumeReadData(lCount / 2);\n        instance.consumeReadData(lCount / 2);\n        try\n        {\n            instance.consumeReadData(1);\n            fail();\n        }\n        catch (BufferUnderflowException e)\n        {\n        }\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest of ConsumeReadData method, of class ByteFifoBuffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testReadOffset()", "name": "testReadOffset", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testReadOffset()", "original_string": "    @Test\n    public void testReadOffset()\n    {\n        int dst_buff_offset = 0;\n        int len = 100;\n        byte[] src_buff = getWData(len);\n        byte[] dst_buff = new byte[len];\n        int offset = 0;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        instance.write(src_buff, len);\n        int result =\n            instance.readOffset(dst_buff, dst_buff_offset, len, offset);\n        assertEquals(len, result);\n        assertArrayEquals(dst_buff, src_buff);\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest of ReadOffset method, of class ByteFifoBuffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testWriteOffset()", "name": "testWriteOffset", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testWriteOffset()", "original_string": "    @Test\n    public void testWriteOffset()\n    {\n        int len = 200;\n        int dataLen = 100;\n        byte[] srcData = getWData(dataLen);\n        byte[] data = new byte[dataLen];\n        int nOffset = 10;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        int result = instance.writeOffset(srcData, dataLen, nOffset);\n        int readCount = instance.readOffset(data, 0, dataLen, nOffset);\n        assertEquals(result, readCount);\n        assertArrayEquals(srcData, data);\n\n        byte[] halfFilled = new byte[dataLen * 2];\n        System.arraycopy(srcData, 0, halfFilled, dataLen, dataLen);\n        byte[] halfFilledRead = new byte[dataLen * 2];\n        instance.readOffset(halfFilledRead, dataLen, dataLen, nOffset);\n        assertArrayEquals(halfFilled, halfFilledRead);\n\n        // case when w_pos+offset exceeds current backing array length\n        instance = new ByteFifoBuffer(len);\n        instance.write(srcData, dataLen);\n        instance.write(srcData, dataLen / 2);// current writePos = 150\n        instance.read(data, dataLen);// curretn readPos = 100\n        instance.writeOffset(srcData, dataLen, 50);\n\n        instance = new ByteFifoBuffer(61440);\n        instance.writeOffset(getWData(1384), 1384, 31832);\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTest of WriteOffset method, of class ByteFifoBuffer.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testWriteReadWriteRead()", "name": "testWriteReadWriteRead", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testWriteReadWriteRead()", "original_string": "    @Test\n    public void testWriteReadWriteRead()\n    {\n        int len = 2000;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        byte[] wrData = getWData(len * 2);\n        int written = 0;\n        byte[] readBuff = new byte[wrData.length];\n        int read = 0;\n        do\n        {\n            int wrRemaining = instance.getWriteRemaining();\n            if (wrRemaining > 0 && written < wrData.length)\n            {\n                int wrCount = instance.writeOffset(wrData, wrRemaining, 0);\n                instance.consumeWriteBuffer(wrCount);\n                written += wrCount;\n            }\n            int readAvailable = instance.getBuffered();\n            if (readAvailable > 0)\n            {\n                int rCount =\n                    instance.readOffset(readBuff, read, readAvailable, 0);\n                instance.consumeReadData(rCount);\n                read += rCount;\n            }\n        }\n        while ((read != wrData.length) || (written != wrData.length));\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[void]testSomeMultiTest()", "name": "testSomeMultiTest", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSomeMultiTest()", "original_string": "    @Test\n    public void testSomeMultiTest()\n    {\n        int Alen = 16;\n        int Blen = 32;\n        int Clen = 64;\n        int Dlen = 256;\n        int len = Alen + Blen + Clen + Dlen;\n        ByteFifoBuffer fifo = new ByteFifoBuffer(len);\n        byte[] A = getWData(Alen);\n        /*byte[] B =*/ getWData(Blen);\n        /*byte[] C =*/ getWData(Clen);\n        /*byte[] D =*/ getWData(Dlen);\n        byte[] Aread = getWData(Alen);\n        /*byte[] Bread =*/ getWData(Blen);\n        /*byte[] Cread =*/ getWData(Clen);\n        /*byte[] Dread =*/ getWData(Dlen);\n\n        fifo.writeOffset(A, Alen, 0);\n        fifo.consumeWriteBuffer(Alen);\n        fifo.readOffset(Aread, 0, Alen, 0);\n        assertArrayEquals(A, Aread);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]testRecoveryFromBothControlledConflict()", "name": "testRecoveryFromBothControlledConflict", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecoveryFromBothControlledConflict()", "original_string": "    @Test\n    public void testRecoveryFromBothControlledConflict()\n        throws Throwable\n    {\n        testRecoveryFromRoleConflict(false);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java", "class_name": "RoleConflictResolutionTest", "class_uri": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]testRecoveryFromBothControllingConflict()", "name": "testRecoveryFromBothControllingConflict", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRecoveryFromBothControllingConflict()", "original_string": "    @Test\n    public void testRecoveryFromBothControllingConflict()\n        throws Throwable\n    {\n        testRecoveryFromRoleConflict(true);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java", "class_name": "RoleConflictResolutionTest", "class_uri": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvesterTest.java.SinglePortUdpHarvesterTest.[void]testRebindWithoutCloseThrows()", "name": "testRebindWithoutCloseThrows", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRebindWithoutCloseThrows()", "original_string": "    @Test\n    public void testRebindWithoutCloseThrows() throws Exception\n    {\n        // Setup test fixture.\n        final TransportAddress address = new TransportAddress( \"127.0.0.1\", 10000, Transport.UDP );\n        SinglePortUdpHarvester firstHarvester;\n        try\n        {\n            firstHarvester = new SinglePortUdpHarvester( address );\n        }\n        catch (BindException ex)\n        {\n            // This is not expected at this stage (the port is likely already in use by another process, voiding this\n            // test). Rethrow as a different exception than the BindException, that is expected to be thrown later in\n            // this test.\n            throw new Exception( \"Test fixture is invalid.\", ex );\n        }\n\n        // Execute system under test.\n        SinglePortUdpHarvester secondHarvester = null;\n        try\n        {\n            secondHarvester = new SinglePortUdpHarvester( address );\n            fail(\"expected BindException to be thrown at this point\");\n        }\n        catch (BindException ex)\n        {\n            //expected, do nothing\n        }\n        finally\n        {\n            // Tear down\n            firstHarvester.close();\n            if (secondHarvester != null)\n            {\n                secondHarvester.close();\n            }\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvesterTest.java", "class_name": "SinglePortUdpHarvesterTest", "class_uri": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvesterTest.java.SinglePortUdpHarvesterTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nVerifies that, without closing, the address used by a harvester cannot be re-used.\n\n@see <a href=\"https://github.com/jitsi/ice4j/issues/139\">https://github.com/jitsi/ice4j/issues/139</a>\n"}, {"uris": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvesterTest.java.SinglePortUdpHarvesterTest.[void]testRebindWithClose()", "name": "testRebindWithClose", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRebindWithClose()", "original_string": "    @Test\n    public void testRebindWithClose() throws Exception\n    {\n        // Setup test fixture.\n        final TransportAddress address = new TransportAddress( \"127.0.0.1\", 10001, Transport.UDP );\n        final SinglePortUdpHarvester firstHarvester = new SinglePortUdpHarvester( address );\n        firstHarvester.close();\n        Thread.sleep( 500 ); // give thread time to close/clean up.\n\n        // Execute system under test.\n        SinglePortUdpHarvester secondHarvester = null;\n\n        try\n        {\n            secondHarvester = new SinglePortUdpHarvester( address );\n        }\n\n        // Verify results.\n        catch ( BindException ex )\n        {\n            fail( \"A bind exception should not have been thrown, as the original harvester was properly closed.\");\n        }\n\n        // Tear down.\n        finally\n        {\n            if ( secondHarvester != null )\n            {\n                secondHarvester.close();\n            }\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvesterTest.java", "class_name": "SinglePortUdpHarvesterTest", "class_uri": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvesterTest.java.SinglePortUdpHarvesterTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nVerifies that, after closing, the address used by a harvester can be re-used.\n\n@see <a href=\"https://github.com/jitsi/ice4j/issues/139\">https://github.com/jitsi/ice4j/issues/139</a>\n"}, {"uris": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvesterTest.java.SinglePortUdpHarvesterTest.[void]testBindWithPortZero()", "name": "testBindWithPortZero", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testBindWithPortZero()", "original_string": "    @Test\n    public void testBindWithPortZero() throws Exception\n    {\n        // Setup test fixture.\n        final TransportAddress address = new TransportAddress(\"127.0.0.1\", 0, Transport.UDP);\n        SinglePortUdpHarvester harvester;\n        try\n        {\n            harvester = new SinglePortUdpHarvester(address);\n        }\n        catch (BindException ex)\n        {\n            // This is not expected at this stage.\n            // Rethrow as a different exception than the BindException, that is expected to be thrown later in\n            // this test.\n            throw new Exception(\"Test fixture is invalid.\", ex);\n        }\n\n        assertFalse(harvester.localAddress.getPort() == 0,\n                \"A random port number not equal to zero should have been chosen by the OS\");\n\n        // Tear down\n        harvester.close();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvesterTest.java", "class_name": "SinglePortUdpHarvesterTest", "class_uri": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvesterTest.java.SinglePortUdpHarvesterTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}]