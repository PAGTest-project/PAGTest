[{"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "name": "Matchers", "file_path": "src/test/java/net/hydromatic/morel/Matchers.java", "superclasses": "", "methods": ["[]Matchers()", "[Matcher<Ast.Literal>]isLiteral(Comparable,String)", "[Matcher<AstNode>]isAst(boolean,String)", "[Matcher<T>]isAst(Class<? extends T>,boolean,String)", "[Matcher<Code>]isCode(String)", "[Matcher<Code>]isCode2(String)", "[Matcher<Code>]isFullyCalcite()", "[List<Object>]list()", "[Map<Object, Object>]map()", "[Matcher<Iterable<E>>]equalsUnordered()", "[Matcher<Iterable<E>>]equalsOrdered()", "[Matcher<E>]isUnordered(E)", "[Matcher<Throwable>]throwsA(String)", "[Matcher<Throwable>]throwsA(String,Pos)", "[Matcher<T>]throwsA(Class<T>,String,Pos)", "[Matcher<T>]throwsA(Class<T>,String)", "[Matcher<Throwable>]throwsA(Class<T>,Matcher<?>)", "[LearningMatcher<T>]learning(Class<T>)", "[Matcher<Object>]whenAppliedTo(Object,Matcher<Object>)", "[Matcher<Type>]hasMoniker(String)", "[Matcher<DataType>]hasTypeConstructors(String)", "[Matcher<T>]instanceOfAnd(Class<T2>,Matcher<T2>)"], "method_uris": ["src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[]Matchers()", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Ast.Literal>]isLiteral(Comparable,String)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<AstNode>]isAst(boolean,String)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<T>]isAst(Class<? extends T>,boolean,String)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Code>]isCode(String)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Code>]isCode2(String)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Code>]isFullyCalcite()", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[List<Object>]list()", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Map<Object, Object>]map()", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Iterable<E>>]equalsUnordered()", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Iterable<E>>]equalsOrdered()", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<E>]isUnordered(E)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Throwable>]throwsA(String)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Throwable>]throwsA(String,Pos)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<T>]throwsA(Class<T>,String,Pos)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<T>]throwsA(Class<T>,String)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Throwable>]throwsA(Class<T>,Matcher<?>)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[LearningMatcher<T>]learning(Class<T>)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Object>]whenAppliedTo(Object,Matcher<Object>)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Type>]hasMoniker(String)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<DataType>]hasTypeConstructors(String)", "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<T>]instanceOfAnd(Class<T2>,Matcher<T2>)"], "overrides": null, "attributes": [{"original_string": "  private abstract static class MatcherWithConsumer<T> extends BaseMatcher<T> {\n    final Matcher<T> matcher;\n\n    MatcherWithConsumer(Matcher<T> matcher) {\n      this.matcher = matcher;\n    }\n\n    protected abstract void consume(T t);\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean matches(Object o) {\n      if (matcher.matches(o)) {\n        consume((T) o);\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    @Override public void describeMismatch(Object o,\n        Description description) {\n      matcher.describeMismatch(o, description);\n    }\n\n    @Override public void describeTo(Description description) {\n      matcher.describeTo(description);\n    }\n  }", "definition": "  private abstract static class MatcherWithConsumer<T> extends BaseMatcher<T>", "class_docstring": " Matcher that performs an action when a value is matched.\n\n@param <T> Type of expected item", "name": "MatcherWithConsumer", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private abstract static", "marker_annotations": [], "non_marker_annotations": ["private", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "final Matcher<T> matcher;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Matcher<T>", "name": "matcher", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    MatcherWithConsumer(Matcher<T> matcher) {\n      this.matcher = matcher;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MatcherWithConsumer", "params": [{"name": "matcher", "type": "Matcher<T>"}], "body": "                                            {\n      this.matcher = matcher;\n    }", "signature": "MatcherWithConsumer(Matcher<T> matcher)"}, {"syntax_pass": true, "original_string": "    protected abstract void consume(T t);", "docstring": "", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "void", "classes": []}, "name": "consume", "params": [{"name": "t", "type": "T"}], "body": "", "signature": "protected abstract void consume(T t)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public boolean matches(Object o) {\n      if (matcher.matches(o)) {\n        consume((T) o);\n        return true;\n      } else {\n        return false;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "o", "type": "Object"}], "body": "                                               {\n      if (matcher.matches(o)) {\n        consume((T) o);\n        return true;\n      } else {\n        return false;\n      }\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public boolean matches(Object o)"}, {"syntax_pass": true, "original_string": "    @Override public void describeMismatch(Object o,\n        Description description) {\n      matcher.describeMismatch(o, description);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "describeMismatch", "params": [{"name": "o", "type": "Object"}, {"name": "description", "type": "Description"}], "body": "                                 {\n      matcher.describeMismatch(o, description);\n    }", "signature": "@Override public void describeMismatch(Object o,\n        Description description)"}, {"syntax_pass": true, "original_string": "    @Override public void describeTo(Description description) {\n      matcher.describeTo(description);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "describeTo", "params": [{"name": "description", "type": "Description"}], "body": "                                                              {\n      matcher.describeTo(description);\n    }", "signature": "@Override public void describeTo(Description description)"}]}, {"original_string": "  private static class LearningMatcherImpl<T> extends MatcherWithConsumer<T>\n      implements LearningMatcher<T> {\n    final List<T> list = new ArrayList<>();\n\n    LearningMatcherImpl(Matcher<T> matcher) {\n      super(matcher);\n    }\n\n    @Override public T get() {\n      return list.get(0);\n    }\n\n    @Override protected void consume(T t) {\n      list.add(t);\n    }\n  }", "definition": "  private static class LearningMatcherImpl<T> extends MatcherWithConsumer<T>\n      implements LearningMatcher<T>", "class_docstring": " Implementation of {@link LearningMatcher}.\n\n@param <T> Type of expected item", "name": "LearningMatcherImpl", "super_interfaces": ["LearningMatcher<T>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final List<T> list = new ArrayList<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<T>", "name": "list = new ArrayList<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    LearningMatcherImpl(Matcher<T> matcher) {\n      super(matcher);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "LearningMatcherImpl", "params": [{"name": "matcher", "type": "Matcher<T>"}], "body": "                                            {\n      super(matcher);\n    }", "signature": "LearningMatcherImpl(Matcher<T> matcher)"}, {"syntax_pass": true, "original_string": "    @Override public T get() {\n      return list.get(0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "get", "params": [], "body": "                             {\n      return list.get(0);\n    }", "signature": "@Override public T get()"}, {"syntax_pass": true, "original_string": "    @Override protected void consume(T t) {\n      list.add(t);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "consume", "params": [{"name": "t", "type": "T"}], "body": "                                          {\n      list.add(t);\n    }", "signature": "@Override protected void consume(T t)"}]}, {"original_string": "  private static class CallingMatcher extends BaseMatcher<Object> {\n    private final Object arg;\n    private final Matcher<Object> resultMatcher;\n\n    CallingMatcher(Object arg, Matcher<Object> resultMatcher) {\n      this.arg = arg;\n      this.resultMatcher = resultMatcher;\n    }\n\n    @Override public void describeTo(Description description) {\n      description.appendText(\"calls with \")\n          .appendValue(arg)\n          .appendText(\" and returns \")\n          .appendDescriptionOf(resultMatcher);\n    }\n\n    @Override public boolean matches(Object o) {\n      if (!(o instanceof Applicable)) {\n        return false;\n      }\n      final Applicable applicable = (Applicable) o;\n      final Object result = applicable.apply(Codes.emptyEnv(), arg);\n      return resultMatcher.matches(result);\n    }\n  }", "definition": "  private static class CallingMatcher extends BaseMatcher<Object>", "class_docstring": " Helper for {@link #whenAppliedTo(Object, Matcher)}.", "name": "CallingMatcher", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Object arg;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "arg", "syntax_pass": true}, {"attribute_expression": "private final Matcher<Object> resultMatcher;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Matcher<Object>", "name": "resultMatcher", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    CallingMatcher(Object arg, Matcher<Object> resultMatcher) {\n      this.arg = arg;\n      this.resultMatcher = resultMatcher;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CallingMatcher", "params": [{"name": "arg", "type": "Object"}, {"name": "resultMatcher", "type": "Matcher<Object>"}], "body": "                                                              {\n      this.arg = arg;\n      this.resultMatcher = resultMatcher;\n    }", "signature": "CallingMatcher(Object arg, Matcher<Object> resultMatcher)"}, {"syntax_pass": true, "original_string": "    @Override public void describeTo(Description description) {\n      description.appendText(\"calls with \")\n          .appendValue(arg)\n          .appendText(\" and returns \")\n          .appendDescriptionOf(resultMatcher);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "describeTo", "params": [{"name": "description", "type": "Description"}], "body": "                                                              {\n      description.appendText(\"calls with \")\n          .appendValue(arg)\n          .appendText(\" and returns \")\n          .appendDescriptionOf(resultMatcher);\n    }", "signature": "@Override public void describeTo(Description description)"}, {"syntax_pass": true, "original_string": "    @Override public boolean matches(Object o) {\n      if (!(o instanceof Applicable)) {\n        return false;\n      }\n      final Applicable applicable = (Applicable) o;\n      final Object result = applicable.apply(Codes.emptyEnv(), arg);\n      return resultMatcher.matches(result);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "o", "type": "Object"}], "body": "                                               {\n      if (!(o instanceof Applicable)) {\n        return false;\n      }\n      final Applicable applicable = (Applicable) o;\n      final Object result = applicable.apply(Codes.emptyEnv(), arg);\n      return resultMatcher.matches(result);\n    }", "signature": "@Override public boolean matches(Object o)"}]}], "class_docstring": " Matchers for use in Morel tests.", "original_string": "public abstract class Matchers {\n\n  private static final Pattern PATTERN0 = Pattern.compile(\"\\\\(\\\\n +\");\n  private static final Pattern PATTERN1 = Pattern.compile(\"\\\\n +\");\n\n  private Matchers() {}\n\n  /** Matches a literal by value. */\n  @SuppressWarnings(\"rawtypes\")\n  static Matcher<Ast.Literal> isLiteral(Comparable comparable, String ml) {\n    return new TypeSafeMatcher<Ast.Literal>() {\n      protected boolean matchesSafely(Ast.Literal literal) {\n        final String actualMl = literal.toString();\n        return literal.value.equals(comparable)\n            && actualMl.equals(ml);\n      }\n\n      public void describeTo(Description description) {\n        description.appendText(\"literal with value \" + comparable\n            + \" and ML \" + ml);\n      }\n    };\n  }\n\n  /** Matches an AST node by its string representation. */\n  static Matcher<AstNode> isAst(boolean parenthesize, String expected) {\n    return isAst(AstNode.class, parenthesize, expected);\n  }\n\n  /** Matches an AST node by its string representation. */\n  static <T extends AstNode> Matcher<T> isAst(Class<? extends T> clazz,\n      boolean parenthesize, String expected) {\n    return new CustomTypeSafeMatcher<T>(\"ast with value [\" + expected + \"]\") {\n      protected boolean matchesSafely(T t) {\n        assertThat(clazz.isInstance(t), is(true));\n        final String s =\n            stringValue(t);\n        return s.equals(expected);\n      }\n\n      private String stringValue(T t) {\n        return t.unparse(new AstWriter().withParenthesize(parenthesize));\n      }\n\n      @Override protected void describeMismatchSafely(T item,\n          Description description) {\n        description.appendText(\"was \").appendValue(stringValue(item));\n      }\n    };\n  }\n\n  /** Matches a Code node by its string representation. */\n  static Matcher<Code> isCode(String expected) {\n    return new CustomTypeSafeMatcher<Code>(\"code \" + expected) {\n      @Override protected boolean matchesSafely(Code code) {\n        final String plan = Codes.describe(code);\n        return plan.equals(expected);\n      }\n\n      @Override protected void describeMismatchSafely(Code code,\n          Description description) {\n        final String plan = Codes.describe(code);\n        description.appendText(\"was \").appendValue(plan);\n      }\n    };\n  }\n\n  /** Matches a Code node by its string representation,\n   * removing spaces that occur after newlines. */\n  static Matcher<Code> isCode2(String expected) {\n    final String expected0 = PATTERN0.matcher(expected).replaceAll(\"(\");\n    final String expected1 = PATTERN1.matcher(expected0).replaceAll(\" \");\n    return isCode(expected1);\n  }\n\n  /** Matches a Code if it is wholly within Calcite. */\n  static Matcher<Code> isFullyCalcite() {\n    return new CustomTypeSafeMatcher<Code>(\"code is all Calcite\") {\n      protected boolean matchesSafely(Code code) {\n        final String plan = Codes.describe(code);\n        return plan.startsWith(\"calcite(\") // instanceof CalciteCode\n            && !plan.contains(\"morelScalar\")\n            && !plan.contains(\"morelTable\");\n      }\n    };\n  }\n\n  static List<Object> list(Object... values) {\n    return Arrays.asList(values);\n  }\n\n  static Map<Object, Object> map(Object... keyValues) {\n    final LinkedHashMap<Object, Object> map = new LinkedHashMap<>();\n    for (int i = 0; i < keyValues.length / 2; i++) {\n      map.put(keyValues[i * 2], keyValues[i * 2 + 1]);\n    }\n    return map;\n  }\n\n  @SafeVarargs\n  static <E> Matcher<Iterable<E>> equalsUnordered(E... elements) {\n    final Set<E> expectedSet = Sets.newHashSet(elements);\n    return new TypeSafeMatcher<Iterable<E>>() {\n      protected boolean matchesSafely(Iterable<E> item) {\n        //noinspection rawtypes\n        return Sets.newHashSet((Iterable) item).equals(expectedSet);\n      }\n\n      public void describeTo(Description description) {\n        description.appendText(\"equalsUnordered\").appendValue(expectedSet);\n      }\n    };\n  }\n\n  @SafeVarargs\n  static <E> Matcher<Iterable<E>> equalsOrdered(E... elements) {\n    final List<E> expectedList = Arrays.asList(elements);\n    return new TypeSafeMatcher<Iterable<E>>() {\n      protected boolean matchesSafely(Iterable<E> item) {\n        return Lists.newArrayList(item).equals(expectedList);\n      }\n\n      public void describeTo(Description description) {\n        description.appendText(\"equalsOrdered\").appendValue(expectedList);\n      }\n    };\n  }\n\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  static <E> Matcher<E> isUnordered(E expected) {\n    final E expectedMultiset = expected instanceof Iterable\n        ? (E) ImmutableMultiset.copyOf((Iterable) expected)\n        : expected;\n    return new TypeSafeMatcher<E>() {\n      @Override public void describeTo(Description description) {\n        description.appendText(\"equalsOrdered\").appendValue(expectedMultiset);\n      }\n\n      @Override protected boolean matchesSafely(E actual) {\n        final E actualMultiset = expectedMultiset instanceof Multiset\n            && actual instanceof Iterable\n            && !(actual instanceof Multiset)\n            ? (E) ImmutableMultiset.copyOf((Iterable) actual)\n            : actual;\n        return expectedMultiset.equals(actualMultiset);\n      }\n    };\n  }\n\n  static Matcher<Throwable> throwsA(String message) {\n    return new CustomTypeSafeMatcher<Throwable>(\"throwable: \" + message) {\n      @Override protected boolean matchesSafely(Throwable item) {\n        return item.toString().contains(message);\n      }\n    };\n  }\n\n  static Matcher<Throwable> throwsA(String message, Pos position) {\n    return throwsA(Throwable.class, message, position);\n  }\n\n  static <T extends Throwable> Matcher<T> throwsA(Class<T> clazz,\n      String message, Pos position) {\n    requireNonNull(clazz, \"clazz\");\n    requireNonNull(message, \"message\");\n    requireNonNull(position, \"position\");\n    return new TypeSafeMatcher<T>(clazz) {\n      @Override public void describeTo(Description description) {\n        description.appendText(\"throwable [\" + message\n            + \"] at position [\" + position + \"]\");\n      }\n\n      @Override protected boolean matchesSafely(Throwable item) {\n        return item.toString().contains(message)\n            && Objects.equals(positionString(item), position.toString());\n      }\n\n      @Nullable String positionString(Throwable e) {\n        if (e instanceof MorelException) {\n          return ((MorelException) e).pos()\n              .describeTo(new StringBuilder()).toString();\n        }\n        return null;\n      }\n    };\n  }\n\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  static <T extends Throwable> Matcher<T> throwsA(Class<T> clazz,\n      String message) {\n    return (Matcher) throwsA(clazz, is(message));\n  }\n\n  static <T extends Throwable> Matcher<Throwable> throwsA(Class<T> clazz,\n      Matcher<?> messageMatcher) {\n    return new TypeSafeMatcher<Throwable>(clazz) {\n      @Override public void describeTo(Description description) {\n        description.appendText(clazz + \" with message \")\n            .appendDescriptionOf(messageMatcher);\n      }\n\n      @Override protected boolean matchesSafely(Throwable item) {\n        return clazz.isInstance(item)\n            && messageMatcher.matches(item.getMessage());\n      }\n    };\n  }\n\n  /** Creates a Matcher that behaves the same as a given delegate Matcher,\n   * but remembers the value that was compared.\n   *\n   * @param <T> Type of expected item */\n  public static <T> LearningMatcher<T> learning(Class<T> type) {\n    return new LearningMatcherImpl<>(Is.isA(type));\n  }\n\n  /** Creates a Matcher that matches an Applicable, calls it with the given\n   * argument, and checks the result. */\n  static Matcher<Object> whenAppliedTo(Object arg,\n      Matcher<Object> resultMatcher) {\n    return new CallingMatcher(arg, resultMatcher);\n  }\n\n  /** Creates a Matcher that matches a Type based on {@link Type#moniker()}. */\n  static Matcher<Type> hasMoniker(String expectedMoniker) {\n    return new CustomTypeSafeMatcher<Type>(\"type with moniker [\"\n        + expectedMoniker + \"]\") {\n      @Override protected boolean matchesSafely(Type type) {\n        return type.moniker().equals(expectedMoniker);\n      }\n    };\n  }\n\n  /** Creates a Matcher that matches a {@link DataType} with given type\n   * constructors. */\n  static Matcher<DataType> hasTypeConstructors(String expected) {\n    return new CustomTypeSafeMatcher<DataType>(\"datatype with constructors \"\n        + expected) {\n      @Override protected boolean matchesSafely(DataType type) {\n        return type.typeConstructors.toString().equals(expected);\n      }\n    };\n  }\n\n  /** Creates a Matcher that tests for a sub-class and then makes another\n   * test.\n   *\n   * @param <T> Value type\n   * @param <T2> Required subtype */\n  static <T, T2 extends T> Matcher<T> instanceOfAnd(Class<T2> expectedClass,\n      Matcher<T2> matcher) {\n    return new TypeSafeDiagnosingMatcher<T>() {\n      @Override protected boolean matchesSafely(T item,\n          Description mismatchDescription) {\n        if (!expectedClass.isInstance(item)) {\n          mismatchDescription.appendText(\"expected instance of \" + expectedClass\n              + \" but was \" + item + \" (a \" + item.getClass() + \")\");\n          return false;\n        }\n        if (!matcher.matches(item)) {\n          matcher.describeMismatch(item, mismatchDescription);\n          return false;\n        }\n        return true;\n      }\n\n      @Override public void describeTo(Description description) {\n        description.appendText(\"instance of \" + expectedClass + \" and \");\n        matcher.describeTo(description);\n      }\n    };\n  }\n\n  /** Matcher that remembers the actual value it was.\n   *\n   * @param <T> Type of expected item */\n  public interface LearningMatcher<T> extends Matcher<T> {\n    T get();\n  }\n\n  /** Matcher that performs an action when a value is matched.\n   *\n   * @param <T> Type of expected item */\n  private abstract static class MatcherWithConsumer<T> extends BaseMatcher<T> {\n    final Matcher<T> matcher;\n\n    MatcherWithConsumer(Matcher<T> matcher) {\n      this.matcher = matcher;\n    }\n\n    protected abstract void consume(T t);\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public boolean matches(Object o) {\n      if (matcher.matches(o)) {\n        consume((T) o);\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    @Override public void describeMismatch(Object o,\n        Description description) {\n      matcher.describeMismatch(o, description);\n    }\n\n    @Override public void describeTo(Description description) {\n      matcher.describeTo(description);\n    }\n  }\n\n  /** Implementation of {@link LearningMatcher}.\n   *\n   * @param <T> Type of expected item */\n  private static class LearningMatcherImpl<T> extends MatcherWithConsumer<T>\n      implements LearningMatcher<T> {\n    final List<T> list = new ArrayList<>();\n\n    LearningMatcherImpl(Matcher<T> matcher) {\n      super(matcher);\n    }\n\n    @Override public T get() {\n      return list.get(0);\n    }\n\n    @Override protected void consume(T t) {\n      list.add(t);\n    }\n  }\n\n  /** Helper for {@link #whenAppliedTo(Object, Matcher)}. */\n  private static class CallingMatcher extends BaseMatcher<Object> {\n    private final Object arg;\n    private final Matcher<Object> resultMatcher;\n\n    CallingMatcher(Object arg, Matcher<Object> resultMatcher) {\n      this.arg = arg;\n      this.resultMatcher = resultMatcher;\n    }\n\n    @Override public void describeTo(Description description) {\n      description.appendText(\"calls with \")\n          .appendValue(arg)\n          .appendText(\" and returns \")\n          .appendDescriptionOf(resultMatcher);\n    }\n\n    @Override public boolean matches(Object o) {\n      if (!(o instanceof Applicable)) {\n        return false;\n      }\n      final Applicable applicable = (Applicable) o;\n      final Object result = applicable.apply(Codes.emptyEnv(), arg);\n      return resultMatcher.matches(result);\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Pattern PATTERN0 = Pattern.compile(\"\\\\(\\\\n +\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "PATTERN0 = Pattern.compile(\"\\\\(\\\\n +\")", "syntax_pass": true}, {"attribute_expression": "private static final Pattern PATTERN1 = Pattern.compile(\"\\\\n +\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "PATTERN1 = Pattern.compile(\"\\\\n +\")", "syntax_pass": true}]}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "name": "UnifierTest", "file_path": "src/test/java/net/hydromatic/morel/UnifierTest.java", "superclasses": "", "methods": ["[Unifier]createUnifier()", "[Unifier.Sequence]arrow(Unifier.Term,Unifier.Term)", "[Unifier.Sequence]a()", "[Unifier.Sequence]b()", "[Unifier.Sequence]c()", "[Unifier.Sequence]d()", "[Unifier.Sequence]f()", "[Unifier.Sequence]g()", "[Unifier.Sequence]h()", "[Unifier.Sequence]p()", "[Unifier.Sequence]bill()", "[Unifier.Sequence]bob()", "[Unifier.Sequence]john()", "[Unifier.Sequence]tom()", "[Unifier.Sequence]father()", "[Unifier.Sequence]mother()", "[Unifier.Sequence]parents()", "[Unifier.Sequence]parent()", "[Unifier.Sequence]grandParent()", "[Unifier.Sequence]connected()", "[Unifier.Sequence]part()", "[void]assertThatUnify(Unifier.Term,Unifier.Term,Matcher<String>)", "[void]assertThatUnify(List<Unifier.TermTerm>,Matcher<String>)", "[void]assertThatCannotUnify(Unifier.Term,Unifier.Term)", "[List<Unifier.TermTerm>]termPairs()", "[void]assertThatCannotUnify(List<Unifier.TermTerm>)"], "method_uris": ["src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier]createUnifier()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]arrow(Unifier.Term,Unifier.Term)", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]a()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]b()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]c()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]d()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]f()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]g()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]h()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]p()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]bill()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]bob()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]john()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]tom()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]father()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]mother()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]parents()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]parent()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]grandParent()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]connected()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]part()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]assertThatUnify(Unifier.Term,Unifier.Term,Matcher<String>)", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]assertThatUnify(List<Unifier.TermTerm>,Matcher<String>)", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]assertThatCannotUnify(Unifier.Term,Unifier.Term)", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[List<Unifier.TermTerm>]termPairs()", "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]assertThatCannotUnify(List<Unifier.TermTerm>)"], "overrides": null, "attributes": [{"original_string": "  public static class RobinsonUnifierTest extends UnifierTest {\n    protected Unifier createUnifier() {\n      return new RobinsonUnifier();\n    }\n  }", "definition": "  public static class RobinsonUnifierTest extends UnifierTest", "class_docstring": " Variant of test that uses\n{@link net.hydromatic.morel.util.RobinsonUnifier}.", "name": "RobinsonUnifierTest", "super_interfaces": [], "superclasses": "UnifierTest", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected Unifier createUnifier() {\n      return new RobinsonUnifier();\n    }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Unifier", "classes": []}, "name": "createUnifier", "params": [], "body": "                                      {\n      return new RobinsonUnifier();\n    }", "signature": "protected Unifier createUnifier()"}]}, {"original_string": "  public static class MartelliUnifierTest extends UnifierTest {\n    protected Unifier createUnifier() {\n      return new MartelliUnifier();\n    }\n\n    /** Solves the equations from the S combinator,\n     * \"{@code fn x => fn y => fn z => x z (z y)}\", in [<a href=\n     * \"https://web.cs.ucla.edu/~palsberg/course/cs239/reading/wand87.pdf\">\n     * Wand 87</a>]. */\n    @Test void test20() {\n      final Unifier.Variable t0 = unifier.variable(0);\n      final Unifier.Variable t1 = unifier.variable(1);\n      final Unifier.Variable t2 = unifier.variable(2);\n      final Unifier.Variable t3 = unifier.variable(3);\n      final Unifier.Variable t4 = unifier.variable(4);\n      final Unifier.Variable t5 = unifier.variable(5);\n      final Unifier.Variable t6 = unifier.variable(6);\n      final Unifier.Variable t7 = unifier.variable(7);\n      final Unifier.Variable t8 = unifier.variable(8);\n      final Unifier.Variable t9 = unifier.variable(9);\n      final Unifier.TermTerm[] termTerms = {\n          new Unifier.TermTerm(t0, arrow(t1, t2)),\n          new Unifier.TermTerm(t2, arrow(t3, t4)),\n          new Unifier.TermTerm(t4, arrow(t5, t6)),\n          new Unifier.TermTerm(t1, arrow(t8, arrow(t7, t6))),\n          new Unifier.TermTerm(t8, t5),\n          new Unifier.TermTerm(arrow(t9, t7), t3),\n          new Unifier.TermTerm(t9, t5)\n      };\n      final Unifier.Result unify =\n          unifier.unify(Arrays.asList(termTerms), ImmutableMap.of(),\n              Tracers.nullTracer());\n      assertThat(unify, notNullValue());\n      assertThat(unify instanceof Unifier.Substitution, is(true));\n      assertThat(unify.toString(),\n          is(\"[->(T1, T2)/T0, ->(T8, ->(T7, T6))/T1, ->(T3, T4)/T2,\"\n              + \" ->(T9, T7)/T3, ->(T5, T6)/T4, T5/T8, T5/T9]\"));\n    }\n\n    @Test void testAtomEqAtom() {\n      assertThatCannotUnify(termPairs(b(), X, a(), X));\n    }\n\n    @Test void testAtomEqAtom2() {\n      assertThatCannotUnify(termPairs(a(), X, a(), X, b(), X));\n    }\n\n    @Test void testAtomEqAtom3() {\n      assertThatUnify(termPairs(a(), X, a(), X), is(\"[a/X]\"));\n    }\n  }", "definition": "  public static class MartelliUnifierTest extends UnifierTest", "class_docstring": " Variant of test that uses\n{@link net.hydromatic.morel.util.MartelliUnifier}.", "name": "MartelliUnifierTest", "super_interfaces": [], "superclasses": "UnifierTest", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected Unifier createUnifier() {\n      return new MartelliUnifier();\n    }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Unifier", "classes": []}, "name": "createUnifier", "params": [], "body": "                                      {\n      return new MartelliUnifier();\n    }", "signature": "protected Unifier createUnifier()"}, {"syntax_pass": true, "original_string": "    @Test void test20() {\n      final Unifier.Variable t0 = unifier.variable(0);\n      final Unifier.Variable t1 = unifier.variable(1);\n      final Unifier.Variable t2 = unifier.variable(2);\n      final Unifier.Variable t3 = unifier.variable(3);\n      final Unifier.Variable t4 = unifier.variable(4);\n      final Unifier.Variable t5 = unifier.variable(5);\n      final Unifier.Variable t6 = unifier.variable(6);\n      final Unifier.Variable t7 = unifier.variable(7);\n      final Unifier.Variable t8 = unifier.variable(8);\n      final Unifier.Variable t9 = unifier.variable(9);\n      final Unifier.TermTerm[] termTerms = {\n          new Unifier.TermTerm(t0, arrow(t1, t2)),\n          new Unifier.TermTerm(t2, arrow(t3, t4)),\n          new Unifier.TermTerm(t4, arrow(t5, t6)),\n          new Unifier.TermTerm(t1, arrow(t8, arrow(t7, t6))),\n          new Unifier.TermTerm(t8, t5),\n          new Unifier.TermTerm(arrow(t9, t7), t3),\n          new Unifier.TermTerm(t9, t5)\n      };\n      final Unifier.Result unify =\n          unifier.unify(Arrays.asList(termTerms), ImmutableMap.of(),\n              Tracers.nullTracer());\n      assertThat(unify, notNullValue());\n      assertThat(unify instanceof Unifier.Substitution, is(true));\n      assertThat(unify.toString(),\n          is(\"[->(T1, T2)/T0, ->(T8, ->(T7, T6))/T1, ->(T3, T4)/T2,\"\n              + \" ->(T9, T7)/T3, ->(T5, T6)/T4, T5/T8, T5/T9]\"));\n    }", "docstring": " Solves the equations from the S combinator,\n\"{@code fn x => fn y => fn z => x z (z y)}\", in [<a href=\n\"https://web.cs.ucla.edu/~palsberg/course/cs239/reading/wand87.pdf\">\nWand 87</a>].", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "test20", "params": [], "body": "                        {\n      final Unifier.Variable t0 = unifier.variable(0);\n      final Unifier.Variable t1 = unifier.variable(1);\n      final Unifier.Variable t2 = unifier.variable(2);\n      final Unifier.Variable t3 = unifier.variable(3);\n      final Unifier.Variable t4 = unifier.variable(4);\n      final Unifier.Variable t5 = unifier.variable(5);\n      final Unifier.Variable t6 = unifier.variable(6);\n      final Unifier.Variable t7 = unifier.variable(7);\n      final Unifier.Variable t8 = unifier.variable(8);\n      final Unifier.Variable t9 = unifier.variable(9);\n      final Unifier.TermTerm[] termTerms = {\n          new Unifier.TermTerm(t0, arrow(t1, t2)),\n          new Unifier.TermTerm(t2, arrow(t3, t4)),\n          new Unifier.TermTerm(t4, arrow(t5, t6)),\n          new Unifier.TermTerm(t1, arrow(t8, arrow(t7, t6))),\n          new Unifier.TermTerm(t8, t5),\n          new Unifier.TermTerm(arrow(t9, t7), t3),\n          new Unifier.TermTerm(t9, t5)\n      };\n      final Unifier.Result unify =\n          unifier.unify(Arrays.asList(termTerms), ImmutableMap.of(),\n              Tracers.nullTracer());\n      assertThat(unify, notNullValue());\n      assertThat(unify instanceof Unifier.Substitution, is(true));\n      assertThat(unify.toString(),\n          is(\"[->(T1, T2)/T0, ->(T8, ->(T7, T6))/T1, ->(T3, T4)/T2,\"\n              + \" ->(T9, T7)/T3, ->(T5, T6)/T4, T5/T8, T5/T9]\"));\n    }", "signature": "@Test void test20()"}, {"syntax_pass": true, "original_string": "    @Test void testAtomEqAtom() {\n      assertThatCannotUnify(termPairs(b(), X, a(), X));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testAtomEqAtom", "params": [], "body": "                                {\n      assertThatCannotUnify(termPairs(b(), X, a(), X));\n    }", "signature": "@Test void testAtomEqAtom()"}, {"syntax_pass": true, "original_string": "    @Test void testAtomEqAtom2() {\n      assertThatCannotUnify(termPairs(a(), X, a(), X, b(), X));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testAtomEqAtom2", "params": [], "body": "                                 {\n      assertThatCannotUnify(termPairs(a(), X, a(), X, b(), X));\n    }", "signature": "@Test void testAtomEqAtom2()"}, {"syntax_pass": true, "original_string": "    @Test void testAtomEqAtom3() {\n      assertThatUnify(termPairs(a(), X, a(), X), is(\"[a/X]\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testAtomEqAtom3", "params": [], "body": "                                 {\n      assertThatUnify(termPairs(a(), X, a(), X), is(\"[a/X]\"));\n    }", "signature": "@Test void testAtomEqAtom3()"}]}], "class_docstring": " Test for {@link RobinsonUnifier}.", "original_string": "public abstract class UnifierTest {\n  final Unifier unifier = createUnifier();\n\n  protected abstract Unifier createUnifier();\n\n  Unifier.Sequence arrow(Unifier.Term t0, Unifier.Term t1) {\n    return unifier.apply(\"->\", t0, t1);\n  }\n\n  Unifier.Sequence a(Unifier.Term... terms) {\n    return unifier.apply(\"a\", terms);\n  }\n\n  Unifier.Sequence b(Unifier.Term... terms) {\n    return unifier.apply(\"b\", terms);\n  }\n\n  private Unifier.Sequence c(Unifier.Term... terms) {\n    return unifier.apply(\"c\", terms);\n  }\n\n  private Unifier.Sequence d(Unifier.Term... terms) {\n    return unifier.apply(\"d\", terms);\n  }\n\n  private Unifier.Sequence f(Unifier.Term... terms) {\n    return unifier.apply(\"f\", terms);\n  }\n\n  private Unifier.Sequence g(Unifier.Term... terms) {\n    return unifier.apply(\"g\", terms);\n  }\n\n  private Unifier.Sequence h(Unifier.Term... terms) {\n    return unifier.apply(\"h\", terms);\n  }\n\n  private Unifier.Sequence p(Unifier.Term... terms) {\n    return unifier.apply(\"p\", terms);\n  }\n\n  private Unifier.Sequence bill(Unifier.Term... terms) {\n    return unifier.apply(\"bill\", terms);\n  }\n\n  private Unifier.Sequence bob(Unifier.Term... terms) {\n    return unifier.apply(\"bob\", terms);\n  }\n\n  private Unifier.Sequence john(Unifier.Term... terms) {\n    return unifier.apply(\"john\", terms);\n  }\n\n  private Unifier.Sequence tom(Unifier.Term... terms) {\n    return unifier.apply(\"tom\", terms);\n  }\n\n  private Unifier.Sequence father(Unifier.Term... terms) {\n    return unifier.apply(\"father\", terms);\n  }\n\n  private Unifier.Sequence mother(Unifier.Term... terms) {\n    return unifier.apply(\"mother\", terms);\n  }\n\n  private Unifier.Sequence parents(Unifier.Term... terms) {\n    return unifier.apply(\"parents\", terms);\n  }\n\n  private Unifier.Sequence parent(Unifier.Term... terms) {\n    return unifier.apply(\"parent\", terms);\n  }\n\n  private Unifier.Sequence grandParent(Unifier.Term... terms) {\n    return unifier.apply(\"grandParent\", terms);\n  }\n\n  private Unifier.Sequence connected(Unifier.Term... terms) {\n    return unifier.apply(\"connected\", terms);\n  }\n\n  private Unifier.Sequence part(Unifier.Term... terms) {\n    return unifier.apply(\"part\", terms);\n  }\n\n  // Turn off checkstyle, because non-static fields are conventionally\n  // lower-case.\n  // CHECKSTYLE: IGNORE 4\n  final Unifier.Variable X = unifier.variable(\"X\");\n  private final Unifier.Variable Y = unifier.variable(\"Y\");\n  private final Unifier.Variable W = unifier.variable(\"W\");\n  private final Unifier.Variable Z = unifier.variable(\"Z\");\n\n  void assertThatUnify(Unifier.Term e1, Unifier.Term e2,\n      Matcher<String> matcher) {\n    assertThatUnify(termPairs(e1, e2), matcher);\n  }\n\n  void assertThatUnify(List<Unifier.TermTerm> termPairs,\n      Matcher<String> matcher) {\n    final Unifier.Result result =\n        unifier.unify(termPairs, ImmutableMap.of(), Tracers.nullTracer());\n    assertThat(result, notNullValue());\n    assertThat(result instanceof Unifier.Substitution, is(true));\n    assertThat(((Unifier.Substitution) result).resolve().toString(), matcher);\n  }\n\n  void assertThatCannotUnify(Unifier.Term e1, Unifier.Term e2) {\n    assertThatCannotUnify(termPairs(e1, e2));\n  }\n\n  /** Given [a, b, c, d], returns [(a, b), (c, d)]. */\n  List<Unifier.TermTerm> termPairs(Unifier.Term... terms) {\n    assert terms.length % 2 == 0;\n    final ImmutableList.Builder<Unifier.TermTerm> pairs =\n        ImmutableList.builder();\n    for (int i = 0; i < terms.length; i += 2) {\n      pairs.add(new Unifier.TermTerm(terms[i], terms[i + 1]));\n    }\n    return pairs.build();\n  }\n\n  void assertThatCannotUnify(List<Unifier.TermTerm> pairList) {\n    final Unifier.Result result =\n        unifier.unify(pairList, ImmutableMap.of(), Tracers.nullTracer());\n    assertThat(result, not(instanceOf(Unifier.Substitution.class)));\n  }\n\n  @Test void test1() {\n    final Unifier.Term e1 = p(f(a()), g(b()), Y);\n    final Unifier.Term e2 = p(Z, g(d()), c());\n    assertThat(e1, hasToString(\"p(f(a), g(b), Y)\"));\n    assertThat(unifier.substitution(f(a(), Y), Z).toString(),\n        is(\"[f(a, Y)/Z]\"));\n    assertThatCannotUnify(e1, e2);\n  }\n\n  @Test void test2() {\n    final Unifier.Term e1 = p(f(a()), g(b()), Y);\n    final Unifier.Term e2 = p(Z, g(W), c());\n    assertThatUnify(e1, e2, is(\"[b/W, c/Y, f(a)/Z]\"));\n  }\n\n  @Test void test3() {\n    // Note: Hesham Alassaf's test says that these cannot be unified; I think\n    // because X is free, and so it assumes that Xs are distinct.\n    final Unifier.Term e1 = p(f(f(b())), X);\n    final Unifier.Term e2 = p(f(Y), X);\n    if (unifier instanceof RobinsonUnifier) {\n      assertThatUnify(e1, e2, is(\"[X/X, f(b)/Y]\"));\n    } else {\n      assertThatUnify(e1, e2, is(\"[f(b)/Y]\"));\n    }\n  }\n\n  @Test void test4() {\n    final Unifier.Term e1 = p(f(f(b())), c());\n    final Unifier.Term e2 = p(f(Y), X);\n    assertThatUnify(e1, e2, is(\"[c/X, f(b)/Y]\"));\n  }\n\n  @Test void test5() {\n    final Unifier.Term e1 = p(a(), X);\n    final Unifier.Term e2 = p(b(), Y);\n    assertThatCannotUnify(e1, e2);\n  }\n\n  @Test void test6() {\n    final Unifier.Term e1 = p(X, a());\n    final Unifier.Term e2 = p(b(), Y);\n    assertThatUnify(e1, e2, is(\"[b/X, a/Y]\"));\n  }\n\n  @Test void test7() {\n    final Unifier.Term e1 = f(a(), X);\n    final Unifier.Term e2 = f(a(), b());\n    assertThatUnify(e1, e2, is(\"[b/X]\"));\n  }\n\n  @Test void test8() {\n    final Unifier.Term e1 = f(X);\n    final Unifier.Term e2 = f(Y);\n    assertThatUnify(e1, e2, is(\"[Y/X]\"));\n  }\n\n  @Test void test9() {\n    final Unifier.Term e1 = f(g(X), X);\n    final Unifier.Term e2 = f(Y);\n    assertThatCannotUnify(e1, e2);\n  }\n\n  @Test void test10() {\n    final Unifier.Term e1 = f(g(X));\n    final Unifier.Term e2 = f(Y);\n    assertThatUnify(e1, e2, is(\"[g(X)/Y]\"));\n  }\n\n  @Test void test11() {\n    final Unifier.Term e1 = f(g(X), X);\n    final Unifier.Term e2 = f(Y, a());\n    assertThatUnify(e1, e2, is(\"[a/X, g(a)/Y]\"));\n  }\n\n  @Test void test12() {\n    final Unifier.Term e1 = father(X, Y);\n    final Unifier.Term e2 = father(bob(), tom());\n    assertThatUnify(e1, e2, is(\"[bob/X, tom/Y]\"));\n  }\n\n  @Test void test13() {\n    final Unifier.Term e1 = parents(X, father(X), mother(bill()));\n    final Unifier.Term e2 = parents(bill(), father(bill()), Y);\n    assertThatUnify(e1, e2, is(\"[bill/X, mother(bill)/Y]\"));\n  }\n\n  @Test void test14() {\n    final Unifier.Term e1 = grandParent(X, parent(parent(X)));\n    final Unifier.Term e2 = grandParent(john(), parent(Y));\n    assertThatUnify(e1, e2, is(\"[john/X, parent(john)/Y]\"));\n  }\n\n  @Test void test15() {\n    final Unifier.Term e1 = p(f(a(), g(X)));\n    final Unifier.Term e2 = p(Y, Y);\n    assertThatCannotUnify(e1, e2);\n  }\n\n  @Test void test16() {\n    final Unifier.Term e1 = p(a(), X, h(g(Z)));\n    final Unifier.Term e2 = p(Z, h(Y), h(Y));\n    assertThatUnify(e1, e2, is(\"[h(g(a))/X, g(a)/Y, a/Z]\"));\n  }\n\n  @Test void test17() {\n    final Unifier.Term e1 = p(X, X);\n    final Unifier.Term e2 = p(Y, f(Y));\n    if (unifier.occurs()) {\n      assertThatCannotUnify(e1, e2);\n    } else if (unifier instanceof RobinsonUnifier) {\n      assertThatUnify(e1, e2, is(\"[Y/X, f(Y)/Y]\"));\n    } else {\n      assertThatCannotUnify(e1, e2);\n    }\n  }\n\n  @Test void test18() {\n    final Unifier.Term e1 = part(W, X);\n    final Unifier.Term e2 = connected(f(W, X), W);\n    assertThatCannotUnify(e1, e2);\n  }\n\n  @Test void test19() {\n    final Unifier.Term e1 = p(f(X), a(), Y);\n    final Unifier.Term e2 = p(f(bill()), Z, g(b()));\n    assertThatUnify(e1, e2, is(\"[bill/X, g(b)/Y, a/Z]\"));\n  }\n\n  /** Variant of test that uses\n   * {@link net.hydromatic.morel.util.RobinsonUnifier}. */\n  public static class RobinsonUnifierTest extends UnifierTest {\n    protected Unifier createUnifier() {\n      return new RobinsonUnifier();\n    }\n  }\n\n  /** Variant of test that uses\n   * {@link net.hydromatic.morel.util.MartelliUnifier}. */\n  public static class MartelliUnifierTest extends UnifierTest {\n    protected Unifier createUnifier() {\n      return new MartelliUnifier();\n    }\n\n    /** Solves the equations from the S combinator,\n     * \"{@code fn x => fn y => fn z => x z (z y)}\", in [<a href=\n     * \"https://web.cs.ucla.edu/~palsberg/course/cs239/reading/wand87.pdf\">\n     * Wand 87</a>]. */\n    @Test void test20() {\n      final Unifier.Variable t0 = unifier.variable(0);\n      final Unifier.Variable t1 = unifier.variable(1);\n      final Unifier.Variable t2 = unifier.variable(2);\n      final Unifier.Variable t3 = unifier.variable(3);\n      final Unifier.Variable t4 = unifier.variable(4);\n      final Unifier.Variable t5 = unifier.variable(5);\n      final Unifier.Variable t6 = unifier.variable(6);\n      final Unifier.Variable t7 = unifier.variable(7);\n      final Unifier.Variable t8 = unifier.variable(8);\n      final Unifier.Variable t9 = unifier.variable(9);\n      final Unifier.TermTerm[] termTerms = {\n          new Unifier.TermTerm(t0, arrow(t1, t2)),\n          new Unifier.TermTerm(t2, arrow(t3, t4)),\n          new Unifier.TermTerm(t4, arrow(t5, t6)),\n          new Unifier.TermTerm(t1, arrow(t8, arrow(t7, t6))),\n          new Unifier.TermTerm(t8, t5),\n          new Unifier.TermTerm(arrow(t9, t7), t3),\n          new Unifier.TermTerm(t9, t5)\n      };\n      final Unifier.Result unify =\n          unifier.unify(Arrays.asList(termTerms), ImmutableMap.of(),\n              Tracers.nullTracer());\n      assertThat(unify, notNullValue());\n      assertThat(unify instanceof Unifier.Substitution, is(true));\n      assertThat(unify.toString(),\n          is(\"[->(T1, T2)/T0, ->(T8, ->(T7, T6))/T1, ->(T3, T4)/T2,\"\n              + \" ->(T9, T7)/T3, ->(T5, T6)/T4, T5/T8, T5/T9]\"));\n    }\n\n    @Test void testAtomEqAtom() {\n      assertThatCannotUnify(termPairs(b(), X, a(), X));\n    }\n\n    @Test void testAtomEqAtom2() {\n      assertThatCannotUnify(termPairs(a(), X, a(), X, b(), X));\n    }\n\n    @Test void testAtomEqAtom3() {\n      assertThatUnify(termPairs(a(), X, a(), X), is(\"[a/X]\"));\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final Unifier unifier = createUnifier();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Unifier", "name": "unifier = createUnifier()", "syntax_pass": true}, {"attribute_expression": "final Unifier.Variable X = unifier.variable(\"X\");", "docstring": " CHECKSTYLE: IGNORE 4", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Unifier.Variable", "name": "X = unifier.variable(\"X\")", "syntax_pass": true}, {"attribute_expression": "private final Unifier.Variable Y = unifier.variable(\"Y\");", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Unifier.Variable", "name": "Y = unifier.variable(\"Y\")", "syntax_pass": true}, {"attribute_expression": "private final Unifier.Variable W = unifier.variable(\"W\");", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Unifier.Variable", "name": "W = unifier.variable(\"W\")", "syntax_pass": true}, {"attribute_expression": "private final Unifier.Variable Z = unifier.variable(\"Z\");", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Unifier.Variable", "name": "Z = unifier.variable(\"Z\")", "syntax_pass": true}]}, {"uris": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe", "name": "TestUnsafe", "file_path": "src/test/java/net/hydromatic/morel/TestUnsafe.java", "superclasses": "", "methods": ["[int]runAppProcess(List<String>,File,Logger,Reader,Writer)", "[boolean]haveGit()", "[List<File>]getJavaFiles()", "[List<File>]getTextFiles()", "[List<File>]getGitFiles()", "[void]getCommitMessages(int,BiConsumer<String, String>)"], "method_uris": ["src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[int]runAppProcess(List<String>,File,Logger,Reader,Writer)", "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[boolean]haveGit()", "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[List<File>]getJavaFiles()", "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[List<File>]getTextFiles()", "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[List<File>]getGitFiles()", "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[void]getCommitMessages(int,BiConsumer<String, String>)"], "overrides": null, "attributes": [], "class_docstring": "\nUnsafe methods to be used by tests.\n\n<p>Contains methods that call JDK methods that the\n<a href=\"https://github.com/policeman-tools/forbidden-apis\">forbidden\nAPIs checker</a> does not approve of.\n\n<p>This class is excluded from the check, so methods called via this class\nwill not fail the build.\n\n<p>Why is this in {@code core/src/test} and not in {@code testkit/src/main}?\nBecause some of the methods (e.g. {@link #runAppProcess}) are so unsafe that\nthey must not be on the class-path of production code.\n", "original_string": "public abstract class TestUnsafe {\n  /**\n   * Runs an external application process.\n   *\n   * @param argumentList  command name and its arguments\n   * @param directory  working directory\n   * @param logger    if not null, command and exit status will be logged here\n   * @param appInput  if not null, data will be copied to application's stdin\n   * @param appOutput if not null, data will be captured from application's\n   *                  stdout and stderr\n   * @return application process exit value\n   */\n  public static int runAppProcess(List<String> argumentList, File directory,\n      @Nullable Logger logger, @Nullable Reader appInput,\n      @Nullable Writer appOutput) throws IOException, InterruptedException {\n\n    // WARNING: ProcessBuilder is security-sensitive. Its use is currently\n    // safe because this code is under \"core/test\". Developers must not move\n    // this code into \"core/main\".\n    final ProcessBuilder pb = new ProcessBuilder(argumentList);\n    pb.directory(directory);\n    pb.redirectErrorStream(true);\n    if (logger != null) {\n      logger.info(\"start process: \" + pb.command());\n    }\n    Process p = pb.start();\n\n    // Setup the input/output streams to the subprocess.\n    // The buffering here is arbitrary. Javadocs strongly encourage\n    // buffering, but the size needed is very dependent on the\n    // specific application being run, the size of the input\n    // provided by the caller, and the amount of output expected.\n    // Since this method is currently used only by unit tests,\n    // large-ish fixed buffer sizes have been chosen. If this\n    // method becomes used for something in production, it might\n    // be better to have the caller provide them as arguments.\n    if (appInput != null) {\n      OutputStream out =\n          new BufferedOutputStream(\n              p.getOutputStream(),\n              100 * 1024);\n      int c;\n      while ((c = appInput.read()) != -1) {\n        out.write(c);\n      }\n      out.flush();\n    }\n    if (appOutput != null) {\n      InputStream in =\n          new BufferedInputStream(\n              p.getInputStream(),\n              100 * 1024);\n      int c;\n      while ((c = in.read()) != -1) {\n        appOutput.write(c);\n      }\n      appOutput.flush();\n      in.close();\n    }\n    p.waitFor();\n\n    int status = p.exitValue();\n    if (logger != null) {\n      logger.info(\"exit status=\" + status + \" from \" + pb.command());\n    }\n    return status;\n  }\n\n  /** Returns whether we seem are in a valid environment. */\n  public static boolean haveGit() {\n    // Is there a '.git' directory? If not, we may be in a source tree\n    // unzipped from a tarball.\n    final File base = TestUtil.getBaseDir(TestUnsafe.class);\n    final File gitDir = new File(base, \".git\");\n    if (!gitDir.exists()\n        || !gitDir.isDirectory()\n        || !gitDir.canRead()) {\n      return false;\n    }\n\n    // Execute a simple git command. If it fails, we're probably not in a\n    // valid git environment.\n    final List<String> argumentList =\n        ImmutableList.of(\"git\", \"--version\");\n    try {\n      final StringWriter sw = new StringWriter();\n      int status =\n          runAppProcess(argumentList, base, null, null, sw);\n      final String s = sw.toString();\n      if (status != 0) {\n        return false;\n      }\n    } catch (Exception e) {\n      return false;\n    }\n    return true;\n  }\n\n  /** Returns a list of Java files in git. */\n  public static List<File> getJavaFiles() {\n    return getGitFiles(\"*.java\");\n  }\n\n  /** Returns a list of text files in git. */\n  public static List<File> getTextFiles() {\n    return getGitFiles(\"*.java\", \"*.jj\", \"*.md\", \"*.properties\",\n        \"*.sh\", \"*.sml\", \"*.smli\", \"*.txt\", \"*.xml\", \"*.yml\");\n  }\n\n  /** Returns a list of files in git matching a given pattern or patterns.\n   *\n   * <p>Assumes running Linux or macOS, and that git is available. */\n  public static List<File> getGitFiles(String... patterns) {\n    String s;\n    try {\n      final List<String> argumentList =\n          ImmutableList.<String>builder().add(\"git\").add(\"ls-files\")\n              .add(patterns).build();\n      final File base = TestUtil.getBaseDir(TestUnsafe.class);\n      try {\n        final StringWriter sw = new StringWriter();\n        int status =\n            runAppProcess(argumentList, base, null, null, sw);\n        if (status != 0) {\n          throw new RuntimeException(\"command \" + argumentList\n              + \": exited with status \" + status);\n        }\n        s = sw.toString();\n      } catch (Exception e) {\n        throw new RuntimeException(\"command \" + argumentList\n            + \": failed with exception\", e);\n      }\n\n      final ImmutableList.Builder<File> files = ImmutableList.builder();\n      try (StringReader r = new StringReader(s);\n           BufferedReader br = new BufferedReader(r)) {\n        for (;;) {\n          String line = br.readLine();\n          if (line == null) {\n            break;\n          }\n          files.add(new File(base, line));\n        }\n      }\n      return files.build();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns the subject / body pairs of the {@code n} most recent commits. */\n  public static void getCommitMessages(int n,\n      BiConsumer<String, String> consumer) {\n    // Generate log like this:\n    //\n    //   ===\n    //   subject\n    //\n    //   body\n    //   ===\n    //   subject 2\n    //\n    //   body2\n    //\n    // then split on \"===\\n\"\n    final File base = TestUtil.getBaseDir(TestUnsafe.class);\n    final List<String> argumentList =\n        ImmutableList.of(\"git\", \"log\", \"-n\" + n, \"--pretty=format:===%n%B\");\n    try {\n      final StringWriter sw = new StringWriter();\n      int status =\n          runAppProcess(argumentList, base, null, null, sw);\n      String s = sw.toString();\n      if (status != 0) {\n        throw new RuntimeException(\"command \" + argumentList\n            + \": exited with status \" + status\n            + (s.isEmpty() ? \"\" : \"; output [\" + s + \"]\"));\n      }\n      Stream.of(s.split(\"===\\n\")).forEach(s2 -> {\n        if (s2.isEmpty()) {\n          return; // ignore empty subject & body\n        }\n        int i = s2.indexOf(\"\\n\");\n        if (i < 0) {\n          i = s2.length(); // no linefeed; treat entire chunk as subject\n        }\n        String subject = s2.substring(0, i);\n        while (i < s2.length() && s2.charAt(i) == '\\n') {\n          ++i; // skip multiple linefeeds between subject and body\n        }\n        String body = s2.substring(i);\n        consumer.accept(subject, body);\n      });\n    } catch (Exception e) {\n      throw new RuntimeException(\"command \" + argumentList\n          + \": failed with exception\", e);\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/TestUtil.java.TestUtil", "name": "TestUtil", "file_path": "src/test/java/net/hydromatic/morel/TestUtil.java", "superclasses": "", "methods": ["[File]getBaseDir(Class<?>)", "[boolean]isProjectDir(File)"], "method_uris": ["src/test/java/net/hydromatic/morel/TestUtil.java.TestUtil.[File]getBaseDir(Class<?>)", "src/test/java/net/hydromatic/morel/TestUtil.java.TestUtil.[boolean]isProjectDir(File)"], "overrides": null, "attributes": [], "class_docstring": "\nStatic utilities for JUnit tests.\n", "original_string": "public abstract class TestUtil {\n  /** Returns the root directory of the source tree. */\n  public static File getBaseDir(Class<?> klass) {\n    // Algorithm:\n    // 1) Find location of TestUtil.class\n    // 2) Climb via getParentFile() until we detect pom.xml\n    // 3) It means we've got BASE/testkit/pom.xml, and we need to get BASE\n    final URL resource = klass.getResource(klass.getSimpleName() + \".class\");\n    final File classFile =\n        Sources.of(requireNonNull(resource, \"resource\")).file();\n\n    File file = classFile.getAbsoluteFile();\n    for (int i = 0; i < 42; i++) {\n      if (isProjectDir(file)) {\n        // Ok, file == BASE/testkit/\n        break;\n      }\n      file = file.getParentFile();\n    }\n    if (!isProjectDir(file)) {\n      fail(\"Could not find pom.xml, build.gradle.kts or gradle.properties. \"\n          + \"Started with \" + classFile.getAbsolutePath()\n          + \", the current path is \" + file.getAbsolutePath());\n    }\n    return file;\n  }\n\n  private static boolean isProjectDir(File dir) {\n    return new File(dir, \"pom.xml\").isFile()\n        || new File(dir, \"build.gradle.kts\").isFile()\n        || new File(dir, \"gradle.properties\").isFile();\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode", "name": "AstNode", "file_path": "src/main/java/net/hydromatic/morel/ast/AstNode.java", "superclasses": "", "methods": ["[]AstNode(Pos,Op)", "[String]toString()", "[String]unparse(AstWriter)", "[AstWriter]unparse(AstWriter,int,int)", "[AstNode]accept(Shuttle)", "[void]accept(Visitor)"], "method_uris": ["src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[]AstNode(Pos,Op)", "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[String]toString()", "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[String]unparse(AstWriter)", "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[AstWriter]unparse(AstWriter,int,int)", "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[AstNode]accept(Shuttle)", "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[void]accept(Visitor)"], "overrides": null, "attributes": [], "class_docstring": " Abstract syntax tree node.", "original_string": "public abstract class AstNode {\n  public final Pos pos;\n  public final Op op;\n\n  public AstNode(Pos pos, Op op) {\n    this.pos = requireNonNull(pos);\n    this.op = requireNonNull(op);\n  }\n\n  /** Converts this node into an ML string.\n   *\n   * <p>The purpose of this string is debugging. If you want to generate an\n   * expression, use {@link #unparse}, which will insert parentheses as\n   * necessary for operator precedence.\n   *\n   * <p>Derived classes <em>may</em> override, but they must produce the same\n   * result; so the only reason to override is if they can do it more\n   * efficiently.\n   */\n  @Override public final String toString() {\n    // Marked final because you should override unparse, not toString\n    return unparse(new AstWriter());\n  }\n\n  /** Converts this node into an ML string, with a given writer. */\n  public final String unparse(AstWriter w) {\n    return unparse(w, 0, 0).toString();\n  }\n\n  abstract AstWriter unparse(AstWriter w, int left, int right);\n\n  /** Accepts a shuttle, calling the\n   * {@link net.hydromatic.morel.ast.Shuttle#visit}\n   * method appropriate to the type of this node, and returning the result. */\n  public abstract AstNode accept(Shuttle shuttle);\n\n  /** Accepts a visitor, calling the\n   * {@link net.hydromatic.morel.ast.Shuttle#visit}\n   * method appropriate to the type of this node, and returning the result. */\n  public abstract void accept(Visitor visitor);\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public final Pos pos;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Pos", "name": "pos", "syntax_pass": true}, {"attribute_expression": "public final Op op;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Op", "name": "op", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2", "name": "Applicable2", "file_path": "src/main/java/net/hydromatic/morel/eval/Applicable2.java", "superclasses": "ApplicableImpl", "methods": ["[]Applicable2(BuiltIn,Pos)", "[]Applicable2(BuiltIn)", "[Object]apply(EvalEnv,Object)", "[R]apply(A0,A1)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2.[]Applicable2(BuiltIn,Pos)", "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2.[]Applicable2(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2.[Object]apply(EvalEnv,Object)", "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2.[R]apply(A0,A1)"], "overrides": null, "attributes": [], "class_docstring": "\nApplicable whose argument is a 3-tuple.\n\n<p>Implementations that use {@code Applicable3} are more efficient and\nconcise than {@link ApplicableImpl} because there is no need to create an\nephemeral tuple (Java {@link List}) to pass the arguments, and Java's\ngenerics provide the casting.\n\n<p>But the rewrite assumes that the function is <b>strict</b> (always\nevaluates all arguments, even if the function throws) and doesn't use\n{@link EvalEnv}, so it is not appropriate for all functions.\nFor example, {@link Codes#andAlso(Code, Code) andalso} evaluates its\narguments lazily and therefore cannot be an {@code Applicable2}.\n\n<p>If a function has an {@code Applicable2} implementation and the argument\ntuple is evaluated whole, the old evaluation path will be used. For example,\nthe first call below uses {@code apply} and the second uses {@code apply}:\n\n<pre>{@code\n- Math.pow (2.0, 3.0);\nval it = 8.0 : real\n- Sys.plan ();\nval it = \"apply2(fnValue Math.pow, constant(2.0), constant(3.0))\" : string\n- Math.pow (List.hd [(2.0, 3.0)]);\nval it = 8.0 : real\n- Sys.plan ();\nval it =\n  \"apply(fnValue Math.pow, argCode apply(fnValue List.hd, argCode tuple(tuple(constant(2.0), constant(3.0)))))\"\n  : string\n}\n</pre>\n\n@see Applicable3\n\n@param <R>  return type\n@param <A0> type of argument 0\n@param <A1> type of argument 1\n", "original_string": "@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic abstract class Applicable2<R, A0, A1> extends ApplicableImpl {\n  protected Applicable2(BuiltIn builtIn, Pos pos) {\n    super(builtIn, pos);\n  }\n\n  protected Applicable2(BuiltIn builtIn) {\n    this(builtIn, Pos.ZERO);\n  }\n\n  @Override public Object apply(EvalEnv env, Object argValue) {\n    final List list = (List) argValue;\n    return apply((A0) list.get(0), (A1) list.get(1));\n  }\n\n  public abstract R apply(A0 a0, A1 a1);\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3", "name": "Applicable3", "file_path": "src/main/java/net/hydromatic/morel/eval/Applicable3.java", "superclasses": "ApplicableImpl", "methods": ["[]Applicable3(BuiltIn,Pos)", "[]Applicable3(BuiltIn)", "[Object]apply(EvalEnv,Object)", "[R]apply(A0,A1,A2)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3.[]Applicable3(BuiltIn,Pos)", "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3.[]Applicable3(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3.[Object]apply(EvalEnv,Object)", "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3.[R]apply(A0,A1,A2)"], "overrides": null, "attributes": [], "class_docstring": "\nApplicable whose argument is a 3-tuple.\n\n<p>Implementations that use {@code Applicable3} are more efficient and\nconcise than {@link ApplicableImpl} because there is no need to create an\nephemeral tuple (Java {@link List}) to pass the arguments, and Java's\ngenerics provide the casting.\n\n<p>But the rewrite assumes that the function is <b>strict</b> (always\nevaluates all arguments, even if the function throws) and doesn't use\n{@link EvalEnv}, so it is not appropriate for all functions.\n\n<p>If a function has an {@code Applicable3} implementation and\nthe argument tuple is evaluated whole, the old evaluation path will be\nused.\n\n@see Applicable2\n\n@param <R>  return type\n@param <A0> type of argument 0\n@param <A1> type of argument 1\n@param <A2> type of argument 2\n", "original_string": "@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic abstract class Applicable3<R, A0, A1, A2>\n    extends ApplicableImpl {\n  protected Applicable3(BuiltIn builtIn, Pos pos) {\n    super(builtIn, pos);\n  }\n\n  protected Applicable3(BuiltIn builtIn) {\n    this(builtIn, Pos.ZERO);\n  }\n\n  @Override public Object apply(EvalEnv env, Object argValue) {\n    final List list = (List) argValue;\n    return apply((A0) list.get(0), (A1) list.get(1), (A2) list.get(2));\n  }\n\n  public abstract R apply(A0 a0, A1 a1, A2 a2);\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl", "name": "ApplicableImpl", "file_path": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java", "superclasses": "", "methods": ["[]ApplicableImpl(String,Pos)", "[]ApplicableImpl(String)", "[]ApplicableImpl(BuiltIn,Pos)", "[]ApplicableImpl(BuiltIn)", "[String]toString()", "[Describer]describe(Describer)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[]ApplicableImpl(String,Pos)", "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[]ApplicableImpl(String)", "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[]ApplicableImpl(BuiltIn,Pos)", "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[]ApplicableImpl(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[String]toString()", "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[Describer]describe(Describer)"], "overrides": null, "attributes": [], "class_docstring": " Abstract implementation of {@link Applicable} that describes itself\nwith a constant name.", "original_string": "abstract class ApplicableImpl implements Applicable {\n  private final String name;\n  final Pos pos;\n\n  protected ApplicableImpl(String name, Pos pos) {\n    this.name = name;\n    this.pos = pos;\n  }\n\n  protected ApplicableImpl(String name) {\n    this(name, Pos.ZERO);\n  }\n\n  /** Creates an ApplicableImpl that directly implements a BuiltIn.\n   * The parameter is currently only for provenance purposes. */\n  protected ApplicableImpl(BuiltIn builtIn, Pos pos) {\n    this(builtIn.mlName.startsWith(\"op \")\n        ? builtIn.mlName.substring(\"op \".length())\n        : builtIn.structure + \".\" + builtIn.mlName,\n        pos);\n  }\n\n  /** Creates an ApplicableImpl that directly implements a BuiltIn.\n   * The parameter is currently only for provenance purposes. */\n  protected ApplicableImpl(BuiltIn builtIn) {\n    this(builtIn, Pos.ZERO);\n  }\n\n  @Override public String toString() {\n    return name;\n  }\n\n  @Override public Describer describe(Describer describer) {\n    return describer.start(name, d -> {});\n  }\n}", "super_interfaces": ["Applicable"], "fields": [{"attribute_expression": "private final String name;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "final Pos pos;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Pos", "name": "pos", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "name": "Codes", "file_path": "src/main/java/net/hydromatic/morel/eval/Codes.java", "superclasses": "", "methods": ["[]Codes()", "[String]describe(Code)", "[Code]constant(Object)", "[ApplicableImpl]identity(BuiltIn)", "[Code]andAlso(Code,Code)", "[Code]orElse(Code,Code)", "[Code]strip(Code)", "[Code]get(String)", "[Code]getTuple(Iterable<String>)", "[Code]let(List<Code>,Code)", "[Code]apply(Code,Code)", "[Code]apply(Applicable,Code)", "[Code]apply2(Applicable2,Code,Code)", "[Code]apply3(Applicable3,Code,Code,Code)", "[Code]list(Iterable<? extends Code>)", "[Code]tuple(Iterable<? extends Code>)", "[Code]wrapRelList(Code)", "[Applicable]tyCon(Type,String)", "[Code]from(Supplier<RowSink>)", "[RowSink]scanRowSink(Op,Core.Pat,Code,Code,RowSink)", "[RowSink]whereRowSink(Code,RowSink)", "[RowSink]skipRowSink(Code,RowSink)", "[RowSink]takeRowSink(Code,RowSink)", "[RowSink]orderRowSink(Iterable<? extends Map.Entry<Code, Boolean>>,ImmutableList<Binding>,RowSink)", "[RowSink]groupRowSink(Code,ImmutableList<Applicable>,ImmutableList<String>,ImmutableList<String>,ImmutableList<String>,RowSink)", "[RowSink]yieldRowSink(Map<String, Code>,RowSink)", "[RowSink]collectRowSink(Code)", "[Applicable]nth(int)", "[String]stringConcat(Pos,String,List<String>)", "[Applicable]stringMap(Applicable)", "[Applicable]translate(Applicable)", "[Applicable]isPrefix(String)", "[Applicable]isSubstring(String)", "[Applicable]isSuffix(String)", "[ApplicableImpl]length(BuiltIn)", "[ApplicableImpl]union(BuiltIn)", "[Applicable]listApp(Applicable)", "[Applicable]listMap(Applicable)", "[Applicable]listMapPartial(Applicable)", "[ApplicableImpl]find(BuiltIn)", "[Applicable]find(Applicable)", "[Applicable]listFilter(Applicable)", "[Applicable]listPartition(Applicable)", "[Applicable]listFold(boolean,Applicable)", "[Applicable]listFold2(boolean,Applicable,Object)", "[ApplicableImpl]exists(BuiltIn)", "[Applicable]listExists(Applicable)", "[ApplicableImpl]all(BuiltIn)", "[Applicable]listAll(Applicable)", "[ApplicableImpl]collate(BuiltIn)", "[Applicable]collate(Applicable)", "[Applicable]optionApp(Applicable)", "[Applicable]optionFilter(Applicable)", "[Applicable]optionMap(Applicable)", "[List]optionSome(Object)", "[Applicable]optionMapPartial(Applicable)", "[Applicable]optionCompose(Applicable,Applicable)", "[Applicable]optionComposePartial(Applicable,Applicable)", "[boolean]isNegative(float)", "[ApplicableImpl]isEmpty(BuiltIn)", "[ApplicableImpl]isNotEmpty(BuiltIn)", "[Core.Exp]sysEnv(TypeSystem,Environment,Type)", "[Applicable]vectorAppi(Applicable)", "[Applicable]vectorApp(Applicable)", "[Applicable]vectorMapi(Applicable)", "[Applicable]vectorMap(Applicable)", "[Applicable]vectorFindi(Applicable)", "[void]populateBuiltIns(Map<String, Object>)", "[EvalEnv]emptyEnv()", "[EvalEnv]emptyEnvWith(Session,Environment)", "[Environment]env(TypeSystem,Environment)", "[Applicable]aggregate(Environment,Code,List<String>,Code)", "[Map<Applicable, BuiltIn>]get()", "[EvalEnv]makeEmptyEnv()", "[StringBuilder]appendFloat(StringBuilder,float)", "[String]floatToString(float)", "[String]floatToString0(float)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[]Codes()", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[String]describe(Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]constant(Object)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]identity(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]andAlso(Code,Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]orElse(Code,Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]strip(Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]get(String)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]getTuple(Iterable<String>)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]let(List<Code>,Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]apply(Code,Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]apply(Applicable,Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]apply2(Applicable2,Code,Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]apply3(Applicable3,Code,Code,Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]list(Iterable<? extends Code>)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]tuple(Iterable<? extends Code>)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]wrapRelList(Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]tyCon(Type,String)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]from(Supplier<RowSink>)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]scanRowSink(Op,Core.Pat,Code,Code,RowSink)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]whereRowSink(Code,RowSink)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]skipRowSink(Code,RowSink)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]takeRowSink(Code,RowSink)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]orderRowSink(Iterable<? extends Map.Entry<Code, Boolean>>,ImmutableList<Binding>,RowSink)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]groupRowSink(Code,ImmutableList<Applicable>,ImmutableList<String>,ImmutableList<String>,ImmutableList<String>,RowSink)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]yieldRowSink(Map<String, Code>,RowSink)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]collectRowSink(Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]nth(int)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[String]stringConcat(Pos,String,List<String>)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]stringMap(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]translate(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]isPrefix(String)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]isSubstring(String)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]isSuffix(String)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]length(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]union(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listApp(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listMap(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listMapPartial(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]find(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]find(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listFilter(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listPartition(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listFold(boolean,Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listFold2(boolean,Applicable,Object)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]exists(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listExists(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]all(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listAll(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]collate(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]collate(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionApp(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionFilter(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionMap(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[List]optionSome(Object)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionMapPartial(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionCompose(Applicable,Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionComposePartial(Applicable,Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[boolean]isNegative(float)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]isEmpty(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]isNotEmpty(BuiltIn)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Core.Exp]sysEnv(TypeSystem,Environment,Type)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]vectorAppi(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]vectorApp(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]vectorMapi(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]vectorMap(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]vectorFindi(Applicable)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[void]populateBuiltIns(Map<String, Object>)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[EvalEnv]emptyEnv()", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[EvalEnv]emptyEnvWith(Session,Environment)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Environment]env(TypeSystem,Environment)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]aggregate(Environment,Code,List<String>,Code)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Map<Applicable, BuiltIn>]get()", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[EvalEnv]makeEmptyEnv()", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[StringBuilder]appendFloat(StringBuilder,float)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[String]floatToString(float)", "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[String]floatToString0(float)"], "overrides": null, "attributes": [{"original_string": "  private static class IntMod\n      extends Applicable2<Integer, Integer, Integer> {\n    IntMod(BuiltIn builtIn) {\n      super(builtIn);\n    }\n\n    @Override public Integer apply(Integer a0, Integer a1) {\n      return Math.floorMod(a0, a1);\n    }\n  }", "definition": "  private static class IntMod\n      extends Applicable2<Integer, Integer, Integer>", "class_docstring": " Implements {@link #INT_MOD} and {@link #OP_MOD}.", "name": "IntMod", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    IntMod(BuiltIn builtIn) {\n      super(builtIn);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "IntMod", "params": [{"name": "builtIn", "type": "BuiltIn"}], "body": "                            {\n      super(builtIn);\n    }", "signature": "IntMod(BuiltIn builtIn)"}, {"syntax_pass": true, "original_string": "    @Override public Integer apply(Integer a0, Integer a1) {\n      return Math.floorMod(a0, a1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "apply", "params": [{"name": "a0", "type": "Integer"}, {"name": "a1", "type": "Integer"}], "body": "                                                           {\n      return Math.floorMod(a0, a1);\n    }", "signature": "@Override public Integer apply(Integer a0, Integer a1)"}]}, {"original_string": "  private static class IntDiv\n      extends Applicable2<Integer, Integer, Integer> {\n    IntDiv(BuiltIn builtIn) {\n      super(builtIn);\n    }\n\n    @Override public Integer apply(Integer a0, Integer a1) {\n      return Math.floorDiv(a0, a1);\n    }\n  }", "definition": "  private static class IntDiv\n      extends Applicable2<Integer, Integer, Integer>", "class_docstring": " Implements {@link #INT_DIV} and {@link #OP_DIV}.", "name": "IntDiv", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    IntDiv(BuiltIn builtIn) {\n      super(builtIn);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "IntDiv", "params": [{"name": "builtIn", "type": "BuiltIn"}], "body": "                            {\n      super(builtIn);\n    }", "signature": "IntDiv(BuiltIn builtIn)"}, {"syntax_pass": true, "original_string": "    @Override public Integer apply(Integer a0, Integer a1) {\n      return Math.floorDiv(a0, a1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "apply", "params": [{"name": "a0", "type": "Integer"}, {"name": "a1", "type": "Integer"}], "body": "                                                           {\n      return Math.floorDiv(a0, a1);\n    }", "signature": "@Override public Integer apply(Integer a0, Integer a1)"}]}, {"original_string": "  private static class InteractUse extends ApplicableImpl\n      implements Positioned {\n    private final boolean silent;\n\n    InteractUse(Pos pos, boolean silent) {\n      super(BuiltIn.INTERACT_USE, pos);\n      this.silent = silent;\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new InteractUse(pos, silent);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final String f = (String) arg;\n      final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n      session.use(f, silent, pos);\n      return Unit.INSTANCE;\n    }\n  }", "definition": "  private static class InteractUse extends ApplicableImpl\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#INTERACT_USE}.", "name": "InteractUse", "super_interfaces": ["Positioned"], "superclasses": "ApplicableImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final boolean silent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "silent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    InteractUse(Pos pos, boolean silent) {\n      super(BuiltIn.INTERACT_USE, pos);\n      this.silent = silent;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "InteractUse", "params": [{"name": "pos", "type": "Pos"}, {"name": "silent", "type": "boolean"}], "body": "                                         {\n      super(BuiltIn.INTERACT_USE, pos);\n      this.silent = silent;\n    }", "signature": "InteractUse(Pos pos, boolean silent)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new InteractUse(pos, silent);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new InteractUse(pos, silent);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Object apply(EvalEnv env, Object arg) {\n      final String f = (String) arg;\n      final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n      session.use(f, silent, pos);\n      return Unit.INSTANCE;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "env", "type": "EvalEnv"}, {"name": "arg", "type": "Object"}], "body": "                                                           {\n      final String f = (String) arg;\n      final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n      session.use(f, silent, pos);\n      return Unit.INSTANCE;\n    }", "signature": "@Override public Object apply(EvalEnv env, Object arg)"}]}, {"original_string": "  private static class StringSub extends Applicable2<Character, String, Integer>\n      implements Positioned {\n    StringSub(Pos pos) {\n      super(BuiltIn.STRING_SUB, pos);\n    }\n\n    @Override public Character apply(String s, Integer i) {\n      if (i < 0 || i >= s.length()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return s.charAt(i);\n    }\n\n    public StringSub withPos(Pos pos) {\n      return new StringSub(pos);\n    }\n  }", "definition": "  private static class StringSub extends Applicable2<Character, String, Integer>\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#STRING_SUB}.", "name": "StringSub", "super_interfaces": ["Positioned"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    StringSub(Pos pos) {\n      super(BuiltIn.STRING_SUB, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "StringSub", "params": [{"name": "pos", "type": "Pos"}], "body": "                       {\n      super(BuiltIn.STRING_SUB, pos);\n    }", "signature": "StringSub(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Character apply(String s, Integer i) {\n      if (i < 0 || i >= s.length()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return s.charAt(i);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Character", "classes": []}, "name": "apply", "params": [{"name": "s", "type": "String"}, {"name": "i", "type": "Integer"}], "body": "                                                          {\n      if (i < 0 || i >= s.length()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return s.charAt(i);\n    }", "signature": "@Override public Character apply(String s, Integer i)"}, {"syntax_pass": true, "original_string": "    public StringSub withPos(Pos pos) {\n      return new StringSub(pos);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringSub", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                      {\n      return new StringSub(pos);\n    }", "signature": "public StringSub withPos(Pos pos)"}]}, {"original_string": "  private static class StringExtract\n      extends Applicable3<String, String, Integer, List> implements Positioned {\n    StringExtract(Pos pos) {\n      super(BuiltIn.STRING_EXTRACT, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new StringExtract(pos);\n    }\n\n    @Override public String apply(String s, Integer i, List jOpt) {\n      if (i < 0) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      if (jOpt.size() == 2) {\n        final int j = (Integer) jOpt.get(1);\n        if (j < 0 || i + j > s.length()) {\n          throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n        }\n        return s.substring(i, i + j);\n      } else {\n        if (i > s.length()) {\n          throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n        }\n        return s.substring(i);\n      }\n    }\n  }", "definition": "  private static class StringExtract\n      extends Applicable3<String, String, Integer, List> implements Positioned", "class_docstring": " Implements {@link BuiltIn#STRING_SUB}.", "name": "StringExtract", "super_interfaces": ["Positioned"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    StringExtract(Pos pos) {\n      super(BuiltIn.STRING_EXTRACT, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "StringExtract", "params": [{"name": "pos", "type": "Pos"}], "body": "                           {\n      super(BuiltIn.STRING_EXTRACT, pos);\n    }", "signature": "StringExtract(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new StringExtract(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new StringExtract(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public String apply(String s, Integer i, List jOpt) {\n      if (i < 0) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      if (jOpt.size() == 2) {\n        final int j = (Integer) jOpt.get(1);\n        if (j < 0 || i + j > s.length()) {\n          throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n        }\n        return s.substring(i, i + j);\n      } else {\n        if (i > s.length()) {\n          throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n        }\n        return s.substring(i);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "apply", "params": [{"name": "s", "type": "String"}, {"name": "i", "type": "Integer"}, {"name": "jOpt", "type": "List"}], "body": "                                                                  {\n      if (i < 0) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      if (jOpt.size() == 2) {\n        final int j = (Integer) jOpt.get(1);\n        if (j < 0 || i + j > s.length()) {\n          throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n        }\n        return s.substring(i, i + j);\n      } else {\n        if (i > s.length()) {\n          throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n        }\n        return s.substring(i);\n      }\n    }", "signature": "@Override public String apply(String s, Integer i, List jOpt)"}]}, {"original_string": "  private static class StringSubstring\n      extends Applicable3<String, String, Integer, Integer>\n      implements Positioned {\n    StringSubstring(Pos pos) {\n      super(BuiltIn.STRING_SUBSTRING, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new StringSubstring(pos);\n    }\n\n    @Override public String apply(String s, Integer i, Integer j) {\n      if (i < 0 || j < 0 || i + j > s.length()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return s.substring(i, i + j);\n    }\n  }", "definition": "  private static class StringSubstring\n      extends Applicable3<String, String, Integer, Integer>\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#STRING_SUBSTRING}.", "name": "StringSubstring", "super_interfaces": ["Positioned"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    StringSubstring(Pos pos) {\n      super(BuiltIn.STRING_SUBSTRING, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "StringSubstring", "params": [{"name": "pos", "type": "Pos"}], "body": "                             {\n      super(BuiltIn.STRING_SUBSTRING, pos);\n    }", "signature": "StringSubstring(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new StringSubstring(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new StringSubstring(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public String apply(String s, Integer i, Integer j) {\n      if (i < 0 || j < 0 || i + j > s.length()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return s.substring(i, i + j);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "apply", "params": [{"name": "s", "type": "String"}, {"name": "i", "type": "Integer"}, {"name": "j", "type": "Integer"}], "body": "                                                                  {\n      if (i < 0 || j < 0 || i + j > s.length()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return s.substring(i, i + j);\n    }", "signature": "@Override public String apply(String s, Integer i, Integer j)"}]}, {"original_string": "  private static class StringConcat extends ApplicableImpl\n      implements Positioned {\n    StringConcat(Pos pos) {\n      super(BuiltIn.STRING_CONCAT, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new StringConcat(pos);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public Object apply(EvalEnv env, Object arg) {\n      return stringConcat(pos, \"\", (List<String>) arg);\n    }\n  }", "definition": "  private static class StringConcat extends ApplicableImpl\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#STRING_CONCAT}.", "name": "StringConcat", "super_interfaces": ["Positioned"], "superclasses": "ApplicableImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    StringConcat(Pos pos) {\n      super(BuiltIn.STRING_CONCAT, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "StringConcat", "params": [{"name": "pos", "type": "Pos"}], "body": "                          {\n      super(BuiltIn.STRING_CONCAT, pos);\n    }", "signature": "StringConcat(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new StringConcat(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new StringConcat(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override public Object apply(EvalEnv env, Object arg) {\n      return stringConcat(pos, \"\", (List<String>) arg);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "env", "type": "EvalEnv"}, {"name": "arg", "type": "Object"}], "body": "                                                           {\n      return stringConcat(pos, \"\", (List<String>) arg);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override public Object apply(EvalEnv env, Object arg)"}]}, {"original_string": "  private static class StringConcatWith extends ApplicableImpl\n      implements Positioned {\n    StringConcatWith(Pos pos) {\n      super(BuiltIn.STRING_CONCAT_WITH, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new StringConcatWith(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object argValue) {\n      final String separator = (String) argValue;\n      return new ApplicableImpl(\"String.concatWith$separator\") {\n        @SuppressWarnings(\"unchecked\")\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return stringConcat(pos, separator, (List<String>) arg);\n        }\n      };\n    }\n  }", "definition": "  private static class StringConcatWith extends ApplicableImpl\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#STRING_CONCAT_WITH}.", "name": "StringConcatWith", "super_interfaces": ["Positioned"], "superclasses": "ApplicableImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    StringConcatWith(Pos pos) {\n      super(BuiltIn.STRING_CONCAT_WITH, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "StringConcatWith", "params": [{"name": "pos", "type": "Pos"}], "body": "                              {\n      super(BuiltIn.STRING_CONCAT_WITH, pos);\n    }", "signature": "StringConcatWith(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new StringConcatWith(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new StringConcatWith(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Object apply(EvalEnv env, Object argValue) {\n      final String separator = (String) argValue;\n      return new ApplicableImpl(\"String.concatWith$separator\") {\n        @SuppressWarnings(\"unchecked\")\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return stringConcat(pos, separator, (List<String>) arg);\n        }\n      };\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "env", "type": "EvalEnv"}, {"name": "argValue", "type": "Object"}], "body": "                                                                {\n      final String separator = (String) argValue;\n      return new ApplicableImpl(\"String.concatWith$separator\") {\n        @SuppressWarnings(\"unchecked\")\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return stringConcat(pos, separator, (List<String>) arg);\n        }\n      };\n    }", "signature": "@Override public Object apply(EvalEnv env, Object argValue)"}]}, {"original_string": "  private static class ListHd extends ApplicableImpl implements Positioned {\n    ListHd(Pos pos) {\n      super(BuiltIn.LIST_HD, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListHd(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      if (list.isEmpty()) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.get(0);\n    }\n  }", "definition": "  private static class ListHd extends ApplicableImpl implements Positioned", "class_docstring": " Implements {@link BuiltIn#LIST_HD}.", "name": "ListHd", "super_interfaces": ["Positioned"], "superclasses": "ApplicableImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ListHd(Pos pos) {\n      super(BuiltIn.LIST_HD, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListHd", "params": [{"name": "pos", "type": "Pos"}], "body": "                    {\n      super(BuiltIn.LIST_HD, pos);\n    }", "signature": "ListHd(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new ListHd(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new ListHd(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      if (list.isEmpty()) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.get(0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "env", "type": "EvalEnv"}, {"name": "arg", "type": "Object"}], "body": "                                                           {\n      final List list = (List) arg;\n      if (list.isEmpty()) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.get(0);\n    }", "signature": "@Override public Object apply(EvalEnv env, Object arg)"}]}, {"original_string": "  private static class ListTl extends ApplicableImpl implements Positioned {\n    ListTl(Pos pos) {\n      super(BuiltIn.LIST_TL, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListTl(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      final int size = list.size();\n      if (size == 0) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.subList(1, size);\n    }\n  }", "definition": "  private static class ListTl extends ApplicableImpl implements Positioned", "class_docstring": " Implements {@link BuiltIn#LIST_TL}.", "name": "ListTl", "super_interfaces": ["Positioned"], "superclasses": "ApplicableImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ListTl(Pos pos) {\n      super(BuiltIn.LIST_TL, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListTl", "params": [{"name": "pos", "type": "Pos"}], "body": "                    {\n      super(BuiltIn.LIST_TL, pos);\n    }", "signature": "ListTl(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new ListTl(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new ListTl(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      final int size = list.size();\n      if (size == 0) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.subList(1, size);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "env", "type": "EvalEnv"}, {"name": "arg", "type": "Object"}], "body": "                                                           {\n      final List list = (List) arg;\n      final int size = list.size();\n      if (size == 0) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.subList(1, size);\n    }", "signature": "@Override public Object apply(EvalEnv env, Object arg)"}]}, {"original_string": "  private static class ListLast extends ApplicableImpl implements Positioned {\n    ListLast(Pos pos) {\n      super(BuiltIn.LIST_LAST, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListLast(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      final int size = list.size();\n      if (size == 0) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.get(size - 1);\n    }\n  }", "definition": "  private static class ListLast extends ApplicableImpl implements Positioned", "class_docstring": " Implements {@link BuiltIn#LIST_LAST}.", "name": "ListLast", "super_interfaces": ["Positioned"], "superclasses": "ApplicableImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ListLast(Pos pos) {\n      super(BuiltIn.LIST_LAST, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListLast", "params": [{"name": "pos", "type": "Pos"}], "body": "                      {\n      super(BuiltIn.LIST_LAST, pos);\n    }", "signature": "ListLast(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new ListLast(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new ListLast(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      final int size = list.size();\n      if (size == 0) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.get(size - 1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "env", "type": "EvalEnv"}, {"name": "arg", "type": "Object"}], "body": "                                                           {\n      final List list = (List) arg;\n      final int size = list.size();\n      if (size == 0) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.get(size - 1);\n    }", "signature": "@Override public Object apply(EvalEnv env, Object arg)"}]}, {"original_string": "  private static class ListNth extends Applicable2<Object, List, Integer>\n      implements Positioned {\n    private final BuiltIn builtIn;\n\n    ListNth(BuiltIn builtIn, Pos pos) {\n      super(builtIn, pos);\n      this.builtIn = builtIn;\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListNth(builtIn, pos);\n    }\n\n    @Override public Object apply(List list, Integer i) {\n      if (i < 0 || i >= list.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return list.get(i);\n    }\n  }", "definition": "  private static class ListNth extends Applicable2<Object, List, Integer>\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#LIST_NTH}\nand {@link BuiltIn#VECTOR_SUB}.", "name": "ListNth", "super_interfaces": ["Positioned"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final BuiltIn builtIn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BuiltIn", "name": "builtIn", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ListNth(BuiltIn builtIn, Pos pos) {\n      super(builtIn, pos);\n      this.builtIn = builtIn;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListNth", "params": [{"name": "builtIn", "type": "BuiltIn"}, {"name": "pos", "type": "Pos"}], "body": "                                      {\n      super(builtIn, pos);\n      this.builtIn = builtIn;\n    }", "signature": "ListNth(BuiltIn builtIn, Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new ListNth(builtIn, pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new ListNth(builtIn, pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Object apply(List list, Integer i) {\n      if (i < 0 || i >= list.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return list.get(i);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "list", "type": "List"}, {"name": "i", "type": "Integer"}], "body": "                                                        {\n      if (i < 0 || i >= list.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return list.get(i);\n    }", "signature": "@Override public Object apply(List list, Integer i)"}]}, {"original_string": "  private static class ListTake extends Applicable2<List, List, Integer>\n      implements Positioned {\n    ListTake(Pos pos) {\n      super(BuiltIn.LIST_TAKE, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListTake(pos);\n    }\n\n    @Override public List apply(List list, Integer i) {\n      if (i < 0 || i > list.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return list.subList(0, i);\n    }\n  }", "definition": "  private static class ListTake extends Applicable2<List, List, Integer>\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#LIST_TAKE}.", "name": "ListTake", "super_interfaces": ["Positioned"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ListTake(Pos pos) {\n      super(BuiltIn.LIST_TAKE, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListTake", "params": [{"name": "pos", "type": "Pos"}], "body": "                      {\n      super(BuiltIn.LIST_TAKE, pos);\n    }", "signature": "ListTake(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new ListTake(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new ListTake(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public List apply(List list, Integer i) {\n      if (i < 0 || i > list.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return list.subList(0, i);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List", "classes": []}, "name": "apply", "params": [{"name": "list", "type": "List"}, {"name": "i", "type": "Integer"}], "body": "                                                      {\n      if (i < 0 || i > list.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return list.subList(0, i);\n    }", "signature": "@Override public List apply(List list, Integer i)"}]}, {"original_string": "  private static class ListTabulate extends ApplicableImpl\n      implements Positioned {\n    private final BuiltIn builtIn;\n\n    ListTabulate(BuiltIn builtIn, Pos pos) {\n      super(builtIn, pos);\n      this.builtIn = builtIn;\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListTabulate(builtIn, pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List tuple = (List) arg;\n      final int count = (Integer) tuple.get(0);\n      if (count < 0) {\n        throw new MorelRuntimeException(BuiltInExn.SIZE, pos);\n      }\n      final Applicable fn = (Applicable) tuple.get(1);\n      final ImmutableList.Builder<Object> builder = ImmutableList.builder();\n      for (int i = 0; i < count; i++) {\n        builder.add(fn.apply(env, i));\n      }\n      return builder.build();\n    }\n  }", "definition": "  private static class ListTabulate extends ApplicableImpl\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#LIST_TABULATE}.", "name": "ListTabulate", "super_interfaces": ["Positioned"], "superclasses": "ApplicableImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final BuiltIn builtIn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BuiltIn", "name": "builtIn", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ListTabulate(BuiltIn builtIn, Pos pos) {\n      super(builtIn, pos);\n      this.builtIn = builtIn;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListTabulate", "params": [{"name": "builtIn", "type": "BuiltIn"}, {"name": "pos", "type": "Pos"}], "body": "                                           {\n      super(builtIn, pos);\n      this.builtIn = builtIn;\n    }", "signature": "ListTabulate(BuiltIn builtIn, Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new ListTabulate(builtIn, pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new ListTabulate(builtIn, pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Object apply(EvalEnv env, Object arg) {\n      final List tuple = (List) arg;\n      final int count = (Integer) tuple.get(0);\n      if (count < 0) {\n        throw new MorelRuntimeException(BuiltInExn.SIZE, pos);\n      }\n      final Applicable fn = (Applicable) tuple.get(1);\n      final ImmutableList.Builder<Object> builder = ImmutableList.builder();\n      for (int i = 0; i < count; i++) {\n        builder.add(fn.apply(env, i));\n      }\n      return builder.build();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "env", "type": "EvalEnv"}, {"name": "arg", "type": "Object"}], "body": "                                                           {\n      final List tuple = (List) arg;\n      final int count = (Integer) tuple.get(0);\n      if (count < 0) {\n        throw new MorelRuntimeException(BuiltInExn.SIZE, pos);\n      }\n      final Applicable fn = (Applicable) tuple.get(1);\n      final ImmutableList.Builder<Object> builder = ImmutableList.builder();\n      for (int i = 0; i < count; i++) {\n        builder.add(fn.apply(env, i));\n      }\n      return builder.build();\n    }", "signature": "@Override public Object apply(EvalEnv env, Object arg)"}]}, {"original_string": "  private static class OptionValOf extends ApplicableImpl\n      implements Positioned {\n    OptionValOf(Pos pos) {\n      super(BuiltIn.OPTION_VAL_OF, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new OptionValOf(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List opt = (List) arg;\n      if (opt.size() == 2) { // SOME has 2 elements, NONE has 1\n        return opt.get(1);\n      } else {\n        throw new MorelRuntimeException(BuiltInExn.OPTION, pos);\n      }\n    }\n  }", "definition": "  private static class OptionValOf extends ApplicableImpl\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#OPTION_VAL_OF}.", "name": "OptionValOf", "super_interfaces": ["Positioned"], "superclasses": "ApplicableImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    OptionValOf(Pos pos) {\n      super(BuiltIn.OPTION_VAL_OF, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OptionValOf", "params": [{"name": "pos", "type": "Pos"}], "body": "                         {\n      super(BuiltIn.OPTION_VAL_OF, pos);\n    }", "signature": "OptionValOf(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new OptionValOf(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new OptionValOf(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Object apply(EvalEnv env, Object arg) {\n      final List opt = (List) arg;\n      if (opt.size() == 2) { // SOME has 2 elements, NONE has 1\n        return opt.get(1);\n      } else {\n        throw new MorelRuntimeException(BuiltInExn.OPTION, pos);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "env", "type": "EvalEnv"}, {"name": "arg", "type": "Object"}], "body": "                                                           {\n      final List opt = (List) arg;\n      if (opt.size() == 2) { // SOME has 2 elements, NONE has 1\n        return opt.get(1);\n      } else {\n        throw new MorelRuntimeException(BuiltInExn.OPTION, pos);\n      }\n    }", "signature": "@Override public Object apply(EvalEnv env, Object arg)"}]}, {"original_string": "  private static class RealCheckFloat extends ApplicableImpl\n      implements Positioned {\n    RealCheckFloat(Pos pos) {\n      super(BuiltIn.REAL_CHECK_FLOAT, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new RealCheckFloat(pos);\n    }\n\n    @Override public Float apply(EvalEnv env, Object arg) {\n      final Float f = (Float) arg;\n      if (Float.isFinite(f)) {\n        return f;\n      }\n      if (Float.isNaN(f)) {\n        throw new MorelRuntimeException(BuiltInExn.DIV, pos);\n      } else {\n        throw new MorelRuntimeException(BuiltInExn.OVERFLOW, pos);\n      }\n    }\n  }", "definition": "  private static class RealCheckFloat extends ApplicableImpl\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#REAL_CHECK_FLOAT}.", "name": "RealCheckFloat", "super_interfaces": ["Positioned"], "superclasses": "ApplicableImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RealCheckFloat(Pos pos) {\n      super(BuiltIn.REAL_CHECK_FLOAT, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RealCheckFloat", "params": [{"name": "pos", "type": "Pos"}], "body": "                            {\n      super(BuiltIn.REAL_CHECK_FLOAT, pos);\n    }", "signature": "RealCheckFloat(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new RealCheckFloat(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new RealCheckFloat(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Float apply(EvalEnv env, Object arg) {\n      final Float f = (Float) arg;\n      if (Float.isFinite(f)) {\n        return f;\n      }\n      if (Float.isNaN(f)) {\n        throw new MorelRuntimeException(BuiltInExn.DIV, pos);\n      } else {\n        throw new MorelRuntimeException(BuiltInExn.OVERFLOW, pos);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Float", "classes": []}, "name": "apply", "params": [{"name": "env", "type": "EvalEnv"}, {"name": "arg", "type": "Object"}], "body": "                                                          {\n      final Float f = (Float) arg;\n      if (Float.isFinite(f)) {\n        return f;\n      }\n      if (Float.isNaN(f)) {\n        throw new MorelRuntimeException(BuiltInExn.DIV, pos);\n      } else {\n        throw new MorelRuntimeException(BuiltInExn.OVERFLOW, pos);\n      }\n    }", "signature": "@Override public Float apply(EvalEnv env, Object arg)"}]}, {"original_string": "  private static class RealCompare extends Applicable2<List, Float, Float>\n      implements Positioned {\n    RealCompare(Pos pos) {\n      super(BuiltIn.REAL_COMPARE, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new RealCompare(pos);\n    }\n\n    @Override public List apply(Float f0, Float f1) {\n      if (Float.isNaN(f0) || Float.isNaN(f1)) {\n        throw new MorelRuntimeException(BuiltInExn.UNORDERED, pos);\n      }\n      if (f0 < f1) {\n        return ORDER_LESS;\n      }\n      if (f0 > f1) {\n        return ORDER_GREATER;\n      }\n      // In particular, compare (~0.0, 0) returns ORDER_EQUAL\n      return ORDER_EQUAL;\n    }\n  }", "definition": "  private static class RealCompare extends Applicable2<List, Float, Float>\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#REAL_COMPARE}.", "name": "RealCompare", "super_interfaces": ["Positioned"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RealCompare(Pos pos) {\n      super(BuiltIn.REAL_COMPARE, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RealCompare", "params": [{"name": "pos", "type": "Pos"}], "body": "                         {\n      super(BuiltIn.REAL_COMPARE, pos);\n    }", "signature": "RealCompare(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new RealCompare(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new RealCompare(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public List apply(Float f0, Float f1) {\n      if (Float.isNaN(f0) || Float.isNaN(f1)) {\n        throw new MorelRuntimeException(BuiltInExn.UNORDERED, pos);\n      }\n      if (f0 < f1) {\n        return ORDER_LESS;\n      }\n      if (f0 > f1) {\n        return ORDER_GREATER;\n      }\n      // In particular, compare (~0.0, 0) returns ORDER_EQUAL\n      return ORDER_EQUAL;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List", "classes": []}, "name": "apply", "params": [{"name": "f0", "type": "Float"}, {"name": "f1", "type": "Float"}], "body": "                                                    {\n      if (Float.isNaN(f0) || Float.isNaN(f1)) {\n        throw new MorelRuntimeException(BuiltInExn.UNORDERED, pos);\n      }\n      if (f0 < f1) {\n        return ORDER_LESS;\n      }\n      if (f0 > f1) {\n        return ORDER_GREATER;\n      }\n      // In particular, compare (~0.0, 0) returns ORDER_EQUAL\n      return ORDER_EQUAL;\n    }", "signature": "@Override public List apply(Float f0, Float f1)"}]}, {"original_string": "  private static class RealSign extends ApplicableImpl\n      implements Positioned {\n    RealSign(Pos pos) {\n      super(BuiltIn.REAL_SIGN, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new RealSign(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final float f = (Float) arg;\n      if (Float.isNaN(f)) {\n        throw new MorelRuntimeException(BuiltInExn.DOMAIN, pos);\n      }\n      return f == 0f ? 0 // positive or negative zero\n          : (f > 0f) ? 1 // positive number or positive infinity\n              : -1; // negative number or negative infinity\n    }\n  }", "definition": "  private static class RealSign extends ApplicableImpl\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#REAL_COMPARE}.", "name": "RealSign", "super_interfaces": ["Positioned"], "superclasses": "ApplicableImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RealSign(Pos pos) {\n      super(BuiltIn.REAL_SIGN, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RealSign", "params": [{"name": "pos", "type": "Pos"}], "body": "                      {\n      super(BuiltIn.REAL_SIGN, pos);\n    }", "signature": "RealSign(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new RealSign(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new RealSign(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Object apply(EvalEnv env, Object arg) {\n      final float f = (Float) arg;\n      if (Float.isNaN(f)) {\n        throw new MorelRuntimeException(BuiltInExn.DOMAIN, pos);\n      }\n      return f == 0f ? 0 // positive or negative zero\n          : (f > 0f) ? 1 // positive number or positive infinity\n              : -1; // negative number or negative infinity\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "env", "type": "EvalEnv"}, {"name": "arg", "type": "Object"}], "body": "                                                           {\n      final float f = (Float) arg;\n      if (Float.isNaN(f)) {\n        throw new MorelRuntimeException(BuiltInExn.DOMAIN, pos);\n      }\n      return f == 0f ? 0 // positive or negative zero\n          : (f > 0f) ? 1 // positive number or positive infinity\n              : -1; // negative number or negative infinity\n    }", "signature": "@Override public Object apply(EvalEnv env, Object arg)"}]}, {"original_string": "  private static class RelationalOnly extends ApplicableImpl\n      implements Positioned {\n    RelationalOnly(Pos pos) {\n      super(BuiltIn.RELATIONAL_ONLY, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new RelationalOnly(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      if (list.isEmpty()) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      if (list.size() > 1) {\n        throw new MorelRuntimeException(BuiltInExn.SIZE, pos);\n      }\n      return list.get(0);\n    }\n  }", "definition": "  private static class RelationalOnly extends ApplicableImpl\n      implements Positioned", "class_docstring": " Implements {@link BuiltIn#RELATIONAL_ONLY}.", "name": "RelationalOnly", "super_interfaces": ["Positioned"], "superclasses": "ApplicableImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RelationalOnly(Pos pos) {\n      super(BuiltIn.RELATIONAL_ONLY, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RelationalOnly", "params": [{"name": "pos", "type": "Pos"}], "body": "                            {\n      super(BuiltIn.RELATIONAL_ONLY, pos);\n    }", "signature": "RelationalOnly(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new RelationalOnly(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new RelationalOnly(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      if (list.isEmpty()) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      if (list.size() > 1) {\n        throw new MorelRuntimeException(BuiltInExn.SIZE, pos);\n      }\n      return list.get(0);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "env", "type": "EvalEnv"}, {"name": "arg", "type": "Object"}], "body": "                                                           {\n      final List list = (List) arg;\n      if (list.isEmpty()) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      if (list.size() > 1) {\n        throw new MorelRuntimeException(BuiltInExn.SIZE, pos);\n      }\n      return list.get(0);\n    }", "signature": "@Override public Object apply(EvalEnv env, Object arg)"}]}, {"original_string": "  private static class VectorUpdate\n      extends Applicable3<List, List, Integer, Object> implements Positioned {\n    VectorUpdate(Pos pos) {\n      super(BuiltIn.VECTOR_UPDATE, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new VectorUpdate(pos);\n    }\n\n    @Override public List apply(List vec, Integer i, Object x) {\n      if (i < 0 || i >= vec.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      final Object[] elements = vec.toArray();\n      elements[i] = x;\n      return ImmutableList.copyOf(elements);\n    }\n  }", "definition": "  private static class VectorUpdate\n      extends Applicable3<List, List, Integer, Object> implements Positioned", "class_docstring": " Implements {@link BuiltIn#VECTOR_UPDATE}.", "name": "VectorUpdate", "super_interfaces": ["Positioned"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    VectorUpdate(Pos pos) {\n      super(BuiltIn.VECTOR_UPDATE, pos);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "VectorUpdate", "params": [{"name": "pos", "type": "Pos"}], "body": "                          {\n      super(BuiltIn.VECTOR_UPDATE, pos);\n    }", "signature": "VectorUpdate(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public Applicable withPos(Pos pos) {\n      return new VectorUpdate(pos);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Applicable", "classes": []}, "name": "withPos", "params": [{"name": "pos", "type": "Pos"}], "body": "                                                 {\n      return new VectorUpdate(pos);\n    }", "signature": "@Override public Applicable withPos(Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public List apply(List vec, Integer i, Object x) {\n      if (i < 0 || i >= vec.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      final Object[] elements = vec.toArray();\n      elements[i] = x;\n      return ImmutableList.copyOf(elements);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List", "classes": []}, "name": "apply", "params": [{"name": "vec", "type": "List"}, {"name": "i", "type": "Integer"}, {"name": "x", "type": "Object"}], "body": "                                                               {\n      if (i < 0 || i >= vec.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      final Object[] elements = vec.toArray();\n      elements[i] = x;\n      return ImmutableList.copyOf(elements);\n    }", "signature": "@Override public List apply(List vec, Integer i, Object x)"}]}, {"original_string": "  public static class TupleCode implements Code {\n    public final List<Code> codes;\n\n    private TupleCode(ImmutableList<Code> codes) {\n      this.codes = codes;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"tuple\", d ->\n          codes.forEach(code -> d.arg(\"\", code)));\n    }\n\n    public Object eval(EvalEnv env) {\n      final Object[] values = new Object[codes.size()];\n      for (int i = 0; i < values.length; i++) {\n        values[i] = codes.get(i).eval(env);\n      }\n      return Arrays.asList(values);\n    }\n  }", "definition": "  public static class TupleCode implements Code", "class_docstring": " A code that evaluates expressions and creates a tuple with the results.\n\n<p>An inner class so that we can pick apart the results of multiply\ndefined functions: {@code fun f = ... and g = ...}.\n", "name": "TupleCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final List<Code> codes;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Code>", "name": "codes", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private TupleCode(ImmutableList<Code> codes) {\n      this.codes = codes;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "TupleCode", "params": [{"name": "codes", "type": "ImmutableList<Code>"}], "body": "                                                 {\n      this.codes = codes;\n    }", "signature": "private TupleCode(ImmutableList<Code> codes)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"tuple\", d ->\n          codes.forEach(code -> d.arg(\"\", code)));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"tuple\", d ->\n          codes.forEach(code -> d.arg(\"\", code)));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    public Object eval(EvalEnv env) {\n      final Object[] values = new Object[codes.size()];\n      for (int i = 0; i < values.length; i++) {\n        values[i] = codes.get(i).eval(env);\n      }\n      return Arrays.asList(values);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                    {\n      final Object[] values = new Object[codes.size()];\n      for (int i = 0; i < values.length; i++) {\n        values[i] = codes.get(i).eval(env);\n      }\n      return Arrays.asList(values);\n    }", "signature": "public Object eval(EvalEnv env)"}]}, {"original_string": "  abstract static class BaseRowSink implements RowSink {\n    final RowSink rowSink;\n\n    BaseRowSink(RowSink rowSink) {\n      this.rowSink = requireNonNull(rowSink);\n    }\n\n    @Override public void start(EvalEnv env) {\n      rowSink.start(env);\n    }\n\n    @Override public void accept(EvalEnv env) {\n      rowSink.accept(env);\n    }\n\n    @Override public List<Object> result(EvalEnv env) {\n      return rowSink.result(env);\n    }\n  }", "definition": "  abstract static class BaseRowSink implements RowSink", "class_docstring": " Abstract implementation for row sinks that have one successor.", "name": "BaseRowSink", "super_interfaces": ["RowSink"], "superclasses": "", "attributes": {"modifiers": "abstract static", "marker_annotations": [], "non_marker_annotations": ["abstract", "static"], "comments": [], "fields": [{"attribute_expression": "final RowSink rowSink;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "RowSink", "name": "rowSink", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    BaseRowSink(RowSink rowSink) {\n      this.rowSink = requireNonNull(rowSink);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "BaseRowSink", "params": [{"name": "rowSink", "type": "RowSink"}], "body": "                                 {\n      this.rowSink = requireNonNull(rowSink);\n    }", "signature": "BaseRowSink(RowSink rowSink)"}, {"syntax_pass": true, "original_string": "    @Override public void start(EvalEnv env) {\n      rowSink.start(env);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "start", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                             {\n      rowSink.start(env);\n    }", "signature": "@Override public void start(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(EvalEnv env) {\n      rowSink.accept(env);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      rowSink.accept(env);\n    }", "signature": "@Override public void accept(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public List<Object> result(EvalEnv env) {\n      return rowSink.result(env);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Object>", "classes": []}, "name": "result", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                                      {\n      return rowSink.result(env);\n    }", "signature": "@Override public List<Object> result(EvalEnv env)"}]}, {"original_string": "  static class ScanRowSink extends BaseRowSink {\n    final Op op; // inner, left, right, full\n    private final Core.Pat pat;\n    private final Code code;\n    final Code conditionCode;\n\n    ScanRowSink(Op op, Core.Pat pat, Code code, Code conditionCode,\n        RowSink rowSink) {\n      super(rowSink);\n      checkArgument(op == Op.SCAN);\n      this.op = op;\n      this.pat = pat;\n      this.code = code;\n      this.conditionCode = conditionCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"join\", d ->\n          d.arg(\"pat\", pat)\n              .arg(\"exp\", code)\n              .argIf(\"condition\", conditionCode, !isConstantTrue(conditionCode))\n              .arg(\"sink\", rowSink));\n    }\n\n    private static boolean isConstantTrue(Code code) {\n      return code.isConstant()\n          && Objects.equals(code.eval(null), true);\n    }\n\n    @Override public void accept(EvalEnv env) {\n      final MutableEvalEnv mutableEvalEnv = env.bindMutablePat(pat);\n      final Iterable<Object> elements = (Iterable<Object>) code.eval(env);\n      for (Object element : elements) {\n        if (mutableEvalEnv.setOpt(element)) {\n          Boolean b = (Boolean) conditionCode.eval(mutableEvalEnv);\n          if (b != null && b) {\n            rowSink.accept(mutableEvalEnv);\n          }\n        }\n      }\n    }\n  }", "definition": "  static class ScanRowSink extends BaseRowSink", "class_docstring": " Implementation of {@link RowSink} for a {@code join} clause.", "name": "ScanRowSink", "super_interfaces": [], "superclasses": "BaseRowSink", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final Op op;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Op", "name": "op", "syntax_pass": true}, {"attribute_expression": "private final Core.Pat pat;", "docstring": " inner, left, right, full", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Core.Pat", "name": "pat", "syntax_pass": true}, {"attribute_expression": "private final Code code;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "code", "syntax_pass": true}, {"attribute_expression": "final Code conditionCode;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Code", "name": "conditionCode", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ScanRowSink(Op op, Core.Pat pat, Code code, Code conditionCode,\n        RowSink rowSink) {\n      super(rowSink);\n      checkArgument(op == Op.SCAN);\n      this.op = op;\n      this.pat = pat;\n      this.code = code;\n      this.conditionCode = conditionCode;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ScanRowSink", "params": [{"name": "op", "type": "Op"}, {"name": "pat", "type": "Core.Pat"}, {"name": "code", "type": "Code"}, {"name": "conditionCode", "type": "Code"}, {"name": "rowSink", "type": "RowSink"}], "body": "                         {\n      super(rowSink);\n      checkArgument(op == Op.SCAN);\n      this.op = op;\n      this.pat = pat;\n      this.code = code;\n      this.conditionCode = conditionCode;\n    }", "signature": "ScanRowSink(Op op, Core.Pat pat, Code code, Code conditionCode,\n        RowSink rowSink)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"join\", d ->\n          d.arg(\"pat\", pat)\n              .arg(\"exp\", code)\n              .argIf(\"condition\", conditionCode, !isConstantTrue(conditionCode))\n              .arg(\"sink\", rowSink));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"join\", d ->\n          d.arg(\"pat\", pat)\n              .arg(\"exp\", code)\n              .argIf(\"condition\", conditionCode, !isConstantTrue(conditionCode))\n              .arg(\"sink\", rowSink));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    private static boolean isConstantTrue(Code code) {\n      return code.isConstant()\n          && Objects.equals(code.eval(null), true);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isConstantTrue", "params": [{"name": "code", "type": "Code"}], "body": "                                                     {\n      return code.isConstant()\n          && Objects.equals(code.eval(null), true);\n    }", "signature": "private static boolean isConstantTrue(Code code)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(EvalEnv env) {\n      final MutableEvalEnv mutableEvalEnv = env.bindMutablePat(pat);\n      final Iterable<Object> elements = (Iterable<Object>) code.eval(env);\n      for (Object element : elements) {\n        if (mutableEvalEnv.setOpt(element)) {\n          Boolean b = (Boolean) conditionCode.eval(mutableEvalEnv);\n          if (b != null && b) {\n            rowSink.accept(mutableEvalEnv);\n          }\n        }\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      final MutableEvalEnv mutableEvalEnv = env.bindMutablePat(pat);\n      final Iterable<Object> elements = (Iterable<Object>) code.eval(env);\n      for (Object element : elements) {\n        if (mutableEvalEnv.setOpt(element)) {\n          Boolean b = (Boolean) conditionCode.eval(mutableEvalEnv);\n          if (b != null && b) {\n            rowSink.accept(mutableEvalEnv);\n          }\n        }\n      }\n    }", "signature": "@Override public void accept(EvalEnv env)"}]}, {"original_string": "  static class WhereRowSink extends BaseRowSink {\n    final Code filterCode;\n\n    WhereRowSink(Code filterCode, RowSink rowSink) {\n      super(rowSink);\n      this.filterCode = filterCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"where\", d ->\n          d.arg(\"condition\", filterCode)\n              .arg(\"sink\", rowSink));\n    }\n\n    @Override public void accept(EvalEnv env) {\n      if ((Boolean) filterCode.eval(env)) {\n        rowSink.accept(env);\n      }\n    }\n  }", "definition": "  static class WhereRowSink extends BaseRowSink", "class_docstring": " Implementation of {@link RowSink} for a {@code where} clause.", "name": "WhereRowSink", "super_interfaces": [], "superclasses": "BaseRowSink", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final Code filterCode;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Code", "name": "filterCode", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    WhereRowSink(Code filterCode, RowSink rowSink) {\n      super(rowSink);\n      this.filterCode = filterCode;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "WhereRowSink", "params": [{"name": "filterCode", "type": "Code"}, {"name": "rowSink", "type": "RowSink"}], "body": "                                                   {\n      super(rowSink);\n      this.filterCode = filterCode;\n    }", "signature": "WhereRowSink(Code filterCode, RowSink rowSink)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"where\", d ->\n          d.arg(\"condition\", filterCode)\n              .arg(\"sink\", rowSink));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"where\", d ->\n          d.arg(\"condition\", filterCode)\n              .arg(\"sink\", rowSink));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(EvalEnv env) {\n      if ((Boolean) filterCode.eval(env)) {\n        rowSink.accept(env);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      if ((Boolean) filterCode.eval(env)) {\n        rowSink.accept(env);\n      }\n    }", "signature": "@Override public void accept(EvalEnv env)"}]}, {"original_string": "  static class SkipRowSink extends BaseRowSink {\n    final Code skipCode;\n    int skip;\n\n    SkipRowSink(Code skipCode, RowSink rowSink) {\n      super(rowSink);\n      this.skipCode = skipCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"skip\", d ->\n          d.arg(\"count\", skipCode)\n              .arg(\"sink\", rowSink));\n    }\n\n    @Override public void start(EvalEnv env) {\n      skip = (Integer) skipCode.eval(env);\n      super.start(env);\n    }\n\n    @Override public void accept(EvalEnv env) {\n      if (skip > 0) {\n        --skip;\n      } else {\n        rowSink.accept(env);\n      }\n    }\n  }", "definition": "  static class SkipRowSink extends BaseRowSink", "class_docstring": " Implementation of {@link RowSink} for a {@code skip} clause.", "name": "SkipRowSink", "super_interfaces": [], "superclasses": "BaseRowSink", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final Code skipCode;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Code", "name": "skipCode", "syntax_pass": true}, {"attribute_expression": "int skip;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "skip", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    SkipRowSink(Code skipCode, RowSink rowSink) {\n      super(rowSink);\n      this.skipCode = skipCode;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SkipRowSink", "params": [{"name": "skipCode", "type": "Code"}, {"name": "rowSink", "type": "RowSink"}], "body": "                                                {\n      super(rowSink);\n      this.skipCode = skipCode;\n    }", "signature": "SkipRowSink(Code skipCode, RowSink rowSink)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"skip\", d ->\n          d.arg(\"count\", skipCode)\n              .arg(\"sink\", rowSink));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"skip\", d ->\n          d.arg(\"count\", skipCode)\n              .arg(\"sink\", rowSink));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public void start(EvalEnv env) {\n      skip = (Integer) skipCode.eval(env);\n      super.start(env);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "start", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                             {\n      skip = (Integer) skipCode.eval(env);\n      super.start(env);\n    }", "signature": "@Override public void start(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(EvalEnv env) {\n      if (skip > 0) {\n        --skip;\n      } else {\n        rowSink.accept(env);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      if (skip > 0) {\n        --skip;\n      } else {\n        rowSink.accept(env);\n      }\n    }", "signature": "@Override public void accept(EvalEnv env)"}]}, {"original_string": "  static class TakeRowSink extends BaseRowSink {\n    final Code takeCode;\n    int take;\n\n    TakeRowSink(Code takeCode, RowSink rowSink) {\n      super(rowSink);\n      this.takeCode = takeCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"take\", d ->\n          d.arg(\"count\", takeCode)\n              .arg(\"sink\", rowSink));\n    }\n\n    @Override public void start(EvalEnv env) {\n      take = (Integer) takeCode.eval(env);\n      super.start(env);\n    }\n\n    @Override public void accept(EvalEnv env) {\n      if (take > 0) {\n        --take;\n        rowSink.accept(env);\n      }\n    }\n  }", "definition": "  static class TakeRowSink extends BaseRowSink", "class_docstring": " Implementation of {@link RowSink} for a {@code take} clause.", "name": "TakeRowSink", "super_interfaces": [], "superclasses": "BaseRowSink", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final Code takeCode;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Code", "name": "takeCode", "syntax_pass": true}, {"attribute_expression": "int take;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "take", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TakeRowSink(Code takeCode, RowSink rowSink) {\n      super(rowSink);\n      this.takeCode = takeCode;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TakeRowSink", "params": [{"name": "takeCode", "type": "Code"}, {"name": "rowSink", "type": "RowSink"}], "body": "                                                {\n      super(rowSink);\n      this.takeCode = takeCode;\n    }", "signature": "TakeRowSink(Code takeCode, RowSink rowSink)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"take\", d ->\n          d.arg(\"count\", takeCode)\n              .arg(\"sink\", rowSink));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"take\", d ->\n          d.arg(\"count\", takeCode)\n              .arg(\"sink\", rowSink));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public void start(EvalEnv env) {\n      take = (Integer) takeCode.eval(env);\n      super.start(env);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "start", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                             {\n      take = (Integer) takeCode.eval(env);\n      super.start(env);\n    }", "signature": "@Override public void start(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(EvalEnv env) {\n      if (take > 0) {\n        --take;\n        rowSink.accept(env);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      if (take > 0) {\n        --take;\n        rowSink.accept(env);\n      }\n    }", "signature": "@Override public void accept(EvalEnv env)"}]}, {"original_string": "  private static class GroupRowSink extends BaseRowSink {\n    final Code keyCode;\n    final ImmutableList<String> inNames;\n    final ImmutableList<String> keyNames;\n    /** group names followed by aggregate names */\n    final ImmutableList<String> outNames;\n    final ImmutableList<Applicable> aggregateCodes;\n    final ListMultimap<Object, Object> map = ArrayListMultimap.create();\n    final Object[] values;\n\n    GroupRowSink(Code keyCode, ImmutableList<Applicable> aggregateCodes,\n        ImmutableList<String> inNames, ImmutableList<String> keyNames,\n        ImmutableList<String> outNames, RowSink rowSink) {\n      super(rowSink);\n      this.keyCode = requireNonNull(keyCode);\n      this.aggregateCodes = requireNonNull(aggregateCodes);\n      this.inNames = requireNonNull(inNames);\n      this.keyNames = requireNonNull(keyNames);\n      this.outNames = requireNonNull(outNames);\n      this.values = inNames.size() == 1 ? null : new Object[inNames.size()];\n      checkArgument(isPrefix(keyNames, outNames));\n    }\n\n    private static <E> boolean isPrefix(List<E> list0, List<E> list1) {\n      return list0.size() <= list1.size()\n          && list0.equals(list1.subList(0, list0.size()));\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"group\", d -> {\n        d.arg(\"key\", keyCode);\n        aggregateCodes.forEach(a -> d.arg(\"agg\", a));\n        d.arg(\"sink\", rowSink);\n      });\n    }\n\n    @Override public void accept(EvalEnv env) {\n      if (inNames.size() == 1) {\n        map.put(keyCode.eval(env), env.getOpt(inNames.get(0)));\n      } else {\n        for (int i = 0; i < inNames.size(); i++) {\n          values[i] = env.getOpt(inNames.get(i));\n        }\n        map.put(keyCode.eval(env), values.clone());\n      }\n    }\n\n    @Override public List<Object> result(final EvalEnv env) {\n      // Derive env2, the environment for our consumer. It consists of our input\n      // environment plus output names.\n      EvalEnv env2 = env;\n      final MutableEvalEnv[] groupEnvs = new MutableEvalEnv[outNames.size()];\n      int i = 0;\n      for (String name : outNames) {\n        env2 = groupEnvs[i++] = env2.bindMutable(name);\n      }\n\n      // Also derive env3, the environment wherein the aggregate functions are\n      // evaluated.\n      final EvalEnv env3 =\n          keyNames.isEmpty() ? env : groupEnvs[keyNames.size() - 1];\n\n      final Map<Object, List<Object>> map2;\n      if (map.isEmpty()\n          && keyCode instanceof TupleCode\n          && ((TupleCode) keyCode).codes.isEmpty()) {\n        // There are no keys, and there were no input rows.\n        map2 = ImmutableMap.of(ImmutableList.of(), ImmutableList.of());\n      } else {\n        //noinspection UnstableApiUsage\n        map2 = Multimaps.asMap(map);\n      }\n      for (Map.Entry<Object, List<Object>> entry : map2.entrySet()) {\n        final List list = (List) entry.getKey();\n        for (i = 0; i < list.size(); i++) {\n          groupEnvs[i].set(list.get(i));\n        }\n        final List<Object> rows = entry.getValue(); // rows in this bucket\n        for (Applicable aggregateCode : aggregateCodes) {\n          groupEnvs[i++].set(aggregateCode.apply(env3, rows));\n        }\n        rowSink.accept(env2);\n      }\n      return rowSink.result(env);\n    }\n  }", "definition": "  private static class GroupRowSink extends BaseRowSink", "class_docstring": " Implementation of {@link RowSink} for a {@code group} clause.", "name": "GroupRowSink", "super_interfaces": [], "superclasses": "BaseRowSink", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Code keyCode;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Code", "name": "keyCode", "syntax_pass": true}, {"attribute_expression": "final ImmutableList<String> inNames;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableList<String>", "name": "inNames", "syntax_pass": true}, {"attribute_expression": "final ImmutableList<String> keyNames;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableList<String>", "name": "keyNames", "syntax_pass": true}, {"attribute_expression": "final ImmutableList<String> outNames;", "docstring": " group names followed by aggregate names", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableList<String>", "name": "outNames", "syntax_pass": true}, {"attribute_expression": "final ImmutableList<Applicable> aggregateCodes;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableList<Applicable>", "name": "aggregateCodes", "syntax_pass": true}, {"attribute_expression": "final ListMultimap<Object, Object> map = ArrayListMultimap.create();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ListMultimap<Object, Object>", "name": "map = ArrayListMultimap.create()", "syntax_pass": true}, {"attribute_expression": "final Object[] values;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Object[]", "name": "values", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    GroupRowSink(Code keyCode, ImmutableList<Applicable> aggregateCodes,\n        ImmutableList<String> inNames, ImmutableList<String> keyNames,\n        ImmutableList<String> outNames, RowSink rowSink) {\n      super(rowSink);\n      this.keyCode = requireNonNull(keyCode);\n      this.aggregateCodes = requireNonNull(aggregateCodes);\n      this.inNames = requireNonNull(inNames);\n      this.keyNames = requireNonNull(keyNames);\n      this.outNames = requireNonNull(outNames);\n      this.values = inNames.size() == 1 ? null : new Object[inNames.size()];\n      checkArgument(isPrefix(keyNames, outNames));\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "GroupRowSink", "params": [{"name": "keyCode", "type": "Code"}, {"name": "aggregateCodes", "type": "ImmutableList<Applicable>"}, {"name": "inNames", "type": "ImmutableList<String>"}, {"name": "keyNames", "type": "ImmutableList<String>"}, {"name": "outNames", "type": "ImmutableList<String>"}, {"name": "rowSink", "type": "RowSink"}], "body": "                                                         {\n      super(rowSink);\n      this.keyCode = requireNonNull(keyCode);\n      this.aggregateCodes = requireNonNull(aggregateCodes);\n      this.inNames = requireNonNull(inNames);\n      this.keyNames = requireNonNull(keyNames);\n      this.outNames = requireNonNull(outNames);\n      this.values = inNames.size() == 1 ? null : new Object[inNames.size()];\n      checkArgument(isPrefix(keyNames, outNames));\n    }", "signature": "GroupRowSink(Code keyCode, ImmutableList<Applicable> aggregateCodes,\n        ImmutableList<String> inNames, ImmutableList<String> keyNames,\n        ImmutableList<String> outNames, RowSink rowSink)"}, {"syntax_pass": true, "original_string": "    private static <E> boolean isPrefix(List<E> list0, List<E> list1) {\n      return list0.size() <= list1.size()\n          && list0.equals(list1.subList(0, list0.size()));\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPrefix", "params": [{"name": "list0", "type": "List<E>"}, {"name": "list1", "type": "List<E>"}], "body": "                                                                      {\n      return list0.size() <= list1.size()\n          && list0.equals(list1.subList(0, list0.size()));\n    }", "signature": "private static <E> boolean isPrefix(List<E> list0, List<E> list1)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"group\", d -> {\n        d.arg(\"key\", keyCode);\n        aggregateCodes.forEach(a -> d.arg(\"agg\", a));\n        d.arg(\"sink\", rowSink);\n      });\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"group\", d -> {\n        d.arg(\"key\", keyCode);\n        aggregateCodes.forEach(a -> d.arg(\"agg\", a));\n        d.arg(\"sink\", rowSink);\n      });\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(EvalEnv env) {\n      if (inNames.size() == 1) {\n        map.put(keyCode.eval(env), env.getOpt(inNames.get(0)));\n      } else {\n        for (int i = 0; i < inNames.size(); i++) {\n          values[i] = env.getOpt(inNames.get(i));\n        }\n        map.put(keyCode.eval(env), values.clone());\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      if (inNames.size() == 1) {\n        map.put(keyCode.eval(env), env.getOpt(inNames.get(0)));\n      } else {\n        for (int i = 0; i < inNames.size(); i++) {\n          values[i] = env.getOpt(inNames.get(i));\n        }\n        map.put(keyCode.eval(env), values.clone());\n      }\n    }", "signature": "@Override public void accept(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public List<Object> result(final EvalEnv env) {\n      // Derive env2, the environment for our consumer. It consists of our input\n      // environment plus output names.\n      EvalEnv env2 = env;\n      final MutableEvalEnv[] groupEnvs = new MutableEvalEnv[outNames.size()];\n      int i = 0;\n      for (String name : outNames) {\n        env2 = groupEnvs[i++] = env2.bindMutable(name);\n      }\n\n      // Also derive env3, the environment wherein the aggregate functions are\n      // evaluated.\n      final EvalEnv env3 =\n          keyNames.isEmpty() ? env : groupEnvs[keyNames.size() - 1];\n\n      final Map<Object, List<Object>> map2;\n      if (map.isEmpty()\n          && keyCode instanceof TupleCode\n          && ((TupleCode) keyCode).codes.isEmpty()) {\n        // There are no keys, and there were no input rows.\n        map2 = ImmutableMap.of(ImmutableList.of(), ImmutableList.of());\n      } else {\n        //noinspection UnstableApiUsage\n        map2 = Multimaps.asMap(map);\n      }\n      for (Map.Entry<Object, List<Object>> entry : map2.entrySet()) {\n        final List list = (List) entry.getKey();\n        for (i = 0; i < list.size(); i++) {\n          groupEnvs[i].set(list.get(i));\n        }\n        final List<Object> rows = entry.getValue(); // rows in this bucket\n        for (Applicable aggregateCode : aggregateCodes) {\n          groupEnvs[i++].set(aggregateCode.apply(env3, rows));\n        }\n        rowSink.accept(env2);\n      }\n      return rowSink.result(env);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Object>", "classes": []}, "name": "result", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                                            {\n      // Derive env2, the environment for our consumer. It consists of our input\n      // environment plus output names.\n      EvalEnv env2 = env;\n      final MutableEvalEnv[] groupEnvs = new MutableEvalEnv[outNames.size()];\n      int i = 0;\n      for (String name : outNames) {\n        env2 = groupEnvs[i++] = env2.bindMutable(name);\n      }\n\n      // Also derive env3, the environment wherein the aggregate functions are\n      // evaluated.\n      final EvalEnv env3 =\n          keyNames.isEmpty() ? env : groupEnvs[keyNames.size() - 1];\n\n      final Map<Object, List<Object>> map2;\n      if (map.isEmpty()\n          && keyCode instanceof TupleCode\n          && ((TupleCode) keyCode).codes.isEmpty()) {\n        // There are no keys, and there were no input rows.\n        map2 = ImmutableMap.of(ImmutableList.of(), ImmutableList.of());\n      } else {\n        //noinspection UnstableApiUsage\n        map2 = Multimaps.asMap(map);\n      }\n      for (Map.Entry<Object, List<Object>> entry : map2.entrySet()) {\n        final List list = (List) entry.getKey();\n        for (i = 0; i < list.size(); i++) {\n          groupEnvs[i].set(list.get(i));\n        }\n        final List<Object> rows = entry.getValue(); // rows in this bucket\n        for (Applicable aggregateCode : aggregateCodes) {\n          groupEnvs[i++].set(aggregateCode.apply(env3, rows));\n        }\n        rowSink.accept(env2);\n      }\n      return rowSink.result(env);\n    }", "signature": "@Override public List<Object> result(final EvalEnv env)"}]}, {"original_string": "  static class OrderRowSink extends BaseRowSink {\n    final ImmutablePairList<Code, Boolean> codes;\n    final ImmutableList<String> names;\n    final List<Object> rows = new ArrayList<>();\n    final Object[] values;\n\n    OrderRowSink(ImmutablePairList<Code, Boolean> codes,\n        ImmutableList<String> names, RowSink rowSink) {\n      super(rowSink);\n      this.codes = codes;\n      this.names = names;\n      this.values = names.size() == 1 ? null : new Object[names.size()];\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"order\", d -> {\n        codes.forEach((code, desc) -> d.arg(desc ? \"desc\" : \"asc\", code));\n        d.arg(\"sink\", rowSink);\n      });\n    }\n\n    @Override public void accept(EvalEnv env) {\n      if (values == null) {\n        rows.add(env.getOpt(names.get(0)));\n      } else {\n        for (int i = 0; i < names.size(); i++) {\n          values[i] = env.getOpt(names.get(i));\n        }\n        rows.add(values.clone());\n      }\n    }\n\n    @Override public List<Object> result(final EvalEnv env) {\n      final MutableEvalEnv leftEnv = env.bindMutableArray(names);\n      final MutableEvalEnv rightEnv = env.bindMutableArray(names);\n      rows.sort((left, right) -> {\n        leftEnv.set(left);\n        rightEnv.set(right);\n        for (Map.Entry<Code, Boolean> code : codes) {\n          final Comparable leftVal = (Comparable) code.getKey().eval(leftEnv);\n          final Comparable rightVal = (Comparable) code.getKey().eval(rightEnv);\n          int c = leftVal.compareTo(rightVal);\n          if (c != 0) {\n            return code.getValue() ? -c : c;\n          }\n        }\n        return 0;\n      });\n      for (Object row : rows) {\n        leftEnv.set(row);\n        rowSink.accept(leftEnv);\n      }\n      return rowSink.result(env);\n    }\n  }", "definition": "  static class OrderRowSink extends BaseRowSink", "class_docstring": " Implementation of {@link RowSink} for an {@code order} clause.", "name": "OrderRowSink", "super_interfaces": [], "superclasses": "BaseRowSink", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final ImmutablePairList<Code, Boolean> codes;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutablePairList<Code, Boolean>", "name": "codes", "syntax_pass": true}, {"attribute_expression": "final ImmutableList<String> names;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableList<String>", "name": "names", "syntax_pass": true}, {"attribute_expression": "final List<Object> rows = new ArrayList<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<Object>", "name": "rows = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "final Object[] values;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Object[]", "name": "values", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    OrderRowSink(ImmutablePairList<Code, Boolean> codes,\n        ImmutableList<String> names, RowSink rowSink) {\n      super(rowSink);\n      this.codes = codes;\n      this.names = names;\n      this.values = names.size() == 1 ? null : new Object[names.size()];\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OrderRowSink", "params": [{"name": "codes", "type": "ImmutablePairList<Code, Boolean>"}, {"name": "names", "type": "ImmutableList<String>"}, {"name": "rowSink", "type": "RowSink"}], "body": "                                                      {\n      super(rowSink);\n      this.codes = codes;\n      this.names = names;\n      this.values = names.size() == 1 ? null : new Object[names.size()];\n    }", "signature": "OrderRowSink(ImmutablePairList<Code, Boolean> codes,\n        ImmutableList<String> names, RowSink rowSink)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"order\", d -> {\n        codes.forEach((code, desc) -> d.arg(desc ? \"desc\" : \"asc\", code));\n        d.arg(\"sink\", rowSink);\n      });\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"order\", d -> {\n        codes.forEach((code, desc) -> d.arg(desc ? \"desc\" : \"asc\", code));\n        d.arg(\"sink\", rowSink);\n      });\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(EvalEnv env) {\n      if (values == null) {\n        rows.add(env.getOpt(names.get(0)));\n      } else {\n        for (int i = 0; i < names.size(); i++) {\n          values[i] = env.getOpt(names.get(i));\n        }\n        rows.add(values.clone());\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      if (values == null) {\n        rows.add(env.getOpt(names.get(0)));\n      } else {\n        for (int i = 0; i < names.size(); i++) {\n          values[i] = env.getOpt(names.get(i));\n        }\n        rows.add(values.clone());\n      }\n    }", "signature": "@Override public void accept(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public List<Object> result(final EvalEnv env) {\n      final MutableEvalEnv leftEnv = env.bindMutableArray(names);\n      final MutableEvalEnv rightEnv = env.bindMutableArray(names);\n      rows.sort((left, right) -> {\n        leftEnv.set(left);\n        rightEnv.set(right);\n        for (Map.Entry<Code, Boolean> code : codes) {\n          final Comparable leftVal = (Comparable) code.getKey().eval(leftEnv);\n          final Comparable rightVal = (Comparable) code.getKey().eval(rightEnv);\n          int c = leftVal.compareTo(rightVal);\n          if (c != 0) {\n            return code.getValue() ? -c : c;\n          }\n        }\n        return 0;\n      });\n      for (Object row : rows) {\n        leftEnv.set(row);\n        rowSink.accept(leftEnv);\n      }\n      return rowSink.result(env);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Object>", "classes": []}, "name": "result", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                                            {\n      final MutableEvalEnv leftEnv = env.bindMutableArray(names);\n      final MutableEvalEnv rightEnv = env.bindMutableArray(names);\n      rows.sort((left, right) -> {\n        leftEnv.set(left);\n        rightEnv.set(right);\n        for (Map.Entry<Code, Boolean> code : codes) {\n          final Comparable leftVal = (Comparable) code.getKey().eval(leftEnv);\n          final Comparable rightVal = (Comparable) code.getKey().eval(rightEnv);\n          int c = leftVal.compareTo(rightVal);\n          if (c != 0) {\n            return code.getValue() ? -c : c;\n          }\n        }\n        return 0;\n      });\n      for (Object row : rows) {\n        leftEnv.set(row);\n        rowSink.accept(leftEnv);\n      }\n      return rowSink.result(env);\n    }", "signature": "@Override public List<Object> result(final EvalEnv env)"}]}, {"original_string": "  private static class YieldRowSink extends BaseRowSink {\n    private final ImmutableList<String> names;\n    private final ImmutableList<Code> codes;\n    private final Object[] values;\n\n    YieldRowSink(ImmutableList<String> names, ImmutableList<Code> codes,\n        RowSink rowSink) {\n      super(rowSink);\n      this.names = names;\n      this.codes = codes;\n      this.values = names.size() == 1 ? null : new Object[names.size()];\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"yield\", d ->\n          d.arg(\"codes\", codes)\n              .arg(\"sink\", rowSink));\n    }\n\n    @Override public void accept(EvalEnv env) {\n      final MutableEvalEnv env2 = env.bindMutableArray(names);\n      if (values == null) {\n        final Object value = codes.get(0).eval(env);\n        env2.set(value);\n      } else {\n        for (int i = 0; i < codes.size(); i++) {\n          values[i] = codes.get(i).eval(env);\n        }\n        env2.set(values);\n      }\n      rowSink.accept(env2);\n    }\n  }", "definition": "  private static class YieldRowSink extends BaseRowSink", "class_docstring": " Implementation of {@link RowSink} for a {@code yield} step.\n\n<p>If this is the last step, use instead a {@link CollectRowSink}. It\nis more efficient; there is no downstream row sink; and a terminal yield\nstep is allowed to generate expressions that are not records. Non-record\nexpressions (e.g. {@code int} expressions) do not have a name, and\ntherefore the value cannot be passed via the {@link EvalEnv}.", "name": "YieldRowSink", "super_interfaces": [], "superclasses": "BaseRowSink", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final ImmutableList<String> names;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ImmutableList<String>", "name": "names", "syntax_pass": true}, {"attribute_expression": "private final ImmutableList<Code> codes;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ImmutableList<Code>", "name": "codes", "syntax_pass": true}, {"attribute_expression": "private final Object[] values;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[]", "name": "values", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    YieldRowSink(ImmutableList<String> names, ImmutableList<Code> codes,\n        RowSink rowSink) {\n      super(rowSink);\n      this.names = names;\n      this.codes = codes;\n      this.values = names.size() == 1 ? null : new Object[names.size()];\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "YieldRowSink", "params": [{"name": "names", "type": "ImmutableList<String>"}, {"name": "codes", "type": "ImmutableList<Code>"}, {"name": "rowSink", "type": "RowSink"}], "body": "                         {\n      super(rowSink);\n      this.names = names;\n      this.codes = codes;\n      this.values = names.size() == 1 ? null : new Object[names.size()];\n    }", "signature": "YieldRowSink(ImmutableList<String> names, ImmutableList<Code> codes,\n        RowSink rowSink)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"yield\", d ->\n          d.arg(\"codes\", codes)\n              .arg(\"sink\", rowSink));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"yield\", d ->\n          d.arg(\"codes\", codes)\n              .arg(\"sink\", rowSink));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(EvalEnv env) {\n      final MutableEvalEnv env2 = env.bindMutableArray(names);\n      if (values == null) {\n        final Object value = codes.get(0).eval(env);\n        env2.set(value);\n      } else {\n        for (int i = 0; i < codes.size(); i++) {\n          values[i] = codes.get(i).eval(env);\n        }\n        env2.set(values);\n      }\n      rowSink.accept(env2);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      final MutableEvalEnv env2 = env.bindMutableArray(names);\n      if (values == null) {\n        final Object value = codes.get(0).eval(env);\n        env2.set(value);\n      } else {\n        for (int i = 0; i < codes.size(); i++) {\n          values[i] = codes.get(i).eval(env);\n        }\n        env2.set(values);\n      }\n      rowSink.accept(env2);\n    }", "signature": "@Override public void accept(EvalEnv env)"}]}, {"original_string": "  private static class CollectRowSink implements RowSink {\n    final List<Object> list = new ArrayList<>();\n    final Code code;\n\n    CollectRowSink(Code code) {\n      this.code = requireNonNull(code);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"collect\", d -> d.arg(\"\", code));\n    }\n\n    @Override public void start(EvalEnv env) {\n      list.clear();\n    }\n\n    @Override public void accept(EvalEnv env) {\n      list.add(code.eval(env));\n    }\n\n    @Override public List<Object> result(EvalEnv env) {\n      return list;\n    }\n  }", "definition": "  private static class CollectRowSink implements RowSink", "class_docstring": " Implementation of {@link RowSink} that the last step of a {@code from}\nwrites into.", "name": "CollectRowSink", "super_interfaces": ["RowSink"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final List<Object> list = new ArrayList<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<Object>", "name": "list = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "final Code code;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Code", "name": "code", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    CollectRowSink(Code code) {\n      this.code = requireNonNull(code);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CollectRowSink", "params": [{"name": "code", "type": "Code"}], "body": "                              {\n      this.code = requireNonNull(code);\n    }", "signature": "CollectRowSink(Code code)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"collect\", d -> d.arg(\"\", code));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"collect\", d -> d.arg(\"\", code));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public void start(EvalEnv env) {\n      list.clear();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "start", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                             {\n      list.clear();\n    }", "signature": "@Override public void start(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public void accept(EvalEnv env) {\n      list.add(code.eval(env));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      list.add(code.eval(env));\n    }", "signature": "@Override public void accept(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public List<Object> result(EvalEnv env) {\n      return list;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Object>", "classes": []}, "name": "result", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                                      {\n      return list;\n    }", "signature": "@Override public List<Object> result(EvalEnv env)"}]}, {"original_string": "  private static class GetCode implements Code {\n    private final String name;\n\n    GetCode(String name) {\n      this.name = requireNonNull(name);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"get\", d -> d.arg(\"name\", name));\n    }\n\n    @Override public String toString() {\n      return \"get(\" + name + \")\";\n    }\n\n    public Object eval(EvalEnv env) {\n      return env.getOpt(name);\n    }\n  }", "definition": "  private static class GetCode implements Code", "class_docstring": " Code that retrieves the value of a variable from the environment.", "name": "GetCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final String name;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    GetCode(String name) {\n      this.name = requireNonNull(name);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "GetCode", "params": [{"name": "name", "type": "String"}], "body": "                         {\n      this.name = requireNonNull(name);\n    }", "signature": "GetCode(String name)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"get\", d -> d.arg(\"name\", name));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"get\", d -> d.arg(\"name\", name));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return \"get(\" + name + \")\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return \"get(\" + name + \")\";\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    public Object eval(EvalEnv env) {\n      return env.getOpt(name);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                    {\n      return env.getOpt(name);\n    }", "signature": "public Object eval(EvalEnv env)"}]}, {"original_string": "  private static class GetTupleCode implements Code {\n    private final ImmutableList<String> names;\n    private final Object[] values; // work space\n\n    GetTupleCode(ImmutableList<String> names) {\n      this.names = requireNonNull(names);\n      this.values = new Object[names.size()];\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"getTuple\", d -> d.arg(\"names\", names));\n    }\n\n    @Override public String toString() {\n      return \"getTuple(\" + names + \")\";\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      for (int i = 0; i < names.size(); i++) {\n        values[i] = env.getOpt(names.get(i));\n      }\n      return Arrays.asList(values.clone());\n    }\n  }", "definition": "  private static class GetTupleCode implements Code", "class_docstring": " Code that retrieves, as a tuple, the value of several variables from the\nenvironment.", "name": "GetTupleCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final ImmutableList<String> names;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ImmutableList<String>", "name": "names", "syntax_pass": true}, {"attribute_expression": "private final Object[] values;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[]", "name": "values", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    GetTupleCode(ImmutableList<String> names) {\n      this.names = requireNonNull(names);\n      this.values = new Object[names.size()];\n    }", "docstring": " work space", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "GetTupleCode", "params": [{"name": "names", "type": "ImmutableList<String>"}], "body": "                                              {\n      this.names = requireNonNull(names);\n      this.values = new Object[names.size()];\n    }", "signature": "GetTupleCode(ImmutableList<String> names)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"getTuple\", d -> d.arg(\"names\", names));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"getTuple\", d -> d.arg(\"names\", names));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return \"getTuple(\" + names + \")\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return \"getTuple(\" + names + \")\";\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv env) {\n      for (int i = 0; i < names.size(); i++) {\n        values[i] = env.getOpt(names.get(i));\n      }\n      return Arrays.asList(values.clone());\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      for (int i = 0; i < names.size(); i++) {\n        values[i] = env.getOpt(names.get(i));\n      }\n      return Arrays.asList(values.clone());\n    }", "signature": "@Override public Object eval(EvalEnv env)"}]}, {"original_string": "  public static class MorelRuntimeException extends RuntimeException\n      implements MorelException {\n    private final BuiltInExn e;\n    private final Pos pos;\n\n    /** Creates a MorelRuntimeException. */\n    public MorelRuntimeException(BuiltInExn e, Pos pos) {\n      this.e = requireNonNull(e);\n      this.pos = requireNonNull(pos);\n    }\n\n    @Override public String toString() {\n      return e.mlName + \" at \" + pos;\n    }\n\n    @Override public StringBuilder describeTo(StringBuilder buf) {\n      return buf.append(\"uncaught exception \")\n          .append(e.mlName);\n    }\n\n    @Override public Pos pos() {\n      return pos;\n    }\n  }", "definition": "  public static class MorelRuntimeException extends RuntimeException\n      implements MorelException", "class_docstring": " Java exception that wraps an exception thrown by the Morel runtime.", "name": "MorelRuntimeException", "super_interfaces": ["MorelException"], "superclasses": "RuntimeException", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final BuiltInExn e;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BuiltInExn", "name": "e", "syntax_pass": true}, {"attribute_expression": "private final Pos pos;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pos", "name": "pos", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public MorelRuntimeException(BuiltInExn e, Pos pos) {\n      this.e = requireNonNull(e);\n      this.pos = requireNonNull(pos);\n    }", "docstring": " Creates a MorelRuntimeException.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MorelRuntimeException", "params": [{"name": "e", "type": "BuiltInExn"}, {"name": "pos", "type": "Pos"}], "body": "                                                        {\n      this.e = requireNonNull(e);\n      this.pos = requireNonNull(pos);\n    }", "signature": "public MorelRuntimeException(BuiltInExn e, Pos pos)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return e.mlName + \" at \" + pos;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return e.mlName + \" at \" + pos;\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    @Override public StringBuilder describeTo(StringBuilder buf) {\n      return buf.append(\"uncaught exception \")\n          .append(e.mlName);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "describeTo", "params": [{"name": "buf", "type": "StringBuilder"}], "body": "                                                                 {\n      return buf.append(\"uncaught exception \")\n          .append(e.mlName);\n    }", "signature": "@Override public StringBuilder describeTo(StringBuilder buf)"}, {"syntax_pass": true, "original_string": "    @Override public Pos pos() {\n      return pos;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pos", "classes": []}, "name": "pos", "params": [], "body": "                               {\n      return pos;\n    }", "signature": "@Override public Pos pos()"}]}, {"original_string": "  private static class ConstantCode implements Code {\n    private final Object value;\n\n    ConstantCode(Object value) {\n      this.value = value;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"constant\", d -> d.arg(\"\", value));\n    }\n\n    public Object eval(EvalEnv env) {\n      return value;\n    }\n\n    @Override public boolean isConstant() {\n      return true;\n    }\n  }", "definition": "  private static class ConstantCode implements Code", "class_docstring": " Code that implements a constant.", "name": "ConstantCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Object value;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ConstantCode(Object value) {\n      this.value = value;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ConstantCode", "params": [{"name": "value", "type": "Object"}], "body": "                               {\n      this.value = value;\n    }", "signature": "ConstantCode(Object value)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"constant\", d -> d.arg(\"\", value));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"constant\", d -> d.arg(\"\", value));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    public Object eval(EvalEnv env) {\n      return value;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                    {\n      return value;\n    }", "signature": "public Object eval(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public boolean isConstant() {\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isConstant", "params": [], "body": "                                          {\n      return true;\n    }", "signature": "@Override public boolean isConstant()"}]}, {"original_string": "  private static class AndAlsoCode implements Code {\n    private final Code code0;\n    private final Code code1;\n\n    AndAlsoCode(Code code0, Code code1) {\n      this.code0 = code0;\n      this.code1 = code1;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"andalso\", d -> d.arg(\"\", code0).arg(\"\", code1));\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      // Lazy evaluation. If code0 returns false, code1 is never evaluated.\n      return (boolean) code0.eval(evalEnv) && (boolean) code1.eval(evalEnv);\n    }\n  }", "definition": "  private static class AndAlsoCode implements Code", "class_docstring": " Code that implements {@link #andAlso(Code, Code)}.", "name": "AndAlsoCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Code code0;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "code0", "syntax_pass": true}, {"attribute_expression": "private final Code code1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "code1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    AndAlsoCode(Code code0, Code code1) {\n      this.code0 = code0;\n      this.code1 = code1;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AndAlsoCode", "params": [{"name": "code0", "type": "Code"}, {"name": "code1", "type": "Code"}], "body": "                                        {\n      this.code0 = code0;\n      this.code1 = code1;\n    }", "signature": "AndAlsoCode(Code code0, Code code1)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"andalso\", d -> d.arg(\"\", code0).arg(\"\", code1));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"andalso\", d -> d.arg(\"\", code0).arg(\"\", code1));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv evalEnv) {\n      // Lazy evaluation. If code0 returns false, code1 is never evaluated.\n      return (boolean) code0.eval(evalEnv) && (boolean) code1.eval(evalEnv);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "evalEnv", "type": "EvalEnv"}], "body": "                                                  {\n      // Lazy evaluation. If code0 returns false, code1 is never evaluated.\n      return (boolean) code0.eval(evalEnv) && (boolean) code1.eval(evalEnv);\n    }", "signature": "@Override public Object eval(EvalEnv evalEnv)"}]}, {"original_string": "  private static class OrElseCode implements Code {\n    private final Code code0;\n    private final Code code1;\n\n    OrElseCode(Code code0, Code code1) {\n      this.code0 = code0;\n      this.code1 = code1;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"orelse\", d -> d.arg(\"\", code0).arg(\"\", code1));\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      // Lazy evaluation. If code0 returns true, code1 is never evaluated.\n      return (boolean) code0.eval(evalEnv) || (boolean) code1.eval(evalEnv);\n    }\n  }", "definition": "  private static class OrElseCode implements Code", "class_docstring": " Code that implements {@link #orElse(Code, Code)}.", "name": "OrElseCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Code code0;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "code0", "syntax_pass": true}, {"attribute_expression": "private final Code code1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "code1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    OrElseCode(Code code0, Code code1) {\n      this.code0 = code0;\n      this.code1 = code1;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "OrElseCode", "params": [{"name": "code0", "type": "Code"}, {"name": "code1", "type": "Code"}], "body": "                                       {\n      this.code0 = code0;\n      this.code1 = code1;\n    }", "signature": "OrElseCode(Code code0, Code code1)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"orelse\", d -> d.arg(\"\", code0).arg(\"\", code1));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"orelse\", d -> d.arg(\"\", code0).arg(\"\", code1));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv evalEnv) {\n      // Lazy evaluation. If code0 returns true, code1 is never evaluated.\n      return (boolean) code0.eval(evalEnv) || (boolean) code1.eval(evalEnv);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "evalEnv", "type": "EvalEnv"}], "body": "                                                  {\n      // Lazy evaluation. If code0 returns true, code1 is never evaluated.\n      return (boolean) code0.eval(evalEnv) || (boolean) code1.eval(evalEnv);\n    }", "signature": "@Override public Object eval(EvalEnv evalEnv)"}]}, {"original_string": "  private static class Let1Code implements Code {\n    private final Code matchCode;\n    private final Code resultCode;\n\n    Let1Code(Code matchCode, Code resultCode) {\n      this.matchCode = matchCode;\n      this.resultCode = resultCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"let1\", d ->\n          d.arg(\"matchCode\", matchCode).arg(\"resultCode\", resultCode));\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      final Closure fnValue = (Closure) matchCode.eval(evalEnv);\n      EvalEnv env2 = fnValue.evalBind(evalEnv);\n      return resultCode.eval(env2);\n    }\n  }", "definition": "  private static class Let1Code implements Code", "class_docstring": " Code that implements {@link #let(List, Code)} with one argument.", "name": "Let1Code", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Code matchCode;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "matchCode", "syntax_pass": true}, {"attribute_expression": "private final Code resultCode;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "resultCode", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Let1Code(Code matchCode, Code resultCode) {\n      this.matchCode = matchCode;\n      this.resultCode = resultCode;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Let1Code", "params": [{"name": "matchCode", "type": "Code"}, {"name": "resultCode", "type": "Code"}], "body": "                                              {\n      this.matchCode = matchCode;\n      this.resultCode = resultCode;\n    }", "signature": "Let1Code(Code matchCode, Code resultCode)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"let1\", d ->\n          d.arg(\"matchCode\", matchCode).arg(\"resultCode\", resultCode));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"let1\", d ->\n          d.arg(\"matchCode\", matchCode).arg(\"resultCode\", resultCode));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv evalEnv) {\n      final Closure fnValue = (Closure) matchCode.eval(evalEnv);\n      EvalEnv env2 = fnValue.evalBind(evalEnv);\n      return resultCode.eval(env2);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "evalEnv", "type": "EvalEnv"}], "body": "                                                  {\n      final Closure fnValue = (Closure) matchCode.eval(evalEnv);\n      EvalEnv env2 = fnValue.evalBind(evalEnv);\n      return resultCode.eval(env2);\n    }", "signature": "@Override public Object eval(EvalEnv evalEnv)"}]}, {"original_string": "  private static class LetCode implements Code {\n    private final ImmutableList<Code> matchCodes;\n    private final Code resultCode;\n\n    LetCode(ImmutableList<Code> matchCodes, Code resultCode) {\n      this.matchCodes = matchCodes;\n      this.resultCode = resultCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"let\", d -> {\n        forEachIndexed(matchCodes, (matchCode, i) ->\n            d.arg(\"matchCode\" + i, matchCode));\n        d.arg(\"resultCode\", resultCode);\n      });\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      EvalEnv evalEnv2 = evalEnv;\n      for (Code matchCode : matchCodes) {\n        final Closure fnValue = (Closure) matchCode.eval(evalEnv);\n        evalEnv2 = fnValue.evalBind(evalEnv2);\n      }\n      return resultCode.eval(evalEnv2);\n    }\n  }", "definition": "  private static class LetCode implements Code", "class_docstring": " Code that implements {@link #let(List, Code)} with multiple arguments.", "name": "LetCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final ImmutableList<Code> matchCodes;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ImmutableList<Code>", "name": "matchCodes", "syntax_pass": true}, {"attribute_expression": "private final Code resultCode;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "resultCode", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    LetCode(ImmutableList<Code> matchCodes, Code resultCode) {\n      this.matchCodes = matchCodes;\n      this.resultCode = resultCode;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "LetCode", "params": [{"name": "matchCodes", "type": "ImmutableList<Code>"}, {"name": "resultCode", "type": "Code"}], "body": "                                                             {\n      this.matchCodes = matchCodes;\n      this.resultCode = resultCode;\n    }", "signature": "LetCode(ImmutableList<Code> matchCodes, Code resultCode)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"let\", d -> {\n        forEachIndexed(matchCodes, (matchCode, i) ->\n            d.arg(\"matchCode\" + i, matchCode));\n        d.arg(\"resultCode\", resultCode);\n      });\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"let\", d -> {\n        forEachIndexed(matchCodes, (matchCode, i) ->\n            d.arg(\"matchCode\" + i, matchCode));\n        d.arg(\"resultCode\", resultCode);\n      });\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv evalEnv) {\n      EvalEnv evalEnv2 = evalEnv;\n      for (Code matchCode : matchCodes) {\n        final Closure fnValue = (Closure) matchCode.eval(evalEnv);\n        evalEnv2 = fnValue.evalBind(evalEnv2);\n      }\n      return resultCode.eval(evalEnv2);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "evalEnv", "type": "EvalEnv"}], "body": "                                                  {\n      EvalEnv evalEnv2 = evalEnv;\n      for (Code matchCode : matchCodes) {\n        final Closure fnValue = (Closure) matchCode.eval(evalEnv);\n        evalEnv2 = fnValue.evalBind(evalEnv2);\n      }\n      return resultCode.eval(evalEnv2);\n    }", "signature": "@Override public Object eval(EvalEnv evalEnv)"}]}, {"original_string": "  private static class ApplyCode implements Code {\n    private final Applicable fnValue;\n    private final Code argCode;\n\n    ApplyCode(Applicable fnValue, Code argCode) {\n      this.fnValue = fnValue;\n      this.argCode = argCode;\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      final Object arg = argCode.eval(env);\n      return fnValue.apply(env, arg);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply\", d ->\n          d.arg(\"fnValue\", fnValue).arg(\"argCode\", argCode));\n    }\n  }", "definition": "  private static class ApplyCode implements Code", "class_docstring": " Applies an {@link Applicable} to a {@link Code}.", "name": "ApplyCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Applicable fnValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Applicable", "name": "fnValue", "syntax_pass": true}, {"attribute_expression": "private final Code argCode;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "argCode", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ApplyCode(Applicable fnValue, Code argCode) {\n      this.fnValue = fnValue;\n      this.argCode = argCode;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ApplyCode", "params": [{"name": "fnValue", "type": "Applicable"}, {"name": "argCode", "type": "Code"}], "body": "                                                {\n      this.fnValue = fnValue;\n      this.argCode = argCode;\n    }", "signature": "ApplyCode(Applicable fnValue, Code argCode)"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv env) {\n      final Object arg = argCode.eval(env);\n      return fnValue.apply(env, arg);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      final Object arg = argCode.eval(env);\n      return fnValue.apply(env, arg);\n    }", "signature": "@Override public Object eval(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply\", d ->\n          d.arg(\"fnValue\", fnValue).arg(\"argCode\", argCode));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"apply\", d ->\n          d.arg(\"fnValue\", fnValue).arg(\"argCode\", argCode));\n    }", "signature": "@Override public Describer describe(Describer describer)"}]}, {"original_string": "  private static class ApplyCode2 implements Code {\n    private final Applicable2 fnValue;\n    private final Code argCode0;\n    private final Code argCode1;\n\n    ApplyCode2(Applicable2 fnValue, Code argCode0, Code argCode1) {\n      this.fnValue = fnValue;\n      this.argCode0 = argCode0;\n      this.argCode1 = argCode1;\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      final Object arg0 = argCode0.eval(env);\n      final Object arg1 = argCode1.eval(env);\n      return fnValue.apply(arg0, arg1);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply2\", d ->\n          d.arg(\"fnValue\", fnValue)\n              .arg(\"\", argCode0)\n              .arg(\"\", argCode1));\n    }\n  }", "definition": "  private static class ApplyCode2 implements Code", "class_docstring": " Applies an {@link Applicable2} to two {@link Code} arguments.", "name": "ApplyCode2", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Applicable2 fnValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Applicable2", "name": "fnValue", "syntax_pass": true}, {"attribute_expression": "private final Code argCode0;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "argCode0", "syntax_pass": true}, {"attribute_expression": "private final Code argCode1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "argCode1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ApplyCode2(Applicable2 fnValue, Code argCode0, Code argCode1) {\n      this.fnValue = fnValue;\n      this.argCode0 = argCode0;\n      this.argCode1 = argCode1;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ApplyCode2", "params": [{"name": "fnValue", "type": "Applicable2"}, {"name": "argCode0", "type": "Code"}, {"name": "argCode1", "type": "Code"}], "body": "                                                                  {\n      this.fnValue = fnValue;\n      this.argCode0 = argCode0;\n      this.argCode1 = argCode1;\n    }", "signature": "ApplyCode2(Applicable2 fnValue, Code argCode0, Code argCode1)"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv env) {\n      final Object arg0 = argCode0.eval(env);\n      final Object arg1 = argCode1.eval(env);\n      return fnValue.apply(arg0, arg1);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      final Object arg0 = argCode0.eval(env);\n      final Object arg1 = argCode1.eval(env);\n      return fnValue.apply(arg0, arg1);\n    }", "signature": "@Override public Object eval(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply2\", d ->\n          d.arg(\"fnValue\", fnValue)\n              .arg(\"\", argCode0)\n              .arg(\"\", argCode1));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"apply2\", d ->\n          d.arg(\"fnValue\", fnValue)\n              .arg(\"\", argCode0)\n              .arg(\"\", argCode1));\n    }", "signature": "@Override public Describer describe(Describer describer)"}]}, {"original_string": "  private static class ApplyCode3 implements Code {\n    private final Applicable3 fnValue;\n    private final Code argCode0;\n    private final Code argCode1;\n    private final Code argCode2;\n\n    ApplyCode3(Applicable3 fnValue, Code argCode0, Code argCode1,\n        Code argCode2) {\n      this.fnValue = fnValue;\n      this.argCode0 = argCode0;\n      this.argCode1 = argCode1;\n      this.argCode2 = argCode2;\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      final Object arg0 = argCode0.eval(env);\n      final Object arg1 = argCode1.eval(env);\n      final Object arg2 = argCode2.eval(env);\n      return fnValue.apply(arg0, arg1, arg2);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply3\", d ->\n          d.arg(\"fnValue\", fnValue)\n              .arg(\"\", argCode0)\n              .arg(\"\", argCode1)\n              .arg(\"\", argCode2));\n    }\n  }", "definition": "  private static class ApplyCode3 implements Code", "class_docstring": " Applies an {@link Applicable3} to three {@link Code} arguments.", "name": "ApplyCode3", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Applicable3 fnValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Applicable3", "name": "fnValue", "syntax_pass": true}, {"attribute_expression": "private final Code argCode0;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "argCode0", "syntax_pass": true}, {"attribute_expression": "private final Code argCode1;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "argCode1", "syntax_pass": true}, {"attribute_expression": "private final Code argCode2;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Code", "name": "argCode2", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ApplyCode3(Applicable3 fnValue, Code argCode0, Code argCode1,\n        Code argCode2) {\n      this.fnValue = fnValue;\n      this.argCode0 = argCode0;\n      this.argCode1 = argCode1;\n      this.argCode2 = argCode2;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ApplyCode3", "params": [{"name": "fnValue", "type": "Applicable3"}, {"name": "argCode0", "type": "Code"}, {"name": "argCode1", "type": "Code"}, {"name": "argCode2", "type": "Code"}], "body": "                       {\n      this.fnValue = fnValue;\n      this.argCode0 = argCode0;\n      this.argCode1 = argCode1;\n      this.argCode2 = argCode2;\n    }", "signature": "ApplyCode3(Applicable3 fnValue, Code argCode0, Code argCode1,\n        Code argCode2)"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv env) {\n      final Object arg0 = argCode0.eval(env);\n      final Object arg1 = argCode1.eval(env);\n      final Object arg2 = argCode2.eval(env);\n      return fnValue.apply(arg0, arg1, arg2);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      final Object arg0 = argCode0.eval(env);\n      final Object arg1 = argCode1.eval(env);\n      final Object arg2 = argCode2.eval(env);\n      return fnValue.apply(arg0, arg1, arg2);\n    }", "signature": "@Override public Object eval(EvalEnv env)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply3\", d ->\n          d.arg(\"fnValue\", fnValue)\n              .arg(\"\", argCode0)\n              .arg(\"\", argCode1)\n              .arg(\"\", argCode2));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"apply3\", d ->\n          d.arg(\"fnValue\", fnValue)\n              .arg(\"\", argCode0)\n              .arg(\"\", argCode1)\n              .arg(\"\", argCode2));\n    }", "signature": "@Override public Describer describe(Describer describer)"}]}, {"original_string": "  static class ApplyCodeCode implements Code {\n    public final Code fnCode;\n    public final Code argCode;\n\n    ApplyCodeCode(Code fnCode, Code argCode) {\n      this.fnCode = fnCode;\n      this.argCode = argCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply\",\n          d -> d.arg(\"fnCode\", fnCode).arg(\"argCode\", argCode));\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      final Applicable fnValue = (Applicable) fnCode.eval(env);\n      final Object arg = argCode.eval(env);\n      return fnValue.apply(env, arg);\n    }\n  }", "definition": "  static class ApplyCodeCode implements Code", "class_docstring": " Applies a {@link Code} to a {@link Code}.\n\n<p>If {@link #fnCode} is constant, you should use {@link ApplyCode}\ninstead.", "name": "ApplyCodeCode", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public final Code fnCode;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Code", "name": "fnCode", "syntax_pass": true}, {"attribute_expression": "public final Code argCode;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Code", "name": "argCode", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ApplyCodeCode(Code fnCode, Code argCode) {\n      this.fnCode = fnCode;\n      this.argCode = argCode;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ApplyCodeCode", "params": [{"name": "fnCode", "type": "Code"}, {"name": "argCode", "type": "Code"}], "body": "                                             {\n      this.fnCode = fnCode;\n      this.argCode = argCode;\n    }", "signature": "ApplyCodeCode(Code fnCode, Code argCode)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply\",\n          d -> d.arg(\"fnCode\", fnCode).arg(\"argCode\", argCode));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"apply\",\n          d -> d.arg(\"fnCode\", fnCode).arg(\"argCode\", argCode));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv env) {\n      final Applicable fnValue = (Applicable) fnCode.eval(env);\n      final Object arg = argCode.eval(env);\n      return fnValue.apply(env, arg);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      final Applicable fnValue = (Applicable) fnCode.eval(env);\n      final Object arg = argCode.eval(env);\n      return fnValue.apply(env, arg);\n    }", "signature": "@Override public Object eval(EvalEnv env)"}]}, {"original_string": "  static class WrapRelList implements Code {\n    public final Code code;\n\n    WrapRelList(Code code) {\n      this.code = code;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"wrapRelList\", d -> d.arg(\"code\", code));\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      final Object arg = code.eval(env);\n      if (arg instanceof RelList) {\n        final RelList list = (RelList) arg;\n        return new AbstractList<Object>() {\n          @Override public Object get(int index) {\n            return list.get(index);\n          }\n\n          @Override public int size() {\n            return list.size();\n          }\n        };\n      }\n      return arg;\n    }\n  }", "definition": "  static class WrapRelList implements Code", "class_docstring": " A {@code Code} that evaluates a {@code Code} and if the result is a\n{@link net.hydromatic.morel.foreign.RelList}, wraps it in a different\nkind of list.", "name": "WrapRelList", "super_interfaces": ["Code"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public final Code code;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Code", "name": "code", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    WrapRelList(Code code) {\n      this.code = code;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "WrapRelList", "params": [{"name": "code", "type": "Code"}], "body": "                           {\n      this.code = code;\n    }", "signature": "WrapRelList(Code code)"}, {"syntax_pass": true, "original_string": "    @Override public Describer describe(Describer describer) {\n      return describer.start(\"wrapRelList\", d -> d.arg(\"code\", code));\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "name": "describe", "params": [{"name": "describer", "type": "Describer"}], "body": "                                                             {\n      return describer.start(\"wrapRelList\", d -> d.arg(\"code\", code));\n    }", "signature": "@Override public Describer describe(Describer describer)"}, {"syntax_pass": true, "original_string": "    @Override public Object eval(EvalEnv env) {\n      final Object arg = code.eval(env);\n      if (arg instanceof RelList) {\n        final RelList list = (RelList) arg;\n        return new AbstractList<Object>() {\n          @Override public Object get(int index) {\n            return list.get(index);\n          }\n\n          @Override public int size() {\n            return list.size();\n          }\n        };\n      }\n      return arg;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "eval", "params": [{"name": "env", "type": "EvalEnv"}], "body": "                                              {\n      final Object arg = code.eval(env);\n      if (arg instanceof RelList) {\n        final RelList list = (RelList) arg;\n        return new AbstractList<Object>() {\n          @Override public Object get(int index) {\n            return list.get(index);\n          }\n\n          @Override public int size() {\n            return list.size();\n          }\n        };\n      }\n      return arg;\n    }", "signature": "@Override public Object eval(EvalEnv env)"}]}], "class_docstring": " Helpers for {@link Code}.", "original_string": "@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic abstract class Codes {\n  /** Converts a {@code float} to a String per the JDK. */\n  private static final Function<Float, String> FLOAT_TO_STRING =\n      JavaVersion.CURRENT.compareTo(JavaVersion.of(19)) >= 0\n          ? f -> Float.toString(f)\n          : Codes::floatToString0;\n\n  /** A special value that represents Standard ML \"~NaN\". */\n  public static final float NEGATIVE_NAN =\n      Float.intBitsToFloat(\n          Float.floatToRawIntBits(Float.NaN)\n              ^ 0x8000_0000);\n\n  private Codes() {}\n\n  /** Describes a {@link Code}. */\n  public static String describe(Code code) {\n    final Code code2 = Codes.strip(code);\n    return code2.describe(new DescriberImpl()).toString();\n  }\n\n  /** Value of {@code NONE}.\n   *\n   * @see #optionSome(Object) */\n  private static final List OPTION_NONE = ImmutableList.of(\"NONE\");\n\n  /** Returns a Code that evaluates to the same value in all environments. */\n  public static Code constant(Object value) {\n    return new ConstantCode(value);\n  }\n\n  /** Returns an Applicable that returns its argument. */\n  private static ApplicableImpl identity(BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return arg;\n      }\n    };\n  }\n\n  /** @see BuiltIn#OP_EQ */\n  private static final Applicable OP_EQ =\n      new Applicable2<Boolean, Object, Object>(BuiltIn.OP_EQ) {\n        @Override public Boolean apply(Object a0, Object a1) {\n          return a0.equals(a1);\n        }\n      };\n\n  /** @see BuiltIn#OP_NE */\n  private static final Applicable OP_NE =\n      new Applicable2<Boolean, Object, Object>(BuiltIn.OP_NE) {\n        @Override public Boolean apply(Object a0, Object a1) {\n          return !a0.equals(a1);\n        }\n      };\n\n  /** @see BuiltIn#OP_LT */\n  private static final Applicable OP_LT =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_LT) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) < 0;\n        }\n      };\n\n  /** @see BuiltIn#OP_GT */\n  private static final Applicable OP_GT =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_GT) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) > 0;\n        }\n      };\n\n  /** @see BuiltIn#OP_LE */\n  private static final Applicable OP_LE =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_LE) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) <= 0;\n        }\n      };\n\n  /** @see BuiltIn#OP_GE */\n  private static final Applicable OP_GE =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_GE) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) >= 0;\n        }\n      };\n\n  /** @see BuiltIn#OP_ELEM */\n  private static final Applicable OP_ELEM =\n      new Applicable2<Boolean, Object, List>(BuiltIn.OP_ELEM) {\n        @Override public Boolean apply(Object a0, List a1) {\n          return a1.contains(a0);\n        }\n      };\n\n  /** @see BuiltIn#OP_NOT_ELEM */\n  private static final Applicable OP_NOT_ELEM =\n      new Applicable2<Boolean, Object, List>(BuiltIn.OP_NOT_ELEM) {\n        @Override public Boolean apply(Object a0, List a1) {\n          return !a1.contains(a0);\n        }\n      };\n\n  /** Returns a Code that evaluates \"andalso\". */\n  public static Code andAlso(Code code0, Code code1) {\n    return new AndAlsoCode(code0, code1);\n  }\n\n  /** Returns a Code that evaluates \"orelse\". */\n  public static Code orElse(Code code0, Code code1) {\n    return new OrElseCode(code0, code1);\n  }\n\n  /** Implements {@link #OP_NEGATE} for type {@code int}. */\n  private static final Applicable Z_NEGATE_INT =\n      new ApplicableImpl(BuiltIn.OP_NEGATE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return -((Integer) arg);\n        }\n      };\n\n  /** Implements {@link #OP_NEGATE} for type {@code real}. */\n  private static final Applicable Z_NEGATE_REAL =\n      new ApplicableImpl(BuiltIn.OP_NEGATE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final float f = (Float) arg;\n          if (Float.isNaN(f)) {\n            // ~nan -> nan\n            // nan (or any other value f such that isNan(f)) -> ~nan\n            return Float.floatToRawIntBits(f)\n                == Float.floatToRawIntBits(NEGATIVE_NAN)\n                ? Float.NaN\n                : NEGATIVE_NAN;\n          }\n          return -f;\n        }\n      };\n\n  /** Implements {@link #OP_PLUS} for type {@code int}. */\n  private static final Applicable Z_PLUS_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_PLUS) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 + a1;\n        }\n      };\n\n  /** Implements {@link #OP_PLUS} for type {@code real}. */\n  private static final Applicable Z_PLUS_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_PLUS) {\n        @Override public Float apply(Float a0, Float a1) {\n          return a0 + a1;\n        }\n      };\n\n  /** Implements {@link #OP_MINUS} for type {@code int}. */\n  private static final Applicable Z_MINUS_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_MINUS) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 - a1;\n        }\n      };\n\n  /** Implements {@link #OP_MINUS} for type {@code real}. */\n  private static final Applicable Z_MINUS_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_MINUS) {\n        @Override public Float apply(Float a0, Float a1) {\n          return a0 - a1;\n        }\n      };\n\n  /** Implements {@link #OP_TIMES} for type {@code int}. */\n  private static final Applicable Z_TIMES_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_TIMES) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 * a1;\n        }\n      };\n\n  /** Implements {@link #OP_TIMES} for type {@code real}. */\n  private static final Applicable Z_TIMES_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_TIMES) {\n        @Override public Float apply(Float a0, Float a1) {\n          return a0 * a1;\n        }\n      };\n\n  /** Implements {@link #OP_DIVIDE} for type {@code int}. */\n  private static final Applicable Z_DIVIDE_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_DIVIDE) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 / a1;\n        }\n      };\n\n  /** Implements {@link #OP_DIVIDE} for type {@code real}. */\n  private static final Applicable Z_DIVIDE_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_DIVIDE) {\n        @Override public Float apply(Float a0, Float a1) {\n          final float v = a0 / a1;\n          if (Float.isNaN(v)) {\n            return Float.NaN; // normalize NaN\n          }\n          return v;\n        }\n      };\n\n  /** @see BuiltIn#OP_NEGATE */\n  private static final Macro OP_NEGATE = (typeSystem, env, argType) -> {\n    switch ((PrimitiveType) argType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_NEGATE_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_NEGATE_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  };\n\n  /** @see BuiltIn#OP_DIVIDE */\n  private static final Macro OP_DIVIDE = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_DIVIDE_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_DIVIDE_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  };\n\n  /** @see BuiltIn#OP_DIV */\n  private static final Applicable OP_DIV = new IntDiv(BuiltIn.OP_DIV);\n\n  /** @see BuiltIn#GENERAL_OP_O */\n  private static final Applicable GENERAL_OP_O =\n      new ApplicableImpl(\"o\") {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"rawtypes\") final List tuple = (List) arg;\n          final Applicable f = (Applicable) tuple.get(0);\n          final Applicable g = (Applicable) tuple.get(1);\n          return new ApplicableImpl(\"o$f$g\") {\n            @Override public Object apply(EvalEnv env, Object arg) {\n              return f.apply(env, g.apply(env, arg));\n            }\n          };\n        }\n      };\n\n  /** @see BuiltIn#INT_ABS */\n  private static final Applicable INT_ABS =\n      new ApplicableImpl(BuiltIn.INT_ABS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Math.abs((int) arg);\n        }\n      };\n\n  /** @see BuiltIn#INT_COMPARE */\n  private static final Applicable INT_COMPARE =\n      new Applicable2<List, Integer, Integer>(BuiltIn.INT_COMPARE) {\n        @Override public List apply(Integer a0, Integer a1) {\n          if (a0 < a1) {\n            return ORDER_LESS;\n          }\n          if (a0 > a1) {\n            return ORDER_GREATER;\n          }\n          return ORDER_EQUAL;\n        }\n      };\n\n  /** @see BuiltIn#INT_FROM_INT */\n  private static final Applicable INT_FROM_INT =\n      identity(BuiltIn.INT_FROM_INT);\n\n  /** @see BuiltIn#INT_FROM_LARGE */\n  private static final Applicable INT_FROM_LARGE =\n      identity(BuiltIn.INT_FROM_LARGE);\n\n  /** Pattern for integers (after '~' has been converted to '-').\n   * \".\", \".e\", \".e-\", \".e5\", \"e7\", \"2.\", \".5\", \"2.e5\" are invalid;\n   * \"-2\", \"5\" are valid. */\n  static final Pattern INT_PATTERN =\n      Pattern.compile(\"^ *-?[0-9]+\");\n\n  /** @see BuiltIn#INT_FROM_STRING */\n  private static final Applicable INT_FROM_STRING =\n      new ApplicableImpl(BuiltIn.INT_FROM_STRING) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          final String s2 = s.replace('~', '-');\n          final Matcher matcher = INT_PATTERN.matcher(s2);\n          if (!matcher.find(0)) {\n            return OPTION_NONE;\n          }\n          final String s3 = s2.substring(0, matcher.end());\n          try {\n            final int f = Integer.parseInt(s3);\n            return optionSome(f);\n          } catch (NumberFormatException e) {\n            // We should not have reached this point. The pattern\n            // should not have matched the input.\n            throw new AssertionError(e);\n          }\n        }\n      };\n\n  /** @see BuiltIn#INT_MAX */\n  private static final Applicable INT_MAX =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_MAX) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return Math.max(a0, a1);\n        }\n      };\n\n  /** @see BuiltIn#INT_MAX_INT */\n  private static final List INT_MAX_INT = optionSome(Integer.MAX_VALUE);\n\n  /** @see BuiltIn#INT_MIN */\n  private static final Applicable INT_MIN =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_MIN) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return Math.min(a0, a1);\n        }\n      };\n\n  /** @see BuiltIn#INT_MIN_INT */\n  private static final List INT_MIN_INT = optionSome(Integer.MAX_VALUE);\n\n  /** @see BuiltIn#INT_DIV */\n  private static final Applicable INT_DIV = new IntDiv(BuiltIn.INT_DIV);\n\n  /** @see BuiltIn#INT_MOD */\n  private static final Applicable INT_MOD = new IntMod(BuiltIn.INT_MOD);\n\n  /** Implements {@link #INT_MOD} and {@link #OP_MOD}. */\n  private static class IntMod\n      extends Applicable2<Integer, Integer, Integer> {\n    IntMod(BuiltIn builtIn) {\n      super(builtIn);\n    }\n\n    @Override public Integer apply(Integer a0, Integer a1) {\n      return Math.floorMod(a0, a1);\n    }\n  }\n\n  /** Implements {@link #INT_DIV} and {@link #OP_DIV}. */\n  private static class IntDiv\n      extends Applicable2<Integer, Integer, Integer> {\n    IntDiv(BuiltIn builtIn) {\n      super(builtIn);\n    }\n\n    @Override public Integer apply(Integer a0, Integer a1) {\n      return Math.floorDiv(a0, a1);\n    }\n  }\n\n  /** @see BuiltIn#INT_PRECISION */\n  private static final List INT_PRECISION = optionSome(32); // Java int 32 bits\n\n  /** @see BuiltIn#INT_QUOT */\n  private static final Applicable INT_QUOT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_QUOT) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 / a1;\n        }\n      };\n\n  /** @see BuiltIn#INT_REM */\n  private static final Applicable INT_REM =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_REM) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 % a1;\n        }\n      };\n\n  /** @see BuiltIn#INT_SAME_SIGN */\n  private static final Applicable INT_SAME_SIGN =\n      new Applicable2<Boolean, Integer, Integer>(BuiltIn.INT_SAME_SIGN) {\n        @Override public Boolean apply(Integer a0, Integer a1) {\n          return a0 < 0 && a1 < 0\n              || a0 == 0 && a1 == 0\n              || a0 > 0 && a1 > 0;\n        }\n      };\n\n  /** @see BuiltIn#INT_SIGN */\n  private static final Applicable INT_SIGN =\n      new ApplicableImpl(BuiltIn.INT_SIGN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Integer.compare((Integer) arg, 0);\n        }\n      };\n\n  /** @see BuiltIn#INT_TO_INT */\n  private static final Applicable INT_TO_INT =\n      identity(BuiltIn.INT_TO_INT);\n\n  /** @see BuiltIn#INT_TO_LARGE */\n  private static final Applicable INT_TO_LARGE = identity(BuiltIn.INT_TO_LARGE);\n\n  /** @see BuiltIn#INT_TO_STRING */\n  private static final Applicable INT_TO_STRING =\n      new ApplicableImpl(BuiltIn.INT_TO_STRING) {\n        @Override public String apply(EvalEnv env, Object arg) {\n          // Java's formatting is reasonably close to ML's formatting,\n          // if we replace minus signs.\n          Integer f = (Integer) arg;\n          final String s = Integer.toString(f);\n          return s.replace('-', '~');\n        }\n      };\n\n  /** @see BuiltIn#INTERACT_USE */\n  private static final Applicable INTERACT_USE =\n      new InteractUse(Pos.ZERO, false);\n\n  /** @see BuiltIn#INTERACT_USE_SILENTLY */\n  private static final Applicable INTERACT_USE_SILENTLY =\n      new InteractUse(Pos.ZERO, true);\n\n  /** Removes wrappers, in particular the one due to\n   * {@link #wrapRelList(Code)}. */\n  public static Code strip(Code code) {\n    for (;;) {\n      if (code instanceof WrapRelList) {\n        code = ((WrapRelList) code).code;\n      } else {\n        return code;\n      }\n    }\n  }\n\n  /** Implements {@link BuiltIn#INTERACT_USE}. */\n  private static class InteractUse extends ApplicableImpl\n      implements Positioned {\n    private final boolean silent;\n\n    InteractUse(Pos pos, boolean silent) {\n      super(BuiltIn.INTERACT_USE, pos);\n      this.silent = silent;\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new InteractUse(pos, silent);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final String f = (String) arg;\n      final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n      session.use(f, silent, pos);\n      return Unit.INSTANCE;\n    }\n  }\n\n  /** @see BuiltIn#OP_CARET */\n  private static final Applicable OP_CARET =\n      new Applicable2<String, String, String>(BuiltIn.OP_CARET) {\n        @Override public String apply(String a0, String a1) {\n          return a0 + a1;\n        }\n      };\n\n  /** @see BuiltIn#OP_CONS */\n  private static final Applicable OP_CONS =\n      new Applicable2<List, Object, Iterable>(BuiltIn.OP_CONS) {\n        @Override public List apply(Object e, Iterable iterable) {\n          return ImmutableList.builder().add(e)\n              .addAll(iterable)\n              .build();\n        }\n      };\n\n  /** @see BuiltIn#OP_EXCEPT */\n  private static final Applicable OP_EXCEPT =\n      new Applicable2<List, List, List>(BuiltIn.OP_EXCEPT) {\n        @Override public List apply(List list0, List list1) {\n          List collection = new ArrayList(list0);\n          final Set set = new HashSet(list1);\n          if (!collection.removeAll(set)) {\n            collection = list0;\n          }\n          return ImmutableList.copyOf(collection);\n        }\n      };\n\n  /** @see BuiltIn#OP_INTERSECT */\n  private static final Applicable OP_INTERSECT =\n      new Applicable2<List, List, List>(BuiltIn.OP_INTERSECT) {\n        @Override public List apply(List list0, List list1) {\n          List collection = new ArrayList(list0);\n          final Set set = new HashSet(list1);\n          if (!collection.retainAll(set)) {\n            collection = list0;\n          }\n          return ImmutableList.copyOf(collection);\n        }\n      };\n\n  /** @see BuiltIn#OP_UNION */\n  private static final Applicable OP_UNION = union(BuiltIn.OP_UNION);\n\n  /** Returns a Code that returns the value of variable \"name\" in the current\n   * environment. */\n  public static Code get(String name) {\n    return new GetCode(name);\n  }\n\n  /** Returns a Code that returns a tuple consisting of the values of variables\n   * \"name0\", ... \"nameN\" in the current environment. */\n  public static Code getTuple(Iterable<String> names) {\n    if (Iterables.isEmpty(names)) {\n      return new ConstantCode(Unit.INSTANCE);\n    }\n    return new GetTupleCode(ImmutableList.copyOf(names));\n  }\n\n  public static Code let(List<Code> matchCodes, Code resultCode) {\n    switch (matchCodes.size()) {\n    case 0:\n      return resultCode;\n\n    case 1:\n      // Use a more efficient runtime path if the list has only one element.\n      // The effect is the same.\n      return new Let1Code(matchCodes.get(0), resultCode);\n\n    default:\n      return new LetCode(ImmutableList.copyOf(matchCodes), resultCode);\n    }\n  }\n\n  /** Generates the code for applying a function (or function value) to an\n   * argument. */\n  public static Code apply(Code fnCode, Code argCode) {\n    assert !fnCode.isConstant(); // if constant, use \"apply(Closure, Code)\"\n    return new ApplyCodeCode(fnCode, argCode);\n  }\n\n  /** Generates the code for applying a function value to an argument. */\n  public static Code apply(Applicable fnValue, Code argCode) {\n    return new ApplyCode(fnValue, argCode);\n  }\n\n  /** Generates the code for applying a function value to two arguments. */\n  public static Code apply2(Applicable2 fnValue, Code argCode0, Code argCode1) {\n    return new ApplyCode2(fnValue, argCode0, argCode1);\n  }\n\n  /** Generates the code for applying a function value to three arguments. */\n  public static Code apply3(Applicable3 fnValue, Code argCode0, Code argCode1,\n      Code argCode2) {\n    return new ApplyCode3(fnValue, argCode0, argCode1, argCode2);\n  }\n\n  public static Code list(Iterable<? extends Code> codes) {\n    return tuple(codes);\n  }\n\n  public static Code tuple(Iterable<? extends Code> codes) {\n    return new TupleCode(ImmutableList.copyOf(codes));\n  }\n\n  public static Code wrapRelList(Code code) {\n    return new WrapRelList(code);\n  }\n\n  /** Returns an applicable that constructs an instance of a datatype.\n   * The instance is a list with two elements [constructorName, value]. */\n  public static Applicable tyCon(Type dataType, String name) {\n    requireNonNull(dataType);\n    requireNonNull(name);\n    return new ApplicableImpl(\"tyCon\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return ImmutableList.of(name, arg);\n      }\n    };\n  }\n\n  public static Code from(Supplier<RowSink> rowSinkFactory) {\n    return new Code() {\n      @Override public Describer describe(Describer describer) {\n        return describer.start(\"from\", d ->\n            d.arg(\"sink\", rowSinkFactory.get()));\n      }\n\n      @Override public Object eval(EvalEnv env) {\n        final RowSink rowSink = rowSinkFactory.get();\n        rowSink.start(env);\n        rowSink.accept(env);\n        return rowSink.result(env);\n      }\n    };\n  }\n\n  /** Creates a {@link RowSink} for a {@code join} clause. */\n  public static RowSink scanRowSink(Op op, Core.Pat pat, Code code,\n      Code conditionCode, RowSink rowSink) {\n    return new ScanRowSink(op, pat, code, conditionCode, rowSink);\n  }\n\n  /** Creates a {@link RowSink} for a {@code where} clause. */\n  public static RowSink whereRowSink(Code filterCode, RowSink rowSink) {\n    return new WhereRowSink(filterCode, rowSink);\n  }\n\n  /** Creates a {@link RowSink} for a {@code skip} clause. */\n  public static RowSink skipRowSink(Code filterCode, RowSink rowSink) {\n    return new SkipRowSink(filterCode, rowSink);\n  }\n\n  /** Creates a {@link RowSink} for a {@code take} clause. */\n  public static RowSink takeRowSink(Code filterCode, RowSink rowSink) {\n    return new TakeRowSink(filterCode, rowSink);\n  }\n\n  /** Creates a {@link RowSink} for a {@code order} clause. */\n  public static RowSink orderRowSink(\n      Iterable<? extends Map.Entry<Code, Boolean>> codes,\n      ImmutableList<Binding> bindings, RowSink rowSink) {\n    return new OrderRowSink(ImmutablePairList.copyOf(codes),\n        transformEager(bindings, b -> b.id.name),\n        rowSink);\n  }\n\n  /** Creates a {@link RowSink} for a {@code group} clause. */\n  public static RowSink groupRowSink(Code keyCode,\n      ImmutableList<Applicable> aggregateCodes, ImmutableList<String> inNames,\n      ImmutableList<String> keyNames,\n      ImmutableList<String> outNames, RowSink rowSink) {\n    return new GroupRowSink(keyCode, aggregateCodes, inNames, keyNames,\n        outNames, rowSink);\n  }\n\n  /** Creates a {@link RowSink} for a non-terminal {@code yield} step. */\n  public static RowSink yieldRowSink(Map<String, Code> yieldCodes,\n      RowSink rowSink) {\n    return new YieldRowSink(ImmutableList.copyOf(yieldCodes.keySet()),\n        ImmutableList.copyOf(yieldCodes.values()), rowSink);\n  }\n\n  /** Creates a {@link RowSink} to collect the results of a {@code from}\n   * expression. */\n  public static RowSink collectRowSink(Code code) {\n    return new CollectRowSink(code);\n  }\n\n  /** Returns an applicable that returns the {@code slot}th field of a tuple or\n   * record. */\n  public static Applicable nth(int slot) {\n    assert slot >= 0 : slot;\n    return new ApplicableImpl(\"nth:\" + slot) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return ((List) arg).get(slot);\n      }\n    };\n  }\n\n  /** An applicable that negates a boolean value. */\n  private static final Applicable NOT =\n      new ApplicableImpl(BuiltIn.NOT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return !(Boolean) arg;\n        }\n      };\n\n  /** An applicable that returns the absolute value of an int. */\n  private static final Applicable ABS =\n      new ApplicableImpl(BuiltIn.ABS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Integer integer = (Integer) arg;\n          return integer >= 0 ? integer : -integer;\n        }\n      };\n\n  /** @see BuiltIn#IGNORE */\n  private static final Applicable IGNORE =\n      new ApplicableImpl(BuiltIn.IGNORE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Unit.INSTANCE;\n        }\n      };\n\n  /** @see BuiltIn#OP_MINUS */\n  private static final Macro OP_MINUS = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_MINUS_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_MINUS_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  };\n\n  /** @see BuiltIn#OP_MOD */\n  private static final Applicable OP_MOD = new IntMod(BuiltIn.OP_MOD);\n\n  /** @see BuiltIn#OP_PLUS */\n  private static final Macro OP_PLUS = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_PLUS_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_PLUS_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  };\n\n  /** @see BuiltIn#OP_TIMES */\n  private static final Macro OP_TIMES = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_TIMES_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_TIMES_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  };\n\n  /** @see BuiltIn#STRING_MAX_SIZE */\n  private static final Integer STRING_MAX_SIZE = Integer.MAX_VALUE;\n\n  /** @see BuiltIn#STRING_SIZE */\n  private static final Applicable STRING_SIZE =\n      new ApplicableImpl(BuiltIn.STRING_SIZE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return ((String) arg).length();\n        }\n      };\n\n  /** @see BuiltIn#STRING_SUB */\n  private static final Applicable STRING_SUB = new StringSub(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#STRING_SUB}. */\n  private static class StringSub extends Applicable2<Character, String, Integer>\n      implements Positioned {\n    StringSub(Pos pos) {\n      super(BuiltIn.STRING_SUB, pos);\n    }\n\n    @Override public Character apply(String s, Integer i) {\n      if (i < 0 || i >= s.length()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return s.charAt(i);\n    }\n\n    public StringSub withPos(Pos pos) {\n      return new StringSub(pos);\n    }\n  }\n\n  /** @see BuiltIn#STRING_EXTRACT */\n  private static final Applicable STRING_EXTRACT =\n      new StringExtract(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#STRING_SUB}. */\n  private static class StringExtract\n      extends Applicable3<String, String, Integer, List> implements Positioned {\n    StringExtract(Pos pos) {\n      super(BuiltIn.STRING_EXTRACT, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new StringExtract(pos);\n    }\n\n    @Override public String apply(String s, Integer i, List jOpt) {\n      if (i < 0) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      if (jOpt.size() == 2) {\n        final int j = (Integer) jOpt.get(1);\n        if (j < 0 || i + j > s.length()) {\n          throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n        }\n        return s.substring(i, i + j);\n      } else {\n        if (i > s.length()) {\n          throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n        }\n        return s.substring(i);\n      }\n    }\n  }\n\n  /** @see BuiltIn#STRING_SUBSTRING */\n  private static final Applicable STRING_SUBSTRING =\n      new StringSubstring(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#STRING_SUBSTRING}. */\n  private static class StringSubstring\n      extends Applicable3<String, String, Integer, Integer>\n      implements Positioned {\n    StringSubstring(Pos pos) {\n      super(BuiltIn.STRING_SUBSTRING, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new StringSubstring(pos);\n    }\n\n    @Override public String apply(String s, Integer i, Integer j) {\n      if (i < 0 || j < 0 || i + j > s.length()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return s.substring(i, i + j);\n    }\n  }\n\n  /** @see BuiltIn#STRING_CONCAT */\n  private static final Applicable STRING_CONCAT = new StringConcat(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#STRING_CONCAT}. */\n  private static class StringConcat extends ApplicableImpl\n      implements Positioned {\n    StringConcat(Pos pos) {\n      super(BuiltIn.STRING_CONCAT, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new StringConcat(pos);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override public Object apply(EvalEnv env, Object arg) {\n      return stringConcat(pos, \"\", (List<String>) arg);\n    }\n  }\n\n  /** @see BuiltIn#STRING_CONCAT_WITH */\n  private static final Applicable STRING_CONCAT_WITH =\n      new StringConcatWith(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#STRING_CONCAT_WITH}. */\n  private static class StringConcatWith extends ApplicableImpl\n      implements Positioned {\n    StringConcatWith(Pos pos) {\n      super(BuiltIn.STRING_CONCAT_WITH, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new StringConcatWith(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object argValue) {\n      final String separator = (String) argValue;\n      return new ApplicableImpl(\"String.concatWith$separator\") {\n        @SuppressWarnings(\"unchecked\")\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return stringConcat(pos, separator, (List<String>) arg);\n        }\n      };\n    }\n  }\n\n  private static String stringConcat(Pos pos, String separator,\n      List<String> list) {\n    long n = 0;\n    for (String s : list) {\n      n += s.length();\n      n += separator.length();\n    }\n    if (n > STRING_MAX_SIZE) {\n      throw new MorelRuntimeException(BuiltInExn.SIZE, pos);\n    }\n    return String.join(separator, list);\n  }\n\n  /** @see BuiltIn#STRING_STR */\n  private static final Applicable STRING_STR =\n      new ApplicableImpl(BuiltIn.STRING_STR) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Character character = (Character) arg;\n          return character + \"\";\n        }\n      };\n\n  /** @see BuiltIn#STRING_IMPLODE */\n  private static final Applicable STRING_IMPLODE =\n      new ApplicableImpl(BuiltIn.STRING_IMPLODE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          // Note: In theory this function should raise Size, but it is not\n          // possible in practice because List.size() is never larger than\n          // Integer.MAX_VALUE.\n          return String.valueOf(Chars.toArray((List) arg));\n        }\n      };\n\n  /** @see BuiltIn#STRING_EXPLODE */\n  private static final Applicable STRING_EXPLODE =\n      new ApplicableImpl(BuiltIn.STRING_EXPLODE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return MapList.of(s.length(), s::charAt);\n        }\n      };\n\n  /** @see BuiltIn#STRING_MAP */\n  private static final Applicable STRING_MAP =\n      new ApplicableImpl(BuiltIn.STRING_MAP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return stringMap((Applicable) arg);\n        }\n      };\n\n  private static Applicable stringMap(Applicable f) {\n    return new ApplicableImpl(\"String.map$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final String s = (String) arg;\n        final StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n          final char c = s.charAt(i);\n          final char c2 = (Character) f.apply(env, c);\n          buf.append(c2);\n        }\n        return buf.toString();\n      }\n    };\n  }\n\n  /** @see BuiltIn#STRING_TRANSLATE */\n  private static final Applicable STRING_TRANSLATE =\n      new ApplicableImpl(BuiltIn.STRING_TRANSLATE) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return translate(f);\n        }\n      };\n\n  private static Applicable translate(Applicable f) {\n    return new ApplicableImpl(\"String.translate$f\") {\n      @Override public String apply(EvalEnv env, Object arg) {\n        final String s = (String) arg;\n        final StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n          final char c = s.charAt(i);\n          final String c2 = (String) f.apply(env, c);\n          buf.append(c2);\n        }\n        return buf.toString();\n      }\n    };\n  }\n\n  /** @see BuiltIn#STRING_IS_PREFIX */\n  private static final Applicable STRING_IS_PREFIX =\n      new ApplicableImpl(BuiltIn.STRING_IS_PREFIX) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return isPrefix(s);\n        }\n      };\n\n  private static Applicable isPrefix(String s) {\n    return new ApplicableImpl(\"String.isPrefix$s\") {\n      @Override public Boolean apply(EvalEnv env, Object arg) {\n        final String s2 = (String) arg;\n        return s2.startsWith(s);\n      }\n    };\n  }\n\n  /** @see BuiltIn#STRING_IS_SUBSTRING */\n  private static final Applicable STRING_IS_SUBSTRING =\n      new ApplicableImpl(BuiltIn.STRING_IS_SUBSTRING) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return isSubstring(s);\n        }\n      };\n\n  private static Applicable isSubstring(String s) {\n    return new ApplicableImpl(\"String.isSubstring$s\") {\n      @Override public Boolean apply(EvalEnv env, Object arg) {\n        final String s2 = (String) arg;\n        return s2.contains(s);\n      }\n    };\n  }\n\n  /** @see BuiltIn#STRING_IS_SUFFIX */\n  private static final Applicable STRING_IS_SUFFIX =\n      new ApplicableImpl(BuiltIn.STRING_IS_SUFFIX) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return isSuffix(s);\n        }\n      };\n\n  private static Applicable isSuffix(String s) {\n    return new ApplicableImpl(\"String.isSuffix$s\") {\n      @Override public Boolean apply(EvalEnv env, Object arg) {\n        final String s2 = (String) arg;\n        return s2.endsWith(s);\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_NULL */\n  private static final Applicable LIST_NULL =\n      isNotEmpty(BuiltIn.LIST_NULL);\n\n  /** @see BuiltIn#LIST_LENGTH */\n  private static final Applicable LIST_LENGTH = length(BuiltIn.LIST_LENGTH);\n\n  private static ApplicableImpl length(BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return ((List) arg).size();\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_AT */\n  private static final Applicable LIST_AT = union(BuiltIn.LIST_AT);\n\n  private static ApplicableImpl union(final BuiltIn builtIn) {\n    return new Applicable2<List, List, List>(builtIn) {\n      @Override public List apply(List list0, List list1) {\n        return ImmutableList.builder().addAll(list0).addAll(list1).build();\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_HD */\n  private static final Applicable LIST_HD =\n      new ListHd(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#LIST_HD}. */\n  private static class ListHd extends ApplicableImpl implements Positioned {\n    ListHd(Pos pos) {\n      super(BuiltIn.LIST_HD, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListHd(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      if (list.isEmpty()) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.get(0);\n    }\n  }\n\n  /** @see BuiltIn#LIST_TL */\n  private static final Applicable LIST_TL = new ListTl(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#LIST_TL}. */\n  private static class ListTl extends ApplicableImpl implements Positioned {\n    ListTl(Pos pos) {\n      super(BuiltIn.LIST_TL, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListTl(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      final int size = list.size();\n      if (size == 0) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.subList(1, size);\n    }\n  }\n\n  /** @see BuiltIn#LIST_LAST */\n  private static final Applicable LIST_LAST = new ListLast(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#LIST_LAST}. */\n  private static class ListLast extends ApplicableImpl implements Positioned {\n    ListLast(Pos pos) {\n      super(BuiltIn.LIST_LAST, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListLast(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      final int size = list.size();\n      if (size == 0) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      return list.get(size - 1);\n    }\n  }\n\n  /** @see BuiltIn#LIST_GET_ITEM */\n  private static final Applicable LIST_GET_ITEM =\n      new ApplicableImpl(BuiltIn.LIST_GET_ITEM) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List list = (List) arg;\n          if (list.isEmpty()) {\n            return OPTION_NONE;\n          } else {\n            return optionSome(\n                ImmutableList.of(list.get(0), list.subList(1, list.size())));\n          }\n        }\n      };\n\n  /** @see BuiltIn#LIST_NTH */\n  private static final Applicable LIST_NTH =\n      new ListNth(BuiltIn.LIST_NTH, Pos.ZERO);\n\n  /** Implements {@link BuiltIn#LIST_NTH}\n   * and {@link BuiltIn#VECTOR_SUB}. */\n  private static class ListNth extends Applicable2<Object, List, Integer>\n      implements Positioned {\n    private final BuiltIn builtIn;\n\n    ListNth(BuiltIn builtIn, Pos pos) {\n      super(builtIn, pos);\n      this.builtIn = builtIn;\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListNth(builtIn, pos);\n    }\n\n    @Override public Object apply(List list, Integer i) {\n      if (i < 0 || i >= list.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return list.get(i);\n    }\n  }\n\n  /** @see BuiltIn#LIST_TAKE */\n  private static final Applicable LIST_TAKE = new ListTake(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#LIST_TAKE}. */\n  private static class ListTake extends Applicable2<List, List, Integer>\n      implements Positioned {\n    ListTake(Pos pos) {\n      super(BuiltIn.LIST_TAKE, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListTake(pos);\n    }\n\n    @Override public List apply(List list, Integer i) {\n      if (i < 0 || i > list.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      return list.subList(0, i);\n    }\n  }\n\n  /** @see BuiltIn#LIST_DROP */\n  private static final Applicable LIST_DROP =\n      new Applicable2<List, List, Integer>(BuiltIn.LIST_DROP) {\n        @Override public List apply(List list, Integer i) {\n          return list.subList(i, list.size());\n        }\n      };\n\n  /** @see BuiltIn#LIST_REV */\n  private static final Applicable LIST_REV =\n      new ApplicableImpl(BuiltIn.LIST_REV) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List list = (List) arg;\n          return Lists.reverse(list);\n        }\n      };\n\n  /** @see BuiltIn#LIST_CONCAT */\n  private static final Applicable LIST_CONCAT =\n      new ApplicableImpl(BuiltIn.LIST_CONCAT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List list = (List) arg;\n          final ImmutableList.Builder<Object> builder = ImmutableList.builder();\n          for (Object o : list) {\n            builder.addAll((List) o);\n          }\n          return builder.build();\n        }\n      };\n\n  /** @see BuiltIn#LIST_REV_APPEND */\n  private static final Applicable LIST_REV_APPEND =\n      new Applicable2<List, List, List>(BuiltIn.LIST_REV_APPEND) {\n        @Override public List apply(List list0, List list1) {\n          return ImmutableList.builder().addAll(Lists.reverse(list0))\n              .addAll(list1).build();\n        }\n      };\n\n  /** @see BuiltIn#LIST_APP */\n  private static final Applicable LIST_APP =\n      new ApplicableImpl(BuiltIn.LIST_APP) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return listApp((Applicable) arg);\n        }\n      };\n\n  private static Applicable listApp(Applicable consumer) {\n    return new ApplicableImpl(\"List.app$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        list.forEach(o -> consumer.apply(env, o));\n        return Unit.INSTANCE;\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_MAP */\n  private static final Applicable LIST_MAP =\n      new ApplicableImpl(BuiltIn.LIST_MAP) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return listMap((Applicable) arg);\n        }\n      };\n\n  private static Applicable listMap(Applicable fn) {\n    return new ApplicableImpl(\"List.map$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        final ImmutableList.Builder<Object> builder = ImmutableList.builder();\n        for (Object o : list) {\n          builder.add(fn.apply(env, o));\n        }\n        return builder.build();\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_MAP_PARTIAL */\n  private static final Applicable LIST_MAP_PARTIAL =\n      new ApplicableImpl(BuiltIn.LIST_MAP_PARTIAL) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return listMapPartial((Applicable) arg);\n        }\n      };\n\n  private static Applicable listMapPartial(Applicable f) {\n    return new ApplicableImpl(\"List.mapPartial$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        final ImmutableList.Builder<Object> builder = ImmutableList.builder();\n        for (Object o : list) {\n          final List opt = (List) f.apply(env, o);\n          if (opt.size() == 2) {\n            builder.add(opt.get(1));\n          }\n        }\n        return builder.build();\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_FIND */\n  private static final Applicable LIST_FIND = find(BuiltIn.LIST_FIND);\n\n  private static ApplicableImpl find(BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Applicable apply(EvalEnv env, Object arg) {\n        final Applicable fn = (Applicable) arg;\n        return find(fn);\n      }\n    };\n  }\n\n  private static Applicable find(Applicable f) {\n    return new ApplicableImpl(\"List.find$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        for (Object o : list) {\n          if ((Boolean) f.apply(env, o)) {\n            return optionSome(o);\n          }\n        }\n        return OPTION_NONE;\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_FILTER */\n  private static final Applicable LIST_FILTER =\n      new ApplicableImpl(BuiltIn.LIST_FILTER) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable fn = (Applicable) arg;\n          return listFilter(fn);\n        }\n      };\n\n  private static Applicable listFilter(Applicable f) {\n    return new ApplicableImpl(\"List.filter$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        final ImmutableList.Builder builder = ImmutableList.builder();\n        for (Object o : list) {\n          if ((Boolean) f.apply(env, o)) {\n            builder.add(o);\n          }\n        }\n        return builder.build();\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_PARTITION */\n  private static final Applicable LIST_PARTITION =\n      new ApplicableImpl(BuiltIn.LIST_PARTITION) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable fn = (Applicable) arg;\n          return listPartition(fn);\n        }\n      };\n\n  private static Applicable listPartition(Applicable f) {\n    return new ApplicableImpl(\"List.partition$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        final ImmutableList.Builder trueBuilder = ImmutableList.builder();\n        final ImmutableList.Builder falseBuilder = ImmutableList.builder();\n        for (Object o : list) {\n          ((Boolean) f.apply(env, o) ? trueBuilder : falseBuilder).add(o);\n        }\n        return ImmutableList.of(trueBuilder.build(), falseBuilder.build());\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_FOLDL */\n  private static final Applicable LIST_FOLDL =\n      new ApplicableImpl(BuiltIn.LIST_FOLDL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return listFold(true, (Applicable) arg);\n        }\n      };\n\n  /** @see BuiltIn#LIST_FOLDR */\n  private static final Applicable LIST_FOLDR =\n      new ApplicableImpl(BuiltIn.LIST_FOLDR) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return listFold(false, (Applicable) arg);\n        }\n      };\n\n  private static Applicable listFold(boolean left, Applicable f) {\n    return new ApplicableImpl(\"List.fold$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return listFold2(left, f, arg);\n      }\n    };\n  }\n\n  private static Applicable listFold2(boolean left, Applicable f,\n      Object init) {\n    return new ApplicableImpl(\"List.fold$f$init\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        Object b = init;\n        for (Object a : left ? list : Lists.reverse(list)) {\n          b = f.apply(env, ImmutableList.of(a, b));\n        }\n        return b;\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_EXISTS */\n  private static final Applicable LIST_EXISTS = exists(BuiltIn.LIST_EXISTS);\n\n  private static ApplicableImpl exists(final BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return listExists((Applicable) arg);\n      }\n    };\n  }\n\n  private static Applicable listExists(Applicable f) {\n    return new ApplicableImpl(\"List.exists$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        for (Object o : list) {\n          if ((Boolean) f.apply(env, o)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_ALL */\n  private static final Applicable LIST_ALL = all(BuiltIn.LIST_ALL);\n\n  private static ApplicableImpl all(final BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return listAll((Applicable) arg);\n      }\n    };\n  }\n\n  private static Applicable listAll(Applicable f) {\n    return new ApplicableImpl(\"List.all$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        for (Object o : list) {\n          if (!(Boolean) f.apply(env, o)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    };\n  }\n\n  /** @see BuiltIn#LIST_TABULATE */\n  private static final Applicable LIST_TABULATE =\n      new ListTabulate(BuiltIn.LIST_TABULATE, Pos.ZERO);\n\n  /** Implements {@link BuiltIn#LIST_TABULATE}. */\n  private static class ListTabulate extends ApplicableImpl\n      implements Positioned {\n    private final BuiltIn builtIn;\n\n    ListTabulate(BuiltIn builtIn, Pos pos) {\n      super(builtIn, pos);\n      this.builtIn = builtIn;\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new ListTabulate(builtIn, pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List tuple = (List) arg;\n      final int count = (Integer) tuple.get(0);\n      if (count < 0) {\n        throw new MorelRuntimeException(BuiltInExn.SIZE, pos);\n      }\n      final Applicable fn = (Applicable) tuple.get(1);\n      final ImmutableList.Builder<Object> builder = ImmutableList.builder();\n      for (int i = 0; i < count; i++) {\n        builder.add(fn.apply(env, i));\n      }\n      return builder.build();\n    }\n  }\n\n  /** @see BuiltIn#LIST_COLLATE */\n  private static final Applicable LIST_COLLATE = collate(BuiltIn.LIST_COLLATE);\n\n  private static ApplicableImpl collate(final BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return collate((Applicable) arg);\n      }\n    };\n  }\n\n  private static Applicable collate(Applicable comparator) {\n    return new ApplicableImpl(\"List.collate$comparator\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List tuple = (List) arg;\n        final List list0 = (List) tuple.get(0);\n        final List list1 = (List) tuple.get(1);\n        final int n0 = list0.size();\n        final int n1 = list1.size();\n        final int n = Math.min(n0, n1);\n        for (int i = 0; i < n; i++) {\n          final Object element0 = list0.get(i);\n          final Object element1 = list1.get(i);\n          final List compare = (List) comparator.apply(env,\n              ImmutableList.of(element0, element1));\n          if (!compare.get(0).equals(\"EQUAL\")) {\n            return compare;\n          }\n        }\n        return n0 < n1 ? ORDER_LESS : n0 == n1 ? ORDER_EQUAL : ORDER_GREATER;\n      }\n    };\n  }\n\n  /** @see BuiltIn#MATH_ACOS */\n  private static final Applicable MATH_ACOS =\n      new ApplicableImpl(BuiltIn.MATH_ACOS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.acos((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_ASIN */\n  private static final Applicable MATH_ASIN =\n      new ApplicableImpl(BuiltIn.MATH_ASIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.asin((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_ATAN */\n  private static final Applicable MATH_ATAN =\n      new ApplicableImpl(BuiltIn.MATH_ATAN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.atan((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_ATAN2 */\n  private static final Applicable MATH_ATAN2 =\n      new Applicable2<Float, Float, Float>(BuiltIn.MATH_ATAN2) {\n        @Override public Float apply(Float arg0, Float arg1) {\n          return (float) Math.atan2(arg0, arg1);\n        }\n      };\n\n  /** @see BuiltIn#MATH_COS */\n  private static final Applicable MATH_COS =\n      new ApplicableImpl(BuiltIn.MATH_COS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.cos((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_COSH */\n  private static final Applicable MATH_COSH =\n      new ApplicableImpl(BuiltIn.MATH_COSH) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.cosh((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_E */\n  private static final float MATH_E = (float) Math.E;\n\n  /** @see BuiltIn#MATH_EXP */\n  private static final Applicable MATH_EXP =\n      new ApplicableImpl(BuiltIn.MATH_EXP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.exp((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_LN */\n  private static final Applicable MATH_LN =\n      new ApplicableImpl(BuiltIn.MATH_LN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.log((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_LOG10 */\n  private static final Applicable MATH_LOG10 =\n      new ApplicableImpl(BuiltIn.MATH_LOG10) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.log10((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_PI */\n  private static final float MATH_PI = (float) Math.PI;\n\n  /** @see BuiltIn#MATH_POW */\n  private static final Applicable MATH_POW =\n      new Applicable2<Float, Float, Float>(BuiltIn.MATH_POW) {\n        @Override public Float apply(Float arg0, Float arg1) {\n          return (float) Math.pow(arg0, arg1);\n        }\n      };\n\n  /** @see BuiltIn#MATH_SIN */\n  private static final Applicable MATH_SIN =\n      new ApplicableImpl(BuiltIn.MATH_SIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.sin((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_SINH */\n  private static final Applicable MATH_SINH =\n      new ApplicableImpl(BuiltIn.MATH_SINH) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.sinh((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_SQRT */\n  private static final Applicable MATH_SQRT =\n      new ApplicableImpl(BuiltIn.MATH_SQRT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.sqrt((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_TAN */\n  private static final Applicable MATH_TAN =\n      new ApplicableImpl(BuiltIn.MATH_TAN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.tan((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#MATH_TANH */\n  private static final Applicable MATH_TANH =\n      new ApplicableImpl(BuiltIn.MATH_TANH) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.tanh((Float) arg);\n        }\n      };\n\n\n  /** @see BuiltIn#OPTION_APP */\n  private static final Applicable OPTION_APP =\n      new ApplicableImpl(BuiltIn.OPTION_APP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return optionApp(f);\n        }\n      };\n\n  /** Implements {@link #OPTION_APP}. */\n  private static Applicable optionApp(Applicable f) {\n    return new ApplicableImpl(\"Option.app$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List a = (List) arg;\n        if (a.size() == 2) {\n          f.apply(env, a.get(1));\n        }\n        return Unit.INSTANCE;\n      }\n    };\n  }\n\n  /** @see BuiltIn#OPTION_GET_OPT */\n  private static final Applicable OPTION_GET_OPT =\n      new ApplicableImpl(BuiltIn.OPTION_GET_OPT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List tuple = (List) arg;\n          final List opt = (List) tuple.get(0);\n          if (opt.size() == 2) {\n            assert opt.get(0).equals(\"SOME\");\n            return opt.get(1); // SOME has 2 elements, NONE has 1\n          }\n          return tuple.get(1);\n        }\n      };\n\n  /** @see BuiltIn#OPTION_IS_SOME */\n  private static final Applicable OPTION_IS_SOME =\n      new ApplicableImpl(BuiltIn.OPTION_IS_SOME) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List opt = (List) arg;\n          return opt.size() == 2; // SOME has 2 elements, NONE has 1\n        }\n      };\n\n  /** @see BuiltIn#OPTION_VAL_OF */\n  private static final Applicable OPTION_VAL_OF =\n      new OptionValOf(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#OPTION_VAL_OF}. */\n  private static class OptionValOf extends ApplicableImpl\n      implements Positioned {\n    OptionValOf(Pos pos) {\n      super(BuiltIn.OPTION_VAL_OF, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new OptionValOf(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List opt = (List) arg;\n      if (opt.size() == 2) { // SOME has 2 elements, NONE has 1\n        return opt.get(1);\n      } else {\n        throw new MorelRuntimeException(BuiltInExn.OPTION, pos);\n      }\n    }\n  }\n\n  /** @see BuiltIn#OPTION_FILTER */\n  private static final Applicable OPTION_FILTER =\n      new ApplicableImpl(BuiltIn.OPTION_FILTER) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return optionFilter(f);\n        }\n      };\n\n  /** Implementation of {@link #OPTION_FILTER}. */\n  private static Applicable optionFilter(Applicable f) {\n    return new ApplicableImpl(\"Option.filter$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        if ((Boolean) f.apply(env, arg)) {\n          return optionSome(arg);\n        } else {\n          return OPTION_NONE;\n        }\n      }\n    };\n  }\n\n  /** @see BuiltIn#OPTION_JOIN */\n  private static final Applicable OPTION_JOIN =\n      new ApplicableImpl(BuiltIn.OPTION_JOIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List opt = (List) arg;\n          return opt.size() == 2\n              ? opt.get(1) // SOME(SOME(v)) -> SOME(v), SOME(NONE) -> NONE\n              : opt; // NONE -> NONE\n        }\n      };\n\n  /** @see BuiltIn#OPTION_MAP */\n  private static final Applicable OPTION_MAP =\n      new ApplicableImpl(BuiltIn.OPTION_MAP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return optionMap((Applicable) arg);\n        }\n      };\n\n  /** Implements {@link #OPTION_MAP}. */\n  private static Applicable optionMap(Applicable f) {\n    return new ApplicableImpl(BuiltIn.OPTION_MAP) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List a = (List) arg;\n        if (a.size() == 2) { // SOME v\n          return optionSome(f.apply(env, a.get(1))); // SOME (f v)\n        }\n        return a; // NONE\n      }\n    };\n  }\n\n  /** Creates a value of {@code SOME v}.\n   *\n   * @see #OPTION_NONE */\n  private static List optionSome(Object o) {\n    return ImmutableList.of(\"SOME\", o);\n  }\n\n  /** @see BuiltIn#OPTION_MAP_PARTIAL */\n  private static final Applicable OPTION_MAP_PARTIAL =\n      new ApplicableImpl(BuiltIn.OPTION_MAP_PARTIAL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return optionMapPartial((Applicable) arg);\n        }\n      };\n\n  /** Implements {@link #OPTION_MAP_PARTIAL}. */\n  private static Applicable optionMapPartial(Applicable f) {\n    return new ApplicableImpl(\"Option.mapPartial$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List a = (List) arg;\n        if (a.size() == 2) { // SOME v\n          return f.apply(env, a.get(1)); // f v\n        }\n        return a; // NONE\n      }\n    };\n  }\n\n  /** @see BuiltIn#OPTION_COMPOSE */\n  private static final Applicable OPTION_COMPOSE =\n      new ApplicableImpl(BuiltIn.OPTION_COMPOSE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List tuple = (List) arg;\n          final Applicable f = (Applicable) tuple.get(0);\n          final Applicable g = (Applicable) tuple.get(1);\n          return optionCompose(f, g);\n        }\n      };\n\n  /** Implements {@link #OPTION_COMPOSE}. */\n  private static Applicable optionCompose(Applicable f, Applicable g) {\n    return new ApplicableImpl(\"Option.compose$f$g\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List ga = (List) g.apply(env, arg); // g (a)\n        if (ga.size() == 2) { // SOME v\n          return optionSome(f.apply(env, ga.get(1))); // SOME (f (v))\n        }\n        return ga; // NONE\n      }\n    };\n  }\n\n  /** @see BuiltIn#OPTION_COMPOSE_PARTIAL */\n  private static final Applicable OPTION_COMPOSE_PARTIAL =\n      new ApplicableImpl(BuiltIn.OPTION_COMPOSE_PARTIAL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List tuple = (List) arg;\n          final Applicable f = (Applicable) tuple.get(0);\n          final Applicable g = (Applicable) tuple.get(1);\n          return optionComposePartial(f, g);\n        }\n      };\n\n  /** Implements {@link #OPTION_COMPOSE_PARTIAL}. */\n  private static Applicable optionComposePartial(Applicable f, Applicable g) {\n    return new ApplicableImpl(\"Option.composePartial$f$g\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List ga = (List) g.apply(env, arg); // g (a)\n        if (ga.size() == 2) { // SOME v\n          return f.apply(env, ga.get(1)); // f (v)\n        }\n        return ga; // NONE\n      }\n    };\n  }\n\n  /** @see BuiltIn#REAL_ABS */\n  private static final Applicable REAL_ABS =\n      new ApplicableImpl(BuiltIn.REAL_ABS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Math.abs((float) arg);\n        }\n      };\n\n  /** @see BuiltIn#REAL_CEIL */\n  private static final Applicable REAL_CEIL =\n      new ApplicableImpl(BuiltIn.REAL_CEIL) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          float f = (float) arg;\n          if (f >= 0) {\n            return Math.round(f);\n          } else {\n            return -Math.round(-f);\n          }\n        }\n      };\n\n  /** @see BuiltIn#REAL_CHECK_FLOAT */\n  private static final Applicable REAL_CHECK_FLOAT =\n      new RealCheckFloat(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#REAL_CHECK_FLOAT}. */\n  private static class RealCheckFloat extends ApplicableImpl\n      implements Positioned {\n    RealCheckFloat(Pos pos) {\n      super(BuiltIn.REAL_CHECK_FLOAT, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new RealCheckFloat(pos);\n    }\n\n    @Override public Float apply(EvalEnv env, Object arg) {\n      final Float f = (Float) arg;\n      if (Float.isFinite(f)) {\n        return f;\n      }\n      if (Float.isNaN(f)) {\n        throw new MorelRuntimeException(BuiltInExn.DIV, pos);\n      } else {\n        throw new MorelRuntimeException(BuiltInExn.OVERFLOW, pos);\n      }\n    }\n  }\n\n  /** @see BuiltIn#REAL_COMPARE */\n  private static final Applicable REAL_COMPARE =\n      new RealCompare(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#REAL_COMPARE}. */\n  private static class RealCompare extends Applicable2<List, Float, Float>\n      implements Positioned {\n    RealCompare(Pos pos) {\n      super(BuiltIn.REAL_COMPARE, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new RealCompare(pos);\n    }\n\n    @Override public List apply(Float f0, Float f1) {\n      if (Float.isNaN(f0) || Float.isNaN(f1)) {\n        throw new MorelRuntimeException(BuiltInExn.UNORDERED, pos);\n      }\n      if (f0 < f1) {\n        return ORDER_LESS;\n      }\n      if (f0 > f1) {\n        return ORDER_GREATER;\n      }\n      // In particular, compare (~0.0, 0) returns ORDER_EQUAL\n      return ORDER_EQUAL;\n    }\n  }\n\n  /** @see BuiltIn#REAL_COPY_SIGN */\n  private static final Applicable REAL_COPY_SIGN =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_COPY_SIGN) {\n        @Override public Float apply(Float f0, Float f1) {\n          if (Float.isNaN(f1)) {\n            // Emulate SMLNJ/Mlton behavior that nan is negative,\n            // ~nan is positive.\n            f1 = isNegative(f1) ? -1.0f : 1.0f;\n          }\n          return Math.copySign(f0, f1);\n        }\n      };\n\n  /** @see BuiltIn#REAL_FLOOR */\n  private static final Applicable REAL_FLOOR =\n      new ApplicableImpl(BuiltIn.REAL_FLOOR) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          float f = (float) arg;\n          if (f >= 0) {\n            return -Math.round(-f);\n          } else {\n            return Math.round(f);\n          }\n        }\n      };\n\n  /** @see BuiltIn#REAL_FROM_INT */\n  private static final Applicable REAL_FROM_INT =\n      new ApplicableImpl(BuiltIn.REAL_FROM_INT) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) ((Integer) arg);\n        }\n      };\n\n  /** @see BuiltIn#REAL_FROM_MAN_EXP */\n  private static final Applicable REAL_FROM_MAN_EXP =\n      new Applicable2<Float, Integer, Float>(BuiltIn.REAL_FROM_MAN_EXP) {\n        @Override public Float apply(Integer exp, Float mantissa) {\n          if (!Float.isFinite(mantissa)) {\n            return mantissa;\n          }\n          if (exp >= Float.MAX_EXPONENT) {\n            final int exp2 = (exp - Float.MIN_EXPONENT) & 0xFF;\n            final int bits = Float.floatToRawIntBits(mantissa);\n            final int bits2 = (bits & ~(0xFF << 23)) | (exp2 << 23);\n            return Float.intBitsToFloat(bits2);\n          }\n          final int exp2 = (exp - Float.MIN_EXPONENT + 1) & 0xFF;\n          final float exp3 = Float.intBitsToFloat(exp2 << 23); // 2 ^ exp\n          return mantissa * exp3;\n        }\n      };\n\n  /** Pattern for floating point numbers (after '~' has been converted to '-').\n   * \".\", \".e\", \".e-\", \".e5\", \"e7\" are invalid;\n   * \"2.\", \".5\", \"2.e5\", \"2.e\" are valid. */\n  static final Pattern FLOAT_PATTERN =\n      Pattern.compile(\"^ *-?([0-9]*\\\\.)?[0-9]+([Ee]-?[0-9]+)?\");\n\n  /** @see BuiltIn#REAL_FROM_STRING */\n  private static final Applicable REAL_FROM_STRING =\n      new ApplicableImpl(BuiltIn.REAL_FROM_STRING) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          final String s2 = s.replace('~', '-');\n          final Matcher matcher = FLOAT_PATTERN.matcher(s2);\n          if (!matcher.find(0)) {\n            return OPTION_NONE;\n          }\n          final String s3 = s2.substring(0, matcher.end());\n          try {\n            final float f = Float.parseFloat(s3);\n            return optionSome(f);\n          } catch (NumberFormatException e) {\n            // We should not have reached this point. The pattern\n            // should not have matched the input.\n            throw new AssertionError(e);\n          }\n        }\n      };\n\n  /** @see BuiltIn#REAL_IS_FINITE */\n  private static final Applicable REAL_IS_FINITE =\n      new ApplicableImpl(BuiltIn.REAL_IS_FINITE) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          return Float.isFinite((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#REAL_IS_NAN */\n  private static final Applicable REAL_IS_NAN =\n      new ApplicableImpl(BuiltIn.REAL_IS_NAN) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          return Float.isNaN((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#REAL_IS_NORMAL */\n  private static final Applicable REAL_IS_NORMAL =\n      new ApplicableImpl(BuiltIn.REAL_IS_NORMAL) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          final Float f = (Float) arg;\n          return Float.isFinite(f)\n              && (f >= Float.MIN_NORMAL || f <= -Float.MIN_NORMAL);\n        }\n      };\n\n  /** @see BuiltIn#REAL_NEG_INF */\n  private static final float REAL_NEG_INF = Float.NEGATIVE_INFINITY;\n\n  /** @see BuiltIn#REAL_POS_INF */\n  private static final float REAL_POS_INF = Float.POSITIVE_INFINITY;\n\n  /** @see BuiltIn#REAL_RADIX */\n  private static final int REAL_RADIX = 2;\n\n  /** @see BuiltIn#REAL_PRECISION */\n  // value is from jdk.internal.math.FloatConsts#SIGNIFICAND_WIDTH\n  // (32 bit IEEE floating point is 1 sign bit, 8 bit exponent,\n  // 23 bit mantissa)\n  private static final int REAL_PRECISION = 24;\n\n  /** @see BuiltIn#REAL_MIN */\n  private static final Applicable REAL_MIN =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_MIN) {\n        @Override public Float apply(Float f0, Float f1) {\n          return Float.isNaN(f0) ? f1\n              : Float.isNaN(f1) ? f0\n              : Math.min(f0, f1);\n        }\n      };\n\n  /** @see BuiltIn#REAL_MAX */\n  private static final Applicable REAL_MAX =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_MAX) {\n        @Override public Float apply(Float f0, Float f1) {\n          return Float.isNaN(f0) ? f1\n              : Float.isNaN(f1) ? f0\n              : Math.max(f0, f1);\n        }\n      };\n\n  /** @see BuiltIn#REAL_MAX_FINITE */\n  private static final float REAL_MAX_FINITE = Float.MAX_VALUE;\n\n  /** @see BuiltIn#REAL_MIN_POS */\n  private static final float REAL_MIN_POS = Float.MIN_VALUE;\n\n  /** @see BuiltIn#REAL_MIN_NORMAL_POS */\n  private static final float REAL_MIN_NORMAL_POS = Float.MIN_NORMAL;\n\n  /** @see BuiltIn#REAL_REAL_MOD */\n  private static final Applicable REAL_REAL_MOD =\n      new ApplicableImpl(BuiltIn.REAL_REAL_MOD) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final float f = (Float) arg;\n          if (Float.isInfinite(f)) {\n            // realMod posInf  => 0.0\n            // realMod negInf  => ~0.0\n            return f > 0f ? 0f : -0f;\n          }\n          return f % 1;\n        }\n      };\n\n  /** @see BuiltIn#REAL_REAL_CEIL */\n  private static final Applicable REAL_REAL_CEIL =\n      new ApplicableImpl(BuiltIn.REAL_REAL_CEIL) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) Math.ceil((float) arg);\n        }\n      };\n\n  /** @see BuiltIn#REAL_REAL_FLOOR */\n  private static final Applicable REAL_REAL_FLOOR =\n      new ApplicableImpl(BuiltIn.REAL_REAL_FLOOR) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) Math.floor((float) arg);\n        }\n      };\n\n  /** @see BuiltIn#REAL_REAL_ROUND */\n  private static final Applicable REAL_REAL_ROUND =\n      new ApplicableImpl(BuiltIn.REAL_REAL_ROUND) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) Math.rint((float) arg);\n        }\n      };\n\n  /** @see BuiltIn#REAL_REAL_TRUNC */\n  private static final Applicable REAL_REAL_TRUNC =\n      new ApplicableImpl(BuiltIn.REAL_REAL_TRUNC) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          final float f = (float) arg;\n          final float frac = f % 1;\n          return f - frac;\n        }\n      };\n\n  /** @see BuiltIn#REAL_REM */\n  private static final Applicable REAL_REM =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_REM) {\n        @Override public Float apply(Float x, Float y) {\n          return x % y;\n        }\n      };\n\n  /** @see BuiltIn#REAL_ROUND */\n  private static final Applicable REAL_ROUND =\n      new ApplicableImpl(BuiltIn.REAL_ROUND) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          return Math.round((float) arg);\n        }\n      };\n\n  /** @see BuiltIn#REAL_SAME_SIGN */\n  private static final Applicable REAL_SAME_SIGN =\n      new Applicable2<Boolean, Float, Float>(BuiltIn.REAL_SAME_SIGN) {\n        @Override public Boolean apply(Float x, Float y) {\n          return isNegative(x) == isNegative(y);\n        }\n      };\n\n  /** Returns whether a {@code float} is negative.\n   * This is the same as the specification of {@code Real.signBit}. */\n  @VisibleForTesting\n  public static boolean isNegative(float f) {\n    final boolean negative =\n        (Float.floatToRawIntBits(f) & 0x8000_0000) == 0x8000_0000;\n    if (Float.isNaN(f)) {\n      // Standard ML/NJ and Mlton treat nan as negative,\n      // and ~nan as positive. Let's do the same.\n      return !negative;\n    }\n    return negative;\n  }\n\n  /** @see BuiltIn#REAL_SIGN */\n  private static final Applicable REAL_SIGN = new RealSign(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#REAL_COMPARE}. */\n  private static class RealSign extends ApplicableImpl\n      implements Positioned {\n    RealSign(Pos pos) {\n      super(BuiltIn.REAL_SIGN, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new RealSign(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final float f = (Float) arg;\n      if (Float.isNaN(f)) {\n        throw new MorelRuntimeException(BuiltInExn.DOMAIN, pos);\n      }\n      return f == 0f ? 0 // positive or negative zero\n          : (f > 0f) ? 1 // positive number or positive infinity\n              : -1; // negative number or negative infinity\n    }\n  }\n\n  /** @see BuiltIn#REAL_SIGN_BIT */\n  private static final Applicable REAL_SIGN_BIT =\n      new ApplicableImpl(BuiltIn.REAL_SIGN_BIT) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          return isNegative((Float) arg);\n        }\n      };\n\n  /** @see BuiltIn#REAL_SPLIT */\n  private static final Applicable REAL_SPLIT =\n      new ApplicableImpl(BuiltIn.REAL_SPLIT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final float f = (Float) arg;\n          final float frac;\n          final float whole;\n          if (Float.isInfinite(f)) {\n            // realMod posInf  => 0.0\n            // realMod negInf  => ~0.0\n            frac = f > 0f ? 0f : -0f;\n            whole = f;\n          } else {\n            frac = f % 1;\n            whole = f - frac;\n          }\n          return ImmutableList.of(frac, whole);\n        }\n      };\n\n  /** @see BuiltIn#REAL_TO_MAN_EXP */\n  private static final Applicable REAL_TO_MAN_EXP =\n      new ApplicableImpl(BuiltIn.REAL_TO_MAN_EXP) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          // In IEEE 32 bit floating point,\n          // bit 31 is the sign (1 bit);\n          // bits 30 - 23 are the exponent (8 bits);\n          // bits 22 - 0 are the mantissa (23 bits).\n          float f = (Float) arg;\n          final int bits = Float.floatToRawIntBits(f);\n          final int exp = (bits >> 23) & 0xFF;\n          final float mantissa;\n          if (exp == 0) {\n            // Exponent = 0 indicates that f is a very small number (0 < abs(f)\n            // <= MIN_NORMAL). The mantissa has leading zeros, so we have to use\n            // a different algorithm to get shift it into range.\n            mantissa = f / Float.MIN_NORMAL;\n          } else if (Float.isFinite(f)) {\n            // Set the exponent to 126 (which is the exponent for 1.0). First\n            // remove all set bits, then OR in the value 126.\n            final int bits2 = (bits & ~(0xFF << 23)) | (0x7E << 23);\n            mantissa = Float.intBitsToFloat(bits2);\n          } else {\n            mantissa = f;\n          }\n          return ImmutableList.of(exp + Float.MIN_EXPONENT, mantissa);\n        }\n      };\n\n  /** @see BuiltIn#REAL_TO_STRING */\n  private static final Applicable REAL_TO_STRING =\n      new ApplicableImpl(BuiltIn.REAL_TO_STRING) {\n        @Override public String apply(EvalEnv env, Object arg) {\n          // Java's formatting is reasonably close to ML's formatting,\n          // if we replace minus signs.\n          Float f = (Float) arg;\n          return floatToString(f);\n        }\n      };\n\n  /** @see BuiltIn#REAL_TRUNC */\n  private static final Applicable REAL_TRUNC =\n      new ApplicableImpl(BuiltIn.REAL_TRUNC) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          float f = (float) arg;\n          return (int) f;\n        }\n      };\n\n  /** @see BuiltIn#REAL_UNORDERED */\n  private static final Applicable REAL_UNORDERED =\n      new Applicable2<Boolean, Float, Float>(BuiltIn.REAL_UNORDERED) {\n        @Override public Boolean apply(Float f0, Float f1) {\n          return Float.isNaN(f0) ||  Float.isNaN(f1);\n        }\n      };\n\n  /** @see BuiltIn#RELATIONAL_COUNT */\n  private static final Applicable RELATIONAL_COUNT =\n      length(BuiltIn.RELATIONAL_COUNT);\n\n  /** @see BuiltIn#RELATIONAL_EXISTS */\n  private static final Applicable RELATIONAL_EXISTS =\n      isEmpty(BuiltIn.RELATIONAL_EXISTS);\n\n  private static ApplicableImpl isEmpty(final BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return !((List) arg).isEmpty();\n      }\n    };\n  }\n\n  /** @see BuiltIn#RELATIONAL_NOT_EXISTS */\n  private static final Applicable RELATIONAL_NOT_EXISTS =\n      isNotEmpty(BuiltIn.RELATIONAL_NOT_EXISTS);\n\n  private static ApplicableImpl isNotEmpty(BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Boolean apply(EvalEnv env, Object arg) {\n        return ((List) arg).isEmpty();\n      }\n    };\n  }\n\n  /** @see BuiltIn#RELATIONAL_ITERATE */\n  private static final Applicable RELATIONAL_ITERATE =\n      new ApplicableImpl(BuiltIn.RELATIONAL_ITERATE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List initialList = (List) arg;\n          return new ApplicableImpl(\"Relational.iterate$list\") {\n            @Override public Object apply(EvalEnv env, Object argValue) {\n              final Applicable update = (Applicable) argValue;\n              List list = initialList;\n              List newList = list;\n              for (;;) {\n                List nextList = (List) update.apply(env,\n                    FlatLists.of(list, newList));\n                if (nextList.isEmpty()) {\n                  return list;\n                }\n                // REVIEW:\n                // 1. should we eliminate duplicates when computing \"oldList\n                //   union newList\"?\n                // 2. should we subtract oldList before checking whether newList\n                //    is empty?\n                // 3. add an \"iterateDistinct\" variant?\n                list =\n                    ImmutableList.builder().addAll(list).addAll(nextList)\n                        .build();\n                newList = nextList;\n              }\n            }\n          };\n        }\n      };\n\n  /** @see BuiltIn#RELATIONAL_ONLY */\n  private static final Applicable RELATIONAL_ONLY =\n      new RelationalOnly(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#RELATIONAL_ONLY}. */\n  private static class RelationalOnly extends ApplicableImpl\n      implements Positioned {\n    RelationalOnly(Pos pos) {\n      super(BuiltIn.RELATIONAL_ONLY, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new RelationalOnly(pos);\n    }\n\n    @Override public Object apply(EvalEnv env, Object arg) {\n      final List list = (List) arg;\n      if (list.isEmpty()) {\n        throw new MorelRuntimeException(BuiltInExn.EMPTY, pos);\n      }\n      if (list.size() > 1) {\n        throw new MorelRuntimeException(BuiltInExn.SIZE, pos);\n      }\n      return list.get(0);\n    }\n  }\n\n  /** Implements {@link #RELATIONAL_SUM} for type {@code int list}. */\n  private static final Applicable Z_SUM_INT =\n      new ApplicableImpl(\"Relational.sum$int\") {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"unchecked\") final List<? extends Number> list =\n              (List) arg;\n          int sum = 0;\n          for (Number o : list) {\n            sum += o.intValue();\n          }\n          return sum;\n        }\n      };\n\n  /** Implements {@link #RELATIONAL_SUM} for type {@code real list}. */\n  private static final Applicable Z_SUM_REAL =\n      new ApplicableImpl(\"Relational.sum$real\") {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"unchecked\") final List<? extends Number> list =\n              (List) arg;\n          float sum = 0;\n          for (Number o : list) {\n            sum += o.floatValue();\n          }\n          return sum;\n        }\n      };\n\n  /** @see BuiltIn#RELATIONAL_SUM */\n  private static final Macro RELATIONAL_SUM = (typeSystem, env, argType) -> {\n    if (argType instanceof ListType) {\n      final Type resultType = ((ListType) argType).elementType;\n      switch ((PrimitiveType) resultType) {\n      case INT:\n        return core.functionLiteral(typeSystem, BuiltIn.Z_SUM_INT);\n      case REAL:\n        return core.functionLiteral(typeSystem, BuiltIn.Z_SUM_REAL);\n      }\n    }\n    throw new AssertionError(\"bad type \" + argType);\n  };\n\n  /** @see BuiltIn#RELATIONAL_MIN */\n  private static final Applicable RELATIONAL_MIN =\n      new ApplicableImpl(BuiltIn.RELATIONAL_MIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Ordering.natural().min((List) arg);\n        }\n      };\n\n  /** @see BuiltIn#RELATIONAL_MAX */\n  private static final Applicable RELATIONAL_MAX =\n      new ApplicableImpl(BuiltIn.RELATIONAL_MAX) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Ordering.natural().max((List) arg);\n        }\n      };\n\n  /** @see BuiltIn#SYS_ENV */\n  private static Core.Exp sysEnv(TypeSystem typeSystem, Environment env,\n      Type argType) {\n    final TupleType stringPairType =\n        typeSystem.tupleType(PrimitiveType.STRING, PrimitiveType.STRING);\n    final List<Core.Tuple> args =\n        env.getValueMap()\n            .entrySet()\n            .stream()\n            .sorted(Map.Entry.comparingByKey())\n            .map(entry ->\n                core.tuple(stringPairType,\n                    core.stringLiteral(entry.getKey()),\n                    core.stringLiteral(entry.getValue().id.type.moniker())))\n            .collect(Collectors.toList());\n    return core.apply(Pos.ZERO, typeSystem.listType(argType),\n        core.functionLiteral(typeSystem, BuiltIn.Z_LIST),\n        core.tuple(typeSystem, null, args));\n  }\n\n  /** @see BuiltIn#SYS_PLAN */\n  private static final Applicable SYS_PLAN =\n      new ApplicableImpl(BuiltIn.SYS_PLAN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          return Codes.describe(session.code);\n        }\n      };\n\n  /** @see BuiltIn#SYS_SET */\n  private static final Applicable SYS_SET =\n      new ApplicableImpl(BuiltIn.SYS_SET) {\n        @Override public Unit apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          final List list = (List) arg;\n          final String propName = (String) list.get(0);\n          final Object value = list.get(1);\n          Prop.lookup(propName).set(session.map, value);\n          return Unit.INSTANCE;\n        }\n      };\n\n  /** @see BuiltIn#SYS_SHOW */\n  private static final Applicable SYS_SHOW =\n      new ApplicableImpl(BuiltIn.SYS_SHOW) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          final String propName = (String) arg;\n          final Object value = Prop.lookup(propName).get(session.map);\n          return value == null ? OPTION_NONE : optionSome(value.toString());\n        }\n      };\n\n  /** @see BuiltIn#SYS_UNSET */\n  private static final Applicable SYS_UNSET =\n      new ApplicableImpl(BuiltIn.SYS_UNSET) {\n        @Override public Unit apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          final String propName = (String) arg;\n          final Prop prop = Prop.lookup(propName);\n          @SuppressWarnings(\"unused\") final Object value =\n              prop.remove(session.map);\n          return Unit.INSTANCE;\n        }\n      };\n\n  private static final List ORDER_LESS = ImmutableList.of(\"LESS\");\n  private static final List ORDER_EQUAL = ImmutableList.of(\"EQUAL\");\n  private static final List ORDER_GREATER = ImmutableList.of(\"GREATER\");\n\n  /** @see BuiltIn#VECTOR_MAX_LEN */\n  private static final int VECTOR_MAX_LEN = (1 << 24) - 1;\n\n  /** @see BuiltIn#VECTOR_FROM_LIST */\n  private static final Applicable VECTOR_FROM_LIST =\n      identity(BuiltIn.VECTOR_FROM_LIST);\n\n  /** @see BuiltIn#VECTOR_TABULATE */\n  private static final Applicable VECTOR_TABULATE =\n      new ListTabulate(BuiltIn.VECTOR_TABULATE, Pos.ZERO);\n\n  /** @see BuiltIn#VECTOR_LENGTH */\n  private static final Applicable VECTOR_LENGTH = length(BuiltIn.VECTOR_LENGTH);\n\n  /** @see BuiltIn#VECTOR_SUB */\n  private static final Applicable VECTOR_SUB =\n      new ListNth(BuiltIn.VECTOR_SUB, Pos.ZERO);\n\n  /** @see BuiltIn#VECTOR_UPDATE */\n  private static final Applicable VECTOR_UPDATE =\n      new VectorUpdate(Pos.ZERO);\n\n  /** Implements {@link BuiltIn#VECTOR_UPDATE}. */\n  private static class VectorUpdate\n      extends Applicable3<List, List, Integer, Object> implements Positioned {\n    VectorUpdate(Pos pos) {\n      super(BuiltIn.VECTOR_UPDATE, pos);\n    }\n\n    @Override public Applicable withPos(Pos pos) {\n      return new VectorUpdate(pos);\n    }\n\n    @Override public List apply(List vec, Integer i, Object x) {\n      if (i < 0 || i >= vec.size()) {\n        throw new MorelRuntimeException(BuiltInExn.SUBSCRIPT, pos);\n      }\n      final Object[] elements = vec.toArray();\n      elements[i] = x;\n      return ImmutableList.copyOf(elements);\n    }\n  }\n\n  /** @see BuiltIn#VECTOR_CONCAT */\n  private static final Applicable VECTOR_CONCAT =\n      new ApplicableImpl(BuiltIn.VECTOR_CONCAT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"unchecked\") final List<List<Object>> lists =\n              (List<List<Object>>) arg;\n          final ImmutableList.Builder<Object> b = ImmutableList.builder();\n          for (List<Object> list : lists) {\n            b.addAll(list);\n          }\n          return b.build();\n        }\n      };\n\n  /** @see BuiltIn#VECTOR_APPI */\n  private static final Applicable VECTOR_APPI =\n      new ApplicableImpl(BuiltIn.VECTOR_APPI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorAppi((Applicable) arg);\n        }\n      };\n\n  /** Implements {@link #VECTOR_APPI}. */\n  private static Applicable vectorAppi(Applicable f) {\n    return new ApplicableImpl(\"Vector.appi$f\") {\n      @Override public Unit apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> vec =\n            (List<Object>) arg;\n        forEachIndexed(vec, (e, i) -> f.apply(env, FlatLists.of(i, e)));\n        return Unit.INSTANCE;\n      }\n    };\n  }\n\n  /** @see BuiltIn#VECTOR_APP */\n  private static final Applicable VECTOR_APP =\n      new ApplicableImpl(BuiltIn.VECTOR_APP) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return vectorApp((Applicable) arg);\n        }\n      };\n\n  /** Implements {@link #VECTOR_APP}. */\n  private static Applicable vectorApp(Applicable f) {\n    return new ApplicableImpl(\"Vector.app$f\") {\n      @Override public Unit apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> vec =\n            (List<Object>) arg;\n        vec.forEach(e -> f.apply(env, e));\n        return Unit.INSTANCE;\n      }\n    };\n  }\n\n  /** @see BuiltIn#VECTOR_MAPI */\n  private static final Applicable VECTOR_MAPI =\n      new ApplicableImpl(BuiltIn.VECTOR_MAPI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorMapi((Applicable) arg);\n        }\n      };\n\n  /** Implements {@link #VECTOR_MAPI}. */\n  private static Applicable vectorMapi(Applicable f) {\n    return new ApplicableImpl(\"Vector.map$f\") {\n      @Override public List apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> vec =\n            (List<Object>) arg;\n        ImmutableList.Builder<Object> b = ImmutableList.builder();\n        forEachIndexed(vec, (e, i) -> b.add(f.apply(env, FlatLists.of(i, e))));\n        return b.build();\n      }\n    };\n  }\n\n  /** @see BuiltIn#VECTOR_MAP */\n  private static final Applicable VECTOR_MAP =\n      new ApplicableImpl(BuiltIn.VECTOR_MAP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorMap((Applicable) arg);\n        }\n      };\n\n  /** Implements {@link #VECTOR_MAP}. */\n  private static Applicable vectorMap(Applicable f) {\n    return new ApplicableImpl(\"Vector.map$f\") {\n      @Override public List apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> vec =\n            (List<Object>) arg;\n        ImmutableList.Builder<Object> b = ImmutableList.builder();\n        vec.forEach(e -> b.add(f.apply(env, e)));\n        return b.build();\n      }\n    };\n  }\n\n  /** @see BuiltIn#VECTOR_FOLDLI */\n  private static final Applicable VECTOR_FOLDLI =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDLI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldli$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldli$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (int i = 0, n = vec.size(); i < n; i++) {\n                    acc = f.apply(env3, FlatLists.of(i, vec.get(i), acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      };\n\n  /** @see BuiltIn#VECTOR_FOLDRI */\n  private static final Applicable VECTOR_FOLDRI =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDRI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldri$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldri$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (int i = vec.size() - 1; i >= 0; i--) {\n                    acc = f.apply(env3, FlatLists.of(i, vec.get(i), acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      };\n\n  /** @see BuiltIn#VECTOR_FOLDL */\n  private static final Applicable VECTOR_FOLDL =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldl$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldl$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (Object o : vec) {\n                    acc = f.apply(env3, FlatLists.of(o, acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      };\n\n  /** @see BuiltIn#VECTOR_FOLDR */\n  private static final Applicable VECTOR_FOLDR =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDR) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldlr$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldr$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (int i = vec.size() - 1; i >= 0; i--) {\n                    acc = f.apply(env3, FlatLists.of(vec.get(i), acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      };\n\n  /** @see BuiltIn#VECTOR_FINDI */\n  private static final Applicable VECTOR_FINDI =\n      new ApplicableImpl(BuiltIn.VECTOR_FINDI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorFindi((Applicable) arg);\n        }\n      };\n\n  /** Implements {@link #VECTOR_FINDI}. */\n  private static Applicable vectorFindi(Applicable f) {\n    return new ApplicableImpl(\"Vector.findi$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> vec =\n            (List<Object>) arg;\n        for (int i = 0, n = vec.size(); i < n; i++) {\n          final List<Object> tuple = FlatLists.of(i, vec.get(i));\n          if ((Boolean) f.apply(env, tuple)) {\n            return optionSome(tuple);\n          }\n        }\n        return OPTION_NONE;\n      }\n    };\n  }\n\n  /** @see BuiltIn#VECTOR_FIND */\n  private static final Applicable VECTOR_FIND = find(BuiltIn.VECTOR_FIND);\n\n  /** @see BuiltIn#VECTOR_EXISTS */\n  private static final Applicable VECTOR_EXISTS = exists(BuiltIn.VECTOR_EXISTS);\n\n  /** @see BuiltIn#VECTOR_ALL */\n  private static final Applicable VECTOR_ALL = all(BuiltIn.VECTOR_ALL);\n\n  /** @see BuiltIn#VECTOR_COLLATE */\n  private static final Applicable VECTOR_COLLATE =\n      collate(BuiltIn.VECTOR_COLLATE);\n\n  /** @see BuiltIn#Z_EXTENT */\n  private static final Applicable Z_EXTENT =\n      new ApplicableImpl(BuiltIn.Z_EXTENT) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          final RangeExtent rangeExtent = (RangeExtent) arg;\n          if (rangeExtent.iterable == null) {\n            throw new AssertionError(\"infinite: \" + rangeExtent);\n          }\n          return ImmutableList.copyOf(rangeExtent.iterable);\n        }\n      };\n\n  /** @see BuiltIn#Z_LIST */\n  private static final Applicable Z_LIST = identity(BuiltIn.Z_LIST);\n\n  private static void populateBuiltIns(Map<String, Object> valueMap) {\n    if (SKIP) {\n      return;\n    }\n    // Dummy type system, thrown away after this method\n    final TypeSystem typeSystem = new TypeSystem();\n    BuiltIn.dataTypes(typeSystem, new ArrayList<>());\n    BuiltIn.forEach(typeSystem, (key, type) -> {\n      final Object value = BUILT_IN_VALUES.get(key);\n      if (value == null) {\n        throw new AssertionError(\"no implementation for \" + key);\n      }\n      if (key.structure == null) {\n        valueMap.put(key.mlName, value);\n      }\n      if (key.alias != null) {\n        valueMap.put(key.alias, value);\n      }\n    });\n    BuiltIn.forEachStructure(typeSystem, (structure, type) ->\n        valueMap.put(structure.name,\n            transformEager(structure.memberMap.values(), BUILT_IN_VALUES::get)));\n  }\n\n  /** Creates an empty evaluation environment. */\n  public static EvalEnv emptyEnv() {\n    return EMPTY_ENV;\n  }\n\n  /** Creates an evaluation environment that contains the bound values from a\n   * compilation environment. */\n  public static EvalEnv emptyEnvWith(Session session, Environment env) {\n    final Map<String, Object> map = EMPTY_ENV.valueMap();\n    env.forEachValue(map::put);\n    map.put(EvalEnv.SESSION, session);\n    return EvalEnvs.copyOf(map);\n  }\n\n  /** Creates a compilation environment. */\n  public static Environment env(TypeSystem typeSystem,\n      Environment environment) {\n    final Environment[] hEnv = {environment};\n    BUILT_IN_VALUES.forEach((key, value) -> {\n      final Type type = key.typeFunction.apply(typeSystem);\n      if (key.structure == null) {\n        final Core.IdPat idPat =\n            core.idPat(type, key.mlName, typeSystem.nameGenerator);\n        hEnv[0] = hEnv[0].bind(idPat, value);\n      }\n      if (key.alias != null) {\n        final Core.IdPat idPat =\n            core.idPat(type, key.alias, typeSystem.nameGenerator);\n        hEnv[0] = hEnv[0].bind(idPat, value);\n      }\n    });\n\n    final List<Object> valueList = new ArrayList<>();\n    BuiltIn.forEachStructure(typeSystem, (structure, type) -> {\n      valueList.clear();\n      structure.memberMap.values()\n          .forEach(builtIn -> valueList.add(BUILT_IN_VALUES.get(builtIn)));\n      final Core.IdPat idPat =\n          core.idPat(type, structure.name, typeSystem.nameGenerator);\n      hEnv[0] = hEnv[0].bind(idPat, ImmutableList.copyOf(valueList));\n    });\n    return hEnv[0];\n  }\n\n  public static Applicable aggregate(Environment env0, Code aggregateCode,\n      List<String> names, @Nullable Code argumentCode) {\n    return new ApplicableImpl(\"aggregate\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> rows =\n            (List<Object>) arg;\n        final List<Object> argRows;\n        if (argumentCode != null) {\n          final MutableEvalEnv env2 = env.bindMutableArray(names);\n          argRows = new ArrayList<>(rows.size());\n          for (Object row : rows) {\n            env2.set(row);\n            argRows.add(argumentCode.eval(env2));\n          }\n        } else if (names.size() != 1) {\n          // Reconcile the fact that we internally represent rows as arrays when\n          // we're buffering for \"group\", lists at other times.\n          argRows = transform(rows, row -> Arrays.asList((Object []) row));\n        } else {\n          argRows = rows;\n        }\n        final Applicable aggregate = (Applicable) aggregateCode.eval(env);\n        return aggregate.apply(env, argRows);\n      }\n    };\n  }\n\n  public static final ImmutableMap<BuiltIn, Object> BUILT_IN_VALUES =\n      ImmutableMap.<BuiltIn, Object>builder()\n          .put(BuiltIn.TRUE, true)\n          .put(BuiltIn.FALSE, false)\n          .put(BuiltIn.NOT, NOT)\n          .put(BuiltIn.ABS, ABS)\n          .put(BuiltIn.IGNORE, IGNORE)\n          .put(BuiltIn.GENERAL_OP_O, GENERAL_OP_O)\n          .put(BuiltIn.INT_ABS, INT_ABS)\n          .put(BuiltIn.INT_COMPARE, INT_COMPARE)\n          .put(BuiltIn.INT_DIV, INT_DIV)\n          .put(BuiltIn.INT_FROM_INT, INT_FROM_INT)\n          .put(BuiltIn.INT_FROM_LARGE, INT_FROM_LARGE)\n          .put(BuiltIn.INT_FROM_STRING, INT_FROM_STRING)\n          .put(BuiltIn.INT_MAX, INT_MAX)\n          .put(BuiltIn.INT_MAX_INT, INT_MAX_INT)\n          .put(BuiltIn.INT_MIN, INT_MIN)\n          .put(BuiltIn.INT_MIN_INT, INT_MIN_INT)\n          .put(BuiltIn.INT_MOD, INT_MOD)\n          .put(BuiltIn.INT_PRECISION, INT_PRECISION)\n          .put(BuiltIn.INT_QUOT, INT_QUOT)\n          .put(BuiltIn.INT_REM, INT_REM)\n          .put(BuiltIn.INT_SAME_SIGN, INT_SAME_SIGN)\n          .put(BuiltIn.INT_SIGN, INT_SIGN)\n          .put(BuiltIn.INT_TO_INT, INT_TO_INT)\n          .put(BuiltIn.INT_TO_LARGE, INT_TO_LARGE)\n          .put(BuiltIn.INT_TO_STRING, INT_TO_STRING)\n          .put(BuiltIn.INTERACT_USE, INTERACT_USE)\n          .put(BuiltIn.INTERACT_USE_SILENTLY, INTERACT_USE_SILENTLY)\n          .put(BuiltIn.OP_CARET, OP_CARET)\n          .put(BuiltIn.OP_CONS, OP_CONS)\n          .put(BuiltIn.OP_DIV, OP_DIV)\n          .put(BuiltIn.OP_DIVIDE, OP_DIVIDE)\n          .put(BuiltIn.OP_ELEM, OP_ELEM)\n          .put(BuiltIn.OP_EQ, OP_EQ)\n          .put(BuiltIn.OP_GE, OP_GE)\n          .put(BuiltIn.OP_GT, OP_GT)\n          .put(BuiltIn.OP_LE, OP_LE)\n          .put(BuiltIn.OP_LT, OP_LT)\n          .put(BuiltIn.OP_NE, OP_NE)\n          .put(BuiltIn.OP_MINUS, OP_MINUS)\n          .put(BuiltIn.OP_MOD, OP_MOD)\n          .put(BuiltIn.OP_NEGATE, OP_NEGATE)\n          .put(BuiltIn.OP_NOT_ELEM, OP_NOT_ELEM)\n          .put(BuiltIn.OP_PLUS, OP_PLUS)\n          .put(BuiltIn.OP_TIMES, OP_TIMES)\n          .put(BuiltIn.OP_EXCEPT, OP_EXCEPT)\n          .put(BuiltIn.OP_INTERSECT, OP_INTERSECT)\n          .put(BuiltIn.OP_UNION, OP_UNION)\n          .put(BuiltIn.STRING_MAX_SIZE, STRING_MAX_SIZE)\n          .put(BuiltIn.STRING_SIZE, STRING_SIZE)\n          .put(BuiltIn.STRING_SUB, STRING_SUB)\n          .put(BuiltIn.STRING_EXTRACT, STRING_EXTRACT)\n          .put(BuiltIn.STRING_SUBSTRING, STRING_SUBSTRING)\n          .put(BuiltIn.STRING_CONCAT, STRING_CONCAT)\n          .put(BuiltIn.STRING_CONCAT_WITH, STRING_CONCAT_WITH)\n          .put(BuiltIn.STRING_STR, STRING_STR)\n          .put(BuiltIn.STRING_IMPLODE, STRING_IMPLODE)\n          .put(BuiltIn.STRING_EXPLODE, STRING_EXPLODE)\n          .put(BuiltIn.STRING_MAP, STRING_MAP)\n          .put(BuiltIn.STRING_TRANSLATE, STRING_TRANSLATE)\n          .put(BuiltIn.STRING_IS_PREFIX, STRING_IS_PREFIX)\n          .put(BuiltIn.STRING_IS_SUBSTRING, STRING_IS_SUBSTRING)\n          .put(BuiltIn.STRING_IS_SUFFIX, STRING_IS_SUFFIX)\n          .put(BuiltIn.LIST_NIL, ImmutableList.of())\n          .put(BuiltIn.LIST_NULL, LIST_NULL)\n          .put(BuiltIn.LIST_LENGTH, LIST_LENGTH)\n          .put(BuiltIn.LIST_AT, LIST_AT)\n          .put(BuiltIn.LIST_OP_AT, LIST_AT) // op @ == List.at\n          .put(BuiltIn.LIST_HD, LIST_HD)\n          .put(BuiltIn.LIST_TL, LIST_TL)\n          .put(BuiltIn.LIST_LAST, LIST_LAST)\n          .put(BuiltIn.LIST_GET_ITEM, LIST_GET_ITEM)\n          .put(BuiltIn.LIST_NTH, LIST_NTH)\n          .put(BuiltIn.LIST_TAKE, LIST_TAKE)\n          .put(BuiltIn.LIST_DROP, LIST_DROP)\n          .put(BuiltIn.LIST_REV, LIST_REV)\n          .put(BuiltIn.LIST_CONCAT, LIST_CONCAT)\n          .put(BuiltIn.LIST_REV_APPEND, LIST_REV_APPEND)\n          .put(BuiltIn.LIST_APP, LIST_APP)\n          .put(BuiltIn.LIST_MAP, LIST_MAP)\n          .put(BuiltIn.LIST_MAP_PARTIAL, LIST_MAP_PARTIAL)\n          .put(BuiltIn.LIST_FIND, LIST_FIND)\n          .put(BuiltIn.LIST_FILTER, LIST_FILTER)\n          .put(BuiltIn.LIST_PARTITION, LIST_PARTITION)\n          .put(BuiltIn.LIST_FOLDL, LIST_FOLDL)\n          .put(BuiltIn.LIST_FOLDR, LIST_FOLDR)\n          .put(BuiltIn.LIST_EXISTS, LIST_EXISTS)\n          .put(BuiltIn.LIST_ALL, LIST_ALL)\n          .put(BuiltIn.LIST_TABULATE, LIST_TABULATE)\n          .put(BuiltIn.LIST_COLLATE, LIST_COLLATE)\n          .put(BuiltIn.MATH_ACOS, MATH_ACOS)\n          .put(BuiltIn.MATH_ASIN, MATH_ASIN)\n          .put(BuiltIn.MATH_ATAN, MATH_ATAN)\n          .put(BuiltIn.MATH_ATAN2, MATH_ATAN2)\n          .put(BuiltIn.MATH_COS, MATH_COS)\n          .put(BuiltIn.MATH_COSH, MATH_COSH)\n          .put(BuiltIn.MATH_E, MATH_E)\n          .put(BuiltIn.MATH_EXP, MATH_EXP)\n          .put(BuiltIn.MATH_LN, MATH_LN)\n          .put(BuiltIn.MATH_LOG10, MATH_LOG10)\n          .put(BuiltIn.MATH_PI, MATH_PI)\n          .put(BuiltIn.MATH_POW, MATH_POW)\n          .put(BuiltIn.MATH_SIN, MATH_SIN)\n          .put(BuiltIn.MATH_SINH, MATH_SINH)\n          .put(BuiltIn.MATH_SQRT, MATH_SQRT)\n          .put(BuiltIn.MATH_TAN, MATH_TAN)\n          .put(BuiltIn.MATH_TANH, MATH_TANH)\n          .put(BuiltIn.OPTION_APP, OPTION_APP)\n          .put(BuiltIn.OPTION_COMPOSE, OPTION_COMPOSE)\n          .put(BuiltIn.OPTION_COMPOSE_PARTIAL, OPTION_COMPOSE_PARTIAL)\n          .put(BuiltIn.OPTION_FILTER, OPTION_FILTER)\n          .put(BuiltIn.OPTION_GET_OPT, OPTION_GET_OPT)\n          .put(BuiltIn.OPTION_IS_SOME, OPTION_IS_SOME)\n          .put(BuiltIn.OPTION_JOIN, OPTION_JOIN)\n          .put(BuiltIn.OPTION_MAP, OPTION_MAP)\n          .put(BuiltIn.OPTION_MAP_PARTIAL, OPTION_MAP_PARTIAL)\n          .put(BuiltIn.OPTION_VAL_OF, OPTION_VAL_OF)\n          .put(BuiltIn.REAL_ABS, REAL_ABS)\n          .put(BuiltIn.REAL_CEIL, REAL_CEIL)\n          .put(BuiltIn.REAL_CHECK_FLOAT, REAL_CHECK_FLOAT)\n          .put(BuiltIn.REAL_COMPARE, REAL_COMPARE)\n          .put(BuiltIn.REAL_COPY_SIGN, REAL_COPY_SIGN)\n          .put(BuiltIn.REAL_FLOOR, REAL_FLOOR)\n          .put(BuiltIn.REAL_FROM_INT, REAL_FROM_INT)\n          .put(BuiltIn.REAL_FROM_MAN_EXP, REAL_FROM_MAN_EXP)\n          .put(BuiltIn.REAL_FROM_STRING, REAL_FROM_STRING)\n          .put(BuiltIn.REAL_IS_FINITE, REAL_IS_FINITE)\n          .put(BuiltIn.REAL_IS_NAN, REAL_IS_NAN)\n          .put(BuiltIn.REAL_IS_NORMAL, REAL_IS_NORMAL)\n          .put(BuiltIn.REAL_MAX, REAL_MAX)\n          .put(BuiltIn.REAL_MAX_FINITE, REAL_MAX_FINITE)\n          .put(BuiltIn.REAL_MIN, REAL_MIN)\n          .put(BuiltIn.REAL_MIN_POS, REAL_MIN_POS)\n          .put(BuiltIn.REAL_MIN_NORMAL_POS, REAL_MIN_NORMAL_POS)\n          .put(BuiltIn.REAL_NEG_INF, REAL_NEG_INF)\n          .put(BuiltIn.REAL_POS_INF, REAL_POS_INF)\n          .put(BuiltIn.REAL_PRECISION, REAL_PRECISION)\n          .put(BuiltIn.REAL_RADIX, REAL_RADIX)\n          .put(BuiltIn.REAL_REAL_MOD, REAL_REAL_MOD)\n          .put(BuiltIn.REAL_REAL_CEIL, REAL_REAL_CEIL)\n          .put(BuiltIn.REAL_REAL_FLOOR, REAL_REAL_FLOOR)\n          .put(BuiltIn.REAL_REAL_ROUND, REAL_REAL_ROUND)\n          .put(BuiltIn.REAL_REAL_TRUNC, REAL_REAL_TRUNC)\n          .put(BuiltIn.REAL_REM, REAL_REM)\n          .put(BuiltIn.REAL_ROUND, REAL_ROUND)\n          .put(BuiltIn.REAL_SAME_SIGN, REAL_SAME_SIGN)\n          .put(BuiltIn.REAL_SIGN, REAL_SIGN)\n          .put(BuiltIn.REAL_SIGN_BIT, REAL_SIGN_BIT)\n          .put(BuiltIn.REAL_SPLIT, REAL_SPLIT)\n          .put(BuiltIn.REAL_TO_MAN_EXP, REAL_TO_MAN_EXP)\n          .put(BuiltIn.REAL_TO_STRING, REAL_TO_STRING)\n          .put(BuiltIn.REAL_TRUNC, REAL_TRUNC)\n          .put(BuiltIn.REAL_UNORDERED, REAL_UNORDERED)\n          .put(BuiltIn.RELATIONAL_COUNT, RELATIONAL_COUNT)\n          .put(BuiltIn.RELATIONAL_EXISTS, RELATIONAL_EXISTS)\n          .put(BuiltIn.RELATIONAL_NOT_EXISTS, RELATIONAL_NOT_EXISTS)\n          .put(BuiltIn.RELATIONAL_ITERATE, RELATIONAL_ITERATE)\n          .put(BuiltIn.RELATIONAL_ONLY, RELATIONAL_ONLY)\n          .put(BuiltIn.RELATIONAL_MAX, RELATIONAL_MAX)\n          .put(BuiltIn.RELATIONAL_MIN, RELATIONAL_MIN)\n          .put(BuiltIn.RELATIONAL_SUM, RELATIONAL_SUM)\n          .put(BuiltIn.SYS_ENV, (Macro) Codes::sysEnv)\n          .put(BuiltIn.SYS_FILE, \"\") // value comes from Session.file\n          .put(BuiltIn.SYS_PLAN, SYS_PLAN)\n          .put(BuiltIn.SYS_SET, SYS_SET)\n          .put(BuiltIn.SYS_SHOW, SYS_SHOW)\n          .put(BuiltIn.SYS_UNSET, SYS_UNSET)\n          .put(BuiltIn.VECTOR_MAX_LEN, VECTOR_MAX_LEN)\n          .put(BuiltIn.VECTOR_FROM_LIST, VECTOR_FROM_LIST)\n          .put(BuiltIn.VECTOR_TABULATE, VECTOR_TABULATE)\n          .put(BuiltIn.VECTOR_LENGTH, VECTOR_LENGTH)\n          .put(BuiltIn.VECTOR_SUB, VECTOR_SUB)\n          .put(BuiltIn.VECTOR_UPDATE, VECTOR_UPDATE)\n          .put(BuiltIn.VECTOR_CONCAT, VECTOR_CONCAT)\n          .put(BuiltIn.VECTOR_APPI, VECTOR_APPI)\n          .put(BuiltIn.VECTOR_APP, VECTOR_APP)\n          .put(BuiltIn.VECTOR_MAPI, VECTOR_MAPI)\n          .put(BuiltIn.VECTOR_MAP, VECTOR_MAP)\n          .put(BuiltIn.VECTOR_FOLDLI, VECTOR_FOLDLI)\n          .put(BuiltIn.VECTOR_FOLDRI, VECTOR_FOLDRI)\n          .put(BuiltIn.VECTOR_FOLDL, VECTOR_FOLDL)\n          .put(BuiltIn.VECTOR_FOLDR, VECTOR_FOLDR)\n          .put(BuiltIn.VECTOR_FINDI, VECTOR_FINDI)\n          .put(BuiltIn.VECTOR_FIND, VECTOR_FIND)\n          .put(BuiltIn.VECTOR_EXISTS, VECTOR_EXISTS)\n          .put(BuiltIn.VECTOR_ALL, VECTOR_ALL)\n          .put(BuiltIn.VECTOR_COLLATE, VECTOR_COLLATE)\n          .put(BuiltIn.Z_ANDALSO, Unit.INSTANCE)\n          .put(BuiltIn.Z_ORELSE, Unit.INSTANCE)\n          .put(BuiltIn.Z_NEGATE_INT, Z_NEGATE_INT)\n          .put(BuiltIn.Z_NEGATE_REAL, Z_NEGATE_REAL)\n          .put(BuiltIn.Z_DIVIDE_INT, Z_DIVIDE_INT)\n          .put(BuiltIn.Z_DIVIDE_REAL, Z_DIVIDE_REAL)\n          .put(BuiltIn.Z_PLUS_INT, Z_PLUS_INT)\n          .put(BuiltIn.Z_PLUS_REAL, Z_PLUS_REAL)\n          .put(BuiltIn.Z_MINUS_INT, Z_MINUS_INT)\n          .put(BuiltIn.Z_MINUS_REAL, Z_MINUS_REAL)\n          .put(BuiltIn.Z_TIMES_INT, Z_TIMES_INT)\n          .put(BuiltIn.Z_TIMES_REAL, Z_TIMES_REAL)\n          .put(BuiltIn.Z_SUM_INT, Z_SUM_INT)\n          .put(BuiltIn.Z_SUM_REAL, Z_SUM_REAL)\n          .put(BuiltIn.Z_EXTENT, Z_EXTENT)\n          .put(BuiltIn.Z_LIST, Z_LIST)\n          .build();\n\n  public static final Map<Applicable, BuiltIn> BUILT_IN_MAP =\n      ((Supplier<Map<Applicable, BuiltIn>>) Codes::get).get();\n\n  private static final EvalEnv EMPTY_ENV =\n      ((Supplier<EvalEnv>) Codes::makeEmptyEnv).get();\n\n  private static Map<Applicable, BuiltIn> get() {\n    final IdentityHashMap<Applicable, BuiltIn> b = new IdentityHashMap<>();\n    BUILT_IN_VALUES.forEach((builtIn, o) -> {\n      if (o instanceof Applicable) {\n        b.put((Applicable) o, builtIn);\n      }\n    });\n    return ImmutableMap.copyOf(b);\n  }\n\n  private static EvalEnv makeEmptyEnv() {\n    final Map<String, Object> map = new HashMap<>();\n    populateBuiltIns(map);\n    return EvalEnvs.copyOf(map);\n  }\n\n  public static StringBuilder appendFloat(StringBuilder buf, float f) {\n    return buf.append(floatToString(f));\n  }\n\n  /** Converts a Java {@code float} to the format expected of Standard ML\n   * {@code real} values. */\n  @VisibleForTesting\n  public static String floatToString(float f) {\n    if (Float.isFinite(f)) {\n      final String s = FLOAT_TO_STRING.apply(f);\n      return s.replace('-', '~');\n    } else if (f == Float.POSITIVE_INFINITY) {\n      return \"inf\";\n    } else if (f == Float.NEGATIVE_INFINITY) {\n      return \"~inf\";\n    } else if (Float.isNaN(f)) {\n      return \"nan\";\n    } else {\n      throw new AssertionError(\"unknown float \" + f);\n    }\n  }\n\n  private static String floatToString0(float f) {\n    String s = Float.toString(f);\n    int lastDigit = s.indexOf(\"E\");\n    if (lastDigit < 0) {\n      lastDigit = s.length();\n    }\n    if (s.equals(\"1.17549435E-38\")) {\n      return \"1.1754944E-38\";\n    }\n    if (s.equals(\"1.23456795E12\")) {\n      return \"1.234568E12\";\n    }\n    if (s.equals(\"1.23456791E11\")) {\n      return \"1.2345679E11\";\n    }\n    if (s.equals(\"1.23456788E10\")) {\n      return \"1.2345679E10\";\n    }\n    if (s.equals(\"1.23456792E8\")) {\n      return \"1.2345679E8\";\n    }\n    return s;\n  }\n\n  /** A code that evaluates expressions and creates a tuple with the results.\n   *\n   * <p>An inner class so that we can pick apart the results of multiply\n   * defined functions: {@code fun f = ... and g = ...}.\n   */\n  public static class TupleCode implements Code {\n    public final List<Code> codes;\n\n    private TupleCode(ImmutableList<Code> codes) {\n      this.codes = codes;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"tuple\", d ->\n          codes.forEach(code -> d.arg(\"\", code)));\n    }\n\n    public Object eval(EvalEnv env) {\n      final Object[] values = new Object[codes.size()];\n      for (int i = 0; i < values.length; i++) {\n        values[i] = codes.get(i).eval(env);\n      }\n      return Arrays.asList(values);\n    }\n  }\n\n  /** Accepts rows produced by a supplier as part of a {@code from} clause. */\n  public interface RowSink extends Describable {\n    void start(EvalEnv env);\n    void accept(EvalEnv env);\n    List<Object> result(EvalEnv env);\n  }\n\n  /** Abstract implementation for row sinks that have one successor. */\n  abstract static class BaseRowSink implements RowSink {\n    final RowSink rowSink;\n\n    BaseRowSink(RowSink rowSink) {\n      this.rowSink = requireNonNull(rowSink);\n    }\n\n    @Override public void start(EvalEnv env) {\n      rowSink.start(env);\n    }\n\n    @Override public void accept(EvalEnv env) {\n      rowSink.accept(env);\n    }\n\n    @Override public List<Object> result(EvalEnv env) {\n      return rowSink.result(env);\n    }\n  }\n\n  /** Implementation of {@link RowSink} for a {@code join} clause. */\n  static class ScanRowSink extends BaseRowSink {\n    final Op op; // inner, left, right, full\n    private final Core.Pat pat;\n    private final Code code;\n    final Code conditionCode;\n\n    ScanRowSink(Op op, Core.Pat pat, Code code, Code conditionCode,\n        RowSink rowSink) {\n      super(rowSink);\n      checkArgument(op == Op.SCAN);\n      this.op = op;\n      this.pat = pat;\n      this.code = code;\n      this.conditionCode = conditionCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"join\", d ->\n          d.arg(\"pat\", pat)\n              .arg(\"exp\", code)\n              .argIf(\"condition\", conditionCode, !isConstantTrue(conditionCode))\n              .arg(\"sink\", rowSink));\n    }\n\n    private static boolean isConstantTrue(Code code) {\n      return code.isConstant()\n          && Objects.equals(code.eval(null), true);\n    }\n\n    @Override public void accept(EvalEnv env) {\n      final MutableEvalEnv mutableEvalEnv = env.bindMutablePat(pat);\n      final Iterable<Object> elements = (Iterable<Object>) code.eval(env);\n      for (Object element : elements) {\n        if (mutableEvalEnv.setOpt(element)) {\n          Boolean b = (Boolean) conditionCode.eval(mutableEvalEnv);\n          if (b != null && b) {\n            rowSink.accept(mutableEvalEnv);\n          }\n        }\n      }\n    }\n  }\n\n  /** Implementation of {@link RowSink} for a {@code where} clause. */\n  static class WhereRowSink extends BaseRowSink {\n    final Code filterCode;\n\n    WhereRowSink(Code filterCode, RowSink rowSink) {\n      super(rowSink);\n      this.filterCode = filterCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"where\", d ->\n          d.arg(\"condition\", filterCode)\n              .arg(\"sink\", rowSink));\n    }\n\n    @Override public void accept(EvalEnv env) {\n      if ((Boolean) filterCode.eval(env)) {\n        rowSink.accept(env);\n      }\n    }\n  }\n\n  /** Implementation of {@link RowSink} for a {@code skip} clause. */\n  static class SkipRowSink extends BaseRowSink {\n    final Code skipCode;\n    int skip;\n\n    SkipRowSink(Code skipCode, RowSink rowSink) {\n      super(rowSink);\n      this.skipCode = skipCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"skip\", d ->\n          d.arg(\"count\", skipCode)\n              .arg(\"sink\", rowSink));\n    }\n\n    @Override public void start(EvalEnv env) {\n      skip = (Integer) skipCode.eval(env);\n      super.start(env);\n    }\n\n    @Override public void accept(EvalEnv env) {\n      if (skip > 0) {\n        --skip;\n      } else {\n        rowSink.accept(env);\n      }\n    }\n  }\n\n  /** Implementation of {@link RowSink} for a {@code take} clause. */\n  static class TakeRowSink extends BaseRowSink {\n    final Code takeCode;\n    int take;\n\n    TakeRowSink(Code takeCode, RowSink rowSink) {\n      super(rowSink);\n      this.takeCode = takeCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"take\", d ->\n          d.arg(\"count\", takeCode)\n              .arg(\"sink\", rowSink));\n    }\n\n    @Override public void start(EvalEnv env) {\n      take = (Integer) takeCode.eval(env);\n      super.start(env);\n    }\n\n    @Override public void accept(EvalEnv env) {\n      if (take > 0) {\n        --take;\n        rowSink.accept(env);\n      }\n    }\n  }\n\n  /** Implementation of {@link RowSink} for a {@code group} clause. */\n  private static class GroupRowSink extends BaseRowSink {\n    final Code keyCode;\n    final ImmutableList<String> inNames;\n    final ImmutableList<String> keyNames;\n    /** group names followed by aggregate names */\n    final ImmutableList<String> outNames;\n    final ImmutableList<Applicable> aggregateCodes;\n    final ListMultimap<Object, Object> map = ArrayListMultimap.create();\n    final Object[] values;\n\n    GroupRowSink(Code keyCode, ImmutableList<Applicable> aggregateCodes,\n        ImmutableList<String> inNames, ImmutableList<String> keyNames,\n        ImmutableList<String> outNames, RowSink rowSink) {\n      super(rowSink);\n      this.keyCode = requireNonNull(keyCode);\n      this.aggregateCodes = requireNonNull(aggregateCodes);\n      this.inNames = requireNonNull(inNames);\n      this.keyNames = requireNonNull(keyNames);\n      this.outNames = requireNonNull(outNames);\n      this.values = inNames.size() == 1 ? null : new Object[inNames.size()];\n      checkArgument(isPrefix(keyNames, outNames));\n    }\n\n    private static <E> boolean isPrefix(List<E> list0, List<E> list1) {\n      return list0.size() <= list1.size()\n          && list0.equals(list1.subList(0, list0.size()));\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"group\", d -> {\n        d.arg(\"key\", keyCode);\n        aggregateCodes.forEach(a -> d.arg(\"agg\", a));\n        d.arg(\"sink\", rowSink);\n      });\n    }\n\n    @Override public void accept(EvalEnv env) {\n      if (inNames.size() == 1) {\n        map.put(keyCode.eval(env), env.getOpt(inNames.get(0)));\n      } else {\n        for (int i = 0; i < inNames.size(); i++) {\n          values[i] = env.getOpt(inNames.get(i));\n        }\n        map.put(keyCode.eval(env), values.clone());\n      }\n    }\n\n    @Override public List<Object> result(final EvalEnv env) {\n      // Derive env2, the environment for our consumer. It consists of our input\n      // environment plus output names.\n      EvalEnv env2 = env;\n      final MutableEvalEnv[] groupEnvs = new MutableEvalEnv[outNames.size()];\n      int i = 0;\n      for (String name : outNames) {\n        env2 = groupEnvs[i++] = env2.bindMutable(name);\n      }\n\n      // Also derive env3, the environment wherein the aggregate functions are\n      // evaluated.\n      final EvalEnv env3 =\n          keyNames.isEmpty() ? env : groupEnvs[keyNames.size() - 1];\n\n      final Map<Object, List<Object>> map2;\n      if (map.isEmpty()\n          && keyCode instanceof TupleCode\n          && ((TupleCode) keyCode).codes.isEmpty()) {\n        // There are no keys, and there were no input rows.\n        map2 = ImmutableMap.of(ImmutableList.of(), ImmutableList.of());\n      } else {\n        //noinspection UnstableApiUsage\n        map2 = Multimaps.asMap(map);\n      }\n      for (Map.Entry<Object, List<Object>> entry : map2.entrySet()) {\n        final List list = (List) entry.getKey();\n        for (i = 0; i < list.size(); i++) {\n          groupEnvs[i].set(list.get(i));\n        }\n        final List<Object> rows = entry.getValue(); // rows in this bucket\n        for (Applicable aggregateCode : aggregateCodes) {\n          groupEnvs[i++].set(aggregateCode.apply(env3, rows));\n        }\n        rowSink.accept(env2);\n      }\n      return rowSink.result(env);\n    }\n  }\n\n  /** Implementation of {@link RowSink} for an {@code order} clause. */\n  static class OrderRowSink extends BaseRowSink {\n    final ImmutablePairList<Code, Boolean> codes;\n    final ImmutableList<String> names;\n    final List<Object> rows = new ArrayList<>();\n    final Object[] values;\n\n    OrderRowSink(ImmutablePairList<Code, Boolean> codes,\n        ImmutableList<String> names, RowSink rowSink) {\n      super(rowSink);\n      this.codes = codes;\n      this.names = names;\n      this.values = names.size() == 1 ? null : new Object[names.size()];\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"order\", d -> {\n        codes.forEach((code, desc) -> d.arg(desc ? \"desc\" : \"asc\", code));\n        d.arg(\"sink\", rowSink);\n      });\n    }\n\n    @Override public void accept(EvalEnv env) {\n      if (values == null) {\n        rows.add(env.getOpt(names.get(0)));\n      } else {\n        for (int i = 0; i < names.size(); i++) {\n          values[i] = env.getOpt(names.get(i));\n        }\n        rows.add(values.clone());\n      }\n    }\n\n    @Override public List<Object> result(final EvalEnv env) {\n      final MutableEvalEnv leftEnv = env.bindMutableArray(names);\n      final MutableEvalEnv rightEnv = env.bindMutableArray(names);\n      rows.sort((left, right) -> {\n        leftEnv.set(left);\n        rightEnv.set(right);\n        for (Map.Entry<Code, Boolean> code : codes) {\n          final Comparable leftVal = (Comparable) code.getKey().eval(leftEnv);\n          final Comparable rightVal = (Comparable) code.getKey().eval(rightEnv);\n          int c = leftVal.compareTo(rightVal);\n          if (c != 0) {\n            return code.getValue() ? -c : c;\n          }\n        }\n        return 0;\n      });\n      for (Object row : rows) {\n        leftEnv.set(row);\n        rowSink.accept(leftEnv);\n      }\n      return rowSink.result(env);\n    }\n  }\n\n  /** Implementation of {@link RowSink} for a {@code yield} step.\n   *\n   * <p>If this is the last step, use instead a {@link CollectRowSink}. It\n   * is more efficient; there is no downstream row sink; and a terminal yield\n   * step is allowed to generate expressions that are not records. Non-record\n   * expressions (e.g. {@code int} expressions) do not have a name, and\n   * therefore the value cannot be passed via the {@link EvalEnv}. */\n  private static class YieldRowSink extends BaseRowSink {\n    private final ImmutableList<String> names;\n    private final ImmutableList<Code> codes;\n    private final Object[] values;\n\n    YieldRowSink(ImmutableList<String> names, ImmutableList<Code> codes,\n        RowSink rowSink) {\n      super(rowSink);\n      this.names = names;\n      this.codes = codes;\n      this.values = names.size() == 1 ? null : new Object[names.size()];\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"yield\", d ->\n          d.arg(\"codes\", codes)\n              .arg(\"sink\", rowSink));\n    }\n\n    @Override public void accept(EvalEnv env) {\n      final MutableEvalEnv env2 = env.bindMutableArray(names);\n      if (values == null) {\n        final Object value = codes.get(0).eval(env);\n        env2.set(value);\n      } else {\n        for (int i = 0; i < codes.size(); i++) {\n          values[i] = codes.get(i).eval(env);\n        }\n        env2.set(values);\n      }\n      rowSink.accept(env2);\n    }\n  }\n\n  /** Implementation of {@link RowSink} that the last step of a {@code from}\n   * writes into. */\n  private static class CollectRowSink implements RowSink {\n    final List<Object> list = new ArrayList<>();\n    final Code code;\n\n    CollectRowSink(Code code) {\n      this.code = requireNonNull(code);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"collect\", d -> d.arg(\"\", code));\n    }\n\n    @Override public void start(EvalEnv env) {\n      list.clear();\n    }\n\n    @Override public void accept(EvalEnv env) {\n      list.add(code.eval(env));\n    }\n\n    @Override public List<Object> result(EvalEnv env) {\n      return list;\n    }\n  }\n\n  /** Code that retrieves the value of a variable from the environment. */\n  private static class GetCode implements Code {\n    private final String name;\n\n    GetCode(String name) {\n      this.name = requireNonNull(name);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"get\", d -> d.arg(\"name\", name));\n    }\n\n    @Override public String toString() {\n      return \"get(\" + name + \")\";\n    }\n\n    public Object eval(EvalEnv env) {\n      return env.getOpt(name);\n    }\n  }\n\n  /** Code that retrieves, as a tuple, the value of several variables from the\n   * environment. */\n  private static class GetTupleCode implements Code {\n    private final ImmutableList<String> names;\n    private final Object[] values; // work space\n\n    GetTupleCode(ImmutableList<String> names) {\n      this.names = requireNonNull(names);\n      this.values = new Object[names.size()];\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"getTuple\", d -> d.arg(\"names\", names));\n    }\n\n    @Override public String toString() {\n      return \"getTuple(\" + names + \")\";\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      for (int i = 0; i < names.size(); i++) {\n        values[i] = env.getOpt(names.get(i));\n      }\n      return Arrays.asList(values.clone());\n    }\n  }\n\n  /** Java exception that wraps an exception thrown by the Morel runtime. */\n  public static class MorelRuntimeException extends RuntimeException\n      implements MorelException {\n    private final BuiltInExn e;\n    private final Pos pos;\n\n    /** Creates a MorelRuntimeException. */\n    public MorelRuntimeException(BuiltInExn e, Pos pos) {\n      this.e = requireNonNull(e);\n      this.pos = requireNonNull(pos);\n    }\n\n    @Override public String toString() {\n      return e.mlName + \" at \" + pos;\n    }\n\n    @Override public StringBuilder describeTo(StringBuilder buf) {\n      return buf.append(\"uncaught exception \")\n          .append(e.mlName);\n    }\n\n    @Override public Pos pos() {\n      return pos;\n    }\n  }\n\n  /** Definitions of Morel built-in exceptions. */\n  public enum BuiltInExn {\n    EMPTY(\"List\", \"Empty\"),\n    BIND(\"General\", \"Bind\"),\n    DIV(\"General\", \"Div\"),\n    DOMAIN(\"General\", \"Domain\"),\n    OPTION(\"Option\", \"Option\"),\n    OVERFLOW(\"General\", \"Overflow\"),\n    ERROR(\"Interact\", \"Error\"), // not in standard basis\n    SIZE(\"General\", \"Size\"),\n    SUBSCRIPT(\"General\", \"Subscript [subscript out of bounds]\"),\n    UNORDERED(\"IEEEReal\", \"Unordered\");\n\n    public final String structure;\n    public final String mlName;\n\n    BuiltInExn(String structure, String mlName) {\n      this.structure = structure;\n      this.mlName = mlName;\n    }\n  }\n\n  /** Code that implements a constant. */\n  private static class ConstantCode implements Code {\n    private final Object value;\n\n    ConstantCode(Object value) {\n      this.value = value;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"constant\", d -> d.arg(\"\", value));\n    }\n\n    public Object eval(EvalEnv env) {\n      return value;\n    }\n\n    @Override public boolean isConstant() {\n      return true;\n    }\n  }\n\n  /** Code that implements {@link #andAlso(Code, Code)}. */\n  private static class AndAlsoCode implements Code {\n    private final Code code0;\n    private final Code code1;\n\n    AndAlsoCode(Code code0, Code code1) {\n      this.code0 = code0;\n      this.code1 = code1;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"andalso\", d -> d.arg(\"\", code0).arg(\"\", code1));\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      // Lazy evaluation. If code0 returns false, code1 is never evaluated.\n      return (boolean) code0.eval(evalEnv) && (boolean) code1.eval(evalEnv);\n    }\n  }\n\n  /** Code that implements {@link #orElse(Code, Code)}. */\n  private static class OrElseCode implements Code {\n    private final Code code0;\n    private final Code code1;\n\n    OrElseCode(Code code0, Code code1) {\n      this.code0 = code0;\n      this.code1 = code1;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"orelse\", d -> d.arg(\"\", code0).arg(\"\", code1));\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      // Lazy evaluation. If code0 returns true, code1 is never evaluated.\n      return (boolean) code0.eval(evalEnv) || (boolean) code1.eval(evalEnv);\n    }\n  }\n\n  /** Code that implements {@link #let(List, Code)} with one argument. */\n  private static class Let1Code implements Code {\n    private final Code matchCode;\n    private final Code resultCode;\n\n    Let1Code(Code matchCode, Code resultCode) {\n      this.matchCode = matchCode;\n      this.resultCode = resultCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"let1\", d ->\n          d.arg(\"matchCode\", matchCode).arg(\"resultCode\", resultCode));\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      final Closure fnValue = (Closure) matchCode.eval(evalEnv);\n      EvalEnv env2 = fnValue.evalBind(evalEnv);\n      return resultCode.eval(env2);\n    }\n  }\n\n  /** Code that implements {@link #let(List, Code)} with multiple arguments. */\n  private static class LetCode implements Code {\n    private final ImmutableList<Code> matchCodes;\n    private final Code resultCode;\n\n    LetCode(ImmutableList<Code> matchCodes, Code resultCode) {\n      this.matchCodes = matchCodes;\n      this.resultCode = resultCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"let\", d -> {\n        forEachIndexed(matchCodes, (matchCode, i) ->\n            d.arg(\"matchCode\" + i, matchCode));\n        d.arg(\"resultCode\", resultCode);\n      });\n    }\n\n    @Override public Object eval(EvalEnv evalEnv) {\n      EvalEnv evalEnv2 = evalEnv;\n      for (Code matchCode : matchCodes) {\n        final Closure fnValue = (Closure) matchCode.eval(evalEnv);\n        evalEnv2 = fnValue.evalBind(evalEnv2);\n      }\n      return resultCode.eval(evalEnv2);\n    }\n  }\n\n  /** Applies an {@link Applicable} to a {@link Code}. */\n  private static class ApplyCode implements Code {\n    private final Applicable fnValue;\n    private final Code argCode;\n\n    ApplyCode(Applicable fnValue, Code argCode) {\n      this.fnValue = fnValue;\n      this.argCode = argCode;\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      final Object arg = argCode.eval(env);\n      return fnValue.apply(env, arg);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply\", d ->\n          d.arg(\"fnValue\", fnValue).arg(\"argCode\", argCode));\n    }\n  }\n\n  /** Applies an {@link Applicable2} to two {@link Code} arguments. */\n  private static class ApplyCode2 implements Code {\n    private final Applicable2 fnValue;\n    private final Code argCode0;\n    private final Code argCode1;\n\n    ApplyCode2(Applicable2 fnValue, Code argCode0, Code argCode1) {\n      this.fnValue = fnValue;\n      this.argCode0 = argCode0;\n      this.argCode1 = argCode1;\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      final Object arg0 = argCode0.eval(env);\n      final Object arg1 = argCode1.eval(env);\n      return fnValue.apply(arg0, arg1);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply2\", d ->\n          d.arg(\"fnValue\", fnValue)\n              .arg(\"\", argCode0)\n              .arg(\"\", argCode1));\n    }\n  }\n\n  /** Applies an {@link Applicable3} to three {@link Code} arguments. */\n  private static class ApplyCode3 implements Code {\n    private final Applicable3 fnValue;\n    private final Code argCode0;\n    private final Code argCode1;\n    private final Code argCode2;\n\n    ApplyCode3(Applicable3 fnValue, Code argCode0, Code argCode1,\n        Code argCode2) {\n      this.fnValue = fnValue;\n      this.argCode0 = argCode0;\n      this.argCode1 = argCode1;\n      this.argCode2 = argCode2;\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      final Object arg0 = argCode0.eval(env);\n      final Object arg1 = argCode1.eval(env);\n      final Object arg2 = argCode2.eval(env);\n      return fnValue.apply(arg0, arg1, arg2);\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply3\", d ->\n          d.arg(\"fnValue\", fnValue)\n              .arg(\"\", argCode0)\n              .arg(\"\", argCode1)\n              .arg(\"\", argCode2));\n    }\n  }\n\n  /** Applies a {@link Code} to a {@link Code}.\n   *\n   * <p>If {@link #fnCode} is constant, you should use {@link ApplyCode}\n   * instead. */\n  static class ApplyCodeCode implements Code {\n    public final Code fnCode;\n    public final Code argCode;\n\n    ApplyCodeCode(Code fnCode, Code argCode) {\n      this.fnCode = fnCode;\n      this.argCode = argCode;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"apply\",\n          d -> d.arg(\"fnCode\", fnCode).arg(\"argCode\", argCode));\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      final Applicable fnValue = (Applicable) fnCode.eval(env);\n      final Object arg = argCode.eval(env);\n      return fnValue.apply(env, arg);\n    }\n  }\n\n  /** A {@code Code} that evaluates a {@code Code} and if the result is a\n   * {@link net.hydromatic.morel.foreign.RelList}, wraps it in a different\n   * kind of list. */\n  static class WrapRelList implements Code {\n    public final Code code;\n\n    WrapRelList(Code code) {\n      this.code = code;\n    }\n\n    @Override public Describer describe(Describer describer) {\n      return describer.start(\"wrapRelList\", d -> d.arg(\"code\", code));\n    }\n\n    @Override public Object eval(EvalEnv env) {\n      final Object arg = code.eval(env);\n      if (arg instanceof RelList) {\n        final RelList list = (RelList) arg;\n        return new AbstractList<Object>() {\n          @Override public Object get(int index) {\n            return list.get(index);\n          }\n\n          @Override public int size() {\n            return list.size();\n          }\n        };\n      }\n      return arg;\n    }\n  }\n\n  /** An {@link Applicable} whose position can be changed.\n   *\n   * <p>Operations that may throw exceptions should implement this interface.\n   * Then the exceptions can be tied to the correct position in the source code.\n   *\n   * <p>If you don't implement this interface, the applicable will use the\n   * default position, which is {@link Pos#ZERO}. If the exception has position\n   * \"0.0-0.0\", that is an indication you need to use this interface, and make\n   * sure that the position is propagated through the translation process. */\n  public interface Positioned extends Applicable {\n    Applicable withPos(Pos pos);\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Function<Float, String> FLOAT_TO_STRING =\n      JavaVersion.CURRENT.compareTo(JavaVersion.of(19)) >= 0\n          ? f -> Float.toString(f)\n          : Codes::floatToString0;", "docstring": " Converts a {@code float} to a String per the JDK.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Function<Float, String>", "name": "FLOAT_TO_STRING =\n      JavaVersion.CURRENT.compareTo(JavaVersion.of(19)) >= 0\n          ? f -> Float.toString(f)\n          : Codes::floatToString0", "syntax_pass": true}, {"attribute_expression": "public static final float NEGATIVE_NAN =\n      Float.intBitsToFloat(\n          Float.floatToRawIntBits(Float.NaN)\n              ^ 0x8000_0000);", "docstring": " A special value that represents Standard ML \"~NaN\".", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "float", "name": "NEGATIVE_NAN =\n      Float.intBitsToFloat(\n          Float.floatToRawIntBits(Float.NaN)\n              ^ 0x8000_0000)", "syntax_pass": true}, {"attribute_expression": "private static final List OPTION_NONE = ImmutableList.of(\"NONE\");", "docstring": " Value of {@code NONE}.\n\n@see #optionSome(Object)", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List", "name": "OPTION_NONE = ImmutableList.of(\"NONE\")", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_EQ =\n      new Applicable2<Boolean, Object, Object>(BuiltIn.OP_EQ) {\n        @Override public Boolean apply(Object a0, Object a1) {\n          return a0.equals(a1);\n        }\n      };", "docstring": " @see BuiltIn#OP_EQ", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_EQ =\n      new Applicable2<Boolean, Object, Object>(BuiltIn.OP_EQ) {\n        @Override public Boolean apply(Object a0, Object a1) {\n          return a0.equals(a1);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_NE =\n      new Applicable2<Boolean, Object, Object>(BuiltIn.OP_NE) {\n        @Override public Boolean apply(Object a0, Object a1) {\n          return !a0.equals(a1);\n        }\n      };", "docstring": " @see BuiltIn#OP_NE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_NE =\n      new Applicable2<Boolean, Object, Object>(BuiltIn.OP_NE) {\n        @Override public Boolean apply(Object a0, Object a1) {\n          return !a0.equals(a1);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_LT =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_LT) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) < 0;\n        }\n      };", "docstring": " @see BuiltIn#OP_LT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_LT =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_LT) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) < 0;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_GT =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_GT) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) > 0;\n        }\n      };", "docstring": " @see BuiltIn#OP_GT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_GT =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_GT) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) > 0;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_LE =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_LE) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) <= 0;\n        }\n      };", "docstring": " @see BuiltIn#OP_LE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_LE =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_LE) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) <= 0;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_GE =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_GE) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) >= 0;\n        }\n      };", "docstring": " @see BuiltIn#OP_GE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_GE =\n      new Applicable2<Boolean, Comparable, Comparable>(BuiltIn.OP_GE) {\n        @Override public Boolean apply(Comparable a0, Comparable a1) {\n          if (a0 instanceof Float && Float.isNaN((Float) a0)\n              || a1 instanceof Float && Float.isNaN((Float) a1)) {\n            return false;\n          }\n          return a0.compareTo(a1) >= 0;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_ELEM =\n      new Applicable2<Boolean, Object, List>(BuiltIn.OP_ELEM) {\n        @Override public Boolean apply(Object a0, List a1) {\n          return a1.contains(a0);\n        }\n      };", "docstring": " @see BuiltIn#OP_ELEM", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_ELEM =\n      new Applicable2<Boolean, Object, List>(BuiltIn.OP_ELEM) {\n        @Override public Boolean apply(Object a0, List a1) {\n          return a1.contains(a0);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_NOT_ELEM =\n      new Applicable2<Boolean, Object, List>(BuiltIn.OP_NOT_ELEM) {\n        @Override public Boolean apply(Object a0, List a1) {\n          return !a1.contains(a0);\n        }\n      };", "docstring": " @see BuiltIn#OP_NOT_ELEM", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_NOT_ELEM =\n      new Applicable2<Boolean, Object, List>(BuiltIn.OP_NOT_ELEM) {\n        @Override public Boolean apply(Object a0, List a1) {\n          return !a1.contains(a0);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_NEGATE_INT =\n      new ApplicableImpl(BuiltIn.OP_NEGATE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return -((Integer) arg);\n        }\n      };", "docstring": " Implements {@link #OP_NEGATE} for type {@code int}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_NEGATE_INT =\n      new ApplicableImpl(BuiltIn.OP_NEGATE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return -((Integer) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_NEGATE_REAL =\n      new ApplicableImpl(BuiltIn.OP_NEGATE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final float f = (Float) arg;\n          if (Float.isNaN(f)) {\n            // ~nan -> nan\n            // nan (or any other value f such that isNan(f)) -> ~nan\n            return Float.floatToRawIntBits(f)\n                == Float.floatToRawIntBits(NEGATIVE_NAN)\n                ? Float.NaN\n                : NEGATIVE_NAN;\n          }\n          return -f;\n        }\n      };", "docstring": " Implements {@link #OP_NEGATE} for type {@code real}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_NEGATE_REAL =\n      new ApplicableImpl(BuiltIn.OP_NEGATE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final float f = (Float) arg;\n          if (Float.isNaN(f)) {\n            // ~nan -> nan\n            // nan (or any other value f such that isNan(f)) -> ~nan\n            return Float.floatToRawIntBits(f)\n                == Float.floatToRawIntBits(NEGATIVE_NAN)\n                ? Float.NaN\n                : NEGATIVE_NAN;\n          }\n          return -f;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_PLUS_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_PLUS) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 + a1;\n        }\n      };", "docstring": " Implements {@link #OP_PLUS} for type {@code int}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_PLUS_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_PLUS) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 + a1;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_PLUS_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_PLUS) {\n        @Override public Float apply(Float a0, Float a1) {\n          return a0 + a1;\n        }\n      };", "docstring": " Implements {@link #OP_PLUS} for type {@code real}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_PLUS_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_PLUS) {\n        @Override public Float apply(Float a0, Float a1) {\n          return a0 + a1;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_MINUS_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_MINUS) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 - a1;\n        }\n      };", "docstring": " Implements {@link #OP_MINUS} for type {@code int}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_MINUS_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_MINUS) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 - a1;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_MINUS_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_MINUS) {\n        @Override public Float apply(Float a0, Float a1) {\n          return a0 - a1;\n        }\n      };", "docstring": " Implements {@link #OP_MINUS} for type {@code real}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_MINUS_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_MINUS) {\n        @Override public Float apply(Float a0, Float a1) {\n          return a0 - a1;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_TIMES_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_TIMES) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 * a1;\n        }\n      };", "docstring": " Implements {@link #OP_TIMES} for type {@code int}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_TIMES_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_TIMES) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 * a1;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_TIMES_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_TIMES) {\n        @Override public Float apply(Float a0, Float a1) {\n          return a0 * a1;\n        }\n      };", "docstring": " Implements {@link #OP_TIMES} for type {@code real}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_TIMES_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_TIMES) {\n        @Override public Float apply(Float a0, Float a1) {\n          return a0 * a1;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_DIVIDE_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_DIVIDE) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 / a1;\n        }\n      };", "docstring": " Implements {@link #OP_DIVIDE} for type {@code int}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_DIVIDE_INT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.OP_DIVIDE) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 / a1;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_DIVIDE_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_DIVIDE) {\n        @Override public Float apply(Float a0, Float a1) {\n          final float v = a0 / a1;\n          if (Float.isNaN(v)) {\n            return Float.NaN; // normalize NaN\n          }\n          return v;\n        }\n      };", "docstring": " Implements {@link #OP_DIVIDE} for type {@code real}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_DIVIDE_REAL =\n      new Applicable2<Float, Float, Float>(BuiltIn.OP_DIVIDE) {\n        @Override public Float apply(Float a0, Float a1) {\n          final float v = a0 / a1;\n          if (Float.isNaN(v)) {\n            return Float.NaN; // normalize NaN\n          }\n          return v;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Macro OP_NEGATE = (typeSystem, env, argType) -> {\n    switch ((PrimitiveType) argType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_NEGATE_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_NEGATE_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  };", "docstring": " @see BuiltIn#OP_NEGATE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Macro", "name": "OP_NEGATE = (typeSystem, env, argType) -> {\n    switch ((PrimitiveType) argType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_NEGATE_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_NEGATE_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  }", "syntax_pass": true}, {"attribute_expression": "private static final Macro OP_DIVIDE = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_DIVIDE_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_DIVIDE_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  };", "docstring": " @see BuiltIn#OP_DIVIDE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Macro", "name": "OP_DIVIDE = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_DIVIDE_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_DIVIDE_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_DIV = new IntDiv(BuiltIn.OP_DIV);", "docstring": " @see BuiltIn#OP_DIV", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_DIV = new IntDiv(BuiltIn.OP_DIV)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable GENERAL_OP_O =\n      new ApplicableImpl(\"o\") {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"rawtypes\") final List tuple = (List) arg;\n          final Applicable f = (Applicable) tuple.get(0);\n          final Applicable g = (Applicable) tuple.get(1);\n          return new ApplicableImpl(\"o$f$g\") {\n            @Override public Object apply(EvalEnv env, Object arg) {\n              return f.apply(env, g.apply(env, arg));\n            }\n          };\n        }\n      };", "docstring": " @see BuiltIn#GENERAL_OP_O", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "GENERAL_OP_O =\n      new ApplicableImpl(\"o\") {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"rawtypes\") final List tuple = (List) arg;\n          final Applicable f = (Applicable) tuple.get(0);\n          final Applicable g = (Applicable) tuple.get(1);\n          return new ApplicableImpl(\"o$f$g\") {\n            @Override public Object apply(EvalEnv env, Object arg) {\n              return f.apply(env, g.apply(env, arg));\n            }\n          };\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_ABS =\n      new ApplicableImpl(BuiltIn.INT_ABS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Math.abs((int) arg);\n        }\n      };", "docstring": " @see BuiltIn#INT_ABS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_ABS =\n      new ApplicableImpl(BuiltIn.INT_ABS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Math.abs((int) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_COMPARE =\n      new Applicable2<List, Integer, Integer>(BuiltIn.INT_COMPARE) {\n        @Override public List apply(Integer a0, Integer a1) {\n          if (a0 < a1) {\n            return ORDER_LESS;\n          }\n          if (a0 > a1) {\n            return ORDER_GREATER;\n          }\n          return ORDER_EQUAL;\n        }\n      };", "docstring": " @see BuiltIn#INT_COMPARE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_COMPARE =\n      new Applicable2<List, Integer, Integer>(BuiltIn.INT_COMPARE) {\n        @Override public List apply(Integer a0, Integer a1) {\n          if (a0 < a1) {\n            return ORDER_LESS;\n          }\n          if (a0 > a1) {\n            return ORDER_GREATER;\n          }\n          return ORDER_EQUAL;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_FROM_INT =\n      identity(BuiltIn.INT_FROM_INT);", "docstring": " @see BuiltIn#INT_FROM_INT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_FROM_INT =\n      identity(BuiltIn.INT_FROM_INT)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_FROM_LARGE =\n      identity(BuiltIn.INT_FROM_LARGE);", "docstring": " @see BuiltIn#INT_FROM_LARGE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_FROM_LARGE =\n      identity(BuiltIn.INT_FROM_LARGE)", "syntax_pass": true}, {"attribute_expression": "static final Pattern INT_PATTERN =\n      Pattern.compile(\"^ *-?[0-9]+\");", "docstring": " Pattern for integers (after '~' has been converted to '-').\n\".\", \".e\", \".e-\", \".e5\", \"e7\", \"2.\", \".5\", \"2.e5\" are invalid;\n\"-2\", \"5\" are valid.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Pattern", "name": "INT_PATTERN =\n      Pattern.compile(\"^ *-?[0-9]+\")", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_FROM_STRING =\n      new ApplicableImpl(BuiltIn.INT_FROM_STRING) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          final String s2 = s.replace('~', '-');\n          final Matcher matcher = INT_PATTERN.matcher(s2);\n          if (!matcher.find(0)) {\n            return OPTION_NONE;\n          }\n          final String s3 = s2.substring(0, matcher.end());\n          try {\n            final int f = Integer.parseInt(s3);\n            return optionSome(f);\n          } catch (NumberFormatException e) {\n            // We should not have reached this point. The pattern\n            // should not have matched the input.\n            throw new AssertionError(e);\n          }\n        }\n      };", "docstring": " @see BuiltIn#INT_FROM_STRING", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_FROM_STRING =\n      new ApplicableImpl(BuiltIn.INT_FROM_STRING) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          final String s2 = s.replace('~', '-');\n          final Matcher matcher = INT_PATTERN.matcher(s2);\n          if (!matcher.find(0)) {\n            return OPTION_NONE;\n          }\n          final String s3 = s2.substring(0, matcher.end());\n          try {\n            final int f = Integer.parseInt(s3);\n            return optionSome(f);\n          } catch (NumberFormatException e) {\n            // We should not have reached this point. The pattern\n            // should not have matched the input.\n            throw new AssertionError(e);\n          }\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_MAX =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_MAX) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return Math.max(a0, a1);\n        }\n      };", "docstring": " @see BuiltIn#INT_MAX", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_MAX =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_MAX) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return Math.max(a0, a1);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final List INT_MAX_INT = optionSome(Integer.MAX_VALUE);", "docstring": " @see BuiltIn#INT_MAX_INT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List", "name": "INT_MAX_INT = optionSome(Integer.MAX_VALUE)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_MIN =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_MIN) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return Math.min(a0, a1);\n        }\n      };", "docstring": " @see BuiltIn#INT_MIN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_MIN =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_MIN) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return Math.min(a0, a1);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final List INT_MIN_INT = optionSome(Integer.MAX_VALUE);", "docstring": " @see BuiltIn#INT_MIN_INT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List", "name": "INT_MIN_INT = optionSome(Integer.MAX_VALUE)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_DIV = new IntDiv(BuiltIn.INT_DIV);", "docstring": " @see BuiltIn#INT_DIV", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_DIV = new IntDiv(BuiltIn.INT_DIV)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_MOD = new IntMod(BuiltIn.INT_MOD);", "docstring": " @see BuiltIn#INT_MOD", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_MOD = new IntMod(BuiltIn.INT_MOD)", "syntax_pass": true}, {"attribute_expression": "private static final List INT_PRECISION = optionSome(32);", "docstring": " @see BuiltIn#INT_PRECISION", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List", "name": "INT_PRECISION = optionSome(32)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_QUOT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_QUOT) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 / a1;\n        }\n      };", "docstring": " @see BuiltIn#INT_QUOT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_QUOT =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_QUOT) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 / a1;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_REM =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_REM) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 % a1;\n        }\n      };", "docstring": " @see BuiltIn#INT_REM", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_REM =\n      new Applicable2<Integer, Integer, Integer>(BuiltIn.INT_REM) {\n        @Override public Integer apply(Integer a0, Integer a1) {\n          return a0 % a1;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_SAME_SIGN =\n      new Applicable2<Boolean, Integer, Integer>(BuiltIn.INT_SAME_SIGN) {\n        @Override public Boolean apply(Integer a0, Integer a1) {\n          return a0 < 0 && a1 < 0\n              || a0 == 0 && a1 == 0\n              || a0 > 0 && a1 > 0;\n        }\n      };", "docstring": " @see BuiltIn#INT_SAME_SIGN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_SAME_SIGN =\n      new Applicable2<Boolean, Integer, Integer>(BuiltIn.INT_SAME_SIGN) {\n        @Override public Boolean apply(Integer a0, Integer a1) {\n          return a0 < 0 && a1 < 0\n              || a0 == 0 && a1 == 0\n              || a0 > 0 && a1 > 0;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_SIGN =\n      new ApplicableImpl(BuiltIn.INT_SIGN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Integer.compare((Integer) arg, 0);\n        }\n      };", "docstring": " @see BuiltIn#INT_SIGN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_SIGN =\n      new ApplicableImpl(BuiltIn.INT_SIGN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Integer.compare((Integer) arg, 0);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_TO_INT =\n      identity(BuiltIn.INT_TO_INT);", "docstring": " @see BuiltIn#INT_TO_INT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_TO_INT =\n      identity(BuiltIn.INT_TO_INT)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_TO_LARGE = identity(BuiltIn.INT_TO_LARGE);", "docstring": " @see BuiltIn#INT_TO_LARGE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_TO_LARGE = identity(BuiltIn.INT_TO_LARGE)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INT_TO_STRING =\n      new ApplicableImpl(BuiltIn.INT_TO_STRING) {\n        @Override public String apply(EvalEnv env, Object arg) {\n          // Java's formatting is reasonably close to ML's formatting,\n          // if we replace minus signs.\n          Integer f = (Integer) arg;\n          final String s = Integer.toString(f);\n          return s.replace('-', '~');\n        }\n      };", "docstring": " @see BuiltIn#INT_TO_STRING", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INT_TO_STRING =\n      new ApplicableImpl(BuiltIn.INT_TO_STRING) {\n        @Override public String apply(EvalEnv env, Object arg) {\n          // Java's formatting is reasonably close to ML's formatting,\n          // if we replace minus signs.\n          Integer f = (Integer) arg;\n          final String s = Integer.toString(f);\n          return s.replace('-', '~');\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INTERACT_USE =\n      new InteractUse(Pos.ZERO, false);", "docstring": " @see BuiltIn#INTERACT_USE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INTERACT_USE =\n      new InteractUse(Pos.ZERO, false)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable INTERACT_USE_SILENTLY =\n      new InteractUse(Pos.ZERO, true);", "docstring": " @see BuiltIn#INTERACT_USE_SILENTLY", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "INTERACT_USE_SILENTLY =\n      new InteractUse(Pos.ZERO, true)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_CARET =\n      new Applicable2<String, String, String>(BuiltIn.OP_CARET) {\n        @Override public String apply(String a0, String a1) {\n          return a0 + a1;\n        }\n      };", "docstring": " @see BuiltIn#OP_CARET", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_CARET =\n      new Applicable2<String, String, String>(BuiltIn.OP_CARET) {\n        @Override public String apply(String a0, String a1) {\n          return a0 + a1;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_CONS =\n      new Applicable2<List, Object, Iterable>(BuiltIn.OP_CONS) {\n        @Override public List apply(Object e, Iterable iterable) {\n          return ImmutableList.builder().add(e)\n              .addAll(iterable)\n              .build();\n        }\n      };", "docstring": " @see BuiltIn#OP_CONS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_CONS =\n      new Applicable2<List, Object, Iterable>(BuiltIn.OP_CONS) {\n        @Override public List apply(Object e, Iterable iterable) {\n          return ImmutableList.builder().add(e)\n              .addAll(iterable)\n              .build();\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_EXCEPT =\n      new Applicable2<List, List, List>(BuiltIn.OP_EXCEPT) {\n        @Override public List apply(List list0, List list1) {\n          List collection = new ArrayList(list0);\n          final Set set = new HashSet(list1);\n          if (!collection.removeAll(set)) {\n            collection = list0;\n          }\n          return ImmutableList.copyOf(collection);\n        }\n      };", "docstring": " @see BuiltIn#OP_EXCEPT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_EXCEPT =\n      new Applicable2<List, List, List>(BuiltIn.OP_EXCEPT) {\n        @Override public List apply(List list0, List list1) {\n          List collection = new ArrayList(list0);\n          final Set set = new HashSet(list1);\n          if (!collection.removeAll(set)) {\n            collection = list0;\n          }\n          return ImmutableList.copyOf(collection);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_INTERSECT =\n      new Applicable2<List, List, List>(BuiltIn.OP_INTERSECT) {\n        @Override public List apply(List list0, List list1) {\n          List collection = new ArrayList(list0);\n          final Set set = new HashSet(list1);\n          if (!collection.retainAll(set)) {\n            collection = list0;\n          }\n          return ImmutableList.copyOf(collection);\n        }\n      };", "docstring": " @see BuiltIn#OP_INTERSECT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_INTERSECT =\n      new Applicable2<List, List, List>(BuiltIn.OP_INTERSECT) {\n        @Override public List apply(List list0, List list1) {\n          List collection = new ArrayList(list0);\n          final Set set = new HashSet(list1);\n          if (!collection.retainAll(set)) {\n            collection = list0;\n          }\n          return ImmutableList.copyOf(collection);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_UNION = union(BuiltIn.OP_UNION);", "docstring": " @see BuiltIn#OP_UNION", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_UNION = union(BuiltIn.OP_UNION)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable NOT =\n      new ApplicableImpl(BuiltIn.NOT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return !(Boolean) arg;\n        }\n      };", "docstring": " An applicable that negates a boolean value.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "NOT =\n      new ApplicableImpl(BuiltIn.NOT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return !(Boolean) arg;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable ABS =\n      new ApplicableImpl(BuiltIn.ABS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Integer integer = (Integer) arg;\n          return integer >= 0 ? integer : -integer;\n        }\n      };", "docstring": " An applicable that returns the absolute value of an int.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "ABS =\n      new ApplicableImpl(BuiltIn.ABS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Integer integer = (Integer) arg;\n          return integer >= 0 ? integer : -integer;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable IGNORE =\n      new ApplicableImpl(BuiltIn.IGNORE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Unit.INSTANCE;\n        }\n      };", "docstring": " @see BuiltIn#IGNORE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "IGNORE =\n      new ApplicableImpl(BuiltIn.IGNORE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Unit.INSTANCE;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Macro OP_MINUS = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_MINUS_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_MINUS_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  };", "docstring": " @see BuiltIn#OP_MINUS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Macro", "name": "OP_MINUS = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_MINUS_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_MINUS_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OP_MOD = new IntMod(BuiltIn.OP_MOD);", "docstring": " @see BuiltIn#OP_MOD", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OP_MOD = new IntMod(BuiltIn.OP_MOD)", "syntax_pass": true}, {"attribute_expression": "private static final Macro OP_PLUS = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_PLUS_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_PLUS_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  };", "docstring": " @see BuiltIn#OP_PLUS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Macro", "name": "OP_PLUS = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_PLUS_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_PLUS_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  }", "syntax_pass": true}, {"attribute_expression": "private static final Macro OP_TIMES = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_TIMES_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_TIMES_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  };", "docstring": " @see BuiltIn#OP_TIMES", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Macro", "name": "OP_TIMES = (typeSystem, env, argType) -> {\n    final Type resultType = ((TupleType) argType).argTypes.get(0);\n    switch ((PrimitiveType) resultType) {\n    case INT:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_TIMES_INT);\n    case REAL:\n      return core.functionLiteral(typeSystem, BuiltIn.Z_TIMES_REAL);\n    default:\n      throw new AssertionError(\"bad type \" + argType);\n    }\n  }", "syntax_pass": true}, {"attribute_expression": "private static final Integer STRING_MAX_SIZE = Integer.MAX_VALUE;", "docstring": " @see BuiltIn#STRING_MAX_SIZE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "STRING_MAX_SIZE = Integer.MAX_VALUE", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_SIZE =\n      new ApplicableImpl(BuiltIn.STRING_SIZE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return ((String) arg).length();\n        }\n      };", "docstring": " @see BuiltIn#STRING_SIZE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_SIZE =\n      new ApplicableImpl(BuiltIn.STRING_SIZE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return ((String) arg).length();\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_SUB = new StringSub(Pos.ZERO);", "docstring": " @see BuiltIn#STRING_SUB", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_SUB = new StringSub(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_EXTRACT =\n      new StringExtract(Pos.ZERO);", "docstring": " @see BuiltIn#STRING_EXTRACT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_EXTRACT =\n      new StringExtract(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_SUBSTRING =\n      new StringSubstring(Pos.ZERO);", "docstring": " @see BuiltIn#STRING_SUBSTRING", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_SUBSTRING =\n      new StringSubstring(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_CONCAT = new StringConcat(Pos.ZERO);", "docstring": " @see BuiltIn#STRING_CONCAT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_CONCAT = new StringConcat(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_CONCAT_WITH =\n      new StringConcatWith(Pos.ZERO);", "docstring": " @see BuiltIn#STRING_CONCAT_WITH", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_CONCAT_WITH =\n      new StringConcatWith(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_STR =\n      new ApplicableImpl(BuiltIn.STRING_STR) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Character character = (Character) arg;\n          return character + \"\";\n        }\n      };", "docstring": " @see BuiltIn#STRING_STR", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_STR =\n      new ApplicableImpl(BuiltIn.STRING_STR) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Character character = (Character) arg;\n          return character + \"\";\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_IMPLODE =\n      new ApplicableImpl(BuiltIn.STRING_IMPLODE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          // Note: In theory this function should raise Size, but it is not\n          // possible in practice because List.size() is never larger than\n          // Integer.MAX_VALUE.\n          return String.valueOf(Chars.toArray((List) arg));\n        }\n      };", "docstring": " @see BuiltIn#STRING_IMPLODE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_IMPLODE =\n      new ApplicableImpl(BuiltIn.STRING_IMPLODE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          // Note: In theory this function should raise Size, but it is not\n          // possible in practice because List.size() is never larger than\n          // Integer.MAX_VALUE.\n          return String.valueOf(Chars.toArray((List) arg));\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_EXPLODE =\n      new ApplicableImpl(BuiltIn.STRING_EXPLODE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return MapList.of(s.length(), s::charAt);\n        }\n      };", "docstring": " @see BuiltIn#STRING_EXPLODE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_EXPLODE =\n      new ApplicableImpl(BuiltIn.STRING_EXPLODE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return MapList.of(s.length(), s::charAt);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_MAP =\n      new ApplicableImpl(BuiltIn.STRING_MAP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return stringMap((Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#STRING_MAP", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_MAP =\n      new ApplicableImpl(BuiltIn.STRING_MAP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return stringMap((Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_TRANSLATE =\n      new ApplicableImpl(BuiltIn.STRING_TRANSLATE) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return translate(f);\n        }\n      };", "docstring": " @see BuiltIn#STRING_TRANSLATE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_TRANSLATE =\n      new ApplicableImpl(BuiltIn.STRING_TRANSLATE) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return translate(f);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_IS_PREFIX =\n      new ApplicableImpl(BuiltIn.STRING_IS_PREFIX) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return isPrefix(s);\n        }\n      };", "docstring": " @see BuiltIn#STRING_IS_PREFIX", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_IS_PREFIX =\n      new ApplicableImpl(BuiltIn.STRING_IS_PREFIX) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return isPrefix(s);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_IS_SUBSTRING =\n      new ApplicableImpl(BuiltIn.STRING_IS_SUBSTRING) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return isSubstring(s);\n        }\n      };", "docstring": " @see BuiltIn#STRING_IS_SUBSTRING", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_IS_SUBSTRING =\n      new ApplicableImpl(BuiltIn.STRING_IS_SUBSTRING) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return isSubstring(s);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable STRING_IS_SUFFIX =\n      new ApplicableImpl(BuiltIn.STRING_IS_SUFFIX) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return isSuffix(s);\n        }\n      };", "docstring": " @see BuiltIn#STRING_IS_SUFFIX", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "STRING_IS_SUFFIX =\n      new ApplicableImpl(BuiltIn.STRING_IS_SUFFIX) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          return isSuffix(s);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_NULL =\n      isNotEmpty(BuiltIn.LIST_NULL);", "docstring": " @see BuiltIn#LIST_NULL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_NULL =\n      isNotEmpty(BuiltIn.LIST_NULL)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_LENGTH = length(BuiltIn.LIST_LENGTH);", "docstring": " @see BuiltIn#LIST_LENGTH", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_LENGTH = length(BuiltIn.LIST_LENGTH)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_AT = union(BuiltIn.LIST_AT);", "docstring": " @see BuiltIn#LIST_AT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_AT = union(BuiltIn.LIST_AT)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_HD =\n      new ListHd(Pos.ZERO);", "docstring": " @see BuiltIn#LIST_HD", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_HD =\n      new ListHd(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_TL = new ListTl(Pos.ZERO);", "docstring": " @see BuiltIn#LIST_TL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_TL = new ListTl(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_LAST = new ListLast(Pos.ZERO);", "docstring": " @see BuiltIn#LIST_LAST", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_LAST = new ListLast(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_GET_ITEM =\n      new ApplicableImpl(BuiltIn.LIST_GET_ITEM) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List list = (List) arg;\n          if (list.isEmpty()) {\n            return OPTION_NONE;\n          } else {\n            return optionSome(\n                ImmutableList.of(list.get(0), list.subList(1, list.size())));\n          }\n        }\n      };", "docstring": " @see BuiltIn#LIST_GET_ITEM", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_GET_ITEM =\n      new ApplicableImpl(BuiltIn.LIST_GET_ITEM) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List list = (List) arg;\n          if (list.isEmpty()) {\n            return OPTION_NONE;\n          } else {\n            return optionSome(\n                ImmutableList.of(list.get(0), list.subList(1, list.size())));\n          }\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_NTH =\n      new ListNth(BuiltIn.LIST_NTH, Pos.ZERO);", "docstring": " @see BuiltIn#LIST_NTH", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_NTH =\n      new ListNth(BuiltIn.LIST_NTH, Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_TAKE = new ListTake(Pos.ZERO);", "docstring": " @see BuiltIn#LIST_TAKE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_TAKE = new ListTake(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_DROP =\n      new Applicable2<List, List, Integer>(BuiltIn.LIST_DROP) {\n        @Override public List apply(List list, Integer i) {\n          return list.subList(i, list.size());\n        }\n      };", "docstring": " @see BuiltIn#LIST_DROP", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_DROP =\n      new Applicable2<List, List, Integer>(BuiltIn.LIST_DROP) {\n        @Override public List apply(List list, Integer i) {\n          return list.subList(i, list.size());\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_REV =\n      new ApplicableImpl(BuiltIn.LIST_REV) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List list = (List) arg;\n          return Lists.reverse(list);\n        }\n      };", "docstring": " @see BuiltIn#LIST_REV", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_REV =\n      new ApplicableImpl(BuiltIn.LIST_REV) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List list = (List) arg;\n          return Lists.reverse(list);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_CONCAT =\n      new ApplicableImpl(BuiltIn.LIST_CONCAT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List list = (List) arg;\n          final ImmutableList.Builder<Object> builder = ImmutableList.builder();\n          for (Object o : list) {\n            builder.addAll((List) o);\n          }\n          return builder.build();\n        }\n      };", "docstring": " @see BuiltIn#LIST_CONCAT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_CONCAT =\n      new ApplicableImpl(BuiltIn.LIST_CONCAT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List list = (List) arg;\n          final ImmutableList.Builder<Object> builder = ImmutableList.builder();\n          for (Object o : list) {\n            builder.addAll((List) o);\n          }\n          return builder.build();\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_REV_APPEND =\n      new Applicable2<List, List, List>(BuiltIn.LIST_REV_APPEND) {\n        @Override public List apply(List list0, List list1) {\n          return ImmutableList.builder().addAll(Lists.reverse(list0))\n              .addAll(list1).build();\n        }\n      };", "docstring": " @see BuiltIn#LIST_REV_APPEND", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_REV_APPEND =\n      new Applicable2<List, List, List>(BuiltIn.LIST_REV_APPEND) {\n        @Override public List apply(List list0, List list1) {\n          return ImmutableList.builder().addAll(Lists.reverse(list0))\n              .addAll(list1).build();\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_APP =\n      new ApplicableImpl(BuiltIn.LIST_APP) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return listApp((Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#LIST_APP", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_APP =\n      new ApplicableImpl(BuiltIn.LIST_APP) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return listApp((Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_MAP =\n      new ApplicableImpl(BuiltIn.LIST_MAP) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return listMap((Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#LIST_MAP", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_MAP =\n      new ApplicableImpl(BuiltIn.LIST_MAP) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return listMap((Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_MAP_PARTIAL =\n      new ApplicableImpl(BuiltIn.LIST_MAP_PARTIAL) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return listMapPartial((Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#LIST_MAP_PARTIAL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_MAP_PARTIAL =\n      new ApplicableImpl(BuiltIn.LIST_MAP_PARTIAL) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return listMapPartial((Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_FIND = find(BuiltIn.LIST_FIND);", "docstring": " @see BuiltIn#LIST_FIND", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_FIND = find(BuiltIn.LIST_FIND)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_FILTER =\n      new ApplicableImpl(BuiltIn.LIST_FILTER) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable fn = (Applicable) arg;\n          return listFilter(fn);\n        }\n      };", "docstring": " @see BuiltIn#LIST_FILTER", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_FILTER =\n      new ApplicableImpl(BuiltIn.LIST_FILTER) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable fn = (Applicable) arg;\n          return listFilter(fn);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_PARTITION =\n      new ApplicableImpl(BuiltIn.LIST_PARTITION) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable fn = (Applicable) arg;\n          return listPartition(fn);\n        }\n      };", "docstring": " @see BuiltIn#LIST_PARTITION", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_PARTITION =\n      new ApplicableImpl(BuiltIn.LIST_PARTITION) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable fn = (Applicable) arg;\n          return listPartition(fn);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_FOLDL =\n      new ApplicableImpl(BuiltIn.LIST_FOLDL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return listFold(true, (Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#LIST_FOLDL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_FOLDL =\n      new ApplicableImpl(BuiltIn.LIST_FOLDL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return listFold(true, (Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_FOLDR =\n      new ApplicableImpl(BuiltIn.LIST_FOLDR) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return listFold(false, (Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#LIST_FOLDR", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_FOLDR =\n      new ApplicableImpl(BuiltIn.LIST_FOLDR) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return listFold(false, (Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_EXISTS = exists(BuiltIn.LIST_EXISTS);", "docstring": " @see BuiltIn#LIST_EXISTS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_EXISTS = exists(BuiltIn.LIST_EXISTS)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_ALL = all(BuiltIn.LIST_ALL);", "docstring": " @see BuiltIn#LIST_ALL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_ALL = all(BuiltIn.LIST_ALL)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_TABULATE =\n      new ListTabulate(BuiltIn.LIST_TABULATE, Pos.ZERO);", "docstring": " @see BuiltIn#LIST_TABULATE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_TABULATE =\n      new ListTabulate(BuiltIn.LIST_TABULATE, Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable LIST_COLLATE = collate(BuiltIn.LIST_COLLATE);", "docstring": " @see BuiltIn#LIST_COLLATE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "LIST_COLLATE = collate(BuiltIn.LIST_COLLATE)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_ACOS =\n      new ApplicableImpl(BuiltIn.MATH_ACOS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.acos((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_ACOS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_ACOS =\n      new ApplicableImpl(BuiltIn.MATH_ACOS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.acos((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_ASIN =\n      new ApplicableImpl(BuiltIn.MATH_ASIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.asin((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_ASIN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_ASIN =\n      new ApplicableImpl(BuiltIn.MATH_ASIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.asin((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_ATAN =\n      new ApplicableImpl(BuiltIn.MATH_ATAN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.atan((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_ATAN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_ATAN =\n      new ApplicableImpl(BuiltIn.MATH_ATAN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.atan((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_ATAN2 =\n      new Applicable2<Float, Float, Float>(BuiltIn.MATH_ATAN2) {\n        @Override public Float apply(Float arg0, Float arg1) {\n          return (float) Math.atan2(arg0, arg1);\n        }\n      };", "docstring": " @see BuiltIn#MATH_ATAN2", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_ATAN2 =\n      new Applicable2<Float, Float, Float>(BuiltIn.MATH_ATAN2) {\n        @Override public Float apply(Float arg0, Float arg1) {\n          return (float) Math.atan2(arg0, arg1);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_COS =\n      new ApplicableImpl(BuiltIn.MATH_COS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.cos((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_COS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_COS =\n      new ApplicableImpl(BuiltIn.MATH_COS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.cos((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_COSH =\n      new ApplicableImpl(BuiltIn.MATH_COSH) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.cosh((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_COSH", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_COSH =\n      new ApplicableImpl(BuiltIn.MATH_COSH) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.cosh((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final float MATH_E = (float) Math.E;", "docstring": " @see BuiltIn#MATH_E", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "float", "name": "MATH_E = (float) Math.E", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_EXP =\n      new ApplicableImpl(BuiltIn.MATH_EXP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.exp((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_EXP", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_EXP =\n      new ApplicableImpl(BuiltIn.MATH_EXP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.exp((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_LN =\n      new ApplicableImpl(BuiltIn.MATH_LN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.log((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_LN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_LN =\n      new ApplicableImpl(BuiltIn.MATH_LN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.log((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_LOG10 =\n      new ApplicableImpl(BuiltIn.MATH_LOG10) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.log10((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_LOG10", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_LOG10 =\n      new ApplicableImpl(BuiltIn.MATH_LOG10) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.log10((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final float MATH_PI = (float) Math.PI;", "docstring": " @see BuiltIn#MATH_PI", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "float", "name": "MATH_PI = (float) Math.PI", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_POW =\n      new Applicable2<Float, Float, Float>(BuiltIn.MATH_POW) {\n        @Override public Float apply(Float arg0, Float arg1) {\n          return (float) Math.pow(arg0, arg1);\n        }\n      };", "docstring": " @see BuiltIn#MATH_POW", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_POW =\n      new Applicable2<Float, Float, Float>(BuiltIn.MATH_POW) {\n        @Override public Float apply(Float arg0, Float arg1) {\n          return (float) Math.pow(arg0, arg1);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_SIN =\n      new ApplicableImpl(BuiltIn.MATH_SIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.sin((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_SIN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_SIN =\n      new ApplicableImpl(BuiltIn.MATH_SIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.sin((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_SINH =\n      new ApplicableImpl(BuiltIn.MATH_SINH) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.sinh((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_SINH", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_SINH =\n      new ApplicableImpl(BuiltIn.MATH_SINH) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.sinh((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_SQRT =\n      new ApplicableImpl(BuiltIn.MATH_SQRT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.sqrt((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_SQRT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_SQRT =\n      new ApplicableImpl(BuiltIn.MATH_SQRT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.sqrt((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_TAN =\n      new ApplicableImpl(BuiltIn.MATH_TAN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.tan((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_TAN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_TAN =\n      new ApplicableImpl(BuiltIn.MATH_TAN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.tan((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable MATH_TANH =\n      new ApplicableImpl(BuiltIn.MATH_TANH) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.tanh((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#MATH_TANH", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "MATH_TANH =\n      new ApplicableImpl(BuiltIn.MATH_TANH) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return (float) Math.tanh((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OPTION_APP =\n      new ApplicableImpl(BuiltIn.OPTION_APP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return optionApp(f);\n        }\n      };", "docstring": " @see BuiltIn#OPTION_APP", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OPTION_APP =\n      new ApplicableImpl(BuiltIn.OPTION_APP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return optionApp(f);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OPTION_GET_OPT =\n      new ApplicableImpl(BuiltIn.OPTION_GET_OPT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List tuple = (List) arg;\n          final List opt = (List) tuple.get(0);\n          if (opt.size() == 2) {\n            assert opt.get(0).equals(\"SOME\");\n            return opt.get(1); // SOME has 2 elements, NONE has 1\n          }\n          return tuple.get(1);\n        }\n      };", "docstring": " @see BuiltIn#OPTION_GET_OPT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OPTION_GET_OPT =\n      new ApplicableImpl(BuiltIn.OPTION_GET_OPT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List tuple = (List) arg;\n          final List opt = (List) tuple.get(0);\n          if (opt.size() == 2) {\n            assert opt.get(0).equals(\"SOME\");\n            return opt.get(1); // SOME has 2 elements, NONE has 1\n          }\n          return tuple.get(1);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OPTION_IS_SOME =\n      new ApplicableImpl(BuiltIn.OPTION_IS_SOME) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List opt = (List) arg;\n          return opt.size() == 2; // SOME has 2 elements, NONE has 1\n        }\n      };", "docstring": " @see BuiltIn#OPTION_IS_SOME", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OPTION_IS_SOME =\n      new ApplicableImpl(BuiltIn.OPTION_IS_SOME) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List opt = (List) arg;\n          return opt.size() == 2; // SOME has 2 elements, NONE has 1\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OPTION_VAL_OF =\n      new OptionValOf(Pos.ZERO);", "docstring": " @see BuiltIn#OPTION_VAL_OF", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OPTION_VAL_OF =\n      new OptionValOf(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OPTION_FILTER =\n      new ApplicableImpl(BuiltIn.OPTION_FILTER) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return optionFilter(f);\n        }\n      };", "docstring": " @see BuiltIn#OPTION_FILTER", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OPTION_FILTER =\n      new ApplicableImpl(BuiltIn.OPTION_FILTER) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return optionFilter(f);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OPTION_JOIN =\n      new ApplicableImpl(BuiltIn.OPTION_JOIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List opt = (List) arg;\n          return opt.size() == 2\n              ? opt.get(1) // SOME(SOME(v)) -> SOME(v), SOME(NONE) -> NONE\n              : opt; // NONE -> NONE\n        }\n      };", "docstring": " @see BuiltIn#OPTION_JOIN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OPTION_JOIN =\n      new ApplicableImpl(BuiltIn.OPTION_JOIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List opt = (List) arg;\n          return opt.size() == 2\n              ? opt.get(1) // SOME(SOME(v)) -> SOME(v), SOME(NONE) -> NONE\n              : opt; // NONE -> NONE\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OPTION_MAP =\n      new ApplicableImpl(BuiltIn.OPTION_MAP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return optionMap((Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#OPTION_MAP", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OPTION_MAP =\n      new ApplicableImpl(BuiltIn.OPTION_MAP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return optionMap((Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OPTION_MAP_PARTIAL =\n      new ApplicableImpl(BuiltIn.OPTION_MAP_PARTIAL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return optionMapPartial((Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#OPTION_MAP_PARTIAL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OPTION_MAP_PARTIAL =\n      new ApplicableImpl(BuiltIn.OPTION_MAP_PARTIAL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return optionMapPartial((Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OPTION_COMPOSE =\n      new ApplicableImpl(BuiltIn.OPTION_COMPOSE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List tuple = (List) arg;\n          final Applicable f = (Applicable) tuple.get(0);\n          final Applicable g = (Applicable) tuple.get(1);\n          return optionCompose(f, g);\n        }\n      };", "docstring": " @see BuiltIn#OPTION_COMPOSE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OPTION_COMPOSE =\n      new ApplicableImpl(BuiltIn.OPTION_COMPOSE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List tuple = (List) arg;\n          final Applicable f = (Applicable) tuple.get(0);\n          final Applicable g = (Applicable) tuple.get(1);\n          return optionCompose(f, g);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable OPTION_COMPOSE_PARTIAL =\n      new ApplicableImpl(BuiltIn.OPTION_COMPOSE_PARTIAL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List tuple = (List) arg;\n          final Applicable f = (Applicable) tuple.get(0);\n          final Applicable g = (Applicable) tuple.get(1);\n          return optionComposePartial(f, g);\n        }\n      };", "docstring": " @see BuiltIn#OPTION_COMPOSE_PARTIAL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "OPTION_COMPOSE_PARTIAL =\n      new ApplicableImpl(BuiltIn.OPTION_COMPOSE_PARTIAL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List tuple = (List) arg;\n          final Applicable f = (Applicable) tuple.get(0);\n          final Applicable g = (Applicable) tuple.get(1);\n          return optionComposePartial(f, g);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_ABS =\n      new ApplicableImpl(BuiltIn.REAL_ABS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Math.abs((float) arg);\n        }\n      };", "docstring": " @see BuiltIn#REAL_ABS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_ABS =\n      new ApplicableImpl(BuiltIn.REAL_ABS) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Math.abs((float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_CEIL =\n      new ApplicableImpl(BuiltIn.REAL_CEIL) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          float f = (float) arg;\n          if (f >= 0) {\n            return Math.round(f);\n          } else {\n            return -Math.round(-f);\n          }\n        }\n      };", "docstring": " @see BuiltIn#REAL_CEIL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_CEIL =\n      new ApplicableImpl(BuiltIn.REAL_CEIL) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          float f = (float) arg;\n          if (f >= 0) {\n            return Math.round(f);\n          } else {\n            return -Math.round(-f);\n          }\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_CHECK_FLOAT =\n      new RealCheckFloat(Pos.ZERO);", "docstring": " @see BuiltIn#REAL_CHECK_FLOAT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_CHECK_FLOAT =\n      new RealCheckFloat(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_COMPARE =\n      new RealCompare(Pos.ZERO);", "docstring": " @see BuiltIn#REAL_COMPARE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_COMPARE =\n      new RealCompare(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_COPY_SIGN =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_COPY_SIGN) {\n        @Override public Float apply(Float f0, Float f1) {\n          if (Float.isNaN(f1)) {\n            // Emulate SMLNJ/Mlton behavior that nan is negative,\n            // ~nan is positive.\n            f1 = isNegative(f1) ? -1.0f : 1.0f;\n          }\n          return Math.copySign(f0, f1);\n        }\n      };", "docstring": " @see BuiltIn#REAL_COPY_SIGN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_COPY_SIGN =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_COPY_SIGN) {\n        @Override public Float apply(Float f0, Float f1) {\n          if (Float.isNaN(f1)) {\n            // Emulate SMLNJ/Mlton behavior that nan is negative,\n            // ~nan is positive.\n            f1 = isNegative(f1) ? -1.0f : 1.0f;\n          }\n          return Math.copySign(f0, f1);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_FLOOR =\n      new ApplicableImpl(BuiltIn.REAL_FLOOR) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          float f = (float) arg;\n          if (f >= 0) {\n            return -Math.round(-f);\n          } else {\n            return Math.round(f);\n          }\n        }\n      };", "docstring": " @see BuiltIn#REAL_FLOOR", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_FLOOR =\n      new ApplicableImpl(BuiltIn.REAL_FLOOR) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          float f = (float) arg;\n          if (f >= 0) {\n            return -Math.round(-f);\n          } else {\n            return Math.round(f);\n          }\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_FROM_INT =\n      new ApplicableImpl(BuiltIn.REAL_FROM_INT) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) ((Integer) arg);\n        }\n      };", "docstring": " @see BuiltIn#REAL_FROM_INT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_FROM_INT =\n      new ApplicableImpl(BuiltIn.REAL_FROM_INT) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) ((Integer) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_FROM_MAN_EXP =\n      new Applicable2<Float, Integer, Float>(BuiltIn.REAL_FROM_MAN_EXP) {\n        @Override public Float apply(Integer exp, Float mantissa) {\n          if (!Float.isFinite(mantissa)) {\n            return mantissa;\n          }\n          if (exp >= Float.MAX_EXPONENT) {\n            final int exp2 = (exp - Float.MIN_EXPONENT) & 0xFF;\n            final int bits = Float.floatToRawIntBits(mantissa);\n            final int bits2 = (bits & ~(0xFF << 23)) | (exp2 << 23);\n            return Float.intBitsToFloat(bits2);\n          }\n          final int exp2 = (exp - Float.MIN_EXPONENT + 1) & 0xFF;\n          final float exp3 = Float.intBitsToFloat(exp2 << 23); // 2 ^ exp\n          return mantissa * exp3;\n        }\n      };", "docstring": " @see BuiltIn#REAL_FROM_MAN_EXP", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_FROM_MAN_EXP =\n      new Applicable2<Float, Integer, Float>(BuiltIn.REAL_FROM_MAN_EXP) {\n        @Override public Float apply(Integer exp, Float mantissa) {\n          if (!Float.isFinite(mantissa)) {\n            return mantissa;\n          }\n          if (exp >= Float.MAX_EXPONENT) {\n            final int exp2 = (exp - Float.MIN_EXPONENT) & 0xFF;\n            final int bits = Float.floatToRawIntBits(mantissa);\n            final int bits2 = (bits & ~(0xFF << 23)) | (exp2 << 23);\n            return Float.intBitsToFloat(bits2);\n          }\n          final int exp2 = (exp - Float.MIN_EXPONENT + 1) & 0xFF;\n          final float exp3 = Float.intBitsToFloat(exp2 << 23); // 2 ^ exp\n          return mantissa * exp3;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "static final Pattern FLOAT_PATTERN =\n      Pattern.compile(\"^ *-?([0-9]*\\\\.)?[0-9]+([Ee]-?[0-9]+)?\");", "docstring": " Pattern for floating point numbers (after '~' has been converted to '-').\n\".\", \".e\", \".e-\", \".e5\", \"e7\" are invalid;\n\"2.\", \".5\", \"2.e5\", \"2.e\" are valid.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Pattern", "name": "FLOAT_PATTERN =\n      Pattern.compile(\"^ *-?([0-9]*\\\\.)?[0-9]+([Ee]-?[0-9]+)?\")", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_FROM_STRING =\n      new ApplicableImpl(BuiltIn.REAL_FROM_STRING) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          final String s2 = s.replace('~', '-');\n          final Matcher matcher = FLOAT_PATTERN.matcher(s2);\n          if (!matcher.find(0)) {\n            return OPTION_NONE;\n          }\n          final String s3 = s2.substring(0, matcher.end());\n          try {\n            final float f = Float.parseFloat(s3);\n            return optionSome(f);\n          } catch (NumberFormatException e) {\n            // We should not have reached this point. The pattern\n            // should not have matched the input.\n            throw new AssertionError(e);\n          }\n        }\n      };", "docstring": " @see BuiltIn#REAL_FROM_STRING", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_FROM_STRING =\n      new ApplicableImpl(BuiltIn.REAL_FROM_STRING) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          final String s = (String) arg;\n          final String s2 = s.replace('~', '-');\n          final Matcher matcher = FLOAT_PATTERN.matcher(s2);\n          if (!matcher.find(0)) {\n            return OPTION_NONE;\n          }\n          final String s3 = s2.substring(0, matcher.end());\n          try {\n            final float f = Float.parseFloat(s3);\n            return optionSome(f);\n          } catch (NumberFormatException e) {\n            // We should not have reached this point. The pattern\n            // should not have matched the input.\n            throw new AssertionError(e);\n          }\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_IS_FINITE =\n      new ApplicableImpl(BuiltIn.REAL_IS_FINITE) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          return Float.isFinite((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#REAL_IS_FINITE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_IS_FINITE =\n      new ApplicableImpl(BuiltIn.REAL_IS_FINITE) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          return Float.isFinite((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_IS_NAN =\n      new ApplicableImpl(BuiltIn.REAL_IS_NAN) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          return Float.isNaN((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#REAL_IS_NAN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_IS_NAN =\n      new ApplicableImpl(BuiltIn.REAL_IS_NAN) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          return Float.isNaN((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_IS_NORMAL =\n      new ApplicableImpl(BuiltIn.REAL_IS_NORMAL) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          final Float f = (Float) arg;\n          return Float.isFinite(f)\n              && (f >= Float.MIN_NORMAL || f <= -Float.MIN_NORMAL);\n        }\n      };", "docstring": " @see BuiltIn#REAL_IS_NORMAL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_IS_NORMAL =\n      new ApplicableImpl(BuiltIn.REAL_IS_NORMAL) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          final Float f = (Float) arg;\n          return Float.isFinite(f)\n              && (f >= Float.MIN_NORMAL || f <= -Float.MIN_NORMAL);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final float REAL_NEG_INF = Float.NEGATIVE_INFINITY;", "docstring": " @see BuiltIn#REAL_NEG_INF", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "float", "name": "REAL_NEG_INF = Float.NEGATIVE_INFINITY", "syntax_pass": true}, {"attribute_expression": "private static final float REAL_POS_INF = Float.POSITIVE_INFINITY;", "docstring": " @see BuiltIn#REAL_POS_INF", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "float", "name": "REAL_POS_INF = Float.POSITIVE_INFINITY", "syntax_pass": true}, {"attribute_expression": "private static final int REAL_RADIX = 2;", "docstring": " @see BuiltIn#REAL_RADIX", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "REAL_RADIX = 2", "syntax_pass": true}, {"attribute_expression": "private static final int REAL_PRECISION = 24;", "docstring": " 23 bit mantissa)", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "REAL_PRECISION = 24", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_MIN =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_MIN) {\n        @Override public Float apply(Float f0, Float f1) {\n          return Float.isNaN(f0) ? f1\n              : Float.isNaN(f1) ? f0\n              : Math.min(f0, f1);\n        }\n      };", "docstring": " @see BuiltIn#REAL_MIN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_MIN =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_MIN) {\n        @Override public Float apply(Float f0, Float f1) {\n          return Float.isNaN(f0) ? f1\n              : Float.isNaN(f1) ? f0\n              : Math.min(f0, f1);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_MAX =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_MAX) {\n        @Override public Float apply(Float f0, Float f1) {\n          return Float.isNaN(f0) ? f1\n              : Float.isNaN(f1) ? f0\n              : Math.max(f0, f1);\n        }\n      };", "docstring": " @see BuiltIn#REAL_MAX", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_MAX =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_MAX) {\n        @Override public Float apply(Float f0, Float f1) {\n          return Float.isNaN(f0) ? f1\n              : Float.isNaN(f1) ? f0\n              : Math.max(f0, f1);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final float REAL_MAX_FINITE = Float.MAX_VALUE;", "docstring": " @see BuiltIn#REAL_MAX_FINITE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "float", "name": "REAL_MAX_FINITE = Float.MAX_VALUE", "syntax_pass": true}, {"attribute_expression": "private static final float REAL_MIN_POS = Float.MIN_VALUE;", "docstring": " @see BuiltIn#REAL_MIN_POS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "float", "name": "REAL_MIN_POS = Float.MIN_VALUE", "syntax_pass": true}, {"attribute_expression": "private static final float REAL_MIN_NORMAL_POS = Float.MIN_NORMAL;", "docstring": " @see BuiltIn#REAL_MIN_NORMAL_POS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "float", "name": "REAL_MIN_NORMAL_POS = Float.MIN_NORMAL", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_REAL_MOD =\n      new ApplicableImpl(BuiltIn.REAL_REAL_MOD) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final float f = (Float) arg;\n          if (Float.isInfinite(f)) {\n            // realMod posInf  => 0.0\n            // realMod negInf  => ~0.0\n            return f > 0f ? 0f : -0f;\n          }\n          return f % 1;\n        }\n      };", "docstring": " @see BuiltIn#REAL_REAL_MOD", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_REAL_MOD =\n      new ApplicableImpl(BuiltIn.REAL_REAL_MOD) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final float f = (Float) arg;\n          if (Float.isInfinite(f)) {\n            // realMod posInf  => 0.0\n            // realMod negInf  => ~0.0\n            return f > 0f ? 0f : -0f;\n          }\n          return f % 1;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_REAL_CEIL =\n      new ApplicableImpl(BuiltIn.REAL_REAL_CEIL) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) Math.ceil((float) arg);\n        }\n      };", "docstring": " @see BuiltIn#REAL_REAL_CEIL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_REAL_CEIL =\n      new ApplicableImpl(BuiltIn.REAL_REAL_CEIL) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) Math.ceil((float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_REAL_FLOOR =\n      new ApplicableImpl(BuiltIn.REAL_REAL_FLOOR) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) Math.floor((float) arg);\n        }\n      };", "docstring": " @see BuiltIn#REAL_REAL_FLOOR", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_REAL_FLOOR =\n      new ApplicableImpl(BuiltIn.REAL_REAL_FLOOR) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) Math.floor((float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_REAL_ROUND =\n      new ApplicableImpl(BuiltIn.REAL_REAL_ROUND) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) Math.rint((float) arg);\n        }\n      };", "docstring": " @see BuiltIn#REAL_REAL_ROUND", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_REAL_ROUND =\n      new ApplicableImpl(BuiltIn.REAL_REAL_ROUND) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          return (float) Math.rint((float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_REAL_TRUNC =\n      new ApplicableImpl(BuiltIn.REAL_REAL_TRUNC) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          final float f = (float) arg;\n          final float frac = f % 1;\n          return f - frac;\n        }\n      };", "docstring": " @see BuiltIn#REAL_REAL_TRUNC", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_REAL_TRUNC =\n      new ApplicableImpl(BuiltIn.REAL_REAL_TRUNC) {\n        @Override public Float apply(EvalEnv env, Object arg) {\n          final float f = (float) arg;\n          final float frac = f % 1;\n          return f - frac;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_REM =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_REM) {\n        @Override public Float apply(Float x, Float y) {\n          return x % y;\n        }\n      };", "docstring": " @see BuiltIn#REAL_REM", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_REM =\n      new Applicable2<Float, Float, Float>(BuiltIn.REAL_REM) {\n        @Override public Float apply(Float x, Float y) {\n          return x % y;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_ROUND =\n      new ApplicableImpl(BuiltIn.REAL_ROUND) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          return Math.round((float) arg);\n        }\n      };", "docstring": " @see BuiltIn#REAL_ROUND", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_ROUND =\n      new ApplicableImpl(BuiltIn.REAL_ROUND) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          return Math.round((float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_SAME_SIGN =\n      new Applicable2<Boolean, Float, Float>(BuiltIn.REAL_SAME_SIGN) {\n        @Override public Boolean apply(Float x, Float y) {\n          return isNegative(x) == isNegative(y);\n        }\n      };", "docstring": " @see BuiltIn#REAL_SAME_SIGN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_SAME_SIGN =\n      new Applicable2<Boolean, Float, Float>(BuiltIn.REAL_SAME_SIGN) {\n        @Override public Boolean apply(Float x, Float y) {\n          return isNegative(x) == isNegative(y);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_SIGN = new RealSign(Pos.ZERO);", "docstring": " @see BuiltIn#REAL_SIGN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_SIGN = new RealSign(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_SIGN_BIT =\n      new ApplicableImpl(BuiltIn.REAL_SIGN_BIT) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          return isNegative((Float) arg);\n        }\n      };", "docstring": " @see BuiltIn#REAL_SIGN_BIT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_SIGN_BIT =\n      new ApplicableImpl(BuiltIn.REAL_SIGN_BIT) {\n        @Override public Boolean apply(EvalEnv env, Object arg) {\n          return isNegative((Float) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_SPLIT =\n      new ApplicableImpl(BuiltIn.REAL_SPLIT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final float f = (Float) arg;\n          final float frac;\n          final float whole;\n          if (Float.isInfinite(f)) {\n            // realMod posInf  => 0.0\n            // realMod negInf  => ~0.0\n            frac = f > 0f ? 0f : -0f;\n            whole = f;\n          } else {\n            frac = f % 1;\n            whole = f - frac;\n          }\n          return ImmutableList.of(frac, whole);\n        }\n      };", "docstring": " @see BuiltIn#REAL_SPLIT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_SPLIT =\n      new ApplicableImpl(BuiltIn.REAL_SPLIT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final float f = (Float) arg;\n          final float frac;\n          final float whole;\n          if (Float.isInfinite(f)) {\n            // realMod posInf  => 0.0\n            // realMod negInf  => ~0.0\n            frac = f > 0f ? 0f : -0f;\n            whole = f;\n          } else {\n            frac = f % 1;\n            whole = f - frac;\n          }\n          return ImmutableList.of(frac, whole);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_TO_MAN_EXP =\n      new ApplicableImpl(BuiltIn.REAL_TO_MAN_EXP) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          // In IEEE 32 bit floating point,\n          // bit 31 is the sign (1 bit);\n          // bits 30 - 23 are the exponent (8 bits);\n          // bits 22 - 0 are the mantissa (23 bits).\n          float f = (Float) arg;\n          final int bits = Float.floatToRawIntBits(f);\n          final int exp = (bits >> 23) & 0xFF;\n          final float mantissa;\n          if (exp == 0) {\n            // Exponent = 0 indicates that f is a very small number (0 < abs(f)\n            // <= MIN_NORMAL). The mantissa has leading zeros, so we have to use\n            // a different algorithm to get shift it into range.\n            mantissa = f / Float.MIN_NORMAL;\n          } else if (Float.isFinite(f)) {\n            // Set the exponent to 126 (which is the exponent for 1.0). First\n            // remove all set bits, then OR in the value 126.\n            final int bits2 = (bits & ~(0xFF << 23)) | (0x7E << 23);\n            mantissa = Float.intBitsToFloat(bits2);\n          } else {\n            mantissa = f;\n          }\n          return ImmutableList.of(exp + Float.MIN_EXPONENT, mantissa);\n        }\n      };", "docstring": " @see BuiltIn#REAL_TO_MAN_EXP", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_TO_MAN_EXP =\n      new ApplicableImpl(BuiltIn.REAL_TO_MAN_EXP) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          // In IEEE 32 bit floating point,\n          // bit 31 is the sign (1 bit);\n          // bits 30 - 23 are the exponent (8 bits);\n          // bits 22 - 0 are the mantissa (23 bits).\n          float f = (Float) arg;\n          final int bits = Float.floatToRawIntBits(f);\n          final int exp = (bits >> 23) & 0xFF;\n          final float mantissa;\n          if (exp == 0) {\n            // Exponent = 0 indicates that f is a very small number (0 < abs(f)\n            // <= MIN_NORMAL). The mantissa has leading zeros, so we have to use\n            // a different algorithm to get shift it into range.\n            mantissa = f / Float.MIN_NORMAL;\n          } else if (Float.isFinite(f)) {\n            // Set the exponent to 126 (which is the exponent for 1.0). First\n            // remove all set bits, then OR in the value 126.\n            final int bits2 = (bits & ~(0xFF << 23)) | (0x7E << 23);\n            mantissa = Float.intBitsToFloat(bits2);\n          } else {\n            mantissa = f;\n          }\n          return ImmutableList.of(exp + Float.MIN_EXPONENT, mantissa);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_TO_STRING =\n      new ApplicableImpl(BuiltIn.REAL_TO_STRING) {\n        @Override public String apply(EvalEnv env, Object arg) {\n          // Java's formatting is reasonably close to ML's formatting,\n          // if we replace minus signs.\n          Float f = (Float) arg;\n          return floatToString(f);\n        }\n      };", "docstring": " @see BuiltIn#REAL_TO_STRING", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_TO_STRING =\n      new ApplicableImpl(BuiltIn.REAL_TO_STRING) {\n        @Override public String apply(EvalEnv env, Object arg) {\n          // Java's formatting is reasonably close to ML's formatting,\n          // if we replace minus signs.\n          Float f = (Float) arg;\n          return floatToString(f);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_TRUNC =\n      new ApplicableImpl(BuiltIn.REAL_TRUNC) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          float f = (float) arg;\n          return (int) f;\n        }\n      };", "docstring": " @see BuiltIn#REAL_TRUNC", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_TRUNC =\n      new ApplicableImpl(BuiltIn.REAL_TRUNC) {\n        @Override public Integer apply(EvalEnv env, Object arg) {\n          float f = (float) arg;\n          return (int) f;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable REAL_UNORDERED =\n      new Applicable2<Boolean, Float, Float>(BuiltIn.REAL_UNORDERED) {\n        @Override public Boolean apply(Float f0, Float f1) {\n          return Float.isNaN(f0) ||  Float.isNaN(f1);\n        }\n      };", "docstring": " @see BuiltIn#REAL_UNORDERED", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "REAL_UNORDERED =\n      new Applicable2<Boolean, Float, Float>(BuiltIn.REAL_UNORDERED) {\n        @Override public Boolean apply(Float f0, Float f1) {\n          return Float.isNaN(f0) ||  Float.isNaN(f1);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable RELATIONAL_COUNT =\n      length(BuiltIn.RELATIONAL_COUNT);", "docstring": " @see BuiltIn#RELATIONAL_COUNT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "RELATIONAL_COUNT =\n      length(BuiltIn.RELATIONAL_COUNT)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable RELATIONAL_EXISTS =\n      isEmpty(BuiltIn.RELATIONAL_EXISTS);", "docstring": " @see BuiltIn#RELATIONAL_EXISTS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "RELATIONAL_EXISTS =\n      isEmpty(BuiltIn.RELATIONAL_EXISTS)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable RELATIONAL_NOT_EXISTS =\n      isNotEmpty(BuiltIn.RELATIONAL_NOT_EXISTS);", "docstring": " @see BuiltIn#RELATIONAL_NOT_EXISTS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "RELATIONAL_NOT_EXISTS =\n      isNotEmpty(BuiltIn.RELATIONAL_NOT_EXISTS)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable RELATIONAL_ITERATE =\n      new ApplicableImpl(BuiltIn.RELATIONAL_ITERATE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List initialList = (List) arg;\n          return new ApplicableImpl(\"Relational.iterate$list\") {\n            @Override public Object apply(EvalEnv env, Object argValue) {\n              final Applicable update = (Applicable) argValue;\n              List list = initialList;\n              List newList = list;\n              for (;;) {\n                List nextList = (List) update.apply(env,\n                    FlatLists.of(list, newList));\n                if (nextList.isEmpty()) {\n                  return list;\n                }\n                // REVIEW:\n                // 1. should we eliminate duplicates when computing \"oldList\n                //   union newList\"?\n                // 2. should we subtract oldList before checking whether newList\n                //    is empty?\n                // 3. add an \"iterateDistinct\" variant?\n                list =\n                    ImmutableList.builder().addAll(list).addAll(nextList)\n                        .build();\n                newList = nextList;\n              }\n            }\n          };\n        }\n      };", "docstring": " @see BuiltIn#RELATIONAL_ITERATE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "RELATIONAL_ITERATE =\n      new ApplicableImpl(BuiltIn.RELATIONAL_ITERATE) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final List initialList = (List) arg;\n          return new ApplicableImpl(\"Relational.iterate$list\") {\n            @Override public Object apply(EvalEnv env, Object argValue) {\n              final Applicable update = (Applicable) argValue;\n              List list = initialList;\n              List newList = list;\n              for (;;) {\n                List nextList = (List) update.apply(env,\n                    FlatLists.of(list, newList));\n                if (nextList.isEmpty()) {\n                  return list;\n                }\n                // REVIEW:\n                // 1. should we eliminate duplicates when computing \"oldList\n                //   union newList\"?\n                // 2. should we subtract oldList before checking whether newList\n                //    is empty?\n                // 3. add an \"iterateDistinct\" variant?\n                list =\n                    ImmutableList.builder().addAll(list).addAll(nextList)\n                        .build();\n                newList = nextList;\n              }\n            }\n          };\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable RELATIONAL_ONLY =\n      new RelationalOnly(Pos.ZERO);", "docstring": " @see BuiltIn#RELATIONAL_ONLY", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "RELATIONAL_ONLY =\n      new RelationalOnly(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_SUM_INT =\n      new ApplicableImpl(\"Relational.sum$int\") {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"unchecked\") final List<? extends Number> list =\n              (List) arg;\n          int sum = 0;\n          for (Number o : list) {\n            sum += o.intValue();\n          }\n          return sum;\n        }\n      };", "docstring": " Implements {@link #RELATIONAL_SUM} for type {@code int list}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_SUM_INT =\n      new ApplicableImpl(\"Relational.sum$int\") {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"unchecked\") final List<? extends Number> list =\n              (List) arg;\n          int sum = 0;\n          for (Number o : list) {\n            sum += o.intValue();\n          }\n          return sum;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_SUM_REAL =\n      new ApplicableImpl(\"Relational.sum$real\") {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"unchecked\") final List<? extends Number> list =\n              (List) arg;\n          float sum = 0;\n          for (Number o : list) {\n            sum += o.floatValue();\n          }\n          return sum;\n        }\n      };", "docstring": " Implements {@link #RELATIONAL_SUM} for type {@code real list}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_SUM_REAL =\n      new ApplicableImpl(\"Relational.sum$real\") {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"unchecked\") final List<? extends Number> list =\n              (List) arg;\n          float sum = 0;\n          for (Number o : list) {\n            sum += o.floatValue();\n          }\n          return sum;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Macro RELATIONAL_SUM = (typeSystem, env, argType) -> {\n    if (argType instanceof ListType) {\n      final Type resultType = ((ListType) argType).elementType;\n      switch ((PrimitiveType) resultType) {\n      case INT:\n        return core.functionLiteral(typeSystem, BuiltIn.Z_SUM_INT);\n      case REAL:\n        return core.functionLiteral(typeSystem, BuiltIn.Z_SUM_REAL);\n      }\n    }\n    throw new AssertionError(\"bad type \" + argType);\n  };", "docstring": " @see BuiltIn#RELATIONAL_SUM", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Macro", "name": "RELATIONAL_SUM = (typeSystem, env, argType) -> {\n    if (argType instanceof ListType) {\n      final Type resultType = ((ListType) argType).elementType;\n      switch ((PrimitiveType) resultType) {\n      case INT:\n        return core.functionLiteral(typeSystem, BuiltIn.Z_SUM_INT);\n      case REAL:\n        return core.functionLiteral(typeSystem, BuiltIn.Z_SUM_REAL);\n      }\n    }\n    throw new AssertionError(\"bad type \" + argType);\n  }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable RELATIONAL_MIN =\n      new ApplicableImpl(BuiltIn.RELATIONAL_MIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Ordering.natural().min((List) arg);\n        }\n      };", "docstring": " @see BuiltIn#RELATIONAL_MIN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "RELATIONAL_MIN =\n      new ApplicableImpl(BuiltIn.RELATIONAL_MIN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Ordering.natural().min((List) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable RELATIONAL_MAX =\n      new ApplicableImpl(BuiltIn.RELATIONAL_MAX) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Ordering.natural().max((List) arg);\n        }\n      };", "docstring": " @see BuiltIn#RELATIONAL_MAX", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "RELATIONAL_MAX =\n      new ApplicableImpl(BuiltIn.RELATIONAL_MAX) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return Ordering.natural().max((List) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable SYS_PLAN =\n      new ApplicableImpl(BuiltIn.SYS_PLAN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          return Codes.describe(session.code);\n        }\n      };", "docstring": " @see BuiltIn#SYS_PLAN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "SYS_PLAN =\n      new ApplicableImpl(BuiltIn.SYS_PLAN) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          return Codes.describe(session.code);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable SYS_SET =\n      new ApplicableImpl(BuiltIn.SYS_SET) {\n        @Override public Unit apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          final List list = (List) arg;\n          final String propName = (String) list.get(0);\n          final Object value = list.get(1);\n          Prop.lookup(propName).set(session.map, value);\n          return Unit.INSTANCE;\n        }\n      };", "docstring": " @see BuiltIn#SYS_SET", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "SYS_SET =\n      new ApplicableImpl(BuiltIn.SYS_SET) {\n        @Override public Unit apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          final List list = (List) arg;\n          final String propName = (String) list.get(0);\n          final Object value = list.get(1);\n          Prop.lookup(propName).set(session.map, value);\n          return Unit.INSTANCE;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable SYS_SHOW =\n      new ApplicableImpl(BuiltIn.SYS_SHOW) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          final String propName = (String) arg;\n          final Object value = Prop.lookup(propName).get(session.map);\n          return value == null ? OPTION_NONE : optionSome(value.toString());\n        }\n      };", "docstring": " @see BuiltIn#SYS_SHOW", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "SYS_SHOW =\n      new ApplicableImpl(BuiltIn.SYS_SHOW) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          final String propName = (String) arg;\n          final Object value = Prop.lookup(propName).get(session.map);\n          return value == null ? OPTION_NONE : optionSome(value.toString());\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable SYS_UNSET =\n      new ApplicableImpl(BuiltIn.SYS_UNSET) {\n        @Override public Unit apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          final String propName = (String) arg;\n          final Prop prop = Prop.lookup(propName);\n          @SuppressWarnings(\"unused\") final Object value =\n              prop.remove(session.map);\n          return Unit.INSTANCE;\n        }\n      };", "docstring": " @see BuiltIn#SYS_UNSET", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "SYS_UNSET =\n      new ApplicableImpl(BuiltIn.SYS_UNSET) {\n        @Override public Unit apply(EvalEnv env, Object arg) {\n          final Session session = (Session) env.getOpt(EvalEnv.SESSION);\n          final String propName = (String) arg;\n          final Prop prop = Prop.lookup(propName);\n          @SuppressWarnings(\"unused\") final Object value =\n              prop.remove(session.map);\n          return Unit.INSTANCE;\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final List ORDER_LESS = ImmutableList.of(\"LESS\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List", "name": "ORDER_LESS = ImmutableList.of(\"LESS\")", "syntax_pass": true}, {"attribute_expression": "private static final List ORDER_EQUAL = ImmutableList.of(\"EQUAL\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List", "name": "ORDER_EQUAL = ImmutableList.of(\"EQUAL\")", "syntax_pass": true}, {"attribute_expression": "private static final List ORDER_GREATER = ImmutableList.of(\"GREATER\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List", "name": "ORDER_GREATER = ImmutableList.of(\"GREATER\")", "syntax_pass": true}, {"attribute_expression": "private static final int VECTOR_MAX_LEN = (1 << 24) - 1;", "docstring": " @see BuiltIn#VECTOR_MAX_LEN", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "VECTOR_MAX_LEN = (1 << 24) - 1", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_FROM_LIST =\n      identity(BuiltIn.VECTOR_FROM_LIST);", "docstring": " @see BuiltIn#VECTOR_FROM_LIST", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_FROM_LIST =\n      identity(BuiltIn.VECTOR_FROM_LIST)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_TABULATE =\n      new ListTabulate(BuiltIn.VECTOR_TABULATE, Pos.ZERO);", "docstring": " @see BuiltIn#VECTOR_TABULATE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_TABULATE =\n      new ListTabulate(BuiltIn.VECTOR_TABULATE, Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_LENGTH = length(BuiltIn.VECTOR_LENGTH);", "docstring": " @see BuiltIn#VECTOR_LENGTH", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_LENGTH = length(BuiltIn.VECTOR_LENGTH)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_SUB =\n      new ListNth(BuiltIn.VECTOR_SUB, Pos.ZERO);", "docstring": " @see BuiltIn#VECTOR_SUB", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_SUB =\n      new ListNth(BuiltIn.VECTOR_SUB, Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_UPDATE =\n      new VectorUpdate(Pos.ZERO);", "docstring": " @see BuiltIn#VECTOR_UPDATE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_UPDATE =\n      new VectorUpdate(Pos.ZERO)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_CONCAT =\n      new ApplicableImpl(BuiltIn.VECTOR_CONCAT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"unchecked\") final List<List<Object>> lists =\n              (List<List<Object>>) arg;\n          final ImmutableList.Builder<Object> b = ImmutableList.builder();\n          for (List<Object> list : lists) {\n            b.addAll(list);\n          }\n          return b.build();\n        }\n      };", "docstring": " @see BuiltIn#VECTOR_CONCAT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_CONCAT =\n      new ApplicableImpl(BuiltIn.VECTOR_CONCAT) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          @SuppressWarnings(\"unchecked\") final List<List<Object>> lists =\n              (List<List<Object>>) arg;\n          final ImmutableList.Builder<Object> b = ImmutableList.builder();\n          for (List<Object> list : lists) {\n            b.addAll(list);\n          }\n          return b.build();\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_APPI =\n      new ApplicableImpl(BuiltIn.VECTOR_APPI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorAppi((Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#VECTOR_APPI", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_APPI =\n      new ApplicableImpl(BuiltIn.VECTOR_APPI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorAppi((Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_APP =\n      new ApplicableImpl(BuiltIn.VECTOR_APP) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return vectorApp((Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#VECTOR_APP", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_APP =\n      new ApplicableImpl(BuiltIn.VECTOR_APP) {\n        @Override public Applicable apply(EvalEnv env, Object arg) {\n          return vectorApp((Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_MAPI =\n      new ApplicableImpl(BuiltIn.VECTOR_MAPI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorMapi((Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#VECTOR_MAPI", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_MAPI =\n      new ApplicableImpl(BuiltIn.VECTOR_MAPI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorMapi((Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_MAP =\n      new ApplicableImpl(BuiltIn.VECTOR_MAP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorMap((Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#VECTOR_MAP", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_MAP =\n      new ApplicableImpl(BuiltIn.VECTOR_MAP) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorMap((Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_FOLDLI =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDLI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldli$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldli$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (int i = 0, n = vec.size(); i < n; i++) {\n                    acc = f.apply(env3, FlatLists.of(i, vec.get(i), acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      };", "docstring": " @see BuiltIn#VECTOR_FOLDLI", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_FOLDLI =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDLI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldli$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldli$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (int i = 0, n = vec.size(); i < n; i++) {\n                    acc = f.apply(env3, FlatLists.of(i, vec.get(i), acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_FOLDRI =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDRI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldri$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldri$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (int i = vec.size() - 1; i >= 0; i--) {\n                    acc = f.apply(env3, FlatLists.of(i, vec.get(i), acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      };", "docstring": " @see BuiltIn#VECTOR_FOLDRI", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_FOLDRI =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDRI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldri$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldri$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (int i = vec.size() - 1; i >= 0; i--) {\n                    acc = f.apply(env3, FlatLists.of(i, vec.get(i), acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_FOLDL =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldl$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldl$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (Object o : vec) {\n                    acc = f.apply(env3, FlatLists.of(o, acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      };", "docstring": " @see BuiltIn#VECTOR_FOLDL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_FOLDL =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDL) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldl$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldl$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (Object o : vec) {\n                    acc = f.apply(env3, FlatLists.of(o, acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_FOLDR =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDR) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldlr$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldr$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (int i = vec.size() - 1; i >= 0; i--) {\n                    acc = f.apply(env3, FlatLists.of(vec.get(i), acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      };", "docstring": " @see BuiltIn#VECTOR_FOLDR", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_FOLDR =\n      new ApplicableImpl(BuiltIn.VECTOR_FOLDR) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          final Applicable f = (Applicable) arg;\n          return new ApplicableImpl(\"Vector.foldlr$f\") {\n            @Override public Object apply(EvalEnv env2, Object init) {\n              return new ApplicableImpl(\"Vector.foldr$f$init\") {\n                @Override public Object apply(EvalEnv env3, Object arg3) {\n                  @SuppressWarnings(\"unchecked\") final List<Object> vec =\n                      (List<Object>) arg3;\n                  Object acc = init;\n                  for (int i = vec.size() - 1; i >= 0; i--) {\n                    acc = f.apply(env3, FlatLists.of(vec.get(i), acc));\n                  }\n                  return acc;\n                }\n              };\n            }\n          };\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_FINDI =\n      new ApplicableImpl(BuiltIn.VECTOR_FINDI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorFindi((Applicable) arg);\n        }\n      };", "docstring": " @see BuiltIn#VECTOR_FINDI", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_FINDI =\n      new ApplicableImpl(BuiltIn.VECTOR_FINDI) {\n        @Override public Object apply(EvalEnv env, Object arg) {\n          return vectorFindi((Applicable) arg);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_FIND = find(BuiltIn.VECTOR_FIND);", "docstring": " @see BuiltIn#VECTOR_FIND", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_FIND = find(BuiltIn.VECTOR_FIND)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_EXISTS = exists(BuiltIn.VECTOR_EXISTS);", "docstring": " @see BuiltIn#VECTOR_EXISTS", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_EXISTS = exists(BuiltIn.VECTOR_EXISTS)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_ALL = all(BuiltIn.VECTOR_ALL);", "docstring": " @see BuiltIn#VECTOR_ALL", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_ALL = all(BuiltIn.VECTOR_ALL)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable VECTOR_COLLATE =\n      collate(BuiltIn.VECTOR_COLLATE);", "docstring": " @see BuiltIn#VECTOR_COLLATE", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "VECTOR_COLLATE =\n      collate(BuiltIn.VECTOR_COLLATE)", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_EXTENT =\n      new ApplicableImpl(BuiltIn.Z_EXTENT) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          final RangeExtent rangeExtent = (RangeExtent) arg;\n          if (rangeExtent.iterable == null) {\n            throw new AssertionError(\"infinite: \" + rangeExtent);\n          }\n          return ImmutableList.copyOf(rangeExtent.iterable);\n        }\n      };", "docstring": " @see BuiltIn#Z_EXTENT", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_EXTENT =\n      new ApplicableImpl(BuiltIn.Z_EXTENT) {\n        @Override public List apply(EvalEnv env, Object arg) {\n          final RangeExtent rangeExtent = (RangeExtent) arg;\n          if (rangeExtent.iterable == null) {\n            throw new AssertionError(\"infinite: \" + rangeExtent);\n          }\n          return ImmutableList.copyOf(rangeExtent.iterable);\n        }\n      }", "syntax_pass": true}, {"attribute_expression": "private static final Applicable Z_LIST = identity(BuiltIn.Z_LIST);", "docstring": " @see BuiltIn#Z_LIST", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Applicable", "name": "Z_LIST = identity(BuiltIn.Z_LIST)", "syntax_pass": true}, {"attribute_expression": "public static final ImmutableMap<BuiltIn, Object> BUILT_IN_VALUES =\n      ImmutableMap.<BuiltIn, Object>builder()\n          .put(BuiltIn.TRUE, true)\n          .put(BuiltIn.FALSE, false)\n          .put(BuiltIn.NOT, NOT)\n          .put(BuiltIn.ABS, ABS)\n          .put(BuiltIn.IGNORE, IGNORE)\n          .put(BuiltIn.GENERAL_OP_O, GENERAL_OP_O)\n          .put(BuiltIn.INT_ABS, INT_ABS)\n          .put(BuiltIn.INT_COMPARE, INT_COMPARE)\n          .put(BuiltIn.INT_DIV, INT_DIV)\n          .put(BuiltIn.INT_FROM_INT, INT_FROM_INT)\n          .put(BuiltIn.INT_FROM_LARGE, INT_FROM_LARGE)\n          .put(BuiltIn.INT_FROM_STRING, INT_FROM_STRING)\n          .put(BuiltIn.INT_MAX, INT_MAX)\n          .put(BuiltIn.INT_MAX_INT, INT_MAX_INT)\n          .put(BuiltIn.INT_MIN, INT_MIN)\n          .put(BuiltIn.INT_MIN_INT, INT_MIN_INT)\n          .put(BuiltIn.INT_MOD, INT_MOD)\n          .put(BuiltIn.INT_PRECISION, INT_PRECISION)\n          .put(BuiltIn.INT_QUOT, INT_QUOT)\n          .put(BuiltIn.INT_REM, INT_REM)\n          .put(BuiltIn.INT_SAME_SIGN, INT_SAME_SIGN)\n          .put(BuiltIn.INT_SIGN, INT_SIGN)\n          .put(BuiltIn.INT_TO_INT, INT_TO_INT)\n          .put(BuiltIn.INT_TO_LARGE, INT_TO_LARGE)\n          .put(BuiltIn.INT_TO_STRING, INT_TO_STRING)\n          .put(BuiltIn.INTERACT_USE, INTERACT_USE)\n          .put(BuiltIn.INTERACT_USE_SILENTLY, INTERACT_USE_SILENTLY)\n          .put(BuiltIn.OP_CARET, OP_CARET)\n          .put(BuiltIn.OP_CONS, OP_CONS)\n          .put(BuiltIn.OP_DIV, OP_DIV)\n          .put(BuiltIn.OP_DIVIDE, OP_DIVIDE)\n          .put(BuiltIn.OP_ELEM, OP_ELEM)\n          .put(BuiltIn.OP_EQ, OP_EQ)\n          .put(BuiltIn.OP_GE, OP_GE)\n          .put(BuiltIn.OP_GT, OP_GT)\n          .put(BuiltIn.OP_LE, OP_LE)\n          .put(BuiltIn.OP_LT, OP_LT)\n          .put(BuiltIn.OP_NE, OP_NE)\n          .put(BuiltIn.OP_MINUS, OP_MINUS)\n          .put(BuiltIn.OP_MOD, OP_MOD)\n          .put(BuiltIn.OP_NEGATE, OP_NEGATE)\n          .put(BuiltIn.OP_NOT_ELEM, OP_NOT_ELEM)\n          .put(BuiltIn.OP_PLUS, OP_PLUS)\n          .put(BuiltIn.OP_TIMES, OP_TIMES)\n          .put(BuiltIn.OP_EXCEPT, OP_EXCEPT)\n          .put(BuiltIn.OP_INTERSECT, OP_INTERSECT)\n          .put(BuiltIn.OP_UNION, OP_UNION)\n          .put(BuiltIn.STRING_MAX_SIZE, STRING_MAX_SIZE)\n          .put(BuiltIn.STRING_SIZE, STRING_SIZE)\n          .put(BuiltIn.STRING_SUB, STRING_SUB)\n          .put(BuiltIn.STRING_EXTRACT, STRING_EXTRACT)\n          .put(BuiltIn.STRING_SUBSTRING, STRING_SUBSTRING)\n          .put(BuiltIn.STRING_CONCAT, STRING_CONCAT)\n          .put(BuiltIn.STRING_CONCAT_WITH, STRING_CONCAT_WITH)\n          .put(BuiltIn.STRING_STR, STRING_STR)\n          .put(BuiltIn.STRING_IMPLODE, STRING_IMPLODE)\n          .put(BuiltIn.STRING_EXPLODE, STRING_EXPLODE)\n          .put(BuiltIn.STRING_MAP, STRING_MAP)\n          .put(BuiltIn.STRING_TRANSLATE, STRING_TRANSLATE)\n          .put(BuiltIn.STRING_IS_PREFIX, STRING_IS_PREFIX)\n          .put(BuiltIn.STRING_IS_SUBSTRING, STRING_IS_SUBSTRING)\n          .put(BuiltIn.STRING_IS_SUFFIX, STRING_IS_SUFFIX)\n          .put(BuiltIn.LIST_NIL, ImmutableList.of())\n          .put(BuiltIn.LIST_NULL, LIST_NULL)\n          .put(BuiltIn.LIST_LENGTH, LIST_LENGTH)\n          .put(BuiltIn.LIST_AT, LIST_AT)\n          .put(BuiltIn.LIST_OP_AT, LIST_AT) // op @ == List.at\n          .put(BuiltIn.LIST_HD, LIST_HD)\n          .put(BuiltIn.LIST_TL, LIST_TL)\n          .put(BuiltIn.LIST_LAST, LIST_LAST)\n          .put(BuiltIn.LIST_GET_ITEM, LIST_GET_ITEM)\n          .put(BuiltIn.LIST_NTH, LIST_NTH)\n          .put(BuiltIn.LIST_TAKE, LIST_TAKE)\n          .put(BuiltIn.LIST_DROP, LIST_DROP)\n          .put(BuiltIn.LIST_REV, LIST_REV)\n          .put(BuiltIn.LIST_CONCAT, LIST_CONCAT)\n          .put(BuiltIn.LIST_REV_APPEND, LIST_REV_APPEND)\n          .put(BuiltIn.LIST_APP, LIST_APP)\n          .put(BuiltIn.LIST_MAP, LIST_MAP)\n          .put(BuiltIn.LIST_MAP_PARTIAL, LIST_MAP_PARTIAL)\n          .put(BuiltIn.LIST_FIND, LIST_FIND)\n          .put(BuiltIn.LIST_FILTER, LIST_FILTER)\n          .put(BuiltIn.LIST_PARTITION, LIST_PARTITION)\n          .put(BuiltIn.LIST_FOLDL, LIST_FOLDL)\n          .put(BuiltIn.LIST_FOLDR, LIST_FOLDR)\n          .put(BuiltIn.LIST_EXISTS, LIST_EXISTS)\n          .put(BuiltIn.LIST_ALL, LIST_ALL)\n          .put(BuiltIn.LIST_TABULATE, LIST_TABULATE)\n          .put(BuiltIn.LIST_COLLATE, LIST_COLLATE)\n          .put(BuiltIn.MATH_ACOS, MATH_ACOS)\n          .put(BuiltIn.MATH_ASIN, MATH_ASIN)\n          .put(BuiltIn.MATH_ATAN, MATH_ATAN)\n          .put(BuiltIn.MATH_ATAN2, MATH_ATAN2)\n          .put(BuiltIn.MATH_COS, MATH_COS)\n          .put(BuiltIn.MATH_COSH, MATH_COSH)\n          .put(BuiltIn.MATH_E, MATH_E)\n          .put(BuiltIn.MATH_EXP, MATH_EXP)\n          .put(BuiltIn.MATH_LN, MATH_LN)\n          .put(BuiltIn.MATH_LOG10, MATH_LOG10)\n          .put(BuiltIn.MATH_PI, MATH_PI)\n          .put(BuiltIn.MATH_POW, MATH_POW)\n          .put(BuiltIn.MATH_SIN, MATH_SIN)\n          .put(BuiltIn.MATH_SINH, MATH_SINH)\n          .put(BuiltIn.MATH_SQRT, MATH_SQRT)\n          .put(BuiltIn.MATH_TAN, MATH_TAN)\n          .put(BuiltIn.MATH_TANH, MATH_TANH)\n          .put(BuiltIn.OPTION_APP, OPTION_APP)\n          .put(BuiltIn.OPTION_COMPOSE, OPTION_COMPOSE)\n          .put(BuiltIn.OPTION_COMPOSE_PARTIAL, OPTION_COMPOSE_PARTIAL)\n          .put(BuiltIn.OPTION_FILTER, OPTION_FILTER)\n          .put(BuiltIn.OPTION_GET_OPT, OPTION_GET_OPT)\n          .put(BuiltIn.OPTION_IS_SOME, OPTION_IS_SOME)\n          .put(BuiltIn.OPTION_JOIN, OPTION_JOIN)\n          .put(BuiltIn.OPTION_MAP, OPTION_MAP)\n          .put(BuiltIn.OPTION_MAP_PARTIAL, OPTION_MAP_PARTIAL)\n          .put(BuiltIn.OPTION_VAL_OF, OPTION_VAL_OF)\n          .put(BuiltIn.REAL_ABS, REAL_ABS)\n          .put(BuiltIn.REAL_CEIL, REAL_CEIL)\n          .put(BuiltIn.REAL_CHECK_FLOAT, REAL_CHECK_FLOAT)\n          .put(BuiltIn.REAL_COMPARE, REAL_COMPARE)\n          .put(BuiltIn.REAL_COPY_SIGN, REAL_COPY_SIGN)\n          .put(BuiltIn.REAL_FLOOR, REAL_FLOOR)\n          .put(BuiltIn.REAL_FROM_INT, REAL_FROM_INT)\n          .put(BuiltIn.REAL_FROM_MAN_EXP, REAL_FROM_MAN_EXP)\n          .put(BuiltIn.REAL_FROM_STRING, REAL_FROM_STRING)\n          .put(BuiltIn.REAL_IS_FINITE, REAL_IS_FINITE)\n          .put(BuiltIn.REAL_IS_NAN, REAL_IS_NAN)\n          .put(BuiltIn.REAL_IS_NORMAL, REAL_IS_NORMAL)\n          .put(BuiltIn.REAL_MAX, REAL_MAX)\n          .put(BuiltIn.REAL_MAX_FINITE, REAL_MAX_FINITE)\n          .put(BuiltIn.REAL_MIN, REAL_MIN)\n          .put(BuiltIn.REAL_MIN_POS, REAL_MIN_POS)\n          .put(BuiltIn.REAL_MIN_NORMAL_POS, REAL_MIN_NORMAL_POS)\n          .put(BuiltIn.REAL_NEG_INF, REAL_NEG_INF)\n          .put(BuiltIn.REAL_POS_INF, REAL_POS_INF)\n          .put(BuiltIn.REAL_PRECISION, REAL_PRECISION)\n          .put(BuiltIn.REAL_RADIX, REAL_RADIX)\n          .put(BuiltIn.REAL_REAL_MOD, REAL_REAL_MOD)\n          .put(BuiltIn.REAL_REAL_CEIL, REAL_REAL_CEIL)\n          .put(BuiltIn.REAL_REAL_FLOOR, REAL_REAL_FLOOR)\n          .put(BuiltIn.REAL_REAL_ROUND, REAL_REAL_ROUND)\n          .put(BuiltIn.REAL_REAL_TRUNC, REAL_REAL_TRUNC)\n          .put(BuiltIn.REAL_REM, REAL_REM)\n          .put(BuiltIn.REAL_ROUND, REAL_ROUND)\n          .put(BuiltIn.REAL_SAME_SIGN, REAL_SAME_SIGN)\n          .put(BuiltIn.REAL_SIGN, REAL_SIGN)\n          .put(BuiltIn.REAL_SIGN_BIT, REAL_SIGN_BIT)\n          .put(BuiltIn.REAL_SPLIT, REAL_SPLIT)\n          .put(BuiltIn.REAL_TO_MAN_EXP, REAL_TO_MAN_EXP)\n          .put(BuiltIn.REAL_TO_STRING, REAL_TO_STRING)\n          .put(BuiltIn.REAL_TRUNC, REAL_TRUNC)\n          .put(BuiltIn.REAL_UNORDERED, REAL_UNORDERED)\n          .put(BuiltIn.RELATIONAL_COUNT, RELATIONAL_COUNT)\n          .put(BuiltIn.RELATIONAL_EXISTS, RELATIONAL_EXISTS)\n          .put(BuiltIn.RELATIONAL_NOT_EXISTS, RELATIONAL_NOT_EXISTS)\n          .put(BuiltIn.RELATIONAL_ITERATE, RELATIONAL_ITERATE)\n          .put(BuiltIn.RELATIONAL_ONLY, RELATIONAL_ONLY)\n          .put(BuiltIn.RELATIONAL_MAX, RELATIONAL_MAX)\n          .put(BuiltIn.RELATIONAL_MIN, RELATIONAL_MIN)\n          .put(BuiltIn.RELATIONAL_SUM, RELATIONAL_SUM)\n          .put(BuiltIn.SYS_ENV, (Macro) Codes::sysEnv)\n          .put(BuiltIn.SYS_FILE, \"\") // value comes from Session.file\n          .put(BuiltIn.SYS_PLAN, SYS_PLAN)\n          .put(BuiltIn.SYS_SET, SYS_SET)\n          .put(BuiltIn.SYS_SHOW, SYS_SHOW)\n          .put(BuiltIn.SYS_UNSET, SYS_UNSET)\n          .put(BuiltIn.VECTOR_MAX_LEN, VECTOR_MAX_LEN)\n          .put(BuiltIn.VECTOR_FROM_LIST, VECTOR_FROM_LIST)\n          .put(BuiltIn.VECTOR_TABULATE, VECTOR_TABULATE)\n          .put(BuiltIn.VECTOR_LENGTH, VECTOR_LENGTH)\n          .put(BuiltIn.VECTOR_SUB, VECTOR_SUB)\n          .put(BuiltIn.VECTOR_UPDATE, VECTOR_UPDATE)\n          .put(BuiltIn.VECTOR_CONCAT, VECTOR_CONCAT)\n          .put(BuiltIn.VECTOR_APPI, VECTOR_APPI)\n          .put(BuiltIn.VECTOR_APP, VECTOR_APP)\n          .put(BuiltIn.VECTOR_MAPI, VECTOR_MAPI)\n          .put(BuiltIn.VECTOR_MAP, VECTOR_MAP)\n          .put(BuiltIn.VECTOR_FOLDLI, VECTOR_FOLDLI)\n          .put(BuiltIn.VECTOR_FOLDRI, VECTOR_FOLDRI)\n          .put(BuiltIn.VECTOR_FOLDL, VECTOR_FOLDL)\n          .put(BuiltIn.VECTOR_FOLDR, VECTOR_FOLDR)\n          .put(BuiltIn.VECTOR_FINDI, VECTOR_FINDI)\n          .put(BuiltIn.VECTOR_FIND, VECTOR_FIND)\n          .put(BuiltIn.VECTOR_EXISTS, VECTOR_EXISTS)\n          .put(BuiltIn.VECTOR_ALL, VECTOR_ALL)\n          .put(BuiltIn.VECTOR_COLLATE, VECTOR_COLLATE)\n          .put(BuiltIn.Z_ANDALSO, Unit.INSTANCE)\n          .put(BuiltIn.Z_ORELSE, Unit.INSTANCE)\n          .put(BuiltIn.Z_NEGATE_INT, Z_NEGATE_INT)\n          .put(BuiltIn.Z_NEGATE_REAL, Z_NEGATE_REAL)\n          .put(BuiltIn.Z_DIVIDE_INT, Z_DIVIDE_INT)\n          .put(BuiltIn.Z_DIVIDE_REAL, Z_DIVIDE_REAL)\n          .put(BuiltIn.Z_PLUS_INT, Z_PLUS_INT)\n          .put(BuiltIn.Z_PLUS_REAL, Z_PLUS_REAL)\n          .put(BuiltIn.Z_MINUS_INT, Z_MINUS_INT)\n          .put(BuiltIn.Z_MINUS_REAL, Z_MINUS_REAL)\n          .put(BuiltIn.Z_TIMES_INT, Z_TIMES_INT)\n          .put(BuiltIn.Z_TIMES_REAL, Z_TIMES_REAL)\n          .put(BuiltIn.Z_SUM_INT, Z_SUM_INT)\n          .put(BuiltIn.Z_SUM_REAL, Z_SUM_REAL)\n          .put(BuiltIn.Z_EXTENT, Z_EXTENT)\n          .put(BuiltIn.Z_LIST, Z_LIST)\n          .build();", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "ImmutableMap<BuiltIn, Object>", "name": "BUILT_IN_VALUES =\n      ImmutableMap.<BuiltIn, Object>builder()\n          .put(BuiltIn.TRUE, true)\n          .put(BuiltIn.FALSE, false)\n          .put(BuiltIn.NOT, NOT)\n          .put(BuiltIn.ABS, ABS)\n          .put(BuiltIn.IGNORE, IGNORE)\n          .put(BuiltIn.GENERAL_OP_O, GENERAL_OP_O)\n          .put(BuiltIn.INT_ABS, INT_ABS)\n          .put(BuiltIn.INT_COMPARE, INT_COMPARE)\n          .put(BuiltIn.INT_DIV, INT_DIV)\n          .put(BuiltIn.INT_FROM_INT, INT_FROM_INT)\n          .put(BuiltIn.INT_FROM_LARGE, INT_FROM_LARGE)\n          .put(BuiltIn.INT_FROM_STRING, INT_FROM_STRING)\n          .put(BuiltIn.INT_MAX, INT_MAX)\n          .put(BuiltIn.INT_MAX_INT, INT_MAX_INT)\n          .put(BuiltIn.INT_MIN, INT_MIN)\n          .put(BuiltIn.INT_MIN_INT, INT_MIN_INT)\n          .put(BuiltIn.INT_MOD, INT_MOD)\n          .put(BuiltIn.INT_PRECISION, INT_PRECISION)\n          .put(BuiltIn.INT_QUOT, INT_QUOT)\n          .put(BuiltIn.INT_REM, INT_REM)\n          .put(BuiltIn.INT_SAME_SIGN, INT_SAME_SIGN)\n          .put(BuiltIn.INT_SIGN, INT_SIGN)\n          .put(BuiltIn.INT_TO_INT, INT_TO_INT)\n          .put(BuiltIn.INT_TO_LARGE, INT_TO_LARGE)\n          .put(BuiltIn.INT_TO_STRING, INT_TO_STRING)\n          .put(BuiltIn.INTERACT_USE, INTERACT_USE)\n          .put(BuiltIn.INTERACT_USE_SILENTLY, INTERACT_USE_SILENTLY)\n          .put(BuiltIn.OP_CARET, OP_CARET)\n          .put(BuiltIn.OP_CONS, OP_CONS)\n          .put(BuiltIn.OP_DIV, OP_DIV)\n          .put(BuiltIn.OP_DIVIDE, OP_DIVIDE)\n          .put(BuiltIn.OP_ELEM, OP_ELEM)\n          .put(BuiltIn.OP_EQ, OP_EQ)\n          .put(BuiltIn.OP_GE, OP_GE)\n          .put(BuiltIn.OP_GT, OP_GT)\n          .put(BuiltIn.OP_LE, OP_LE)\n          .put(BuiltIn.OP_LT, OP_LT)\n          .put(BuiltIn.OP_NE, OP_NE)\n          .put(BuiltIn.OP_MINUS, OP_MINUS)\n          .put(BuiltIn.OP_MOD, OP_MOD)\n          .put(BuiltIn.OP_NEGATE, OP_NEGATE)\n          .put(BuiltIn.OP_NOT_ELEM, OP_NOT_ELEM)\n          .put(BuiltIn.OP_PLUS, OP_PLUS)\n          .put(BuiltIn.OP_TIMES, OP_TIMES)\n          .put(BuiltIn.OP_EXCEPT, OP_EXCEPT)\n          .put(BuiltIn.OP_INTERSECT, OP_INTERSECT)\n          .put(BuiltIn.OP_UNION, OP_UNION)\n          .put(BuiltIn.STRING_MAX_SIZE, STRING_MAX_SIZE)\n          .put(BuiltIn.STRING_SIZE, STRING_SIZE)\n          .put(BuiltIn.STRING_SUB, STRING_SUB)\n          .put(BuiltIn.STRING_EXTRACT, STRING_EXTRACT)\n          .put(BuiltIn.STRING_SUBSTRING, STRING_SUBSTRING)\n          .put(BuiltIn.STRING_CONCAT, STRING_CONCAT)\n          .put(BuiltIn.STRING_CONCAT_WITH, STRING_CONCAT_WITH)\n          .put(BuiltIn.STRING_STR, STRING_STR)\n          .put(BuiltIn.STRING_IMPLODE, STRING_IMPLODE)\n          .put(BuiltIn.STRING_EXPLODE, STRING_EXPLODE)\n          .put(BuiltIn.STRING_MAP, STRING_MAP)\n          .put(BuiltIn.STRING_TRANSLATE, STRING_TRANSLATE)\n          .put(BuiltIn.STRING_IS_PREFIX, STRING_IS_PREFIX)\n          .put(BuiltIn.STRING_IS_SUBSTRING, STRING_IS_SUBSTRING)\n          .put(BuiltIn.STRING_IS_SUFFIX, STRING_IS_SUFFIX)\n          .put(BuiltIn.LIST_NIL, ImmutableList.of())\n          .put(BuiltIn.LIST_NULL, LIST_NULL)\n          .put(BuiltIn.LIST_LENGTH, LIST_LENGTH)\n          .put(BuiltIn.LIST_AT, LIST_AT)\n          .put(BuiltIn.LIST_OP_AT, LIST_AT) // op @ == List.at\n          .put(BuiltIn.LIST_HD, LIST_HD)\n          .put(BuiltIn.LIST_TL, LIST_TL)\n          .put(BuiltIn.LIST_LAST, LIST_LAST)\n          .put(BuiltIn.LIST_GET_ITEM, LIST_GET_ITEM)\n          .put(BuiltIn.LIST_NTH, LIST_NTH)\n          .put(BuiltIn.LIST_TAKE, LIST_TAKE)\n          .put(BuiltIn.LIST_DROP, LIST_DROP)\n          .put(BuiltIn.LIST_REV, LIST_REV)\n          .put(BuiltIn.LIST_CONCAT, LIST_CONCAT)\n          .put(BuiltIn.LIST_REV_APPEND, LIST_REV_APPEND)\n          .put(BuiltIn.LIST_APP, LIST_APP)\n          .put(BuiltIn.LIST_MAP, LIST_MAP)\n          .put(BuiltIn.LIST_MAP_PARTIAL, LIST_MAP_PARTIAL)\n          .put(BuiltIn.LIST_FIND, LIST_FIND)\n          .put(BuiltIn.LIST_FILTER, LIST_FILTER)\n          .put(BuiltIn.LIST_PARTITION, LIST_PARTITION)\n          .put(BuiltIn.LIST_FOLDL, LIST_FOLDL)\n          .put(BuiltIn.LIST_FOLDR, LIST_FOLDR)\n          .put(BuiltIn.LIST_EXISTS, LIST_EXISTS)\n          .put(BuiltIn.LIST_ALL, LIST_ALL)\n          .put(BuiltIn.LIST_TABULATE, LIST_TABULATE)\n          .put(BuiltIn.LIST_COLLATE, LIST_COLLATE)\n          .put(BuiltIn.MATH_ACOS, MATH_ACOS)\n          .put(BuiltIn.MATH_ASIN, MATH_ASIN)\n          .put(BuiltIn.MATH_ATAN, MATH_ATAN)\n          .put(BuiltIn.MATH_ATAN2, MATH_ATAN2)\n          .put(BuiltIn.MATH_COS, MATH_COS)\n          .put(BuiltIn.MATH_COSH, MATH_COSH)\n          .put(BuiltIn.MATH_E, MATH_E)\n          .put(BuiltIn.MATH_EXP, MATH_EXP)\n          .put(BuiltIn.MATH_LN, MATH_LN)\n          .put(BuiltIn.MATH_LOG10, MATH_LOG10)\n          .put(BuiltIn.MATH_PI, MATH_PI)\n          .put(BuiltIn.MATH_POW, MATH_POW)\n          .put(BuiltIn.MATH_SIN, MATH_SIN)\n          .put(BuiltIn.MATH_SINH, MATH_SINH)\n          .put(BuiltIn.MATH_SQRT, MATH_SQRT)\n          .put(BuiltIn.MATH_TAN, MATH_TAN)\n          .put(BuiltIn.MATH_TANH, MATH_TANH)\n          .put(BuiltIn.OPTION_APP, OPTION_APP)\n          .put(BuiltIn.OPTION_COMPOSE, OPTION_COMPOSE)\n          .put(BuiltIn.OPTION_COMPOSE_PARTIAL, OPTION_COMPOSE_PARTIAL)\n          .put(BuiltIn.OPTION_FILTER, OPTION_FILTER)\n          .put(BuiltIn.OPTION_GET_OPT, OPTION_GET_OPT)\n          .put(BuiltIn.OPTION_IS_SOME, OPTION_IS_SOME)\n          .put(BuiltIn.OPTION_JOIN, OPTION_JOIN)\n          .put(BuiltIn.OPTION_MAP, OPTION_MAP)\n          .put(BuiltIn.OPTION_MAP_PARTIAL, OPTION_MAP_PARTIAL)\n          .put(BuiltIn.OPTION_VAL_OF, OPTION_VAL_OF)\n          .put(BuiltIn.REAL_ABS, REAL_ABS)\n          .put(BuiltIn.REAL_CEIL, REAL_CEIL)\n          .put(BuiltIn.REAL_CHECK_FLOAT, REAL_CHECK_FLOAT)\n          .put(BuiltIn.REAL_COMPARE, REAL_COMPARE)\n          .put(BuiltIn.REAL_COPY_SIGN, REAL_COPY_SIGN)\n          .put(BuiltIn.REAL_FLOOR, REAL_FLOOR)\n          .put(BuiltIn.REAL_FROM_INT, REAL_FROM_INT)\n          .put(BuiltIn.REAL_FROM_MAN_EXP, REAL_FROM_MAN_EXP)\n          .put(BuiltIn.REAL_FROM_STRING, REAL_FROM_STRING)\n          .put(BuiltIn.REAL_IS_FINITE, REAL_IS_FINITE)\n          .put(BuiltIn.REAL_IS_NAN, REAL_IS_NAN)\n          .put(BuiltIn.REAL_IS_NORMAL, REAL_IS_NORMAL)\n          .put(BuiltIn.REAL_MAX, REAL_MAX)\n          .put(BuiltIn.REAL_MAX_FINITE, REAL_MAX_FINITE)\n          .put(BuiltIn.REAL_MIN, REAL_MIN)\n          .put(BuiltIn.REAL_MIN_POS, REAL_MIN_POS)\n          .put(BuiltIn.REAL_MIN_NORMAL_POS, REAL_MIN_NORMAL_POS)\n          .put(BuiltIn.REAL_NEG_INF, REAL_NEG_INF)\n          .put(BuiltIn.REAL_POS_INF, REAL_POS_INF)\n          .put(BuiltIn.REAL_PRECISION, REAL_PRECISION)\n          .put(BuiltIn.REAL_RADIX, REAL_RADIX)\n          .put(BuiltIn.REAL_REAL_MOD, REAL_REAL_MOD)\n          .put(BuiltIn.REAL_REAL_CEIL, REAL_REAL_CEIL)\n          .put(BuiltIn.REAL_REAL_FLOOR, REAL_REAL_FLOOR)\n          .put(BuiltIn.REAL_REAL_ROUND, REAL_REAL_ROUND)\n          .put(BuiltIn.REAL_REAL_TRUNC, REAL_REAL_TRUNC)\n          .put(BuiltIn.REAL_REM, REAL_REM)\n          .put(BuiltIn.REAL_ROUND, REAL_ROUND)\n          .put(BuiltIn.REAL_SAME_SIGN, REAL_SAME_SIGN)\n          .put(BuiltIn.REAL_SIGN, REAL_SIGN)\n          .put(BuiltIn.REAL_SIGN_BIT, REAL_SIGN_BIT)\n          .put(BuiltIn.REAL_SPLIT, REAL_SPLIT)\n          .put(BuiltIn.REAL_TO_MAN_EXP, REAL_TO_MAN_EXP)\n          .put(BuiltIn.REAL_TO_STRING, REAL_TO_STRING)\n          .put(BuiltIn.REAL_TRUNC, REAL_TRUNC)\n          .put(BuiltIn.REAL_UNORDERED, REAL_UNORDERED)\n          .put(BuiltIn.RELATIONAL_COUNT, RELATIONAL_COUNT)\n          .put(BuiltIn.RELATIONAL_EXISTS, RELATIONAL_EXISTS)\n          .put(BuiltIn.RELATIONAL_NOT_EXISTS, RELATIONAL_NOT_EXISTS)\n          .put(BuiltIn.RELATIONAL_ITERATE, RELATIONAL_ITERATE)\n          .put(BuiltIn.RELATIONAL_ONLY, RELATIONAL_ONLY)\n          .put(BuiltIn.RELATIONAL_MAX, RELATIONAL_MAX)\n          .put(BuiltIn.RELATIONAL_MIN, RELATIONAL_MIN)\n          .put(BuiltIn.RELATIONAL_SUM, RELATIONAL_SUM)\n          .put(BuiltIn.SYS_ENV, (Macro) Codes::sysEnv)\n          .put(BuiltIn.SYS_FILE, \"\") // value comes from Session.file\n          .put(BuiltIn.SYS_PLAN, SYS_PLAN)\n          .put(BuiltIn.SYS_SET, SYS_SET)\n          .put(BuiltIn.SYS_SHOW, SYS_SHOW)\n          .put(BuiltIn.SYS_UNSET, SYS_UNSET)\n          .put(BuiltIn.VECTOR_MAX_LEN, VECTOR_MAX_LEN)\n          .put(BuiltIn.VECTOR_FROM_LIST, VECTOR_FROM_LIST)\n          .put(BuiltIn.VECTOR_TABULATE, VECTOR_TABULATE)\n          .put(BuiltIn.VECTOR_LENGTH, VECTOR_LENGTH)\n          .put(BuiltIn.VECTOR_SUB, VECTOR_SUB)\n          .put(BuiltIn.VECTOR_UPDATE, VECTOR_UPDATE)\n          .put(BuiltIn.VECTOR_CONCAT, VECTOR_CONCAT)\n          .put(BuiltIn.VECTOR_APPI, VECTOR_APPI)\n          .put(BuiltIn.VECTOR_APP, VECTOR_APP)\n          .put(BuiltIn.VECTOR_MAPI, VECTOR_MAPI)\n          .put(BuiltIn.VECTOR_MAP, VECTOR_MAP)\n          .put(BuiltIn.VECTOR_FOLDLI, VECTOR_FOLDLI)\n          .put(BuiltIn.VECTOR_FOLDRI, VECTOR_FOLDRI)\n          .put(BuiltIn.VECTOR_FOLDL, VECTOR_FOLDL)\n          .put(BuiltIn.VECTOR_FOLDR, VECTOR_FOLDR)\n          .put(BuiltIn.VECTOR_FINDI, VECTOR_FINDI)\n          .put(BuiltIn.VECTOR_FIND, VECTOR_FIND)\n          .put(BuiltIn.VECTOR_EXISTS, VECTOR_EXISTS)\n          .put(BuiltIn.VECTOR_ALL, VECTOR_ALL)\n          .put(BuiltIn.VECTOR_COLLATE, VECTOR_COLLATE)\n          .put(BuiltIn.Z_ANDALSO, Unit.INSTANCE)\n          .put(BuiltIn.Z_ORELSE, Unit.INSTANCE)\n          .put(BuiltIn.Z_NEGATE_INT, Z_NEGATE_INT)\n          .put(BuiltIn.Z_NEGATE_REAL, Z_NEGATE_REAL)\n          .put(BuiltIn.Z_DIVIDE_INT, Z_DIVIDE_INT)\n          .put(BuiltIn.Z_DIVIDE_REAL, Z_DIVIDE_REAL)\n          .put(BuiltIn.Z_PLUS_INT, Z_PLUS_INT)\n          .put(BuiltIn.Z_PLUS_REAL, Z_PLUS_REAL)\n          .put(BuiltIn.Z_MINUS_INT, Z_MINUS_INT)\n          .put(BuiltIn.Z_MINUS_REAL, Z_MINUS_REAL)\n          .put(BuiltIn.Z_TIMES_INT, Z_TIMES_INT)\n          .put(BuiltIn.Z_TIMES_REAL, Z_TIMES_REAL)\n          .put(BuiltIn.Z_SUM_INT, Z_SUM_INT)\n          .put(BuiltIn.Z_SUM_REAL, Z_SUM_REAL)\n          .put(BuiltIn.Z_EXTENT, Z_EXTENT)\n          .put(BuiltIn.Z_LIST, Z_LIST)\n          .build()", "syntax_pass": true}, {"attribute_expression": "public static final Map<Applicable, BuiltIn> BUILT_IN_MAP =\n      ((Supplier<Map<Applicable, BuiltIn>>) Codes::get).get();", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Map<Applicable, BuiltIn>", "name": "BUILT_IN_MAP =\n      ((Supplier<Map<Applicable, BuiltIn>>) Codes::get).get()", "syntax_pass": true}, {"attribute_expression": "private static final EvalEnv EMPTY_ENV =\n      ((Supplier<EvalEnv>) Codes::makeEmptyEnv).get();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "EvalEnv", "name": "EMPTY_ENV =\n      ((Supplier<EvalEnv>) Codes::makeEmptyEnv).get()", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle", "name": "EnvShuttle", "file_path": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java", "superclasses": "Shuttle", "methods": ["[]EnvShuttle(TypeSystem,Environment)", "[EnvShuttle]push(Environment)", "[EnvShuttle]bind(Binding)", "[EnvShuttle]bind(List<Binding>)", "[Core.Fn]visit(Core.Fn)", "[Core.Match]visit(Core.Match)", "[Core.Exp]visit(Core.Let)", "[Core.Exp]visit(Core.Local)", "[Core.RecValDecl]visit(Core.RecValDecl)", "[Core.Exp]visit(Core.From)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[]EnvShuttle(TypeSystem,Environment)", "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[EnvShuttle]push(Environment)", "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[EnvShuttle]bind(Binding)", "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[EnvShuttle]bind(List<Binding>)", "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.Fn]visit(Core.Fn)", "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.Match]visit(Core.Match)", "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.Exp]visit(Core.Let)", "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.Exp]visit(Core.Local)", "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.RecValDecl]visit(Core.RecValDecl)", "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.Exp]visit(Core.From)"], "overrides": null, "attributes": [], "class_docstring": "\nShuttle that keeps an environment of what variables are in scope.\n", "original_string": "abstract class EnvShuttle extends Shuttle {\n  final Environment env;\n\n  /** Creates an EnvShuttle. */\n  protected EnvShuttle(TypeSystem typeSystem, Environment env) {\n    super(typeSystem);\n    this.env = env;\n  }\n\n  /** Creates a shuttle the same as this but with a new environment. */\n  protected abstract EnvShuttle push(Environment env);\n\n  /** Creates a shuttle the same as this but overriding a binding. */\n  protected EnvShuttle bind(Binding binding) {\n    return push(env.bind(binding));\n  }\n\n  /** Creates a shuttle the same as this but with overriding bindings. */\n  protected EnvShuttle bind(List<Binding> bindingList) {\n    // The \"env2 != env\" check is an optimization. If you remove it, this method\n    // will have the same effect, just slower.\n    final Environment env2 = env.bindAll(bindingList);\n    if (env2 == env) {\n      return this;\n    }\n    return push(env2);\n  }\n\n  @Override protected Core.Fn visit(Core.Fn fn) {\n    final Core.IdPat idPat2 = fn.idPat.accept(this);\n    final Binding binding = Binding.of(fn.idPat);\n    return fn.copy(idPat2, fn.exp.accept(bind(binding)));\n  }\n\n  @Override protected Core.Match visit(Core.Match match) {\n    final List<Binding> bindings = new ArrayList<>();\n    final Core.Pat pat2 = match.pat.accept(this);\n    Compiles.bindPattern(typeSystem, bindings, pat2);\n    return core.match(match.pos, pat2, match.exp.accept(bind(bindings)));\n  }\n\n  @Override protected Core.Exp visit(Core.Let let) {\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.bindPattern(typeSystem, bindings, let.decl);\n    return let.copy(let.decl.accept(this), let.exp.accept(bind(bindings)));\n  }\n\n  @Override protected Core.Exp visit(Core.Local local) {\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.bindDataType(typeSystem, bindings, local.dataType);\n    return local.copy(local.dataType, local.exp.accept(bind(bindings)));\n  }\n\n  @Override protected Core.RecValDecl visit(Core.RecValDecl recValDecl) {\n    final List<Binding> bindings = new ArrayList<>();\n    recValDecl.list.forEach(decl ->\n        Compiles.bindPattern(typeSystem, bindings, decl.pat));\n    return recValDecl.copy(bind(bindings).visitList(recValDecl.list));\n  }\n\n  @Override protected Core.Exp visit(Core.From from) {\n    List<Binding> bindings = ImmutableList.of();\n    final List<Core.FromStep> steps = new ArrayList<>();\n    for (Core.FromStep step : from.steps) {\n      final Core.FromStep step2 = step.accept(bind(bindings));\n      steps.add(step2);\n      bindings = step2.bindings;\n    }\n\n    return from.copy(typeSystem, env, steps);\n  }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final Environment env;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Environment", "name": "env", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers", "name": "Tracers", "file_path": "src/main/java/net/hydromatic/morel/compile/Tracers.java", "superclasses": "", "methods": ["[Tracer]empty()", "[Tracer]withOnCore(Tracer,int,Consumer<Core.Decl>)", "[Tracer]withOnPlan(Tracer,Consumer<Code>)", "[Tracer]withOnResult(Tracer,Consumer<Object>)", "[Tracer]withOnWarnings(Tracer,Consumer<List<Throwable>>)", "[Tracer]withOnException(Tracer,Consumer<@Nullable Throwable>)", "[Tracer]withOnCompileException(Tracer,Consumer<CompileException>)", "[Tracer]withOnTypeException(Tracer,Consumer<TypeResolver.TypeException>)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]empty()", "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnCore(Tracer,int,Consumer<Core.Decl>)", "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnPlan(Tracer,Consumer<Code>)", "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnResult(Tracer,Consumer<Object>)", "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnWarnings(Tracer,Consumer<List<Throwable>>)", "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnException(Tracer,Consumer<@Nullable Throwable>)", "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnCompileException(Tracer,Consumer<CompileException>)", "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnTypeException(Tracer,Consumer<TypeResolver.TypeException>)"], "overrides": null, "attributes": [{"original_string": "  private static class EmptyTracer implements Tracer {\n    static final Tracer INSTANCE = new EmptyTracer();\n\n    @Override public void onCore(int pass, Core.Decl e) {\n    }\n\n    @Override public void onPlan(Code code) {\n    }\n\n    @Override public void onResult(Object o) {\n    }\n\n    @Override public void onWarnings(List<Throwable> warningList) {\n    }\n\n    @Override public boolean onTypeException(TypeResolver.TypeException e) {\n      return false;\n    }\n\n    @Override public boolean onException(@Nullable Throwable e) {\n      return false;\n    }\n\n    @Override public boolean handleCompileException(\n        @Nullable CompileException e) {\n      return false;\n    }\n  }", "definition": "  private static class EmptyTracer implements Tracer", "class_docstring": " Tracer that does nothing.", "name": "EmptyTracer", "super_interfaces": ["Tracer"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "static final Tracer INSTANCE = new EmptyTracer();", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Tracer", "name": "INSTANCE = new EmptyTracer()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override public void onCore(int pass, Core.Decl e) {\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onCore", "params": [{"name": "pass", "type": "int"}, {"name": "e", "type": "Core.Decl"}], "body": "                                                        {\n    }", "signature": "@Override public void onCore(int pass, Core.Decl e)"}, {"syntax_pass": true, "original_string": "    @Override public void onPlan(Code code) {\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onPlan", "params": [{"name": "code", "type": "Code"}], "body": "                                            {\n    }", "signature": "@Override public void onPlan(Code code)"}, {"syntax_pass": true, "original_string": "    @Override public void onResult(Object o) {\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onResult", "params": [{"name": "o", "type": "Object"}], "body": "                                             {\n    }", "signature": "@Override public void onResult(Object o)"}, {"syntax_pass": true, "original_string": "    @Override public void onWarnings(List<Throwable> warningList) {\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onWarnings", "params": [{"name": "warningList", "type": "List<Throwable>"}], "body": "                                                                  {\n    }", "signature": "@Override public void onWarnings(List<Throwable> warningList)"}, {"syntax_pass": true, "original_string": "    @Override public boolean onTypeException(TypeResolver.TypeException e) {\n      return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "onTypeException", "params": [{"name": "e", "type": "TypeResolver.TypeException"}], "body": "                                                                           {\n      return false;\n    }", "signature": "@Override public boolean onTypeException(TypeResolver.TypeException e)"}, {"syntax_pass": true, "original_string": "    @Override public boolean onException(@Nullable Throwable e) {\n      return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "onException", "params": [{"name": "e", "type": "Throwable"}], "body": "                                                                {\n      return false;\n    }", "signature": "@Override public boolean onException(@Nullable Throwable e)"}, {"syntax_pass": true, "original_string": "    @Override public boolean handleCompileException(\n        @Nullable CompileException e) {\n      return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "handleCompileException", "params": [{"name": "e", "type": "CompileException"}], "body": "                                      {\n      return false;\n    }", "signature": "@Override public boolean handleCompileException(\n        @Nullable CompileException e)"}]}, {"original_string": "  private static class DelegatingTracer implements Tracer {\n    final Tracer tracer;\n\n    DelegatingTracer(Tracer tracer) {\n      this.tracer = tracer;\n    }\n\n    @Override public void onCore(int pass, Core.Decl e) {\n      tracer.onCore(pass, e);\n    }\n\n    @Override public void onPlan(Code code) {\n      tracer.onPlan(code);\n    }\n\n    @Override public void onResult(Object o) {\n      tracer.onResult(o);\n    }\n\n    @Override public void onWarnings(List<Throwable> warningList) {\n      tracer.onWarnings(warningList);\n    }\n\n    @Override public boolean onException(@Nullable Throwable e) {\n      return tracer.onException(e);\n    }\n\n    @Override public boolean onTypeException(TypeResolver.TypeException e) {\n      return tracer.onTypeException(e);\n    }\n\n    @Override public boolean handleCompileException(\n        @Nullable CompileException e) {\n      return tracer.handleCompileException(e);\n    }\n  }", "definition": "  private static class DelegatingTracer implements Tracer", "class_docstring": " Tracer that delegates to an underlying tracer.", "name": "DelegatingTracer", "super_interfaces": ["Tracer"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Tracer tracer;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Tracer", "name": "tracer", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    DelegatingTracer(Tracer tracer) {\n      this.tracer = tracer;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DelegatingTracer", "params": [{"name": "tracer", "type": "Tracer"}], "body": "                                    {\n      this.tracer = tracer;\n    }", "signature": "DelegatingTracer(Tracer tracer)"}, {"syntax_pass": true, "original_string": "    @Override public void onCore(int pass, Core.Decl e) {\n      tracer.onCore(pass, e);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onCore", "params": [{"name": "pass", "type": "int"}, {"name": "e", "type": "Core.Decl"}], "body": "                                                        {\n      tracer.onCore(pass, e);\n    }", "signature": "@Override public void onCore(int pass, Core.Decl e)"}, {"syntax_pass": true, "original_string": "    @Override public void onPlan(Code code) {\n      tracer.onPlan(code);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onPlan", "params": [{"name": "code", "type": "Code"}], "body": "                                            {\n      tracer.onPlan(code);\n    }", "signature": "@Override public void onPlan(Code code)"}, {"syntax_pass": true, "original_string": "    @Override public void onResult(Object o) {\n      tracer.onResult(o);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onResult", "params": [{"name": "o", "type": "Object"}], "body": "                                             {\n      tracer.onResult(o);\n    }", "signature": "@Override public void onResult(Object o)"}, {"syntax_pass": true, "original_string": "    @Override public void onWarnings(List<Throwable> warningList) {\n      tracer.onWarnings(warningList);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onWarnings", "params": [{"name": "warningList", "type": "List<Throwable>"}], "body": "                                                                  {\n      tracer.onWarnings(warningList);\n    }", "signature": "@Override public void onWarnings(List<Throwable> warningList)"}, {"syntax_pass": true, "original_string": "    @Override public boolean onException(@Nullable Throwable e) {\n      return tracer.onException(e);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "onException", "params": [{"name": "e", "type": "Throwable"}], "body": "                                                                {\n      return tracer.onException(e);\n    }", "signature": "@Override public boolean onException(@Nullable Throwable e)"}, {"syntax_pass": true, "original_string": "    @Override public boolean onTypeException(TypeResolver.TypeException e) {\n      return tracer.onTypeException(e);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "onTypeException", "params": [{"name": "e", "type": "TypeResolver.TypeException"}], "body": "                                                                           {\n      return tracer.onTypeException(e);\n    }", "signature": "@Override public boolean onTypeException(TypeResolver.TypeException e)"}, {"syntax_pass": true, "original_string": "    @Override public boolean handleCompileException(\n        @Nullable CompileException e) {\n      return tracer.handleCompileException(e);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "handleCompileException", "params": [{"name": "e", "type": "CompileException"}], "body": "                                      {\n      return tracer.handleCompileException(e);\n    }", "signature": "@Override public boolean handleCompileException(\n        @Nullable CompileException e)"}]}], "class_docstring": " Utilities for {@link Tracer}.", "original_string": "public abstract class Tracers {\n\n  /** Returns a tracer that does nothing. */\n  public static Tracer empty() {\n    return EmptyTracer.INSTANCE;\n  }\n\n  /** Returns a tracer that performs the given action on a declaration,\n   * then calls the underlying tracer. */\n  public static Tracer withOnCore(Tracer tracer, int pass,\n      Consumer<Core.Decl> consumer) {\n    final int expectedPass = pass;\n    return new DelegatingTracer(tracer) {\n      @Override public void onCore(int pass, Core.Decl e) {\n        if (pass == expectedPass) {\n          consumer.accept(e);\n        }\n        super.onCore(pass, e);\n      }\n    };\n  }\n\n  /** Returns a tracer that performs the given action on code,\n   * then calls the underlying tracer. */\n  public static Tracer withOnPlan(Tracer tracer, Consumer<Code> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public void onPlan(Code code) {\n        consumer.accept(code);\n        super.onPlan(code);\n      }\n    };\n  }\n\n  /** Returns a tracer that performs the given action on the result of an\n   * evaluation, then calls the underlying tracer. */\n  public static Tracer withOnResult(Tracer tracer, Consumer<Object> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public void onResult(Object o) {\n        consumer.accept(o);\n        super.onResult(o);\n      }\n    };\n  }\n\n  public static Tracer withOnWarnings(Tracer tracer,\n      Consumer<List<Throwable>> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public void onWarnings(List<Throwable> warningList) {\n        consumer.accept(warningList);\n        super.onWarnings(warningList);\n      }\n    };\n  }\n\n  public static Tracer withOnException(Tracer tracer,\n      Consumer<@Nullable Throwable> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public boolean onException(@Nullable Throwable e) {\n        consumer.accept(e);\n        super.onException(e);\n        return true;\n      }\n    };\n  }\n\n  public static Tracer withOnCompileException(Tracer tracer,\n      Consumer<CompileException> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public boolean handleCompileException(\n          @Nullable CompileException e) {\n        consumer.accept(e);\n        super.handleCompileException(e);\n        return true;\n      }\n    };\n  }\n\n  public static Tracer withOnTypeException(Tracer tracer,\n      Consumer<TypeResolver.TypeException> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public boolean onTypeException(TypeResolver.TypeException e) {\n        consumer.accept(e);\n        super.onTypeException(e);\n        return true;\n      }\n    };\n  }\n\n  /** Tracer that does nothing. */\n  private static class EmptyTracer implements Tracer {\n    static final Tracer INSTANCE = new EmptyTracer();\n\n    @Override public void onCore(int pass, Core.Decl e) {\n    }\n\n    @Override public void onPlan(Code code) {\n    }\n\n    @Override public void onResult(Object o) {\n    }\n\n    @Override public void onWarnings(List<Throwable> warningList) {\n    }\n\n    @Override public boolean onTypeException(TypeResolver.TypeException e) {\n      return false;\n    }\n\n    @Override public boolean onException(@Nullable Throwable e) {\n      return false;\n    }\n\n    @Override public boolean handleCompileException(\n        @Nullable CompileException e) {\n      return false;\n    }\n  }\n\n  /** Tracer that delegates to an underlying tracer. */\n  private static class DelegatingTracer implements Tracer {\n    final Tracer tracer;\n\n    DelegatingTracer(Tracer tracer) {\n      this.tracer = tracer;\n    }\n\n    @Override public void onCore(int pass, Core.Decl e) {\n      tracer.onCore(pass, e);\n    }\n\n    @Override public void onPlan(Code code) {\n      tracer.onPlan(code);\n    }\n\n    @Override public void onResult(Object o) {\n      tracer.onResult(o);\n    }\n\n    @Override public void onWarnings(List<Throwable> warningList) {\n      tracer.onWarnings(warningList);\n    }\n\n    @Override public boolean onException(@Nullable Throwable e) {\n      return tracer.onException(e);\n    }\n\n    @Override public boolean onTypeException(TypeResolver.TypeException e) {\n      return tracer.onTypeException(e);\n    }\n\n    @Override public boolean handleCompileException(\n        @Nullable CompileException e) {\n      return tracer.handleCompileException(e);\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "name": "EnvVisitor", "file_path": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "superclasses": "Visitor", "methods": ["[]EnvVisitor(TypeSystem,Environment,Deque<FromContext>)", "[EnvVisitor]push(Environment)", "[EnvVisitor]bind(Binding)", "[EnvVisitor]bind(Iterable<Binding>)", "[void]visit(Core.Fn)", "[void]visit(Core.Match)", "[void]visit(Core.Let)", "[void]visit(Core.Local)", "[void]visit(Core.RecValDecl)", "[void]visit(Core.From)", "[void]visitStep(Core.FromStep,List<Binding>)", "[void]visit(Core.Aggregate)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[]EnvVisitor(TypeSystem,Environment,Deque<FromContext>)", "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[EnvVisitor]push(Environment)", "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[EnvVisitor]bind(Binding)", "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[EnvVisitor]bind(Iterable<Binding>)", "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.Fn)", "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.Match)", "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.Let)", "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.Local)", "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.RecValDecl)", "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.From)", "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visitStep(Core.FromStep,List<Binding>)", "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.Aggregate)"], "overrides": null, "attributes": [{"original_string": "  public static class FromContext {\n    final EnvVisitor visitor;\n    final Core.FromStep step;\n\n    FromContext(EnvVisitor visitor, Core.FromStep step) {\n      this.visitor = visitor;\n      this.step = step;\n    }\n  }", "definition": "  public static class FromContext", "class_docstring": " Where we are in an iteration through the steps of a {@code from}.\nAllows the step handlers to retrieve the original environment and make\na custom environment for each step (or part of a step).", "name": "FromContext", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "final EnvVisitor visitor;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "EnvVisitor", "name": "visitor", "syntax_pass": true}, {"attribute_expression": "final Core.FromStep step;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.FromStep", "name": "step", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FromContext(EnvVisitor visitor, Core.FromStep step) {\n      this.visitor = visitor;\n      this.step = step;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FromContext", "params": [{"name": "visitor", "type": "EnvVisitor"}, {"name": "step", "type": "Core.FromStep"}], "body": "                                                        {\n      this.visitor = visitor;\n      this.step = step;\n    }", "signature": "FromContext(EnvVisitor visitor, Core.FromStep step)"}]}], "class_docstring": "\nShuttle that keeps an environment of what variables are in scope.\n", "original_string": "abstract class EnvVisitor extends Visitor {\n  final TypeSystem typeSystem;\n  final Environment env;\n  final Deque<FromContext> fromStack;\n\n  /** Creates an EnvVisitor. */\n  protected EnvVisitor(TypeSystem typeSystem, Environment env,\n      Deque<FromContext> fromStack) {\n    this.typeSystem = typeSystem;\n    this.env = env;\n    this.fromStack = fromStack;\n  }\n\n  /** Creates a visitor the same as this but with a new environment. */\n  protected abstract EnvVisitor push(Environment env);\n\n  /** Creates a visitor the same as this but overriding a binding. */\n  protected EnvVisitor bind(Binding binding) {\n    return push(env.bind(binding));\n  }\n\n  /** Creates a visitor the same as this but with overriding bindings. */\n  protected EnvVisitor bind(Iterable<Binding> bindingList)  {\n    // The \"env2 == env\" check is an optimization.\n    // If you remove it, this method will have the same effect, just slower.\n    final Environment env2 = env.bindAll(bindingList);\n    if (env2 != env) {\n      return push(env2);\n    }\n    return this;\n  }\n\n  @Override protected void visit(Core.Fn fn) {\n    fn.idPat.accept(this);\n    fn.exp.accept(bind(Binding.of(fn.idPat)));\n  }\n\n  @Override protected void visit(Core.Match match) {\n    final List<Binding> bindings = new ArrayList<>();\n    match.pat.accept(this);\n    Compiles.bindPattern(typeSystem, bindings, match.pat);\n    match.exp.accept(bind(bindings));\n  }\n\n  @Override protected void visit(Core.Let let) {\n    let.decl.accept(this);\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.bindPattern(typeSystem, bindings, let.decl);\n    let.exp.accept(bind(bindings));\n  }\n\n  @Override protected void visit(Core.Local local) {\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.bindDataType(typeSystem, bindings, local.dataType);\n    local.exp.accept(bind(bindings));\n  }\n\n  @Override protected void visit(Core.RecValDecl recValDecl) {\n    final List<Binding> bindings = new ArrayList<>();\n    recValDecl.list.forEach(decl ->\n        Compiles.bindPattern(typeSystem, bindings, decl.pat));\n    final EnvVisitor v2 = bind(bindings);\n    recValDecl.list.forEach(v2::accept);\n  }\n\n  @Override protected void visit(Core.From from) {\n    List<Binding> bindings = ImmutableList.of();\n    for (Core.FromStep step : from.steps) {\n      visitStep(step, bindings);\n      bindings = step.bindings;\n    }\n  }\n\n  public void visitStep(Core.FromStep step, List<Binding> bindings) {\n    try {\n      fromStack.push(new FromContext(this, step));\n      step.accept(bind(bindings));\n    } finally {\n      fromStack.pop();\n    }\n  }\n\n  @Override protected void visit(Core.Aggregate aggregate) {\n    // Aggregates need an environment that includes the group keys.\n    // For example,\n    //   from (i, j) in [(1, 2), (2, 3)]\n    //     group k = i + 2\n    //     compute fn list => List.size list + j of i + j\n    // the aggregate \"fn list => List.size list + j\" needs an environment [k];\n    // the argument \"i + j\" needs an environment [i, j].\n    EnvVisitor v2 = fromStack.element().visitor;\n    Core.Group group = (Core.Group) fromStack.element().step;\n    EnvVisitor v3 = v2.bind(transform(group.groupExps.keySet(), Binding::of));\n    aggregate.aggregate.accept(v3);\n    if (aggregate.argument != null) {\n      aggregate.argument.accept(this);\n    }\n  }\n\n  /** Where we are in an iteration through the steps of a {@code from}.\n   * Allows the step handlers to retrieve the original environment and make\n   * a custom environment for each step (or part of a step). */\n  public static class FromContext {\n    final EnvVisitor visitor;\n    final Core.FromStep step;\n\n    FromContext(EnvVisitor visitor, Core.FromStep step) {\n      this.visitor = visitor;\n      this.step = step;\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final TypeSystem typeSystem;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}, {"attribute_expression": "final Environment env;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Environment", "name": "env", "syntax_pass": true}, {"attribute_expression": "final Deque<FromContext> fromStack;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Deque<FromContext>", "name": "fromStack", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments", "name": "Environments", "file_path": "src/main/java/net/hydromatic/morel/compile/Environments.java", "superclasses": "", "methods": ["[]Environments()", "[Environment]empty()", "[Environment]env(TypeSystem,Session,Map<String, ForeignValue>)", "[Environment]env(Environment,TypeSystem,Session,Map<String, ForeignValue>)", "[void]foreignBindings(TypeSystem,Map<String, ForeignValue>,List<Binding>)", "[Environment]bind(Environment,Iterable<Binding>)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[]Environments()", "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[Environment]empty()", "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[Environment]env(TypeSystem,Session,Map<String, ForeignValue>)", "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[Environment]env(Environment,TypeSystem,Session,Map<String, ForeignValue>)", "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[void]foreignBindings(TypeSystem,Map<String, ForeignValue>,List<Binding>)", "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[Environment]bind(Environment,Iterable<Binding>)"], "overrides": null, "attributes": [{"original_string": "  static class SubEnvironment extends Environment {\n    private final Environment parent;\n    private final Binding binding;\n\n    SubEnvironment(Environment parent, Binding binding) {\n      this.parent = requireNonNull(parent);\n      this.binding = requireNonNull(binding);\n    }\n\n    @Override public String toString() {\n      return binding.id + \", ...\";\n    }\n\n    @Override public @Nullable Binding getOpt(String name) {\n      if (name.equals(binding.id.name)) {\n        return binding;\n      }\n      return parent.getOpt(name);\n    }\n\n    @Override public @Nullable Binding getOpt(Core.NamedPat id) {\n      if (id.equals(binding.id)) {\n        return binding;\n      }\n      return parent.getOpt(id);\n    }\n\n    @Override protected Environment bind(Binding binding) {\n      Environment env;\n      if (this.binding.id.equals(binding.id)) {\n        // The new binding will obscure the current environment's binding,\n        // because it binds a variable of the same name. Bind the parent\n        // environment instead. This strategy is worthwhile because it tends to\n        // prevent long chains from forming, and allows obscured values to be\n        // garbage-collected.\n        env = parent;\n        while (env instanceof SubEnvironment\n            && ((SubEnvironment) env).binding.id.name.equals(binding.id.name)) {\n          env = ((SubEnvironment) env).parent;\n        }\n      } else {\n        env = this;\n      }\n      return new Environments.SubEnvironment(env, binding);\n    }\n\n    void visit(Consumer<Binding> consumer) {\n      consumer.accept(binding);\n      parent.visit(consumer);\n    }\n\n    @Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names) {\n      return names.contains(binding.id)\n          ? parent.nearestAncestorNotObscuredBy(names)\n          : this;\n    }\n\n    @Override int distance(int soFar, Core.NamedPat id) {\n      if (id.equals(this.binding.id)) {\n        return soFar;\n      } else {\n        return parent.distance(soFar + 1, id);\n      }\n    }\n  }", "definition": "  static class SubEnvironment extends Environment", "class_docstring": " Environment that inherits from a parent environment and adds one\nbinding.", "name": "SubEnvironment", "super_interfaces": [], "superclasses": "Environment", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Environment parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Environment", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private final Binding binding;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Binding", "name": "binding", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    SubEnvironment(Environment parent, Binding binding) {\n      this.parent = requireNonNull(parent);\n      this.binding = requireNonNull(binding);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SubEnvironment", "params": [{"name": "parent", "type": "Environment"}, {"name": "binding", "type": "Binding"}], "body": "                                                        {\n      this.parent = requireNonNull(parent);\n      this.binding = requireNonNull(binding);\n    }", "signature": "SubEnvironment(Environment parent, Binding binding)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return binding.id + \", ...\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return binding.id + \", ...\";\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    @Override public @Nullable Binding getOpt(String name) {\n      if (name.equals(binding.id.name)) {\n        return binding;\n      }\n      return parent.getOpt(name);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public @Nullable", "marker_annotations": ["@Override", "@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Binding", "classes": []}, "name": "getOpt", "params": [{"name": "name", "type": "String"}], "body": "                                                           {\n      if (name.equals(binding.id.name)) {\n        return binding;\n      }\n      return parent.getOpt(name);\n    }", "signature": "@Override public @Nullable Binding getOpt(String name)"}, {"syntax_pass": true, "original_string": "    @Override public @Nullable Binding getOpt(Core.NamedPat id) {\n      if (id.equals(binding.id)) {\n        return binding;\n      }\n      return parent.getOpt(id);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public @Nullable", "marker_annotations": ["@Override", "@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Binding", "classes": []}, "name": "getOpt", "params": [{"name": "id", "type": "Core.NamedPat"}], "body": "                                                                {\n      if (id.equals(binding.id)) {\n        return binding;\n      }\n      return parent.getOpt(id);\n    }", "signature": "@Override public @Nullable Binding getOpt(Core.NamedPat id)"}, {"syntax_pass": true, "original_string": "    @Override protected Environment bind(Binding binding) {\n      Environment env;\n      if (this.binding.id.equals(binding.id)) {\n        // The new binding will obscure the current environment's binding,\n        // because it binds a variable of the same name. Bind the parent\n        // environment instead. This strategy is worthwhile because it tends to\n        // prevent long chains from forming, and allows obscured values to be\n        // garbage-collected.\n        env = parent;\n        while (env instanceof SubEnvironment\n            && ((SubEnvironment) env).binding.id.name.equals(binding.id.name)) {\n          env = ((SubEnvironment) env).parent;\n        }\n      } else {\n        env = this;\n      }\n      return new Environments.SubEnvironment(env, binding);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Environment", "classes": []}, "name": "bind", "params": [{"name": "binding", "type": "Binding"}], "body": "                                                          {\n      Environment env;\n      if (this.binding.id.equals(binding.id)) {\n        // The new binding will obscure the current environment's binding,\n        // because it binds a variable of the same name. Bind the parent\n        // environment instead. This strategy is worthwhile because it tends to\n        // prevent long chains from forming, and allows obscured values to be\n        // garbage-collected.\n        env = parent;\n        while (env instanceof SubEnvironment\n            && ((SubEnvironment) env).binding.id.name.equals(binding.id.name)) {\n          env = ((SubEnvironment) env).parent;\n        }\n      } else {\n        env = this;\n      }\n      return new Environments.SubEnvironment(env, binding);\n    }", "signature": "@Override protected Environment bind(Binding binding)"}, {"syntax_pass": true, "original_string": "    void visit(Consumer<Binding> consumer) {\n      consumer.accept(binding);\n      parent.visit(consumer);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "consumer", "type": "Consumer<Binding>"}], "body": "                                           {\n      consumer.accept(binding);\n      parent.visit(consumer);\n    }", "signature": "void visit(Consumer<Binding> consumer)"}, {"syntax_pass": true, "original_string": "    @Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names) {\n      return names.contains(binding.id)\n          ? parent.nearestAncestorNotObscuredBy(names)\n          : this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Environment", "classes": []}, "name": "nearestAncestorNotObscuredBy", "params": [{"name": "names", "type": "Set<Core.NamedPat>"}], "body": "                                                                                 {\n      return names.contains(binding.id)\n          ? parent.nearestAncestorNotObscuredBy(names)\n          : this;\n    }", "signature": "@Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names)"}, {"syntax_pass": true, "original_string": "    @Override int distance(int soFar, Core.NamedPat id) {\n      if (id.equals(this.binding.id)) {\n        return soFar;\n      } else {\n        return parent.distance(soFar + 1, id);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "name": "distance", "params": [{"name": "soFar", "type": "int"}, {"name": "id", "type": "Core.NamedPat"}], "body": "                                                        {\n      if (id.equals(this.binding.id)) {\n        return soFar;\n      } else {\n        return parent.distance(soFar + 1, id);\n      }\n    }", "signature": "@Override int distance(int soFar, Core.NamedPat id)"}]}, {"original_string": "  private static class EmptyEnvironment extends Environment {\n    static final EmptyEnvironment INSTANCE = new EmptyEnvironment();\n\n    void visit(Consumer<Binding> consumer) {\n    }\n\n    @Override public @Nullable Binding getOpt(String name) {\n      return null;\n    }\n\n    @Override public @Nullable Binding getOpt(Core.NamedPat id) {\n      return null;\n    }\n\n    @Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names) {\n      return this;\n    }\n\n    @Override int distance(int soFar, Core.NamedPat id) {\n      return -1;\n    }\n  }", "definition": "  private static class EmptyEnvironment extends Environment", "class_docstring": " Empty environment.", "name": "EmptyEnvironment", "super_interfaces": [], "superclasses": "Environment", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "static final EmptyEnvironment INSTANCE = new EmptyEnvironment();", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "EmptyEnvironment", "name": "INSTANCE = new EmptyEnvironment()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    void visit(Consumer<Binding> consumer) {\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "consumer", "type": "Consumer<Binding>"}], "body": "                                           {\n    }", "signature": "void visit(Consumer<Binding> consumer)"}, {"syntax_pass": true, "original_string": "    @Override public @Nullable Binding getOpt(String name) {\n      return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public @Nullable", "marker_annotations": ["@Override", "@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Binding", "classes": []}, "name": "getOpt", "params": [{"name": "name", "type": "String"}], "body": "                                                           {\n      return null;\n    }", "signature": "@Override public @Nullable Binding getOpt(String name)"}, {"syntax_pass": true, "original_string": "    @Override public @Nullable Binding getOpt(Core.NamedPat id) {\n      return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public @Nullable", "marker_annotations": ["@Override", "@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Binding", "classes": []}, "name": "getOpt", "params": [{"name": "id", "type": "Core.NamedPat"}], "body": "                                                                {\n      return null;\n    }", "signature": "@Override public @Nullable Binding getOpt(Core.NamedPat id)"}, {"syntax_pass": true, "original_string": "    @Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names) {\n      return this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Environment", "classes": []}, "name": "nearestAncestorNotObscuredBy", "params": [{"name": "names", "type": "Set<Core.NamedPat>"}], "body": "                                                                                 {\n      return this;\n    }", "signature": "@Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names)"}, {"syntax_pass": true, "original_string": "    @Override int distance(int soFar, Core.NamedPat id) {\n      return -1;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "name": "distance", "params": [{"name": "soFar", "type": "int"}, {"name": "id", "type": "Core.NamedPat"}], "body": "                                                        {\n      return -1;\n    }", "signature": "@Override int distance(int soFar, Core.NamedPat id)"}]}, {"original_string": "  static class MapEnvironment extends Environment {\n    private final Environment parent;\n    private final Map<Core.NamedPat, Binding> map;\n\n    MapEnvironment(Environment parent,\n        ImmutableMap<Core.NamedPat, Binding> map) {\n      this.parent = requireNonNull(parent);\n      this.map = requireNonNull(map);\n    }\n\n    void visit(Consumer<Binding> consumer) {\n      map.values().forEach(consumer);\n      parent.visit(consumer);\n    }\n\n    public @Nullable Binding getOpt(String name) {\n      for (Map.Entry<Core.NamedPat, Binding> entry : map.entrySet()) {\n        if (entry.getKey().name.equals(name)) {\n          return entry.getValue();\n        }\n      }\n      return parent.getOpt(name);\n    }\n\n    public @Nullable Binding getOpt(Core.NamedPat id) {\n      final Binding binding = map.get(id);\n      return binding != null && binding.id.i == id.i ? binding\n          : parent.getOpt(id);\n    }\n\n    @Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names) {\n      return names.containsAll(map.keySet())\n          ? parent.nearestAncestorNotObscuredBy(names)\n          : this;\n    }\n\n    @Override int distance(int soFar, Core.NamedPat id) {\n      final int i = find(map.keySet(), id);\n      if (i >= 0) {\n        return soFar + map.size() - 1 - i;\n      } else {\n        return parent.distance(soFar + map.size(), id);\n      }\n    }\n\n    private <E> int find(Iterable<E> iterable, E e) {\n      int i = 0;\n      for (E e1 : iterable) {\n        if (e1.equals(e)) {\n          return i;\n        }\n        ++i;\n      }\n      return -1;\n    }\n  }", "definition": "  static class MapEnvironment extends Environment", "class_docstring": " Environment that keeps bindings in a map.", "name": "MapEnvironment", "super_interfaces": [], "superclasses": "Environment", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Environment parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Environment", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private final Map<Core.NamedPat, Binding> map;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Core.NamedPat, Binding>", "name": "map", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    MapEnvironment(Environment parent,\n        ImmutableMap<Core.NamedPat, Binding> map) {\n      this.parent = requireNonNull(parent);\n      this.map = requireNonNull(map);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MapEnvironment", "params": [{"name": "parent", "type": "Environment"}, {"name": "map", "type": "ImmutableMap<Core.NamedPat, Binding>"}], "body": "                                                  {\n      this.parent = requireNonNull(parent);\n      this.map = requireNonNull(map);\n    }", "signature": "MapEnvironment(Environment parent,\n        ImmutableMap<Core.NamedPat, Binding> map)"}, {"syntax_pass": true, "original_string": "    void visit(Consumer<Binding> consumer) {\n      map.values().forEach(consumer);\n      parent.visit(consumer);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "consumer", "type": "Consumer<Binding>"}], "body": "                                           {\n      map.values().forEach(consumer);\n      parent.visit(consumer);\n    }", "signature": "void visit(Consumer<Binding> consumer)"}, {"syntax_pass": true, "original_string": "    public @Nullable Binding getOpt(String name) {\n      for (Map.Entry<Core.NamedPat, Binding> entry : map.entrySet()) {\n        if (entry.getKey().name.equals(name)) {\n          return entry.getValue();\n        }\n      }\n      return parent.getOpt(name);\n    }", "docstring": "", "attributes": {"modifiers": "public @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Binding", "classes": []}, "name": "getOpt", "params": [{"name": "name", "type": "String"}], "body": "                                                 {\n      for (Map.Entry<Core.NamedPat, Binding> entry : map.entrySet()) {\n        if (entry.getKey().name.equals(name)) {\n          return entry.getValue();\n        }\n      }\n      return parent.getOpt(name);\n    }", "signature": "public @Nullable Binding getOpt(String name)"}, {"syntax_pass": true, "original_string": "    public @Nullable Binding getOpt(Core.NamedPat id) {\n      final Binding binding = map.get(id);\n      return binding != null && binding.id.i == id.i ? binding\n          : parent.getOpt(id);\n    }", "docstring": "", "attributes": {"modifiers": "public @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Binding", "classes": []}, "name": "getOpt", "params": [{"name": "id", "type": "Core.NamedPat"}], "body": "                                                      {\n      final Binding binding = map.get(id);\n      return binding != null && binding.id.i == id.i ? binding\n          : parent.getOpt(id);\n    }", "signature": "public @Nullable Binding getOpt(Core.NamedPat id)"}, {"syntax_pass": true, "original_string": "    @Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names) {\n      return names.containsAll(map.keySet())\n          ? parent.nearestAncestorNotObscuredBy(names)\n          : this;\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "Environment", "classes": []}, "name": "nearestAncestorNotObscuredBy", "params": [{"name": "names", "type": "Set<Core.NamedPat>"}], "body": "                                                                                 {\n      return names.containsAll(map.keySet())\n          ? parent.nearestAncestorNotObscuredBy(names)\n          : this;\n    }", "signature": "@Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names)"}, {"syntax_pass": true, "original_string": "    @Override int distance(int soFar, Core.NamedPat id) {\n      final int i = find(map.keySet(), id);\n      if (i >= 0) {\n        return soFar + map.size() - 1 - i;\n      } else {\n        return parent.distance(soFar + map.size(), id);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "name": "distance", "params": [{"name": "soFar", "type": "int"}, {"name": "id", "type": "Core.NamedPat"}], "body": "                                                        {\n      final int i = find(map.keySet(), id);\n      if (i >= 0) {\n        return soFar + map.size() - 1 - i;\n      } else {\n        return parent.distance(soFar + map.size(), id);\n      }\n    }", "signature": "@Override int distance(int soFar, Core.NamedPat id)"}, {"syntax_pass": true, "original_string": "    private <E> int find(Iterable<E> iterable, E e) {\n      int i = 0;\n      for (E e1 : iterable) {\n        if (e1.equals(e)) {\n          return i;\n        }\n        ++i;\n      }\n      return -1;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "find", "params": [{"name": "iterable", "type": "Iterable<E>"}, {"name": "e", "type": "E"}], "body": "                                                    {\n      int i = 0;\n      for (E e1 : iterable) {\n        if (e1.equals(e)) {\n          return i;\n        }\n        ++i;\n      }\n      return -1;\n    }", "signature": "private <E> int find(Iterable<E> iterable, E e)"}]}], "class_docstring": " Helpers for {@link Environment}.", "original_string": "public abstract class Environments {\n\n  /** An environment with only \"true\" and \"false\". */\n  private static final Environment BASIC_ENVIRONMENT =\n      EmptyEnvironment.INSTANCE\n          .bind(core.idPat(PrimitiveType.BOOL, \"true\", 0), true)\n          .bind(core.idPat(PrimitiveType.BOOL, \"false\", 0), false);\n\n  private Environments() {}\n\n  /** Creates an empty environment. */\n  public static Environment empty() {\n    return BASIC_ENVIRONMENT;\n  }\n\n  /** Creates an environment containing built-ins and the given foreign\n   * values. */\n  public static Environment env(TypeSystem typeSystem,\n      @Nullable Session session, Map<String, ForeignValue> valueMap) {\n    return env(EmptyEnvironment.INSTANCE, typeSystem, session, valueMap);\n  }\n\n  /** Creates a compilation environment, including built-ins and foreign\n   * values. */\n  private static Environment env(Environment environment, TypeSystem typeSystem,\n      @Nullable Session session, Map<String, ForeignValue> valueMap) {\n    if (SKIP) {\n      return environment;\n    }\n    final List<Binding> bindings = new ArrayList<>();\n    BuiltIn.dataTypes(typeSystem, bindings);\n    final NameGenerator nameGen = typeSystem.nameGenerator;\n    Codes.BUILT_IN_VALUES.forEach((key, value) -> {\n      if (\"$\".equals(key.structure)) {\n        return; // ignore Z_ANDALSO, Z_LIST, etc.\n      }\n      final Type type = key.typeFunction.apply(typeSystem);\n      if (key.sessionValue != null) {\n        if (session == null) {\n          return;\n        }\n        value = key.sessionValue.apply(session);\n      }\n      if (key.structure == null) {\n        bindings.add(Binding.of(core.idPat(type, key.mlName, nameGen), value));\n      }\n      if (key.alias != null) {\n        bindings.add(Binding.of(core.idPat(type, key.alias, nameGen), value));\n      }\n    });\n\n    final EvalEnv emptyEnv = Codes.emptyEnv();\n    BuiltIn.forEachStructure(typeSystem, (structure, type) ->\n        bindings.add(\n            Binding.of(core.idPat(type, structure.name, nameGen),\n                emptyEnv.getOpt(structure.name))));\n\n    foreignBindings(typeSystem, valueMap, bindings);\n    return bind(environment, bindings);\n  }\n\n  private static void foreignBindings(TypeSystem typeSystem,\n      Map<String, ForeignValue> map, List<Binding> bindings) {\n    map.forEach((name, value) -> bindings.add(\n        Binding.of(\n            core.idPat(value.type(typeSystem), name, typeSystem.nameGenerator),\n            value.value())\n            .withParameter(true)));\n  }\n\n  /** Creates an environment that is a given environment plus bindings. */\n  static Environment bind(Environment env, Iterable<Binding> bindings) {\n    if (shorterThan(bindings, 5)) {\n      for (Binding binding : bindings) {\n        env = env.bind(binding);\n      }\n      return env;\n    } else {\n      // We assume that the set of bindings does not include two Core.IdPat\n      // instances with the same name but different ordinals.\n      final ImmutableMap.Builder<Core.NamedPat, Binding> b =\n          ImmutableMap.builder();\n      bindings.forEach(binding -> b.put(binding.id, binding));\n      final ImmutableMap<Core.NamedPat, Binding> map = b.build();\n      final ImmutableSet<Core.NamedPat> names = map.keySet();\n      env = env.nearestAncestorNotObscuredBy(names);\n      return new MapEnvironment(env, map);\n    }\n  }\n\n  /** Environment that inherits from a parent environment and adds one\n   * binding. */\n  static class SubEnvironment extends Environment {\n    private final Environment parent;\n    private final Binding binding;\n\n    SubEnvironment(Environment parent, Binding binding) {\n      this.parent = requireNonNull(parent);\n      this.binding = requireNonNull(binding);\n    }\n\n    @Override public String toString() {\n      return binding.id + \", ...\";\n    }\n\n    @Override public @Nullable Binding getOpt(String name) {\n      if (name.equals(binding.id.name)) {\n        return binding;\n      }\n      return parent.getOpt(name);\n    }\n\n    @Override public @Nullable Binding getOpt(Core.NamedPat id) {\n      if (id.equals(binding.id)) {\n        return binding;\n      }\n      return parent.getOpt(id);\n    }\n\n    @Override protected Environment bind(Binding binding) {\n      Environment env;\n      if (this.binding.id.equals(binding.id)) {\n        // The new binding will obscure the current environment's binding,\n        // because it binds a variable of the same name. Bind the parent\n        // environment instead. This strategy is worthwhile because it tends to\n        // prevent long chains from forming, and allows obscured values to be\n        // garbage-collected.\n        env = parent;\n        while (env instanceof SubEnvironment\n            && ((SubEnvironment) env).binding.id.name.equals(binding.id.name)) {\n          env = ((SubEnvironment) env).parent;\n        }\n      } else {\n        env = this;\n      }\n      return new Environments.SubEnvironment(env, binding);\n    }\n\n    void visit(Consumer<Binding> consumer) {\n      consumer.accept(binding);\n      parent.visit(consumer);\n    }\n\n    @Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names) {\n      return names.contains(binding.id)\n          ? parent.nearestAncestorNotObscuredBy(names)\n          : this;\n    }\n\n    @Override int distance(int soFar, Core.NamedPat id) {\n      if (id.equals(this.binding.id)) {\n        return soFar;\n      } else {\n        return parent.distance(soFar + 1, id);\n      }\n    }\n  }\n\n  /** Empty environment. */\n  private static class EmptyEnvironment extends Environment {\n    static final EmptyEnvironment INSTANCE = new EmptyEnvironment();\n\n    void visit(Consumer<Binding> consumer) {\n    }\n\n    @Override public @Nullable Binding getOpt(String name) {\n      return null;\n    }\n\n    @Override public @Nullable Binding getOpt(Core.NamedPat id) {\n      return null;\n    }\n\n    @Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names) {\n      return this;\n    }\n\n    @Override int distance(int soFar, Core.NamedPat id) {\n      return -1;\n    }\n  }\n\n  /** Environment that keeps bindings in a map. */\n  static class MapEnvironment extends Environment {\n    private final Environment parent;\n    private final Map<Core.NamedPat, Binding> map;\n\n    MapEnvironment(Environment parent,\n        ImmutableMap<Core.NamedPat, Binding> map) {\n      this.parent = requireNonNull(parent);\n      this.map = requireNonNull(map);\n    }\n\n    void visit(Consumer<Binding> consumer) {\n      map.values().forEach(consumer);\n      parent.visit(consumer);\n    }\n\n    public @Nullable Binding getOpt(String name) {\n      for (Map.Entry<Core.NamedPat, Binding> entry : map.entrySet()) {\n        if (entry.getKey().name.equals(name)) {\n          return entry.getValue();\n        }\n      }\n      return parent.getOpt(name);\n    }\n\n    public @Nullable Binding getOpt(Core.NamedPat id) {\n      final Binding binding = map.get(id);\n      return binding != null && binding.id.i == id.i ? binding\n          : parent.getOpt(id);\n    }\n\n    @Override Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names) {\n      return names.containsAll(map.keySet())\n          ? parent.nearestAncestorNotObscuredBy(names)\n          : this;\n    }\n\n    @Override int distance(int soFar, Core.NamedPat id) {\n      final int i = find(map.keySet(), id);\n      if (i >= 0) {\n        return soFar + map.size() - 1 - i;\n      } else {\n        return parent.distance(soFar + map.size(), id);\n      }\n    }\n\n    private <E> int find(Iterable<E> iterable, E e) {\n      int i = 0;\n      for (E e1 : iterable) {\n        if (e1.equals(e)) {\n          return i;\n        }\n        ++i;\n      }\n      return -1;\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Environment BASIC_ENVIRONMENT =\n      EmptyEnvironment.INSTANCE\n          .bind(core.idPat(PrimitiveType.BOOL, \"true\", 0), true)\n          .bind(core.idPat(PrimitiveType.BOOL, \"false\", 0), false);", "docstring": " An environment with only \"true\" and \"false\".", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Environment", "name": "BASIC_ENVIRONMENT =\n      EmptyEnvironment.INSTANCE\n          .bind(core.idPat(PrimitiveType.BOOL, \"true\", 0), true)\n          .bind(core.idPat(PrimitiveType.BOOL, \"false\", 0), false)", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "name": "Compiles", "file_path": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "superclasses": "", "methods": ["[TypeResolver.Resolved]validateExpression(AstNode,Map<Prop, Object>,Map<String, ForeignValue>)", "[CompiledStatement]prepareStatement(TypeSystem,Session,Environment,AstNode,Calcite,Consumer<CompileException>,Tracer)", "[CompiledStatement]prepareDecl(TypeSystem,Session,Environment,Calcite,Ast.Decl,Consumer<CompileException>,Tracer)", "[Core.@Nullable NamedPat]getSkipPat(Ast.Decl,Core.Decl)", "[void]checkPatternCoverage(TypeSystem,Core.Decl,Consumer<CompileException>)", "[void]checkPatternCoverage(TypeSystem,Core.Case,Consumer<CompileException>,Consumer<CompileException>)", "[Ast.ValDecl]toValDecl(Ast.Exp)", "[Ast.ValDecl]toValDecl(AstNode)", "[Ast.Decl]toDecl(AstNode)", "[Core.Exp]toExp(Core.NonRecValDecl)", "[void]bindPattern(TypeSystem,List<Binding>,Core.DatatypeDecl)", "[void]bindPattern(TypeSystem,List<Binding>,Core.ValDecl)", "[void]bindPattern(TypeSystem,List<Binding>,Core.Pat)", "[void]bindPattern(TypeSystem,List<Binding>,Core.NamedPat)", "[void]bindDataType(TypeSystem,List<Binding>,DataType)", "[PatternBinder]binding(TypeSystem,List<Binding>)", "[void]acceptBinding(TypeSystem,Core.Pat,List<Binding>)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[TypeResolver.Resolved]validateExpression(AstNode,Map<Prop, Object>,Map<String, ForeignValue>)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[CompiledStatement]prepareStatement(TypeSystem,Session,Environment,AstNode,Calcite,Consumer<CompileException>,Tracer)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[CompiledStatement]prepareDecl(TypeSystem,Session,Environment,Calcite,Ast.Decl,Consumer<CompileException>,Tracer)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[Core.@Nullable NamedPat]getSkipPat(Ast.Decl,Core.Decl)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]checkPatternCoverage(TypeSystem,Core.Decl,Consumer<CompileException>)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]checkPatternCoverage(TypeSystem,Core.Case,Consumer<CompileException>,Consumer<CompileException>)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[Ast.ValDecl]toValDecl(Ast.Exp)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[Ast.ValDecl]toValDecl(AstNode)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[Ast.Decl]toDecl(AstNode)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[Core.Exp]toExp(Core.NonRecValDecl)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]bindPattern(TypeSystem,List<Binding>,Core.DatatypeDecl)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]bindPattern(TypeSystem,List<Binding>,Core.ValDecl)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]bindPattern(TypeSystem,List<Binding>,Core.Pat)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]bindPattern(TypeSystem,List<Binding>,Core.NamedPat)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]bindDataType(TypeSystem,List<Binding>,DataType)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[PatternBinder]binding(TypeSystem,List<Binding>)", "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]acceptBinding(TypeSystem,Core.Pat,List<Binding>)"], "overrides": null, "attributes": [{"original_string": "  private static class PatternBinder extends Visitor {\n    private final TypeSystem typeSystem;\n    private final List<Binding> bindings;\n\n    PatternBinder(TypeSystem typeSystem, List<Binding> bindings) {\n      this.typeSystem = typeSystem;\n      this.bindings = bindings;\n    }\n\n    @Override protected void visit(Core.IdPat idPat) {\n      bindPattern(typeSystem, bindings, idPat);\n    }\n\n    @Override protected void visit(Core.AsPat asPat) {\n      bindPattern(typeSystem, bindings, asPat);\n      super.visit(asPat);\n    }\n\n    @Override protected void visit(Core.NonRecValDecl valBind) {\n      // The super method visits valBind.e; we do not\n      valBind.pat.accept(this);\n    }\n\n    @Override protected void visit(Core.DatatypeDecl datatypeDecl) {\n      datatypeDecl.dataTypes.forEach(dataType ->\n          bindDataType(typeSystem, bindings, dataType));\n    }\n\n    @Override protected void visit(Core.Local local) {\n      bindDataType(typeSystem, bindings, local.dataType);\n    }\n  }", "definition": "  private static class PatternBinder extends Visitor", "class_docstring": " Visitor that adds a {@link Binding} each time it see an\n{@link Core.IdPat} or {@link Core.AsPat}.", "name": "PatternBinder", "super_interfaces": [], "superclasses": "Visitor", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final TypeSystem typeSystem;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TypeSystem", "name": "typeSystem", "syntax_pass": true}, {"attribute_expression": "private final List<Binding> bindings;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Binding>", "name": "bindings", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    PatternBinder(TypeSystem typeSystem, List<Binding> bindings) {\n      this.typeSystem = typeSystem;\n      this.bindings = bindings;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "PatternBinder", "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "bindings", "type": "List<Binding>"}], "body": "                                                                 {\n      this.typeSystem = typeSystem;\n      this.bindings = bindings;\n    }", "signature": "PatternBinder(TypeSystem typeSystem, List<Binding> bindings)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.IdPat idPat) {\n      bindPattern(typeSystem, bindings, idPat);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "idPat", "type": "Core.IdPat"}], "body": "                                                     {\n      bindPattern(typeSystem, bindings, idPat);\n    }", "signature": "@Override protected void visit(Core.IdPat idPat)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.AsPat asPat) {\n      bindPattern(typeSystem, bindings, asPat);\n      super.visit(asPat);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "asPat", "type": "Core.AsPat"}], "body": "                                                     {\n      bindPattern(typeSystem, bindings, asPat);\n      super.visit(asPat);\n    }", "signature": "@Override protected void visit(Core.AsPat asPat)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.NonRecValDecl valBind) {\n      // The super method visits valBind.e; we do not\n      valBind.pat.accept(this);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "valBind", "type": "Core.NonRecValDecl"}], "body": "                                                               {\n      // The super method visits valBind.e; we do not\n      valBind.pat.accept(this);\n    }", "signature": "@Override protected void visit(Core.NonRecValDecl valBind)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.DatatypeDecl datatypeDecl) {\n      datatypeDecl.dataTypes.forEach(dataType ->\n          bindDataType(typeSystem, bindings, dataType));\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "datatypeDecl", "type": "Core.DatatypeDecl"}], "body": "                                                                   {\n      datatypeDecl.dataTypes.forEach(dataType ->\n          bindDataType(typeSystem, bindings, dataType));\n    }", "signature": "@Override protected void visit(Core.DatatypeDecl datatypeDecl)"}, {"syntax_pass": true, "original_string": "    @Override protected void visit(Core.Local local) {\n      bindDataType(typeSystem, bindings, local.dataType);\n    }", "docstring": "", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "visit", "params": [{"name": "local", "type": "Core.Local"}], "body": "                                                     {\n      bindDataType(typeSystem, bindings, local.dataType);\n    }", "signature": "@Override protected void visit(Core.Local local)"}]}], "class_docstring": " Helpers for {@link Compiler} and {@link TypeResolver}.", "original_string": "public abstract class Compiles {\n  /** Validates an expression or declaration, deducing its type and perhaps\n   * rewriting the expression to a form that can more easily be compiled.\n   *\n   * <p>Used for testing. */\n  public static TypeResolver.Resolved validateExpression(AstNode statement,\n      Map<Prop, Object> propMap, Map<String, ForeignValue> valueMap) {\n    final TypeSystem typeSystem = new TypeSystem();\n    final Session session = new Session(propMap);\n    final Environment env = Environments.env(typeSystem, session, valueMap);\n    return TypeResolver.deduceType(env, toDecl(statement), typeSystem);\n  }\n\n  /**\n   * Validates and compiles a statement (expression or declaration), and\n   * compiles it to code that can be evaluated by the interpreter.\n   */\n  public static CompiledStatement prepareStatement(TypeSystem typeSystem,\n      Session session, Environment env, AstNode statement,\n      @Nullable Calcite calcite, Consumer<CompileException> warningConsumer,\n      Tracer tracer) {\n    Ast.Decl decl;\n    if (statement instanceof Ast.Exp) {\n      decl = toValDecl((Ast.Exp) statement);\n    } else {\n      decl = (Ast.Decl) statement;\n    }\n    return prepareDecl(typeSystem, session, env, calcite, decl,\n        warningConsumer, tracer);\n  }\n\n  /**\n   * Validates and compiles a declaration, and compiles it to\n   * code that can be evaluated by the interpreter.\n   */\n  private static CompiledStatement prepareDecl(TypeSystem typeSystem,\n      Session session, Environment env, @Nullable Calcite calcite,\n      Ast.Decl decl,\n      Consumer<CompileException> warningConsumer, Tracer tracer) {\n    final TypeResolver.Resolved resolved =\n        TypeResolver.deduceType(env, decl, typeSystem);\n    final boolean hybrid = Prop.HYBRID.booleanValue(session.map);\n    final int inlinePassCount =\n        Math.max(Prop.INLINE_PASS_COUNT.intValue(session.map), 0);\n    final boolean relationalize =\n        Prop.RELATIONALIZE.booleanValue(session.map);\n\n    final Resolver resolver = Resolver.of(resolved.typeMap, env, session);\n    final Core.Decl coreDecl0 = resolver.toCore(resolved.node);\n    tracer.onCore(0, coreDecl0);\n\n    // Should we skip printing the root pattern?\n    // Yes, if they wrote 'val x = 1 and y = 2' and\n    // core became 'val it as (x, y) = (1, 2)'.\n    // No, if they actually wrote 'val (x, y) = (1, 2)'.\n    final Core.NamedPat skipPat = getSkipPat(resolved.node, coreDecl0);\n\n    // Check for exhaustive and redundant patterns, and throw errors or\n    // warnings.\n    final boolean matchCoverageEnabled =\n        Prop.MATCH_COVERAGE_ENABLED.booleanValue(session.map);\n    if (matchCoverageEnabled) {\n      checkPatternCoverage(typeSystem, coreDecl0, warningConsumer);\n    }\n\n    // Ensures that once we discover that there are no unbounded variables,\n    // we stop looking; makes things a bit more efficient.\n    boolean mayContainUnbounded = true;\n\n    Core.Decl coreDecl;\n    tracer.onCore(1, coreDecl0);\n    if (inlinePassCount == 0) {\n      // Inlining is disabled. Use the Inliner in a limited mode.\n      final Inliner inliner = Inliner.of(typeSystem, env, null);\n      coreDecl = coreDecl0.accept(inliner);\n    } else {\n      final @Nullable Relationalizer relationalizer =\n          relationalize ? Relationalizer.of(typeSystem, env)\n              : null;\n\n      // Inline few times, or until we reach fixed point, whichever is sooner.\n      coreDecl = coreDecl0;\n      for (int i = 0; i < inlinePassCount; i++) {\n        final Analyzer.Analysis analysis =\n            Analyzer.analyze(typeSystem, env, coreDecl);\n        final Inliner inliner = Inliner.of(typeSystem, env, analysis);\n        final Core.Decl coreDecl2 = coreDecl;\n        coreDecl = coreDecl2.accept(inliner);\n        if (relationalizer != null) {\n          coreDecl = coreDecl.accept(relationalizer);\n        }\n        if (coreDecl == coreDecl2) {\n          break;\n        }\n        tracer.onCore(i + 2, coreDecl);\n      }\n      for (int i = 0; i < inlinePassCount; i++) {\n        final Core.Decl coreDecl2 = coreDecl;\n        if (mayContainUnbounded) {\n          if (SuchThatShuttle.containsUnbounded(coreDecl)) {\n            coreDecl = coreDecl.accept(new SuchThatShuttle(typeSystem, env));\n          } else {\n            mayContainUnbounded = false;\n          }\n        }\n        coreDecl = Extents.infinitePats(typeSystem, coreDecl);\n        if (coreDecl == coreDecl2) {\n          break;\n        }\n        tracer.onCore(i + 2, coreDecl);\n      }\n    }\n    tracer.onCore(-1, coreDecl);\n    final Compiler compiler;\n    if (hybrid) {\n      if (calcite == null) {\n        calcite = Calcite.withDataSets(ImmutableMap.of());\n      }\n      compiler = new CalciteCompiler(typeSystem, calcite);\n    } else {\n      compiler = new Compiler(typeSystem);\n    }\n\n    // If the user wrote \"scott.depts\" we will print \"<relation>\";\n    // but if the user wrote \"from d in scott.depts\", they would like to see\n    // the full contents. Those two expressions may have been simplified to the\n    // same Core.Exp, but in the latter case we will 'wrap' the RelList value\n    // as a regular List so that it is printed in full.\n    final ImmutableSet.Builder<Core.Exp> queriesToWrap = ImmutableSet.builder();\n    if (resolved.originalNode instanceof Ast.ValDecl\n        && coreDecl instanceof Core.NonRecValDecl) {\n      final Ast.ValDecl valDecl = (Ast.ValDecl) resolved.originalNode;\n      final Ast.ValBind valBind = valDecl.valBinds.get(0);\n      final Core.NonRecValDecl nonRecValDecl = (Core.NonRecValDecl) coreDecl;\n      if (valBind.exp.op == Op.FROM) {\n        queriesToWrap.add(nonRecValDecl.exp);\n      }\n    }\n\n    return compiler.compileStatement(env, coreDecl, skipPat,\n        queriesToWrap.build());\n  }\n\n  /** Returns a pattern that should not be printed, or null.\n   *\n   * <p>Consider the two declarations:\n   *\n   * <blockquote><pre>{@code\n   *   val it as (x, y) = (5, 6);\n   *   val (x, y) = (5, 6);\n   * }</pre></blockquote>\n   *\n   * <p>{@code coreDecl} is the same for both. For the first, we should print\n   *\n   * <blockquote><pre>{@code\n   *   val it = (5,6) : int * int\n   *   val x = 5 : int\n   *   val x = 6 : int\n   * }</pre></blockquote>\n   *\n   * <p>but for the second we should skip {@code it}, as follows:\n   *\n   * <blockquote><pre>{@code\n   *   val x = 5 : int\n   *   val x = 6 : int\n   * }</pre></blockquote>\n   */\n  private static Core.@Nullable NamedPat getSkipPat(Ast.Decl decl,\n      Core.Decl coreDecl) {\n    if (coreDecl instanceof Core.NonRecValDecl\n        && decl instanceof Ast.ValDecl) {\n      final Core.NonRecValDecl nonRecValDecl = (Core.NonRecValDecl) coreDecl;\n      final Ast.ValDecl valDecl = (Ast.ValDecl) decl;\n      if (nonRecValDecl.pat.name.equals(\"it\")) {\n        if (valDecl.valBinds.size() == 1) {\n          final Ast.Pat pat = valDecl.valBinds.get(0).pat;\n          if (pat instanceof Ast.AsPat\n              && ((Ast.AsPat) pat).id.name.equals(\"it\")) {\n            return null;\n          }\n          if (pat instanceof Ast.IdPat\n              && ((Ast.IdPat) pat).name.equals(\"it\")) {\n            return null;\n          }\n        }\n        return nonRecValDecl.pat;\n      }\n    }\n    return null;\n  }\n\n  /** Checks for exhaustive and redundant patterns, and throws if there are\n   * errors/warnings. */\n  private static void checkPatternCoverage(TypeSystem typeSystem,\n      Core.Decl decl, final Consumer<CompileException> warningConsumer) {\n    final List<CompileException> errorList = new ArrayList<>();\n    decl.accept(new Visitor() {\n      @Override protected void visit(Core.Case kase) {\n        super.visit(kase);\n        checkPatternCoverage(typeSystem, kase, errorList::add,\n            warningConsumer);\n      }\n    });\n    if (!errorList.isEmpty()) {\n      throw errorList.get(0);\n    }\n  }\n\n  private static void checkPatternCoverage(TypeSystem typeSystem,\n      Core.Case kase, Consumer<CompileException> errorConsumer,\n      Consumer<CompileException> warningConsumer) {\n    final List<Core.Pat> prevPatList = new ArrayList<>();\n    final List<Core.Match> redundantMatchList = new ArrayList<>();\n    for (Core.Match match : kase.matchList) {\n      if (PatternCoverageChecker.isCoveredBy(typeSystem, prevPatList,\n          match.pat)) {\n        redundantMatchList.add(match);\n      }\n      prevPatList.add(match.pat);\n    }\n    final boolean exhaustive =\n        PatternCoverageChecker.isExhaustive(typeSystem, prevPatList);\n    if (!redundantMatchList.isEmpty()) {\n      final String message = exhaustive\n          ? \"match redundant\"\n          : \"match redundant and nonexhaustive\";\n      errorConsumer.accept(\n          new CompileException(message, false,\n              redundantMatchList.get(0).pos));\n    } else if (!exhaustive) {\n      warningConsumer.accept(\n          new CompileException(\"match nonexhaustive\", true, kase.pos));\n    }\n  }\n\n  /** Converts {@code e} to {@code val = e}. */\n  public static Ast.ValDecl toValDecl(Ast.Exp statement) {\n    final Pos pos = statement.pos;\n    return ast.valDecl(pos, false,\n        ImmutableList.of(ast.valBind(pos, ast.idPat(pos, \"it\"), statement)));\n  }\n\n  /** Converts an expression or value declaration to a value declaration. */\n  public static Ast.ValDecl toValDecl(AstNode statement) {\n    return statement instanceof Ast.ValDecl ? (Ast.ValDecl) statement\n        : toValDecl((Ast.Exp) statement);\n  }\n\n  /** Converts an expression or declaration to a declaration. */\n  public static Ast.Decl toDecl(AstNode statement) {\n    return statement instanceof Ast.Decl ? (Ast.Decl) statement\n        : toValDecl((Ast.Exp) statement);\n  }\n\n  /** Converts {@code val = e} to {@code e};\n   * the converse of {@link #toValDecl(Ast.Exp)}. */\n  public static Core.Exp toExp(Core.NonRecValDecl decl) {\n    return decl.exp;\n  }\n\n  static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.DatatypeDecl datatypeDecl) {\n    datatypeDecl.accept(binding(typeSystem, bindings));\n  }\n\n  /** Richer than {@link #bindPattern(TypeSystem, List, Core.Pat)} because\n   * we have the expression. */\n  static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.ValDecl valDecl) {\n    valDecl.forEachBinding((pat, exp, pos) -> {\n      if (pat instanceof Core.IdPat) {\n        bindings.add(Binding.of(pat, exp));\n      }\n    });\n  }\n\n  static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.Pat pat) {\n    pat.accept(binding(typeSystem, bindings));\n  }\n\n  static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.NamedPat namedPat) {\n    bindings.add(Binding.of(namedPat));\n  }\n\n  public static void bindDataType(TypeSystem typeSystem, List<Binding> bindings,\n      DataType dataType) {\n    dataType.typeConstructors.keySet().forEach(name ->\n        bindings.add(typeSystem.bindTyCon(dataType, name)));\n  }\n\n  static PatternBinder binding(TypeSystem typeSystem, List<Binding> bindings) {\n    return new PatternBinder(typeSystem, bindings);\n  }\n\n  /** Visits a pattern, adding bindings to a list.\n   *\n   * <p>If the pattern is an {@link net.hydromatic.morel.ast.Core.IdPat},\n   * don't use this method: just bind directly. */\n  public static void acceptBinding(TypeSystem typeSystem, Core.Pat pat,\n      List<Binding> bindings) {\n    pat.accept(binding(typeSystem, bindings));\n  }\n\n  /** Visitor that adds a {@link Binding} each time it see an\n   * {@link Core.IdPat} or {@link Core.AsPat}. */\n  private static class PatternBinder extends Visitor {\n    private final TypeSystem typeSystem;\n    private final List<Binding> bindings;\n\n    PatternBinder(TypeSystem typeSystem, List<Binding> bindings) {\n      this.typeSystem = typeSystem;\n      this.bindings = bindings;\n    }\n\n    @Override protected void visit(Core.IdPat idPat) {\n      bindPattern(typeSystem, bindings, idPat);\n    }\n\n    @Override protected void visit(Core.AsPat asPat) {\n      bindPattern(typeSystem, bindings, asPat);\n      super.visit(asPat);\n    }\n\n    @Override protected void visit(Core.NonRecValDecl valBind) {\n      // The super method visits valBind.e; we do not\n      valBind.pat.accept(this);\n    }\n\n    @Override protected void visit(Core.DatatypeDecl datatypeDecl) {\n      datatypeDecl.dataTypes.forEach(dataType ->\n          bindDataType(typeSystem, bindings, dataType));\n    }\n\n    @Override protected void visit(Core.Local local) {\n      bindDataType(typeSystem, bindings, local.dataType);\n    }\n  }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "name": "Environment", "file_path": "src/main/java/net/hydromatic/morel/compile/Environment.java", "superclasses": "", "methods": ["[void]visit(Consumer<Binding>)", "[String]asString()", "[Binding]getOpt(String)", "[Binding]getOpt(Core.NamedPat)", "[Environment]bind(Core.IdPat,Object)", "[Environment]bind(Binding)", "[void]forEachType(TypeSystem,BiConsumer<String, Type>)", "[void]forEachValue(BiConsumer<String, Object>)", "[Map<String, Binding>]getValueMap()", "[Environment]bindAll(Iterable<Binding>)", "[Environment]nearestAncestorNotObscuredBy(Set<Core.NamedPat>)", "[int]distance(int,Core.NamedPat)", "[Environment]plus(Environment)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[void]visit(Consumer<Binding>)", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[String]asString()", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Binding]getOpt(String)", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Binding]getOpt(Core.NamedPat)", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Environment]bind(Core.IdPat,Object)", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Environment]bind(Binding)", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[void]forEachType(TypeSystem,BiConsumer<String, Type>)", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[void]forEachValue(BiConsumer<String, Object>)", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Map<String, Binding>]getValueMap()", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Environment]bindAll(Iterable<Binding>)", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Environment]nearestAncestorNotObscuredBy(Set<Core.NamedPat>)", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[int]distance(int,Core.NamedPat)", "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Environment]plus(Environment)"], "overrides": null, "attributes": [], "class_docstring": " Environment for validation/compilation.\n\n<p>Every environment is immutable; when you call {@link #bind}, a new\nenvironment is created that inherits from the previous environment.\nThe new environment may obscure bindings in the old environment, but\nneither the new nor the old will ever change.\n\n<p>To create an empty environment, call {@link Environments#empty()}.\n\n@see TypeResolver.TypeEnv\n@see EvalEnv\n", "original_string": "public abstract class Environment {\n  /** Visits every variable binding in this environment.\n   *\n   * <p>Bindings that are obscured by more recent bindings of the same name\n   * are visited, but after the more obscuring bindings. */\n  abstract void visit(Consumer<Binding> consumer);\n\n  /** Converts this environment to a string.\n   *\n   * <p>This method does not override the {@link #toString()} method; if we did,\n   * debuggers would invoke it automatically, burning lots of CPU and memory. */\n  public String asString() {\n    final StringBuilder b = new StringBuilder();\n    getValueMap().forEach((k, v) ->\n        b.append(v).append(\"\\n\"));\n    return b.toString();\n  }\n\n  /** Returns the binding of {@code name} if bound, null if not. */\n  public abstract @Nullable Binding getOpt(String name);\n\n  /** Returns the binding of {@code id} if bound, null if not. */\n  public abstract @Nullable Binding getOpt(Core.NamedPat id);\n\n  /** Creates an environment that is the same as a given environment, plus one\n   * more variable. */\n  public Environment bind(Core.IdPat id, Object value) {\n    return bind(Binding.of(id, value));\n  }\n\n  protected Environment bind(Binding binding) {\n    return new Environments.SubEnvironment(this, binding);\n  }\n\n  /** Calls a consumer for each variable and its type.\n   * Does not visit obscured bindings. */\n  public void forEachType(TypeSystem typeSystem,\n      BiConsumer<String, Type> consumer) {\n    final Set<String> names = new HashSet<>();\n    visit(binding -> {\n      if (names.add(binding.id.name)) {\n        final Type type =\n            binding.value instanceof TypedValue\n                ? ((TypedValue) binding.value).typeKey().toType(typeSystem)\n                : binding.id.type;\n        consumer.accept(binding.id.name, type);\n      }\n    });\n  }\n\n  /** Calls a consumer for each variable and its value.\n   * Does not visit obscured bindings, or bindings to {@link Unit#INSTANCE}. */\n  public void forEachValue(BiConsumer<String, Object> consumer) {\n    final Set<String> names = new HashSet<>();\n    visit(binding -> {\n      if (names.add(binding.id.name) && binding.value != Unit.INSTANCE) {\n        consumer.accept(binding.id.name, binding.value);\n      }\n    });\n  }\n\n  /** Returns a map of the values and bindings. */\n  public final Map<String, Binding> getValueMap() {\n    final Map<String, Binding> valueMap = new HashMap<>();\n    visit(binding -> valueMap.putIfAbsent(binding.id.name, binding));\n    return valueMap;\n  }\n\n  /** Creates an environment that is the same as this, plus the\n   * given bindings. */\n  public final Environment bindAll(Iterable<Binding> bindings) {\n    return Environments.bind(this, bindings);\n  }\n\n  /** If this environment only defines bindings in the given set, returns\n   * its parent. Never returns null. The empty environment returns itself. */\n  abstract Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names);\n\n  abstract int distance(int soFar, Core.NamedPat id);\n\n  /** Returns this environment plus the bindings in the given environment. */\n  public Environment plus(Environment env) {\n    final List<Binding> bindingList = new ArrayList<>();\n    env.visit(bindingList::add);\n    return bindAll(reverse(bindingList));\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder", "name": "Folder", "file_path": "src/main/java/net/hydromatic/morel/util/Folder.java", "superclasses": "", "methods": ["[]Folder(E)", "[E]combine(List<Folder<E>>)", "[E]combineAll(List<Folder<E>>)", "[Folder<E>]end(E)", "[void]at(List<Folder<Ast.Exp>>,Ast.Exp)", "[void]cons(List<Folder<Ast.Exp>>,Ast.Exp)", "[void]start(List<Folder<E>>,E)", "[void]append(List<Folder<E>>,E,Function<E, Folder<E>>)", "[Folder<Ast.Exp>]op(Ast.Exp,Op)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[]Folder(E)", "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[E]combine(List<Folder<E>>)", "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[E]combineAll(List<Folder<E>>)", "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[Folder<E>]end(E)", "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[void]at(List<Folder<Ast.Exp>>,Ast.Exp)", "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[void]cons(List<Folder<Ast.Exp>>,Ast.Exp)", "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[void]start(List<Folder<E>>,E)", "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[void]append(List<Folder<E>>,E,Function<E, Folder<E>>)", "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[Folder<Ast.Exp>]op(Ast.Exp,Op)"], "overrides": null, "attributes": [{"original_string": "  private static class End<E> extends Folder<E> {\n    End(E e) {\n      super(e);\n    }\n\n    E combine(List<Folder<E>> list) {\n      assert list.isEmpty();\n      return e;\n    }\n  }", "definition": "  private static class End<E> extends Folder<E>", "class_docstring": " Sub-class of {@code Folder} that marks the end of a list.\n\n@param <E> element type", "name": "End", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    End(E e) {\n      super(e);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "End", "params": [{"name": "e", "type": "E"}], "body": "             {\n      super(e);\n    }", "signature": "End(E e)"}, {"syntax_pass": true, "original_string": "    E combine(List<Folder<E>> list) {\n      assert list.isEmpty();\n      return e;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "E", "classes": []}, "name": "combine", "params": [{"name": "list", "type": "List<Folder<E>>"}], "body": "                                    {\n      assert list.isEmpty();\n      return e;\n    }", "signature": "E combine(List<Folder<E>> list)"}]}], "class_docstring": "\nEnable creating right-deep trees.\n\n@param <E> Element type\n", "original_string": "public abstract class Folder<E> {\n  final E e;\n\n  Folder(E e) {\n    this.e = requireNonNull(e);\n  }\n\n  abstract E combine(List<Folder<E>> list);\n\n  public static <E> E combineAll(List<Folder<E>> list) {\n    if (list.size() == 0) {\n      throw new AssertionError();\n    }\n    final Folder<E> head = list.get(0);\n    final List<Folder<E>> tail = skip(list);\n    return head.combine(tail);\n  }\n\n  private static <E> Folder<E> end(E e) {\n    return new End<>(e);\n  }\n\n  /** Appends an element using \"@\". */\n  public static void at(List<Folder<Ast.Exp>> list, Ast.Exp exp) {\n    append(list, exp, e1 -> op(e1, Op.AT));\n  }\n\n  /** Appends an element using \"::\". */\n  public static void cons(List<Folder<Ast.Exp>> list, Ast.Exp exp) {\n    append(list, exp, e1 -> op(e1, Op.CONS));\n  }\n\n  /** Adds an element to an empty list. */\n  public static <E> void start(List<Folder<E>> list, E e) {\n    if (!list.isEmpty()) {\n      throw new AssertionError();\n    }\n    list.add(end(e));\n  }\n\n  /** Adds an element and operator to a non-empty list. */\n  private static <E> void append(List<Folder<E>> list, E e,\n      Function<E, Folder<E>> fn) {\n    if (list.isEmpty()) {\n      throw new AssertionError();\n    }\n    @SuppressWarnings(\"unchecked\")\n    final End<E> end = (End) list.get(list.size() - 1);\n    list.set(list.size() - 1, fn.apply(end.e));\n    list.add(end(e));\n  }\n\n  /** Creates a folder that combines an expression with whatever follows\n   * using an infix operator. */\n  private static Folder<Ast.Exp> op(Ast.Exp exp, final Op at) {\n    return new Folder<Ast.Exp>(exp) {\n      Ast.Exp combine(List<Folder<Ast.Exp>> list) {\n        final Ast.Exp rest = combineAll(list);\n        return ast.infixCall(e.pos.plus(rest.pos), at, e, rest);\n      }\n    };\n  }\n\n  /** Sub-class of {@code Folder} that marks the end of a list.\n   *\n   * @param <E> element type */\n  private static class End<E> extends Folder<E> {\n    End(E e) {\n      super(e);\n    }\n\n    E combine(List<Folder<E>> list) {\n      assert list.isEmpty();\n      return e;\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final E e;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "E", "name": "e", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "name": "AbstractImmutableList", "file_path": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "superclasses": "", "methods": ["[List<E>]toList()", "[Iterator<E>]iterator()", "[ListIterator<E>]listIterator()", "[boolean]isEmpty()", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[boolean]addAll(int,Collection<? extends E>)", "[boolean]removeAll(Collection<?>)", "[boolean]retainAll(Collection<?>)", "[void]clear()", "[E]set(int,E)", "[void]add(int,E)", "[E]remove(int)", "[ListIterator<E>]listIterator(int)", "[List<E>]subList(int,int)", "[boolean]contains(Object)", "[boolean]containsAll(Collection<?>)", "[boolean]remove(Object)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[List<E>]toList()", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[Iterator<E>]iterator()", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[ListIterator<E>]listIterator()", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]isEmpty()", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]add(E)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]addAll(Collection<? extends E>)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]removeAll(Collection<?>)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]retainAll(Collection<?>)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[void]clear()", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[E]set(int,E)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[void]add(int,E)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[E]remove(int)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[ListIterator<E>]listIterator(int)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[List<E>]subList(int,int)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]contains(Object)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]containsAll(Collection<?>)", "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]remove(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nBase class for lists whose contents are constant after creation.\n\n@param <E> Element type\n", "original_string": "abstract class AbstractImmutableList<E> implements List<E> {\n  protected abstract List<E> toList();\n\n  @NonNull public Iterator<E> iterator() {\n    return toList().iterator();\n  }\n\n  @NonNull public ListIterator<E> listIterator() {\n    return toList().listIterator();\n  }\n\n  public boolean isEmpty() {\n    return false;\n  }\n\n  public boolean add(E t) {\n    throw new UnsupportedOperationException();\n  }\n\n  public boolean addAll(@NonNull Collection<? extends E> c) {\n    throw new UnsupportedOperationException();\n  }\n\n  public boolean addAll(int index, @NonNull Collection<? extends E> c) {\n    throw new UnsupportedOperationException();\n  }\n\n  public boolean removeAll(@NonNull Collection<?> c) {\n    throw new UnsupportedOperationException();\n  }\n\n  public boolean retainAll(@NonNull Collection<?> c) {\n    throw new UnsupportedOperationException();\n  }\n\n  public void clear() {\n    throw new UnsupportedOperationException();\n  }\n\n  public E set(int index, E element) {\n    throw new UnsupportedOperationException();\n  }\n\n  public void add(int index, E element) {\n    throw new UnsupportedOperationException();\n  }\n\n  public E remove(int index) {\n    throw new UnsupportedOperationException();\n  }\n\n  @NonNull public ListIterator<E> listIterator(int index) {\n    return toList().listIterator(index);\n  }\n\n  @NonNull public List<E> subList(int fromIndex, int toIndex) {\n    return toList().subList(fromIndex, toIndex);\n  }\n\n  public boolean contains(Object o) {\n    return indexOf(o) >= 0;\n  }\n\n  public boolean containsAll(@NonNull Collection<?> c) {\n    for (Object o : c) {\n      if (!contains(o)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public boolean remove(Object o) {\n    throw new UnsupportedOperationException();\n  }\n}", "super_interfaces": ["List<E>"], "fields": []}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "name": "Unifier", "file_path": "src/main/java/net/hydromatic/morel/util/Unifier.java", "superclasses": "", "methods": ["[boolean]occurs()", "[Sequence]apply(String)", "[Sequence]apply(String,Iterable<? extends Term>)", "[Variable]variable(String)", "[Variable]variable(int)", "[Variable]variable()", "[Term]atom(String)", "[Substitution]substitution()", "[Sequence]sequenceApply(String,Map<Variable, Term>,Iterable<Term>)", "[Result]unify(List<TermTerm>,Map<Variable, Action>,Tracer)", "[void]checkCycles(Map<Variable, Term>,Map<Variable, Variable>)", "[Failure]failure(String)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[boolean]occurs()", "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Sequence]apply(String)", "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Sequence]apply(String,Iterable<? extends Term>)", "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Variable]variable(String)", "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Variable]variable(int)", "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Variable]variable()", "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Term]atom(String)", "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Substitution]substitution()", "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Sequence]sequenceApply(String,Map<Variable, Term>,Iterable<Term>)", "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Result]unify(List<TermTerm>,Map<Variable, Action>,Tracer)", "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[void]checkCycles(Map<Variable, Term>,Map<Variable, Variable>)", "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Failure]failure(String)"], "overrides": null, "attributes": [{"original_string": "  public static class Failure implements Result {\n  }", "definition": "  public static class Failure implements Result", "class_docstring": " Result indicating that unification was not possible.", "name": "Failure", "super_interfaces": ["Result"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "  public static final class SubstitutionResult extends Substitution\n      implements Result {\n    private SubstitutionResult(Map<Variable, Term> resultMap) {\n      super(ImmutableSortedMap.copyOf(resultMap));\n    }\n\n    /** Empty substitution result. */\n    public static final SubstitutionResult EMPTY =\n        create(ImmutableSortedMap.of());\n\n    /** Creates a substitution result from a map. */\n    public static SubstitutionResult create(Map<Variable, Term> resultMap) {\n      return new SubstitutionResult(ImmutableSortedMap.copyOf(resultMap));\n    }\n\n    /** Creates a substitution result with one (variable, term) entry. */\n    public static SubstitutionResult create(Variable v, Term t) {\n      return new SubstitutionResult(ImmutableSortedMap.of(v, t));\n    }\n  }", "definition": "  public static final class SubstitutionResult extends Substitution\n      implements Result", "class_docstring": " The results of a successful unification. Gives access to the raw variable\nmapping that resulted from the algorithm, but can also resolve a variable\nto the fullest extent possible with the {@link #resolve} method.", "name": "SubstitutionResult", "super_interfaces": ["Result"], "superclasses": "Substitution", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "public static final SubstitutionResult EMPTY =\n        create(ImmutableSortedMap.of());", "docstring": " Empty substitution result.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "SubstitutionResult", "name": "EMPTY =\n        create(ImmutableSortedMap.of())", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private SubstitutionResult(Map<Variable, Term> resultMap) {\n      super(ImmutableSortedMap.copyOf(resultMap));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "SubstitutionResult", "params": [{"name": "resultMap", "type": "Map<Variable, Term>"}], "body": "                                                              {\n      super(ImmutableSortedMap.copyOf(resultMap));\n    }", "signature": "private SubstitutionResult(Map<Variable, Term> resultMap)"}, {"syntax_pass": true, "original_string": "    public static SubstitutionResult create(Map<Variable, Term> resultMap) {\n      return new SubstitutionResult(ImmutableSortedMap.copyOf(resultMap));\n    }", "docstring": " Creates a substitution result from a map.", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SubstitutionResult", "classes": []}, "name": "create", "params": [{"name": "resultMap", "type": "Map<Variable, Term>"}], "body": "                                                                           {\n      return new SubstitutionResult(ImmutableSortedMap.copyOf(resultMap));\n    }", "signature": "public static SubstitutionResult create(Map<Variable, Term> resultMap)"}, {"syntax_pass": true, "original_string": "    public static SubstitutionResult create(Variable v, Term t) {\n      return new SubstitutionResult(ImmutableSortedMap.of(v, t));\n    }", "docstring": " Creates a substitution result with one (variable, term) entry.", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SubstitutionResult", "classes": []}, "name": "create", "params": [{"name": "v", "type": "Variable"}, {"name": "t", "type": "Term"}], "body": "                                                                {\n      return new SubstitutionResult(ImmutableSortedMap.of(v, t));\n    }", "signature": "public static SubstitutionResult create(Variable v, Term t)"}]}, {"original_string": "  public static class Substitution {\n    /** The result of the unification algorithm proper. This does not have\n     * everything completely resolved: some variable substitutions are required\n     * before getting the most atom-y representation. */\n    public final Map<Variable, Term> resultMap;\n\n    Substitution(Map<Variable, Term> resultMap) {\n      this.resultMap = resultMap;\n    }\n\n    @Override public int hashCode() {\n      return resultMap.hashCode();\n    }\n\n    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof Substitution\n          && resultMap.equals(((Substitution) obj).resultMap);\n    }\n\n    @Override public String toString() {\n      return accept(new StringBuilder()).toString();\n    }\n\n    public StringBuilder accept(StringBuilder buf) {\n      buf.append(\"[\");\n      forEachIndexed(resultMap, (i, variable, term) ->\n          buf.append(i > 0 ? \", \" : \"\").append(term)\n              .append(\"/\").append(variable));\n      return buf.append(\"]\");\n    }\n\n    public Term resolve(Term term) {\n      Term previous;\n      Term current = term;\n      do {\n        previous = current;\n        current = current.apply(resultMap);\n      } while (!current.equals(previous));\n      return current;\n    }\n\n    private boolean hasCycles(Map<Variable, Term> map) {\n      try {\n        checkCycles(map, new IdentityHashMap<>());\n        return false;\n      } catch (CycleException e) {\n        return true;\n      }\n    }\n\n    public Substitution resolve() {\n      if (hasCycles(resultMap)) {\n        return this;\n      }\n      final ImmutableMap.Builder<Variable, Term> builder =\n          ImmutableMap.builder();\n      resultMap.forEach((key, value) -> builder.put(key, resolve(value)));\n      return new Substitution(builder.build());\n    }\n  }", "definition": "  public static class Substitution", "class_docstring": " Map from variables to terms.\n\n<p>Quicker to create than its sub-class {@link SubstitutionResult}\nbecause the map is mutable and not sorted.", "name": "Substitution", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final Map<Variable, Term> resultMap;", "docstring": " The result of the unification algorithm proper. This does not have\neverything completely resolved: some variable substitutions are required\nbefore getting the most atom-y representation.", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Map<Variable, Term>", "name": "resultMap", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Substitution(Map<Variable, Term> resultMap) {\n      this.resultMap = resultMap;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Substitution", "params": [{"name": "resultMap", "type": "Map<Variable, Term>"}], "body": "                                                {\n      this.resultMap = resultMap;\n    }", "signature": "Substitution(Map<Variable, Term> resultMap)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return resultMap.hashCode();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return resultMap.hashCode();\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof Substitution\n          && resultMap.equals(((Substitution) obj).resultMap);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return this == obj\n          || obj instanceof Substitution\n          && resultMap.equals(((Substitution) obj).resultMap);\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return accept(new StringBuilder()).toString();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return accept(new StringBuilder()).toString();\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    public StringBuilder accept(StringBuilder buf) {\n      buf.append(\"[\");\n      forEachIndexed(resultMap, (i, variable, term) ->\n          buf.append(i > 0 ? \", \" : \"\").append(term)\n              .append(\"/\").append(variable));\n      return buf.append(\"]\");\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "accept", "params": [{"name": "buf", "type": "StringBuilder"}], "body": "                                                   {\n      buf.append(\"[\");\n      forEachIndexed(resultMap, (i, variable, term) ->\n          buf.append(i > 0 ? \", \" : \"\").append(term)\n              .append(\"/\").append(variable));\n      return buf.append(\"]\");\n    }", "signature": "public StringBuilder accept(StringBuilder buf)"}, {"syntax_pass": true, "original_string": "    public Term resolve(Term term) {\n      Term previous;\n      Term current = term;\n      do {\n        previous = current;\n        current = current.apply(resultMap);\n      } while (!current.equals(previous));\n      return current;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Term", "classes": []}, "name": "resolve", "params": [{"name": "term", "type": "Term"}], "body": "                                   {\n      Term previous;\n      Term current = term;\n      do {\n        previous = current;\n        current = current.apply(resultMap);\n      } while (!current.equals(previous));\n      return current;\n    }", "signature": "public Term resolve(Term term)"}, {"syntax_pass": true, "original_string": "    private boolean hasCycles(Map<Variable, Term> map) {\n      try {\n        checkCycles(map, new IdentityHashMap<>());\n        return false;\n      } catch (CycleException e) {\n        return true;\n      }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasCycles", "params": [{"name": "map", "type": "Map<Variable, Term>"}], "body": "                                                       {\n      try {\n        checkCycles(map, new IdentityHashMap<>());\n        return false;\n      } catch (CycleException e) {\n        return true;\n      }\n    }", "signature": "private boolean hasCycles(Map<Variable, Term> map)"}, {"syntax_pass": true, "original_string": "    public Substitution resolve() {\n      if (hasCycles(resultMap)) {\n        return this;\n      }\n      final ImmutableMap.Builder<Variable, Term> builder =\n          ImmutableMap.builder();\n      resultMap.forEach((key, value) -> builder.put(key, resolve(value)));\n      return new Substitution(builder.build());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Substitution", "classes": []}, "name": "resolve", "params": [], "body": "                                  {\n      if (hasCycles(resultMap)) {\n        return this;\n      }\n      final ImmutableMap.Builder<Variable, Term> builder =\n          ImmutableMap.builder();\n      resultMap.forEach((key, value) -> builder.put(key, resolve(value)));\n      return new Substitution(builder.build());\n    }", "signature": "public Substitution resolve()"}]}, {"original_string": "  private static class CycleException extends Exception {\n  }", "definition": "  private static class CycleException extends Exception", "class_docstring": " Control flow exception, thrown by {@link Term#checkCycle(Map, Map)} if\nit finds a cycle in a substitution map.", "name": "CycleException", "super_interfaces": [], "superclasses": "Exception", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "  public static final class Variable implements Term, Comparable<Variable> {\n    final String name;\n    final int ordinal;\n\n    Variable(String name, int ordinal) {\n      this.name = requireNonNull(name);\n      this.ordinal = ordinal;\n      checkArgument(name.equals(name.toUpperCase(Locale.ROOT)),\n          \"must be upper case: %s\", name);\n    }\n\n    /** Creates a variable with a name. The name must not be like \"T0\" or\n     * \"T123\", because those are the names created for variables with\n     * ordinals. */\n    Variable(String name) {\n      this(name, -1);\n      checkArgument(!name.matches(\"T[0-9]+\"), name);\n    }\n\n    /** Creates a variable with an ordinal. If the ordinal is \"34\" the name will\n     * be \"T34\". The ordinal must be non-negative. */\n    Variable(int ordinal) {\n      this(\"T\" + ordinal, ordinal);\n      checkArgument(ordinal >= 0, ordinal);\n    }\n\n    @Override public String toString() {\n      return name;\n    }\n\n    @Override public int compareTo(Variable o) {\n      int c = Integer.compare(ordinal, o.ordinal);\n      if (c == 0) {\n        c = name.compareTo(o.name);\n      }\n      return c;\n    }\n\n    public Term apply(Map<Variable, Term> substitutions) {\n      return substitutions.getOrDefault(this, this);\n    }\n\n    public boolean contains(Variable variable) {\n      return variable == this;\n    }\n\n    public void checkCycle(Map<Variable, Term> map,\n        Map<Variable, Variable> active) throws CycleException {\n      final Term term = map.get(this);\n      if (term != null) {\n        if (active.put(this, this) != null) {\n          throw new CycleException();\n        }\n        term.checkCycle(map, active);\n        active.remove(this);\n      }\n    }\n\n    public <R> R accept(TermVisitor<R> visitor) {\n      return visitor.visit(this);\n    }\n  }", "definition": "  public static final class Variable implements Term, Comparable<Variable>", "class_docstring": " A variable that represents a symbol or a sequence; unification's\ntask is to find the substitutions for such variables.", "name": "Variable", "super_interfaces": ["Term", "Comparable<Variable>"], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "final String name;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "final int ordinal;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "ordinal", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Variable(String name, int ordinal) {\n      this.name = requireNonNull(name);\n      this.ordinal = ordinal;\n      checkArgument(name.equals(name.toUpperCase(Locale.ROOT)),\n          \"must be upper case: %s\", name);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Variable", "params": [{"name": "name", "type": "String"}, {"name": "ordinal", "type": "int"}], "body": "                                       {\n      this.name = requireNonNull(name);\n      this.ordinal = ordinal;\n      checkArgument(name.equals(name.toUpperCase(Locale.ROOT)),\n          \"must be upper case: %s\", name);\n    }", "signature": "Variable(String name, int ordinal)"}, {"syntax_pass": true, "original_string": "    Variable(String name) {\n      this(name, -1);\n      checkArgument(!name.matches(\"T[0-9]+\"), name);\n    }", "docstring": " Creates a variable with a name. The name must not be like \"T0\" or\n\"T123\", because those are the names created for variables with\nordinals.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Variable", "params": [{"name": "name", "type": "String"}], "body": "                          {\n      this(name, -1);\n      checkArgument(!name.matches(\"T[0-9]+\"), name);\n    }", "signature": "Variable(String name)"}, {"syntax_pass": true, "original_string": "    Variable(int ordinal) {\n      this(\"T\" + ordinal, ordinal);\n      checkArgument(ordinal >= 0, ordinal);\n    }", "docstring": " Creates a variable with an ordinal. If the ordinal is \"34\" the name will\nbe \"T34\". The ordinal must be non-negative.", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Variable", "params": [{"name": "ordinal", "type": "int"}], "body": "                          {\n      this(\"T\" + ordinal, ordinal);\n      checkArgument(ordinal >= 0, ordinal);\n    }", "signature": "Variable(int ordinal)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return name;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return name;\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    @Override public int compareTo(Variable o) {\n      int c = Integer.compare(ordinal, o.ordinal);\n      if (c == 0) {\n        c = name.compareTo(o.name);\n      }\n      return c;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compareTo", "params": [{"name": "o", "type": "Variable"}], "body": "                                               {\n      int c = Integer.compare(ordinal, o.ordinal);\n      if (c == 0) {\n        c = name.compareTo(o.name);\n      }\n      return c;\n    }", "signature": "@Override public int compareTo(Variable o)"}, {"syntax_pass": true, "original_string": "    public Term apply(Map<Variable, Term> substitutions) {\n      return substitutions.getOrDefault(this, this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Term", "classes": []}, "name": "apply", "params": [{"name": "substitutions", "type": "Map<Variable, Term>"}], "body": "                                                         {\n      return substitutions.getOrDefault(this, this);\n    }", "signature": "public Term apply(Map<Variable, Term> substitutions)"}, {"syntax_pass": true, "original_string": "    public boolean contains(Variable variable) {\n      return variable == this;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "variable", "type": "Variable"}], "body": "                                               {\n      return variable == this;\n    }", "signature": "public boolean contains(Variable variable)"}, {"syntax_pass": true, "original_string": "    public void checkCycle(Map<Variable, Term> map,\n        Map<Variable, Variable> active) throws CycleException {\n      final Term term = map.get(this);\n      if (term != null) {\n        if (active.put(this, this) != null) {\n          throw new CycleException();\n        }\n        term.checkCycle(map, active);\n        active.remove(this);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "checkCycle", "params": [{"name": "map", "type": "Map<Variable, Term>"}, {"name": "active", "type": "Map<Variable, Variable>"}], "body": "                                                              {\n      final Term term = map.get(this);\n      if (term != null) {\n        if (active.put(this, this) != null) {\n          throw new CycleException();\n        }\n        term.checkCycle(map, active);\n        active.remove(this);\n      }\n    }", "signature": "public void checkCycle(Map<Variable, Term> map,\n        Map<Variable, Variable> active)"}, {"syntax_pass": true, "original_string": "    public <R> R accept(TermVisitor<R> visitor) {\n      return visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "TermVisitor<R>"}], "body": "                                                {\n      return visitor.visit(this);\n    }", "signature": "public <R> R accept(TermVisitor<R> visitor)"}]}, {"original_string": "  public static final class TermTerm {\n    final Term left;\n    final Term right;\n\n    public TermTerm(Term left, Term right) {\n      this.left = requireNonNull(left);\n      this.right = requireNonNull(right);\n    }\n\n    @Override public String toString() {\n      return left + \" = \" + right;\n    }\n  }", "definition": "  public static final class TermTerm", "class_docstring": " A pair of terms.", "name": "TermTerm", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "final Term left;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Term", "name": "left", "syntax_pass": true}, {"attribute_expression": "final Term right;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Term", "name": "right", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public TermTerm(Term left, Term right) {\n      this.left = requireNonNull(left);\n      this.right = requireNonNull(right);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TermTerm", "params": [{"name": "left", "type": "Term"}, {"name": "right", "type": "Term"}], "body": "                                           {\n      this.left = requireNonNull(left);\n      this.right = requireNonNull(right);\n    }", "signature": "public TermTerm(Term left, Term right)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return left + \" = \" + right;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return left + \" = \" + right;\n    }", "signature": "@Override public String toString()"}]}, {"original_string": "  public static final class Sequence implements Term {\n    public final String operator;\n    public final List<Term> terms;\n\n    Sequence(String operator, List<Term> terms) {\n      this.operator = requireNonNull(operator);\n      this.terms = ImmutableList.copyOf(terms);\n    }\n\n    Sequence(String operator) {\n      this(operator, ImmutableList.of());\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(operator, terms);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof Sequence\n          && operator.equals(((Sequence) obj).operator)\n          && terms.equals(((Sequence) obj).terms);\n    }\n\n    @Override public String toString() {\n      if (terms.isEmpty()) {\n        return operator;\n      }\n      final StringBuilder builder = new StringBuilder(operator).append('(');\n      for (int i = 0; i < terms.size(); i++) {\n        Term term = terms.get(i);\n        if (i > 0) {\n          builder.append(\", \");\n        }\n        builder.append(term);\n      }\n      return builder.append(')').toString();\n    }\n\n    public Term apply(Map<Variable, Term> substitutions) {\n      final Sequence sequence = sequenceApply(operator, substitutions, terms);\n      if (sequence.equalsShallow(this)) {\n        return this;\n      }\n      return sequence;\n    }\n\n    public void checkCycle(Map<Variable, Term> map,\n        Map<Variable, Variable> active) throws CycleException {\n      for (Term term : terms) {\n        term.checkCycle(map, active);\n      }\n    }\n\n    /** Compares whether two sequences have the same terms.\n     * Compares addresses, not contents, to avoid hitting cycles\n     * if any of the terms are cyclic (e.g. \"X = f(X)\"). */\n    private boolean equalsShallow(Sequence sequence) {\n      return this == sequence || listEqual(terms, sequence.terms);\n    }\n\n    private static <E> boolean listEqual(List<E> list0, List<E> list1) {\n      if (list0.size() != list1.size()) {\n        return false;\n      }\n      for (int i = 0; i < list0.size(); i++) {\n        if (list0.get(i) != list1.get(i)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    public boolean contains(Variable variable) {\n      for (Term term : terms) {\n        if (term.contains(variable)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    public <R> R accept(TermVisitor<R> visitor) {\n      return visitor.visit(this);\n    }\n  }", "definition": "  public static final class Sequence implements Term", "class_docstring": " A sequence of terms.\n\n<p>A sequence [a b c] is often printed \"a(b, c)\", as if \"a\" is the type of\nnode and \"b\" and \"c\" are its children.", "name": "Sequence", "super_interfaces": ["Term"], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "public final String operator;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "operator", "syntax_pass": true}, {"attribute_expression": "public final List<Term> terms;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Term>", "name": "terms", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Sequence(String operator, List<Term> terms) {\n      this.operator = requireNonNull(operator);\n      this.terms = ImmutableList.copyOf(terms);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Sequence", "params": [{"name": "operator", "type": "String"}, {"name": "terms", "type": "List<Term>"}], "body": "                                                {\n      this.operator = requireNonNull(operator);\n      this.terms = ImmutableList.copyOf(terms);\n    }", "signature": "Sequence(String operator, List<Term> terms)"}, {"syntax_pass": true, "original_string": "    Sequence(String operator) {\n      this(operator, ImmutableList.of());\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Sequence", "params": [{"name": "operator", "type": "String"}], "body": "                              {\n      this(operator, ImmutableList.of());\n    }", "signature": "Sequence(String operator)"}, {"syntax_pass": true, "original_string": "    @Override public int hashCode() {\n      return Objects.hash(operator, terms);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                    {\n      return Objects.hash(operator, terms);\n    }", "signature": "@Override public int hashCode()"}, {"syntax_pass": true, "original_string": "    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof Sequence\n          && operator.equals(((Sequence) obj).operator)\n          && terms.equals(((Sequence) obj).terms);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n      return this == obj\n          || obj instanceof Sequence\n          && operator.equals(((Sequence) obj).operator)\n          && terms.equals(((Sequence) obj).terms);\n    }", "signature": "@Override public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      if (terms.isEmpty()) {\n        return operator;\n      }\n      final StringBuilder builder = new StringBuilder(operator).append('(');\n      for (int i = 0; i < terms.size(); i++) {\n        Term term = terms.get(i);\n        if (i > 0) {\n          builder.append(\", \");\n        }\n        builder.append(term);\n      }\n      return builder.append(')').toString();\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      if (terms.isEmpty()) {\n        return operator;\n      }\n      final StringBuilder builder = new StringBuilder(operator).append('(');\n      for (int i = 0; i < terms.size(); i++) {\n        Term term = terms.get(i);\n        if (i > 0) {\n          builder.append(\", \");\n        }\n        builder.append(term);\n      }\n      return builder.append(')').toString();\n    }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "    public Term apply(Map<Variable, Term> substitutions) {\n      final Sequence sequence = sequenceApply(operator, substitutions, terms);\n      if (sequence.equalsShallow(this)) {\n        return this;\n      }\n      return sequence;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Term", "classes": []}, "name": "apply", "params": [{"name": "substitutions", "type": "Map<Variable, Term>"}], "body": "                                                         {\n      final Sequence sequence = sequenceApply(operator, substitutions, terms);\n      if (sequence.equalsShallow(this)) {\n        return this;\n      }\n      return sequence;\n    }", "signature": "public Term apply(Map<Variable, Term> substitutions)"}, {"syntax_pass": true, "original_string": "    public void checkCycle(Map<Variable, Term> map,\n        Map<Variable, Variable> active) throws CycleException {\n      for (Term term : terms) {\n        term.checkCycle(map, active);\n      }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "checkCycle", "params": [{"name": "map", "type": "Map<Variable, Term>"}, {"name": "active", "type": "Map<Variable, Variable>"}], "body": "                                                              {\n      for (Term term : terms) {\n        term.checkCycle(map, active);\n      }\n    }", "signature": "public void checkCycle(Map<Variable, Term> map,\n        Map<Variable, Variable> active)"}, {"syntax_pass": true, "original_string": "    private boolean equalsShallow(Sequence sequence) {\n      return this == sequence || listEqual(terms, sequence.terms);\n    }", "docstring": " Compares whether two sequences have the same terms.\nCompares addresses, not contents, to avoid hitting cycles\nif any of the terms are cyclic (e.g. \"X = f(X)\").", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equalsShallow", "params": [{"name": "sequence", "type": "Sequence"}], "body": "                                                     {\n      return this == sequence || listEqual(terms, sequence.terms);\n    }", "signature": "private boolean equalsShallow(Sequence sequence)"}, {"syntax_pass": true, "original_string": "    private static <E> boolean listEqual(List<E> list0, List<E> list1) {\n      if (list0.size() != list1.size()) {\n        return false;\n      }\n      for (int i = 0; i < list0.size(); i++) {\n        if (list0.get(i) != list1.get(i)) {\n          return false;\n        }\n      }\n      return true;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "listEqual", "params": [{"name": "list0", "type": "List<E>"}, {"name": "list1", "type": "List<E>"}], "body": "                                                                       {\n      if (list0.size() != list1.size()) {\n        return false;\n      }\n      for (int i = 0; i < list0.size(); i++) {\n        if (list0.get(i) != list1.get(i)) {\n          return false;\n        }\n      }\n      return true;\n    }", "signature": "private static <E> boolean listEqual(List<E> list0, List<E> list1)"}, {"syntax_pass": true, "original_string": "    public boolean contains(Variable variable) {\n      for (Term term : terms) {\n        if (term.contains(variable)) {\n          return true;\n        }\n      }\n      return false;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "variable", "type": "Variable"}], "body": "                                               {\n      for (Term term : terms) {\n        if (term.contains(variable)) {\n          return true;\n        }\n      }\n      return false;\n    }", "signature": "public boolean contains(Variable variable)"}, {"syntax_pass": true, "original_string": "    public <R> R accept(TermVisitor<R> visitor) {\n      return visitor.visit(this);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "name": "accept", "params": [{"name": "visitor", "type": "TermVisitor<R>"}], "body": "                                                {\n      return visitor.visit(this);\n    }", "signature": "public <R> R accept(TermVisitor<R> visitor)"}]}], "class_docstring": " Given pairs of terms, finds a substitution to minimize those pairs of\nterms.", "original_string": "public abstract class Unifier {\n  private int varId;\n  private final Map<String, Variable> variableMap = new HashMap<>();\n  private final Map<String, Sequence> atomMap = new HashMap<>();\n  private final Map<String, Sequence> sequenceMap = new HashMap<>();\n\n  /** Whether this unifier checks for cycles in substitutions. */\n  public boolean occurs() {\n    return false;\n  }\n\n  /** Creates a sequence, or returns an existing one with the same terms. */\n  public Sequence apply(String operator, Term... args) {\n    return apply(operator, ImmutableList.copyOf(args));\n  }\n\n  /** Creates a sequence, or returns an existing one with the same terms. */\n  public Sequence apply(String operator, Iterable<? extends Term> args) {\n    final Sequence sequence =\n        new Sequence(operator, ImmutableList.copyOf(args));\n    return sequenceMap.computeIfAbsent(sequence.toString(), n -> sequence);\n  }\n\n  /** Creates a variable, or returns an existing one with the same name. */\n  public Variable variable(String name) {\n    return variableMap.computeIfAbsent(name, Variable::new);\n  }\n\n  /** Creates a variable, or returns an existing one with the same ordinal. */\n  public Variable variable(int ordinal) {\n    String name = \"T\" + ordinal;\n    return variableMap.computeIfAbsent(name, name2 -> new Variable(ordinal));\n  }\n\n  /** Creates a new variable, with a new name. */\n  public Variable variable() {\n    for (;;) {\n      final int ordinal = varId++;\n      final String name = \"T\" + ordinal;\n      if (!variableMap.containsKey(name)) {\n        final Variable variable = new Variable(ordinal);\n        assert variable.name.equals(name);\n        variableMap.put(name, variable);\n        return variable;\n      }\n    }\n  }\n\n  /** Creates an atom, or returns an existing one with the same name. */\n  public Term atom(String name) {\n    return atomMap.computeIfAbsent(name, Sequence::new);\n  }\n\n  /** Creates a substitution.\n   *\n   * <p>The arguments are alternating variable / term pairs. For example,\n   * {@code substitution(a, x, b, y)} becomes [a/X, b/Y]. */\n  public Substitution substitution(Term... varTerms) {\n    final ImmutableMap.Builder<Variable, Term> mapBuilder =\n        ImmutableMap.builder();\n    if (varTerms.length % 2 != 0) {\n      throw new AssertionError();\n    }\n    for (int i = 0; i < varTerms.length; i += 2) {\n      mapBuilder.put((Variable) varTerms[i + 1], varTerms[i]);\n    }\n    return new Substitution(mapBuilder.build());\n  }\n\n  static Sequence sequenceApply(String operator,\n      Map<Variable, Term> substitutions, Iterable<Term> terms) {\n    final ImmutableList.Builder<Term> newTerms = ImmutableList.builder();\n    for (Term term : terms) {\n      newTerms.add(term.apply(substitutions));\n    }\n    return new Sequence(operator, newTerms.build());\n  }\n\n  public abstract @NonNull Result unify(List<TermTerm> termPairs,\n      Map<Variable, Action> termActions, Tracer tracer);\n\n  private static void checkCycles(Map<Variable, Term> map,\n      Map<Variable, Variable> active) throws CycleException {\n    for (Term term : map.values()) {\n      term.checkCycle(map, active);\n    }\n  }\n\n  protected Failure failure(String reason) {\n    return new Failure() {\n      @Override public String toString() {\n        return reason;\n      }\n    };\n  }\n\n  /** Called by the unifier when a Term's type becomes known. */\n  @FunctionalInterface\n  public interface Action {\n    void accept(Variable variable, Term term, Substitution substitution,\n        List<TermTerm> termPairs);\n  }\n\n  /** Result of attempting unification. A success is {@link Substitution},\n   * but there are other failures. */\n  public interface Result {\n  }\n\n  /** Result indicating that unification was not possible. */\n  public static class Failure implements Result {\n  }\n\n  /** The results of a successful unification. Gives access to the raw variable\n   * mapping that resulted from the algorithm, but can also resolve a variable\n   * to the fullest extent possible with the {@link #resolve} method. */\n  public static final class SubstitutionResult extends Substitution\n      implements Result {\n    private SubstitutionResult(Map<Variable, Term> resultMap) {\n      super(ImmutableSortedMap.copyOf(resultMap));\n    }\n\n    /** Empty substitution result. */\n    public static final SubstitutionResult EMPTY =\n        create(ImmutableSortedMap.of());\n\n    /** Creates a substitution result from a map. */\n    public static SubstitutionResult create(Map<Variable, Term> resultMap) {\n      return new SubstitutionResult(ImmutableSortedMap.copyOf(resultMap));\n    }\n\n    /** Creates a substitution result with one (variable, term) entry. */\n    public static SubstitutionResult create(Variable v, Term t) {\n      return new SubstitutionResult(ImmutableSortedMap.of(v, t));\n    }\n  }\n\n  /** Map from variables to terms.\n   *\n   * <p>Quicker to create than its sub-class {@link SubstitutionResult}\n   * because the map is mutable and not sorted. */\n  public static class Substitution {\n    /** The result of the unification algorithm proper. This does not have\n     * everything completely resolved: some variable substitutions are required\n     * before getting the most atom-y representation. */\n    public final Map<Variable, Term> resultMap;\n\n    Substitution(Map<Variable, Term> resultMap) {\n      this.resultMap = resultMap;\n    }\n\n    @Override public int hashCode() {\n      return resultMap.hashCode();\n    }\n\n    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof Substitution\n          && resultMap.equals(((Substitution) obj).resultMap);\n    }\n\n    @Override public String toString() {\n      return accept(new StringBuilder()).toString();\n    }\n\n    public StringBuilder accept(StringBuilder buf) {\n      buf.append(\"[\");\n      forEachIndexed(resultMap, (i, variable, term) ->\n          buf.append(i > 0 ? \", \" : \"\").append(term)\n              .append(\"/\").append(variable));\n      return buf.append(\"]\");\n    }\n\n    public Term resolve(Term term) {\n      Term previous;\n      Term current = term;\n      do {\n        previous = current;\n        current = current.apply(resultMap);\n      } while (!current.equals(previous));\n      return current;\n    }\n\n    private boolean hasCycles(Map<Variable, Term> map) {\n      try {\n        checkCycles(map, new IdentityHashMap<>());\n        return false;\n      } catch (CycleException e) {\n        return true;\n      }\n    }\n\n    public Substitution resolve() {\n      if (hasCycles(resultMap)) {\n        return this;\n      }\n      final ImmutableMap.Builder<Variable, Term> builder =\n          ImmutableMap.builder();\n      resultMap.forEach((key, value) -> builder.put(key, resolve(value)));\n      return new Substitution(builder.build());\n    }\n  }\n\n  /** Term (variable, symbol or node). */\n  public interface Term {\n    Term apply(Map<Variable, Term> substitutions);\n\n    boolean contains(Variable variable);\n\n    /** Throws CycleException if expanding this term leads to a cycle. */\n    void checkCycle(Map<Variable, Term> map, Map<Variable, Variable> active)\n        throws CycleException;\n\n    <R> R accept(TermVisitor<R> visitor);\n  }\n\n  /** Visitor for terms.\n   *\n   * @param <R> return type\n   *\n   * @see Term#accept(TermVisitor) */\n  public interface TermVisitor<R> {\n    R visit(Sequence sequence);\n    R visit(Variable variable);\n  }\n\n  /** Control flow exception, thrown by {@link Term#checkCycle(Map, Map)} if\n   * it finds a cycle in a substitution map. */\n  private static class CycleException extends Exception {\n  }\n\n  /** A variable that represents a symbol or a sequence; unification's\n   * task is to find the substitutions for such variables. */\n  public static final class Variable implements Term, Comparable<Variable> {\n    final String name;\n    final int ordinal;\n\n    Variable(String name, int ordinal) {\n      this.name = requireNonNull(name);\n      this.ordinal = ordinal;\n      checkArgument(name.equals(name.toUpperCase(Locale.ROOT)),\n          \"must be upper case: %s\", name);\n    }\n\n    /** Creates a variable with a name. The name must not be like \"T0\" or\n     * \"T123\", because those are the names created for variables with\n     * ordinals. */\n    Variable(String name) {\n      this(name, -1);\n      checkArgument(!name.matches(\"T[0-9]+\"), name);\n    }\n\n    /** Creates a variable with an ordinal. If the ordinal is \"34\" the name will\n     * be \"T34\". The ordinal must be non-negative. */\n    Variable(int ordinal) {\n      this(\"T\" + ordinal, ordinal);\n      checkArgument(ordinal >= 0, ordinal);\n    }\n\n    @Override public String toString() {\n      return name;\n    }\n\n    @Override public int compareTo(Variable o) {\n      int c = Integer.compare(ordinal, o.ordinal);\n      if (c == 0) {\n        c = name.compareTo(o.name);\n      }\n      return c;\n    }\n\n    public Term apply(Map<Variable, Term> substitutions) {\n      return substitutions.getOrDefault(this, this);\n    }\n\n    public boolean contains(Variable variable) {\n      return variable == this;\n    }\n\n    public void checkCycle(Map<Variable, Term> map,\n        Map<Variable, Variable> active) throws CycleException {\n      final Term term = map.get(this);\n      if (term != null) {\n        if (active.put(this, this) != null) {\n          throw new CycleException();\n        }\n        term.checkCycle(map, active);\n        active.remove(this);\n      }\n    }\n\n    public <R> R accept(TermVisitor<R> visitor) {\n      return visitor.visit(this);\n    }\n  }\n\n  /** A pair of terms. */\n  public static final class TermTerm {\n    final Term left;\n    final Term right;\n\n    public TermTerm(Term left, Term right) {\n      this.left = requireNonNull(left);\n      this.right = requireNonNull(right);\n    }\n\n    @Override public String toString() {\n      return left + \" = \" + right;\n    }\n  }\n\n  /** A sequence of terms.\n   *\n   * <p>A sequence [a b c] is often printed \"a(b, c)\", as if \"a\" is the type of\n   * node and \"b\" and \"c\" are its children. */\n  public static final class Sequence implements Term {\n    public final String operator;\n    public final List<Term> terms;\n\n    Sequence(String operator, List<Term> terms) {\n      this.operator = requireNonNull(operator);\n      this.terms = ImmutableList.copyOf(terms);\n    }\n\n    Sequence(String operator) {\n      this(operator, ImmutableList.of());\n    }\n\n    @Override public int hashCode() {\n      return Objects.hash(operator, terms);\n    }\n\n    @Override public boolean equals(Object obj) {\n      return this == obj\n          || obj instanceof Sequence\n          && operator.equals(((Sequence) obj).operator)\n          && terms.equals(((Sequence) obj).terms);\n    }\n\n    @Override public String toString() {\n      if (terms.isEmpty()) {\n        return operator;\n      }\n      final StringBuilder builder = new StringBuilder(operator).append('(');\n      for (int i = 0; i < terms.size(); i++) {\n        Term term = terms.get(i);\n        if (i > 0) {\n          builder.append(\", \");\n        }\n        builder.append(term);\n      }\n      return builder.append(')').toString();\n    }\n\n    public Term apply(Map<Variable, Term> substitutions) {\n      final Sequence sequence = sequenceApply(operator, substitutions, terms);\n      if (sequence.equalsShallow(this)) {\n        return this;\n      }\n      return sequence;\n    }\n\n    public void checkCycle(Map<Variable, Term> map,\n        Map<Variable, Variable> active) throws CycleException {\n      for (Term term : terms) {\n        term.checkCycle(map, active);\n      }\n    }\n\n    /** Compares whether two sequences have the same terms.\n     * Compares addresses, not contents, to avoid hitting cycles\n     * if any of the terms are cyclic (e.g. \"X = f(X)\"). */\n    private boolean equalsShallow(Sequence sequence) {\n      return this == sequence || listEqual(terms, sequence.terms);\n    }\n\n    private static <E> boolean listEqual(List<E> list0, List<E> list1) {\n      if (list0.size() != list1.size()) {\n        return false;\n      }\n      for (int i = 0; i < list0.size(); i++) {\n        if (list0.get(i) != list1.get(i)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    public boolean contains(Variable variable) {\n      for (Term term : terms) {\n        if (term.contains(variable)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    public <R> R accept(TermVisitor<R> visitor) {\n      return visitor.visit(this);\n    }\n  }\n\n  /** Called on various events during unification. */\n  public interface Tracer {\n    void onDelete(Term left, Term right);\n    void onConflict(Sequence left, Sequence right);\n    void onSequence(Sequence left, Sequence right);\n    void onSwap(Term left, Term right);\n    void onCycle(Variable variable, Term term);\n    void onVariable(Variable variable, Term term);\n    void onSubstitute(Term left, Term right, Term left2, Term right2);\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private int varId;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "varId", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Variable> variableMap = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Variable>", "name": "variableMap = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Sequence> atomMap = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Sequence>", "name": "atomMap = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Sequence> sequenceMap = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Sequence>", "name": "sequenceMap = new HashMap<>()", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType", "name": "ParameterizedType", "file_path": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java", "superclasses": "BaseType", "methods": ["[]ParameterizedType(Op,String,String,int)", "[String]name()", "[String]moniker()", "[String]toString()", "[String]computeMoniker(String,List<? extends Type>)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType.[]ParameterizedType(Op,String,String,int)", "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType.[String]name()", "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType.[String]moniker()", "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType.[String]toString()", "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType.[String]computeMoniker(String,List<? extends Type>)"], "overrides": null, "attributes": [], "class_docstring": " Base class for types that accept type parameters.\n\n<p>These types have not just names but also monikers. For example,\nthe datatype named {@code option} has instantiations whose monikers\ninclude {@code int option}, {@code (string * bool) option}, and\n{@code 'b option}.\n", "original_string": "public abstract class ParameterizedType extends BaseType implements NamedType {\n  public final String name;\n  public final String moniker;\n  public final List<Type> parameterTypes;\n\n  /** Creates a ParameterizedType. */\n  ParameterizedType(Op op, String name, String moniker, int parameterCount) {\n    super(op);\n    this.name = requireNonNull(name);\n    this.moniker = requireNonNull(moniker);\n    this.parameterTypes = MapList.of(parameterCount, TypeVar::new);\n  }\n\n  public String name() {\n    return name;\n  }\n\n  @Override public String moniker() {\n    return moniker;\n  }\n\n  @Override public String toString() {\n    return moniker;\n  }\n\n  static String computeMoniker(String name, List<? extends Type> typeVars) {\n    if (typeVars.isEmpty()) {\n      return name;\n    }\n    final StringBuilder b = new StringBuilder();\n    if (typeVars.size() > 1) {\n      b.append('(');\n    }\n    forEachIndexed(typeVars, (t, i) -> {\n      if (i > 0) {\n        b.append(\",\");\n      }\n      if (t instanceof TupleType) {\n        b.append('(').append(t.moniker()).append(')');\n      } else {\n        b.append(t.moniker());\n      }\n    });\n    if (typeVars.size() > 1) {\n      b.append(')');\n    }\n    return b.append(' ').append(name).toString();\n  }\n}", "super_interfaces": ["NamedType"], "fields": [{"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "public final String moniker;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "moniker", "syntax_pass": true}, {"attribute_expression": "public final List<Type> parameterTypes;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "List<Type>", "name": "parameterTypes", "syntax_pass": true}]}, {"uris": "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType", "name": "BaseType", "file_path": "src/main/java/net/hydromatic/morel/type/BaseType.java", "superclasses": "", "methods": ["[]BaseType(Op)", "[Op]op()", "[String]toString()", "[boolean]equals(Object)", "[int]hashCode()"], "method_uris": ["src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType.[]BaseType(Op)", "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType.[Op]op()", "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType.[String]toString()", "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType.[boolean]equals(Object)", "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType.[int]hashCode()"], "overrides": null, "attributes": [], "class_docstring": " Abstract implementation of Type.", "original_string": "abstract class BaseType implements Type {\n  final Op op;\n\n  protected BaseType(Op op) {\n    this.op = requireNonNull(op);\n  }\n\n  public Op op() {\n    return op;\n  }\n\n  @Override public String toString() {\n    return key().toString();\n  }\n\n  @Override public boolean equals(Object o) {\n    return this == o\n        || o instanceof BaseType\n        && key().equals(((BaseType) o).key());\n  }\n\n  @Override public int hashCode() {\n    return key().hashCode();\n  }\n}", "super_interfaces": ["Type"], "fields": [{"attribute_expression": "final Op op;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Op", "name": "op", "syntax_pass": true}]}]