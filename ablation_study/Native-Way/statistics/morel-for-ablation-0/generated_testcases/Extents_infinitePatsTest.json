[{"strategy": "retry", "code": "\npackage net.hydromatic.morel.compile;\n\nimport net.hydromatic.morel.ast.Core;\nimport net.hydromatic.morel.ast.FromBuilder;\nimport net.hydromatic.morel.ast.Shuttle;\nimport net.hydromatic.morel.type.TypeSystem;\nimport net.hydromatic.morel.util.ImmutablePairList;\nimport net.hydromatic.morel.util.Ord;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.*;\n\npublic class Extents_infinitePatsTest {\n\n    @Test\n    public void testInfinitePats_WithInfiniteScan() {\n        // Given\n        TypeSystem typeSystem = mock(TypeSystem.class);\n        Core.Decl node = mock(Core.Decl.class);\n        Core.From from = mock(Core.From.class);\n        Core.Scan scan = mock(Core.Scan.class);\n        Core.Exp exp = mock(Core.Exp.class);\n        Core.Pat pat = mock(Core.Pat.class);\n        Core.FromStep step2 = mock(Core.FromStep.class);\n        List<Core.FromStep> steps = List.of(step2);\n        Ord<Core.FromStep> ordStep = new Ord<>(0, scan);\n        List<Ord<Core.FromStep>> ordSteps = List.of(ordStep);\n\n        when(node.accept(any(Shuttle.class))).thenReturn(from);\n        when(from.steps).thenReturn(steps);\n        when(scan.exp).thenReturn(exp);\n        when(scan.pat).thenReturn(pat);\n        when(step2.equals(scan)).thenReturn(false);\n        when(step2 instanceof Core.Where).thenReturn(false);\n        when(Extents.isInfinite(exp)).thenReturn(true);\n\n        FromBuilder fromBuilder = mock(FromBuilder.class);\n        when(core.fromBuilder(typeSystem)).thenReturn(fromBuilder);\n        when(fromBuilder.build()).thenReturn(from);\n\n        Analysis analysis = mock(Analysis.class);\n        when(analysis.extentExp).thenReturn(exp);\n        when(analysis.satisfiedFilters).thenReturn(List.of());\n\n        when(Extents.create(eq(typeSystem), eq(pat), any(), any(), any())).thenReturn(analysis);\n\n        // When\n        Core.Decl result = Extents.infinitePats(typeSystem, node);\n\n        // Then\n        assertEquals(from, result);\n        verify(fromBuilder).scan(eq(pat), eq(exp), any());\n        verify(fromBuilder).addAll(eq(steps));\n        verify(fromBuilder).build();\n    }\n\n    @Test\n    public void testInfinitePats_WithoutInfiniteScan() {\n        // Given\n        TypeSystem typeSystem = mock(TypeSystem.class);\n        Core.Decl node = mock(Core.Decl.class);\n        Core.From from = mock(Core.From.class);\n        Core.Scan scan = mock(Core.Scan.class);\n        Core.Exp exp = mock(Core.Exp.class);\n        Core.FromStep step2 = mock(Core.FromStep.class);\n        List<Core.FromStep> steps = List.of(step2);\n        Ord<Core.FromStep> ordStep = new Ord<>(0, scan);\n        List<Ord<Core.FromStep>> ordSteps = List.of(ordStep);\n\n        when(node.accept(any(Shuttle.class))).thenReturn(from);\n        when(from.steps).thenReturn(steps);\n        when(scan.exp).thenReturn(exp);\n        when(Extents.isInfinite(exp)).thenReturn(false);\n\n        // When\n        Core.Decl result = Extents.infinitePats(typeSystem, node);\n\n        // Then\n        assertEquals(from, result);\n        verifyNoInteractions(core.fromBuilder(typeSystem));\n    }\n}\n"}]