[{"uris": "src/main/java/net/hydromatic/morel/eval/Describer.java.Describer", "name": "Describer", "file_path": "src/main/java/net/hydromatic/morel/eval/Describer.java", "superclasses": [], "methods": ["[Describer]start(String,Consumer<Detail>)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/Describer.java.Describer.[Describer]start(String,Consumer<Detail>)"], "overrides": null, "attributes": null, "class_docstring": " Describes a plan (tree of {@link Code} or {@link Applicable} objects).", "original_string": "public interface Describer {\n  Describer start(String name, Consumer<Detail> detail);\n\n  /** Provided as a callback while describing a node. */\n  interface Detail {\n    Detail arg(String name, Object value);\n    Detail arg(String name, Describable describable);\n    default Detail argIf(String name, Describable describable,\n        boolean condition) {\n      return condition ? arg(name, describable) : this;\n    }\n  }\n}"}, {"uris": "src/main/java/net/hydromatic/morel/eval/Code.java.Code", "name": "Code", "file_path": "src/main/java/net/hydromatic/morel/eval/Code.java", "superclasses": ["Describable"], "methods": ["[Object]eval(EvalEnv)", "[boolean]isConstant()"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/Code.java.Code.[Object]eval(EvalEnv)", "src/main/java/net/hydromatic/morel/eval/Code.java.Code.[boolean]isConstant()"], "overrides": null, "attributes": null, "class_docstring": " A compiled expression, that can be evaluated.", "original_string": "public interface Code extends Describable {\n  Object eval(EvalEnv evalEnv);\n\n  default boolean isConstant() {\n    return false;\n  }\n}"}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable.java.Applicable", "name": "Applicable", "file_path": "src/main/java/net/hydromatic/morel/eval/Applicable.java", "superclasses": ["Describable"], "methods": ["[Object]apply(EvalEnv,Object)", "[Code]asCode()"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/Applicable.java.Applicable.[Object]apply(EvalEnv,Object)", "src/main/java/net/hydromatic/morel/eval/Applicable.java.Applicable.[Code]asCode()"], "overrides": null, "attributes": null, "class_docstring": " A compiled expression that can be evaluated by applying to an argument.\n\n<p>Similar to {@link Code} but more efficient, because it does not require\ncreating a new runtime environment.\n", "original_string": "public interface Applicable extends Describable {\n  Object apply(EvalEnv env, Object argValue);\n\n  /** Converts this Applicable to a Code that has similar effect\n   * (but is less efficient). */\n  default Code asCode() {\n    return new Code() {\n      @Override public Describer describe(Describer describer) {\n        return describer.start(\"code2\", d ->\n            d.arg(\"applicable\", Applicable.this));\n      }\n\n      @Override public Object eval(EvalEnv env) {\n        return Applicable.this;\n      }\n\n      @Override public boolean isConstant() {\n        return true;\n      }\n    };\n  }\n}"}, {"uris": "src/main/java/net/hydromatic/morel/eval/File.java.File", "name": "File", "file_path": "src/main/java/net/hydromatic/morel/eval/File.java", "superclasses": ["TypedValue"], "methods": ["[File]expand()", "[File]discoverField(TypeSystem,String)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/File.java.File.[File]expand()", "src/main/java/net/hydromatic/morel/eval/File.java.File.[File]discoverField(TypeSystem,String)"], "overrides": null, "attributes": null, "class_docstring": " Directory in the file system.\n\n<p>Its type is progressive, so that it can discover new files and\nsubdirectories.\n\n@see Files\n@see Files#create(java.io.File)\n", "original_string": "public interface File extends TypedValue {\n  /** Expands this file to a file with a more precise type.\n   *\n   * <p>During expansion, record types may get new fields, never lose them.\n   *\n   * <p>This file object may or may not be mutable. If this file is immutable\n   * and is expanded, returns the new file. If this file is mutable, returns\n   * this file regardless of whether expansion occurred; the caller cannot\n   * discern whether expansion occurred. */\n  default File expand() {\n    return this;\n  }\n\n  default File discoverField(TypeSystem typeSystem,\n      String fieldName) {\n    return this;\n  }\n}"}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv", "name": "EvalEnv", "file_path": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java", "superclasses": [], "methods": ["[Object]getOpt(String)", "[EvalEnv]bind(String,Object)", "[MutableEvalEnv]bindMutable(String)", "[MutableEvalEnv]bindMutablePat(Core.Pat)", "[MutableEvalEnv]bindMutableArray(List<String>)", "[void]visit(BiConsumer<String, Object>)", "[Map<String, Object>]valueMap()", "[EvalEnv]fix()"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[Object]getOpt(String)", "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[EvalEnv]bind(String,Object)", "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[MutableEvalEnv]bindMutable(String)", "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[MutableEvalEnv]bindMutablePat(Core.Pat)", "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[MutableEvalEnv]bindMutableArray(List<String>)", "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[void]visit(BiConsumer<String, Object>)", "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[Map<String, Object>]valueMap()", "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[EvalEnv]fix()"], "overrides": null, "attributes": null, "class_docstring": " Evaluation environment.\n\n<p>Whereas {@link Environment} contains both types and values,\nbecause it is used for validation/compilation, EvalEnv contains\nonly values.", "original_string": "public interface EvalEnv {\n\n  /** The name of the variable that contains the {@link Session}. */\n  String SESSION = \"$session\";\n\n  /** Returns the binding of {@code name} if bound, null if not. */\n  Object getOpt(String name);\n\n  /** Creates an environment that has the same content as this one, plus\n   * the binding (name, value). */\n  default EvalEnv bind(String name, Object value) {\n    return new EvalEnvs.SubEvalEnv(this, name, value);\n  }\n\n  /** Creates an evaluation environment that has the same content as this one,\n   * plus a mutable slot. */\n  default MutableEvalEnv bindMutable(String name) {\n    return new EvalEnvs.MutableSubEvalEnv(this, name);\n  }\n\n  /** Creates an evaluation environment that has the same content as this one,\n   * plus mutable slots for each name in a pattern. */\n  default MutableEvalEnv bindMutablePat(Core.Pat pat) {\n    if (pat instanceof Core.IdPat) {\n      // Pattern is simple; use a simple implementation.\n      return bindMutable(((Core.IdPat) pat).name);\n    }\n    final List<String> names = new ArrayList<>();\n    pat.accept(new Visitor() {\n      @Override protected void visit(Core.IdPat idPat) {\n        names.add(idPat.name);\n      }\n      @Override protected void visit(Core.AsPat asPat) {\n        names.add(asPat.name);\n        super.visit(asPat);\n      }\n    });\n    return new EvalEnvs.MutablePatSubEvalEnv(this, pat, names);\n  }\n\n  /** Creates an evaluation environment that has the same content as this one,\n   * plus a mutable slot or slots.\n   *\n   * <p>If {@code names} has one element, calling\n   * {@link MutableEvalEnv#set(Object)} will populate the slot will be filled by\n   * an object; if {@code names} has more than one element, {@code set} will\n   * expect to be given an array with the same number of elements. */\n  default MutableEvalEnv bindMutableArray(List<String> names) {\n    if (names.size() == 1) {\n      return bindMutable(names.get(0));\n    }\n    return new EvalEnvs.MutableArraySubEvalEnv(this, names);\n  }\n\n  /** Visits every variable binding in this environment.\n   *\n   * <p>Bindings that are obscured by more recent bindings of the same name\n   * are visited, but after the more obscuring bindings. */\n  void visit(BiConsumer<String, Object> consumer);\n\n  /** Returns a map of the values and bindings. */\n  default Map<String, Object> valueMap() {\n    final Map<String, Object> valueMap = new HashMap<>();\n    visit(valueMap::putIfAbsent);\n    return valueMap;\n  }\n\n  /** Converts this environment to a non-mutable environment. */\n  default EvalEnv fix() {\n    return this;\n  }\n}"}, {"uris": "src/main/java/net/hydromatic/morel/eval/Describable.java.Describable", "name": "Describable", "file_path": "src/main/java/net/hydromatic/morel/eval/Describable.java", "superclasses": [], "methods": ["[Describer]describe(Describer)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/Describable.java.Describable.[Describer]describe(Describer)"], "overrides": null, "attributes": null, "class_docstring": " Can be visited by a {@link Describer}.\n\n<p>(There are no plans for an {@code interface Indescribable}.", "original_string": "public interface Describable {\n  Describer describe(Describer describer);\n}"}, {"uris": "src/main/java/net/hydromatic/morel/eval/MutableEvalEnv.java.MutableEvalEnv", "name": "MutableEvalEnv", "file_path": "src/main/java/net/hydromatic/morel/eval/MutableEvalEnv.java", "superclasses": ["EvalEnv"], "methods": ["[void]set(Object)", "[boolean]setOpt(Object)"], "method_uris": ["src/main/java/net/hydromatic/morel/eval/MutableEvalEnv.java.MutableEvalEnv.[void]set(Object)", "src/main/java/net/hydromatic/morel/eval/MutableEvalEnv.java.MutableEvalEnv.[boolean]setOpt(Object)"], "overrides": null, "attributes": null, "class_docstring": " An evaluation environment whose last entry is mutable.", "original_string": "public interface MutableEvalEnv extends EvalEnv {\n  /** Puts a value into this environment. */\n  void set(Object value);\n\n  /** Puts a value into this environment in a way that may not succeed.\n   *\n   * <p>For example, if this environment is based on the pattern (x, 2)\n   * then (1, 2) will succeed and will bind x to 1, but (3, 4) will fail.\n   *\n   * <p>The default implementation calls {@link #set} and always succeeds.\n   */\n  default boolean setOpt(Object value) {\n    set(value);\n    return true;\n  }\n}"}, {"uris": "src/main/java/net/hydromatic/morel/compile/CompiledStatement.java.CompiledStatement", "name": "CompiledStatement", "file_path": "src/main/java/net/hydromatic/morel/compile/CompiledStatement.java", "superclasses": [], "methods": ["[void]eval(Session,Environment,Consumer<String>,Consumer<Binding>)", "[Type]getType()"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/CompiledStatement.java.CompiledStatement.[void]eval(Session,Environment,Consumer<String>,Consumer<Binding>)", "src/main/java/net/hydromatic/morel/compile/CompiledStatement.java.CompiledStatement.[Type]getType()"], "overrides": null, "attributes": null, "class_docstring": "\nStatement that has been compiled and is ready to be run from the\nREPL.\n\n<p>If a declaration, it evaluates an expression and also\ncreates a new environment (with new variables bound) and\ngenerates a line or two of output for the REPL.\n", "original_string": "public interface CompiledStatement {\n  /** Evaluates this statement, adding lines of feedback to {@code output}\n   * and writing bindings (values to variables, and types definitions) to\n   * {@code bindings}. The environment for the next statement can be\n   * constructed from the bindings.\n   *\n   * @param session Session\n   * @param environment Evaluation environment\n   * @param outLines List to which to append lines of output\n   * @param outBindings List to which to append bound variables and types\n   */\n  void eval(Session session, Environment environment, Consumer<String> outLines,\n      Consumer<Binding> outBindings);\n\n  Type getType();\n}"}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer", "name": "Tracer", "file_path": "src/main/java/net/hydromatic/morel/compile/Tracer.java", "superclasses": [], "methods": ["[void]onCore(int,Core.Decl)", "[void]onPlan(Code)", "[void]onResult(Object)", "[void]onWarnings(List<Throwable>)", "[boolean]onException(Throwable)", "[boolean]onTypeException(TypeResolver.TypeException)", "[boolean]handleCompileException(CompileException)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[void]onCore(int,Core.Decl)", "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[void]onPlan(Code)", "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[void]onResult(Object)", "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[void]onWarnings(List<Throwable>)", "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[boolean]onException(Throwable)", "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[boolean]onTypeException(TypeResolver.TypeException)", "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[boolean]handleCompileException(CompileException)"], "overrides": null, "attributes": null, "class_docstring": " Called on various events during compilation.", "original_string": "public interface Tracer {\n  /** Called when the expression is converted to core. */\n  void onCore(int pass, Core.Decl e);\n\n  /** Called when code is generated. */\n  void onPlan(Code code);\n\n  /** Called on the result of an evaluation. */\n  void onResult(Object o);\n\n  /** Called with the list of warnings after evaluation. */\n  void onWarnings(List<Throwable> warningList);\n\n  /** Called with the exception thrown during evaluation, or null if no\n   * exception was thrown. Returns whether a handler was found. */\n  boolean onException(@Nullable Throwable e);\n\n  /** Called with the exception thrown during type resolution.\n   * Returns whether a handler was found. */\n  boolean onTypeException(TypeResolver.TypeException e);\n\n  /** Called with the exception thrown during validation, or null if no\n   * exception was thrown. Returns whether a handler was found. */\n  boolean handleCompileException(@Nullable CompileException e);\n}"}, {"uris": "src/main/java/net/hydromatic/morel/compile/Macro.java.Macro", "name": "Macro", "file_path": "src/main/java/net/hydromatic/morel/compile/Macro.java", "superclasses": [], "methods": ["[Core.Exp]expand(TypeSystem,Environment,Type)"], "method_uris": ["src/main/java/net/hydromatic/morel/compile/Macro.java.Macro.[Core.Exp]expand(TypeSystem,Environment,Type)"], "overrides": null, "attributes": null, "class_docstring": " A function that is 'called' at compile time,\nand generates an expanded parse tree.\n\n<p>Currently, Macros are internal.\nAlso, the macro is validated as if it were a function.\nIts type is derived before expansion.\nExpansion must preserve the type.", "original_string": "public interface Macro {\n  Core.Exp expand(TypeSystem typeSystem, Environment env, Type argType);\n}"}, {"uris": "src/main/java/net/hydromatic/morel/util/MorelException.java.MorelException", "name": "MorelException", "file_path": "src/main/java/net/hydromatic/morel/util/MorelException.java", "superclasses": [], "methods": ["[Pos]pos()", "[StringBuilder]describeTo(StringBuilder)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/MorelException.java.MorelException.[Pos]pos()", "src/main/java/net/hydromatic/morel/util/MorelException.java.MorelException.[StringBuilder]describeTo(StringBuilder)"], "overrides": null, "attributes": null, "class_docstring": " Interface implemented by all exceptions in Morel.", "original_string": "public interface MorelException {\n  /** Returns the position. */\n  Pos pos();\n\n  /** Writes a description of this exception. */\n  StringBuilder describeTo(StringBuilder buf);\n}"}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "name": "PairList", "file_path": "src/main/java/net/hydromatic/morel/util/PairList.java", "superclasses": ["List<Map.Entry<T, U>>"], "methods": ["[PairList<T, U>]of()", "[PairList<T, U>]of(T,U)", "[PairList<T, U>]copyOf(T,U)", "[PairList<T, U>]withCapacity(int)", "[PairList<T, U>]backedBy(List<@Nullable Object>)", "[PairList<T, U>]of(Map<T, U>)", "[Builder<T, U>]builder()", "[void]add(T,U)", "[void]add(int,T,U)", "[boolean]addAll(PairList<T, U>)", "[boolean]addAll(int,PairList<T, U>)", "[Map.Entry<T, U>]set(int,Map.Entry<T, U>)", "[Map.Entry<T, U>]set(int,T,U)", "[Map.Entry<T, U>]remove(int)", "[T]left(int)", "[U]right(int)", "[List<T>]leftList()", "[List<U>]rightList()", "[void]forEach(BiConsumer<T, U>)", "[void]forEachIndexed(IndexedBiConsumer<T, U>)", "[ImmutableMap<T, U>]toImmutableMap()", "[ImmutablePairList<T, U>]immutable()", "[List<R>]transform(BiFunction<T, U, R>)", "[ImmutableList<R>]transform2(BiFunction<T, U, R>)", "[boolean]anyMatch(BiPredicate<T, U>)", "[boolean]allMatch(BiPredicate<T, U>)", "[int]firstMatch(BiPredicate<T, U>)", "[boolean]noMatch(BiPredicate<T, U>)"], "method_uris": ["src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]of()", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]of(T,U)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]copyOf(T,U)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]withCapacity(int)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]backedBy(List<@Nullable Object>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]of(Map<T, U>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[Builder<T, U>]builder()", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[void]add(T,U)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[void]add(int,T,U)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[boolean]addAll(PairList<T, U>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[boolean]addAll(int,PairList<T, U>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[Map.Entry<T, U>]set(int,Map.Entry<T, U>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[Map.Entry<T, U>]set(int,T,U)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[Map.Entry<T, U>]remove(int)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[T]left(int)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[U]right(int)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[List<T>]leftList()", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[List<U>]rightList()", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[void]forEach(BiConsumer<T, U>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[void]forEachIndexed(IndexedBiConsumer<T, U>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[ImmutableMap<T, U>]toImmutableMap()", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[ImmutablePairList<T, U>]immutable()", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[List<R>]transform(BiFunction<T, U, R>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[ImmutableList<R>]transform2(BiFunction<T, U, R>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[boolean]anyMatch(BiPredicate<T, U>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[boolean]allMatch(BiPredicate<T, U>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[int]firstMatch(BiPredicate<T, U>)", "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[boolean]noMatch(BiPredicate<T, U>)"], "overrides": null, "attributes": null, "class_docstring": " A list of pairs, stored as a quotient list.\n\n@param <T> First type\n@param <U> Second type\n", "original_string": "public interface PairList<T, U> extends List<Map.Entry<T, U>> {\n  /** Creates an empty PairList. */\n  static <T, U> PairList<T, U> of() {\n    return new PairLists.MutablePairList<>(new ArrayList<>());\n  }\n\n  /** Creates a singleton PairList. */\n  @SuppressWarnings(\"RedundantCast\")\n  static <T, U> PairList<T, U> of(T t, U u) {\n    final List<@Nullable Object> list = new ArrayList<>();\n    list.add((Object) t);\n    list.add((Object) u);\n    return new PairLists.MutablePairList<>(list);\n  }\n\n  /** Creates a PairList with one or more entries. */\n  static <T, U> PairList<T, U> copyOf(T t, U u, Object... rest) {\n    checkArgument(rest.length % 2 == 0, \"even number\");\n    final List<Object> list = Lists.asList(t, u, rest);\n    return new PairLists.MutablePairList<>(new ArrayList<>(list));\n  }\n\n  /** Creates an empty PairList with a specified initial capacity. */\n  static <T, U> PairList<T, U> withCapacity(int initialCapacity) {\n    return backedBy(new ArrayList<>(initialCapacity));\n  }\n\n  /** Creates a PairList backed by a given list.\n   *\n   * <p>Changes to the backing list will be reflected in the PairList.\n   * If the backing list is immutable, this PairList will be also. */\n  static <T, U> PairList<T, U> backedBy(List<@Nullable Object> list) {\n    return new PairLists.MutablePairList<>(list);\n  }\n\n  /** Creates a PairList from a Map. */\n  @SuppressWarnings(\"RedundantCast\")\n  static <T, U> PairList<T, U> of(Map<T, U> map) {\n    final List<@Nullable Object> list = new ArrayList<>(map.size() * 2);\n    map.forEach((t, u) -> {\n      list.add((Object) t);\n      list.add((Object) u);\n    });\n    return new PairLists.MutablePairList<>(list);\n  }\n\n  /** Creates a Builder. */\n  static <T, U> Builder<T, U> builder() {\n    return new Builder<>();\n  }\n\n  /** Adds a pair to this list. */\n  default void add(T t, U u) {\n    throw new UnsupportedOperationException(\"add\");\n  }\n\n  /** Adds a pair to this list at a given position. */\n  default void add(int index, T t, U u) {\n    throw new UnsupportedOperationException(\"add\");\n  }\n\n  /** Adds to this list the contents of another PairList.\n   *\n   * <p>Equivalent to {@link #addAll(Collection)}, but more efficient. */\n  default boolean addAll(PairList<T, U> list2) {\n    throw new UnsupportedOperationException(\"addAll\");\n  }\n\n  /** Adds to this list, at a given index, the contents of another PairList.\n   *\n   * <p>Equivalent to {@link #addAll(int, Collection)}, but more efficient. */\n  default boolean addAll(int index, PairList<T, U> list2) {\n    throw new UnsupportedOperationException(\"addAll\");\n  }\n\n  @Override default Map.Entry<T, U> set(int index, Map.Entry<T, U> entry) {\n    return set(index, entry.getKey(), entry.getValue());\n  }\n\n  /** Sets the entry at position {@code index} to the pair {@code (t, u)}. */\n  default Map.Entry<T, U> set(int index, T t, U u) {\n    throw new UnsupportedOperationException(\"set\");\n  }\n\n  @Override default Map.Entry<T, U> remove(int index) {\n    throw new UnsupportedOperationException(\"remove\");\n  }\n\n  /** Returns the left part of the {@code index}th pair. */\n  T left(int index);\n\n  /** Returns the right part of the {@code index}th pair. */\n  U right(int index);\n\n  /** Returns an unmodifiable list view consisting of the left entry of each\n   * pair. */\n  List<T> leftList();\n\n  /** Returns an unmodifiable list view consisting of the right entry of each\n   * pair. */\n  List<U> rightList();\n\n  /** Calls a BiConsumer with each pair in this list. */\n  void forEach(BiConsumer<T, U> consumer);\n\n  /** Calls a BiConsumer with each pair in this list. */\n  void forEachIndexed(IndexedBiConsumer<T, U> consumer);\n\n  /** Creates an {@link ImmutableMap} whose entries are the pairs in this list.\n   * Throws if keys are not unique. */\n  default ImmutableMap<T, U> toImmutableMap() {\n    final ImmutableMap.Builder<T, U> b = ImmutableMap.builder();\n    forEach((t, u) -> b.put(t, u));\n    return b.build();\n  }\n\n  /** Returns an ImmutablePairList whose contents are the same as this\n   * PairList. */\n  ImmutablePairList<T, U> immutable();\n\n  /** Applies a mapping function to each element of this list. */\n  <R> List<R> transform(BiFunction<T, U, R> function);\n\n  /** Applies a mapping function to each element of this list. */\n  <R> ImmutableList<R> transform2(BiFunction<T, U, R> function);\n\n  /** Returns whether the predicate is true for at least one pair\n   * in this list. */\n  boolean anyMatch(BiPredicate<T, U> predicate);\n\n  /** Returns whether the predicate is true for all pairs\n   * in this list. */\n  boolean allMatch(BiPredicate<T, U> predicate);\n\n  /** Returns the index of the first match of a predicate. */\n  int firstMatch(BiPredicate<T, U> predicate);\n\n  /** Returns whether the predicate is true for no pairs\n   * in this list. */\n  boolean noMatch(BiPredicate<T, U> predicate);\n\n  /** Action to be taken each step of an indexed iteration over a PairList.\n   *\n   * @param <T> First type\n   * @param <U> Second type\n   *\n   * @see PairList#forEachIndexed(IndexedBiConsumer)\n   */\n  interface IndexedBiConsumer<T, U> {\n    /**\n     * Performs this operation on the given arguments.\n     *\n     * @param index Index\n     * @param t First input argument\n     * @param u Second input argument\n     */\n    void accept(int index, T t, U u);\n  }\n\n  /** Builds a PairList.\n   *\n   * @param <T> First type\n   * @param <U> Second type */\n  class Builder<T, U> {\n    final List<@Nullable Object> list = new ArrayList<>();\n\n    /** Adds a pair to the list under construction. */\n    @SuppressWarnings(\"RedundantCast\")\n    public Builder<T, U> add(T t, U u) {\n      list.add((Object) t);\n      list.add((Object) u);\n      return this;\n    }\n\n    /** Builds the PairList. */\n    public PairList<T, U> build() {\n      return new PairLists.MutablePairList<>(list);\n    }\n  }\n}"}, {"uris": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList", "name": "ImmutablePairList", "file_path": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java", "superclasses": ["PairList<T, U>"], "methods": ["[ImmutablePairList<T, U>]of()", "[ImmutablePairList<T, U>]of(T,U)", "[PairList<T, U>]copyOf(T,U)", "[ImmutablePairList<T, U>]copyOf(Iterable<? extends Map.Entry<T, U>>)", "[ImmutablePairList<T, U>]immutable()"], "method_uris": ["src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList.[ImmutablePairList<T, U>]of()", "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList.[ImmutablePairList<T, U>]of(T,U)", "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList.[PairList<T, U>]copyOf(T,U)", "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList.[ImmutablePairList<T, U>]copyOf(Iterable<? extends Map.Entry<T, U>>)", "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList.[ImmutablePairList<T, U>]immutable()"], "overrides": null, "attributes": null, "class_docstring": " Immutable list of pairs.\n\n@param <T> First type\n@param <U> Second type\n", "original_string": "public interface ImmutablePairList<T, U> extends PairList<T, U> {\n\n  /** Creates an empty ImmutablePairList. */\n  @SuppressWarnings(\"unchecked\")\n  static <T, U> ImmutablePairList<T, U> of() {\n    return (ImmutablePairList<T, U>) PairLists.EMPTY;\n  }\n\n  /** Creates a singleton ImmutablePairList. */\n  static <T, U> ImmutablePairList<T, U> of(T t, U u) {\n    return new PairLists.SingletonImmutablePairList<>(t, u);\n  }\n\n  /** Creates an ImmutablePairList with one or more entries. */\n  static <T, U> PairList<T, U> copyOf(T t, U u, Object... rest) {\n    checkArgument(rest.length % 2 == 0, \"even number\");\n    if (rest.length == 0) {\n      return new PairLists.SingletonImmutablePairList<>(t, u);\n    }\n    Object[] elements = new Object[rest.length + 2];\n    elements[0] = t;\n    elements[1] = u;\n    System.arraycopy(rest, 0, elements, 2, rest.length);\n    return new PairLists.ArrayImmutablePairList<>(elements);\n  }\n\n  /** Creates an ImmutablePairList whose contents are a copy of a given\n   * collection. */\n  @SuppressWarnings(\"unchecked\")\n  static <T, U> ImmutablePairList<T, U> copyOf(\n      Iterable<? extends Map.Entry<T, U>> iterable) {\n    // Every PairList - mutable and immutable - knows how to quickly make\n    // itself immutable.\n    if (iterable instanceof PairList) {\n      return ((PairList<T, U>) iterable).immutable();\n    }\n\n    // If it's a collection, we know its size, and therefore can create an\n    // array directly, without an intermediate ArrayList.\n    if (iterable instanceof Collection) {\n      final Collection<? extends Map.Entry<T, U>> collection =\n          (Collection<? extends Map.Entry<T, U>>) iterable;\n      switch (collection.size()) {\n      case 0:\n        return of();\n\n      case 1:\n        // Use of iterator is suboptimal. If we knew this was a list we could\n        // call get(0), but the special case doesn't seem worth the effort.\n        final Map.Entry<T, U> entry = iterable.iterator().next();\n        return of(entry.getKey(), entry.getValue());\n\n      default:\n        Object[] elements = new Object[2 * collection.size()];\n        int i = 0;\n        for (Map.Entry<T, U> entry2 : iterable) {\n          elements[i++] = entry2.getKey();\n          elements[i++] = entry2.getValue();\n        }\n        return new PairLists.ArrayImmutablePairList<>(elements);\n      }\n    }\n\n    // Not a collection, so we don't know its size in advance.\n    final List<Object> list = new ArrayList<>();\n    iterable.forEach(entry -> {\n      list.add(entry.getKey());\n      list.add(entry.getValue());\n    });\n    return PairLists.immutableBackedBy(list);\n  }\n\n  @Override default ImmutablePairList<T, U> immutable() {\n    return this;\n  }\n}"}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType", "name": "RecordLikeType", "file_path": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java", "superclasses": ["Type"], "methods": ["[SortedMap<String, Type>]argNameTypes()", "[List<Type>]argTypes()", "[Type]argType(int)", "[TypedValue]asTypedValue()"], "method_uris": ["src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType.[SortedMap<String, Type>]argNameTypes()", "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType.[List<Type>]argTypes()", "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType.[Type]argType(int)", "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType.[TypedValue]asTypedValue()"], "overrides": null, "attributes": null, "class_docstring": " A type that has named fields, as a record type does.", "original_string": "public interface RecordLikeType extends Type {\n  /** Returns a map of the field types, keyed by field names. */\n  SortedMap<String, Type> argNameTypes();\n\n  /** Returns a list of field types, ordered by field names. */\n  default List<Type> argTypes() {\n    return ImmutableList.copyOf(argNameTypes().values());\n  }\n\n  /** Returns the type of the {@code i}th field, or throws. */\n  Type argType(int i);\n\n  /** Returns a {@link TypedValue} if this\n   * type wraps a single dynamically typed value, otherwise null. */\n  default @Nullable TypedValue asTypedValue() {\n    return null;\n  }\n}"}, {"uris": "src/main/java/net/hydromatic/morel/type/Type.java.Type", "name": "Type", "file_path": "src/main/java/net/hydromatic/morel/type/Type.java", "superclasses": [], "methods": ["[Key]key()", "[String]moniker()", "[Op]op()", "[Type]copy(TypeSystem,UnaryOperator<Type>)", "[R]accept(TypeVisitor<R>)", "[Type]substitute(TypeSystem,List<? extends Type>)", "[boolean]isProgressive()", "[boolean]isFinite()"], "method_uris": ["src/main/java/net/hydromatic/morel/type/Type.java.Type.[Key]key()", "src/main/java/net/hydromatic/morel/type/Type.java.Type.[String]moniker()", "src/main/java/net/hydromatic/morel/type/Type.java.Type.[Op]op()", "src/main/java/net/hydromatic/morel/type/Type.java.Type.[Type]copy(TypeSystem,UnaryOperator<Type>)", "src/main/java/net/hydromatic/morel/type/Type.java.Type.[R]accept(TypeVisitor<R>)", "src/main/java/net/hydromatic/morel/type/Type.java.Type.[Type]substitute(TypeSystem,List<? extends Type>)", "src/main/java/net/hydromatic/morel/type/Type.java.Type.[boolean]isProgressive()", "src/main/java/net/hydromatic/morel/type/Type.java.Type.[boolean]isFinite()"], "overrides": null, "attributes": null, "class_docstring": " Type.", "original_string": "public interface Type {\n  /** Description of the type, e.g. \"{@code int}\", \"{@code int -> int}\",\n   * \"{@code NONE | SOME of 'a}\". */\n  Key key();\n\n  /** Key of the type.\n   *\n   * <p>Often the same as {@link #key()}, but an exception is datatype.\n   * For example, datatype \"{@code 'a option}\" has moniker and name\n   * \"{@code option}\" and description \"{@code NONE | SOME of 'a}\".\n   *\n   * <p>Use the description if you are looking for a type that is structurally\n   * equivalent. Use the moniker to identify it when printing. */\n  default String moniker() {\n    return key().toString();\n  }\n\n  /** Type operator. */\n  Op op();\n\n  /** Copies this type, applying a given transform to component types,\n   * and returning the original type if the component types are unchanged. */\n  Type copy(TypeSystem typeSystem, UnaryOperator<Type> transform);\n\n  <R> R accept(TypeVisitor<R> typeVisitor);\n\n  /** Returns a copy of this type, specialized by substituting type\n   * parameters. */\n  default Type substitute(TypeSystem typeSystem, List<? extends Type> types) {\n    if (types.isEmpty()) {\n      return this;\n    }\n    return accept(\n        new TypeShuttle(typeSystem) {\n          @Override public Type visit(TypeVar typeVar) {\n            return types.get(typeVar.ordinal);\n          }\n        });\n  }\n\n  /** Returns whether this type is progressive.\n   *\n   * <p>Progressive types are records, but can have additional fields each time\n   * you look.\n   *\n   * <p>The \"file\" value is an example. */\n  default boolean isProgressive() {\n    return false;\n  }\n\n  /** Whether this type has a small, fixed set of instances.\n   * True for {@code bool}, data types on finite types. */\n  default boolean isFinite() {\n    return false;\n  }\n\n  /** Structural identifier of a type. */\n  abstract class Key {\n    public final Op op;\n\n    /** Creates a key. */\n    protected Key(Op op) {\n      this.op = requireNonNull(op);\n    }\n\n    /** Returns a description of this key.\n     *\n     * <p>The default implementation calls\n     * {@link #describe(StringBuilder, int, int)}, but subclasses may override\n     * to provide a more efficient implementation. */\n    @Override public String toString() {\n      return describe(new StringBuilder(), 0, 0).toString();\n    }\n\n    /** Writes a description of this key to a string builder. */\n    abstract StringBuilder describe(StringBuilder buf, int left, int right);\n\n    /** Converts this key to a type, and ensures that it is registered in the\n     * type system. */\n    public abstract Type toType(TypeSystem typeSystem);\n\n    /** If this is a type variable {@code ordinal}, returns the\n     * {@code ordinal}th type in the list, otherwise this. */\n    Key substitute(List<? extends Type> types) {\n      return this;\n    }\n\n    /** Copies this key, applying a transform to constituent keys. */\n    Key copy(UnaryOperator<Key> transform) {\n      return this;\n    }\n  }\n}"}, {"uris": "src/main/java/net/hydromatic/morel/type/NamedType.java.NamedType", "name": "NamedType", "file_path": "src/main/java/net/hydromatic/morel/type/NamedType.java", "superclasses": ["Type"], "methods": ["[String]name()"], "method_uris": ["src/main/java/net/hydromatic/morel/type/NamedType.java.NamedType.[String]name()"], "overrides": null, "attributes": null, "class_docstring": " Type that has a name.", "original_string": "public interface NamedType extends Type {\n  /** Name of the type. */\n  String name();\n}"}, {"uris": "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue", "name": "TypedValue", "file_path": "src/main/java/net/hydromatic/morel/type/TypedValue.java", "superclasses": [], "methods": ["[V]valueAs(Class<V>)", "[V]fieldValueAs(String,Class<V>)", "[V]fieldValueAs(int,Class<V>)", "[Type.Key]typeKey()", "[TypedValue]discoverField(TypeSystem,String)"], "method_uris": ["src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue.[V]valueAs(Class<V>)", "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue.[V]fieldValueAs(String,Class<V>)", "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue.[V]fieldValueAs(int,Class<V>)", "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue.[Type.Key]typeKey()", "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue.[TypedValue]discoverField(TypeSystem,String)"], "overrides": null, "attributes": null, "class_docstring": " A value that knows its own type.", "original_string": "public interface TypedValue {\n  /** Returns the value cast as a particular type. */\n  <V> V valueAs(Class<V> clazz);\n\n  /** Returns the value of a field, identified by name,\n   * cast as a particular type. */\n  default <V> V fieldValueAs(String fieldName, Class<V> clazz) {\n    throw new UnsupportedOperationException(\"not a record\");\n  }\n\n  /** Returns the value of a field, identified by ordinal,\n   * cast as a particular type. */\n  default <V> V fieldValueAs(int fieldIndex, Class<V> clazz) {\n    throw new UnsupportedOperationException(\"not a record\");\n  }\n\n  /** Key from which the type of this value can be constructed. */\n  Type.Key typeKey();\n\n  /** Tries to expand the type to include the given field name.\n   *\n   * <p>Returns this value or an expanded value. */\n  default TypedValue discoverField(TypeSystem typeSystem, String fieldName) {\n    return this;\n  }\n}"}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converter.java.Converter", "name": "Converter", "file_path": "src/main/java/net/hydromatic/morel/foreign/Converter.java", "superclasses": ["Function<E, Object>"], "methods": [], "method_uris": [], "overrides": null, "attributes": null, "class_docstring": " Converts from a Calcite row to a Morel value (often a record).\n\n<p>The Calcite row is represented as an array, ordered by field ordinal;\nthe SML record is represented by a list, ordered by field name.\n\n@param <E> Source object type\n", "original_string": "public interface Converter<E> extends Function<E, Object> {\n}"}, {"uris": "src/main/java/net/hydromatic/morel/foreign/DataSet.java.DataSet", "name": "DataSet", "file_path": "src/main/java/net/hydromatic/morel/foreign/DataSet.java", "superclasses": [], "methods": ["[ForeignValue]foreignValue(Calcite)"], "method_uris": ["src/main/java/net/hydromatic/morel/foreign/DataSet.java.DataSet.[ForeignValue]foreignValue(Calcite)"], "overrides": null, "attributes": null, "class_docstring": " Data set for testing.", "original_string": "public interface DataSet {\n  /** Returns this data set as a foreign value. */\n  ForeignValue foreignValue(Calcite calcite);\n}"}, {"uris": "src/main/java/net/hydromatic/morel/foreign/ForeignValue.java.ForeignValue", "name": "ForeignValue", "file_path": "src/main/java/net/hydromatic/morel/foreign/ForeignValue.java", "superclasses": [], "methods": ["[Type]type(TypeSystem)", "[Object]value()"], "method_uris": ["src/main/java/net/hydromatic/morel/foreign/ForeignValue.java.ForeignValue.[Type]type(TypeSystem)", "src/main/java/net/hydromatic/morel/foreign/ForeignValue.java.ForeignValue.[Object]value()"], "overrides": null, "attributes": null, "class_docstring": " External value.\n\n<p>A common example is a table backed by a JDBC database, that manifests in\nML as a list of records.\n\n@see CalciteForeignValue", "original_string": "public interface ForeignValue {\n  Type type(TypeSystem typeSystem);\n  Object value();\n}"}, {"uris": "src/main/java/net/hydromatic/morel/parse/MorelParser.java.MorelParser", "name": "MorelParser", "file_path": "src/main/java/net/hydromatic/morel/parse/MorelParser.java", "superclasses": [], "methods": ["[Pos]pos()", "[void]zero(String)"], "method_uris": ["src/main/java/net/hydromatic/morel/parse/MorelParser.java.MorelParser.[Pos]pos()", "src/main/java/net/hydromatic/morel/parse/MorelParser.java.MorelParser.[void]zero(String)"], "overrides": null, "attributes": null, "class_docstring": " Parser for Morel, a variant of Standard ML.", "original_string": "public interface MorelParser {\n  /** Returns the position of the last token returned by the parser. */\n  Pos pos();\n\n  /** Sets the current file, and sets the current line to zero. */\n  void zero(String file);\n}"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplConstants.java.MorelParserImplConstants", "name": "MorelParserImplConstants", "file_path": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplConstants.java", "superclasses": [], "methods": [], "method_uris": [], "overrides": null, "attributes": null, "class_docstring": "\nToken literal values and constants.\nGenerated by org.javacc.parser.OtherFilesGen#start()\n", "original_string": "public interface MorelParserImplConstants {\n\n  /** End of File. */\n  int EOF = 0;\n  /** RegularExpression Id. */\n  int AND = 2;\n  /** RegularExpression Id. */\n  int ANDALSO = 3;\n  /** RegularExpression Id. */\n  int AS = 4;\n  /** RegularExpression Id. */\n  int CASE = 5;\n  /** RegularExpression Id. */\n  int DATATYPE = 6;\n  /** RegularExpression Id. */\n  int DIV = 7;\n  /** RegularExpression Id. */\n  int ELEM = 8;\n  /** RegularExpression Id. */\n  int ELSE = 9;\n  /** RegularExpression Id. */\n  int EXCEPT = 10;\n  /** RegularExpression Id. */\n  int END = 11;\n  /** RegularExpression Id. */\n  int FN = 12;\n  /** RegularExpression Id. */\n  int FUN = 13;\n  /** RegularExpression Id. */\n  int IF = 14;\n  /** RegularExpression Id. */\n  int IN = 15;\n  /** RegularExpression Id. */\n  int INTERSECT = 16;\n  /** RegularExpression Id. */\n  int LET = 17;\n  /** RegularExpression Id. */\n  int MOD = 18;\n  /** RegularExpression Id. */\n  int NOT_ELEM = 19;\n  /** RegularExpression Id. */\n  int O = 20;\n  /** RegularExpression Id. */\n  int OF = 21;\n  /** RegularExpression Id. */\n  int ORELSE = 22;\n  /** RegularExpression Id. */\n  int REC = 23;\n  /** RegularExpression Id. */\n  int THEN = 24;\n  /** RegularExpression Id. */\n  int UNION = 25;\n  /** RegularExpression Id. */\n  int VAL = 26;\n  /** RegularExpression Id. */\n  int COMPUTE = 27;\n  /** RegularExpression Id. */\n  int DESC = 28;\n  /** RegularExpression Id. */\n  int FROM = 29;\n  /** RegularExpression Id. */\n  int GROUP = 30;\n  /** RegularExpression Id. */\n  int INTO = 31;\n  /** RegularExpression Id. */\n  int JOIN = 32;\n  /** RegularExpression Id. */\n  int ON = 33;\n  /** RegularExpression Id. */\n  int ORDER = 34;\n  /** RegularExpression Id. */\n  int SKIP_ = 35;\n  /** RegularExpression Id. */\n  int TAKE = 36;\n  /** RegularExpression Id. */\n  int THROUGH = 37;\n  /** RegularExpression Id. */\n  int WHERE = 38;\n  /** RegularExpression Id. */\n  int YIELD = 39;\n  /** RegularExpression Id. */\n  int NON_NEGATIVE_INTEGER_LITERAL = 40;\n  /** RegularExpression Id. */\n  int NEGATIVE_INTEGER_LITERAL = 41;\n  /** RegularExpression Id. */\n  int REAL_LITERAL = 42;\n  /** RegularExpression Id. */\n  int SCIENTIFIC_LITERAL = 43;\n  /** RegularExpression Id. */\n  int HEXDIGIT = 44;\n  /** RegularExpression Id. */\n  int WHITESPACE = 45;\n  /** RegularExpression Id. */\n  int QUOTED_STRING = 46;\n  /** RegularExpression Id. */\n  int CHAR_LITERAL = 47;\n  /** RegularExpression Id. */\n  int LPAREN = 48;\n  /** RegularExpression Id. */\n  int RPAREN = 49;\n  /** RegularExpression Id. */\n  int LBRACE = 50;\n  /** RegularExpression Id. */\n  int RBRACE = 51;\n  /** RegularExpression Id. */\n  int LBRACKET = 52;\n  /** RegularExpression Id. */\n  int RBRACKET = 53;\n  /** RegularExpression Id. */\n  int SEMICOLON = 54;\n  /** RegularExpression Id. */\n  int BAR = 55;\n  /** RegularExpression Id. */\n  int DOT = 56;\n  /** RegularExpression Id. */\n  int COMMA = 57;\n  /** RegularExpression Id. */\n  int RARROW = 58;\n  /** RegularExpression Id. */\n  int RTHINARROW = 59;\n  /** RegularExpression Id. */\n  int EQ = 60;\n  /** RegularExpression Id. */\n  int GT = 61;\n  /** RegularExpression Id. */\n  int LT = 62;\n  /** RegularExpression Id. */\n  int COLON = 63;\n  /** RegularExpression Id. */\n  int LE = 64;\n  /** RegularExpression Id. */\n  int GE = 65;\n  /** RegularExpression Id. */\n  int NE = 66;\n  /** RegularExpression Id. */\n  int PLUS = 67;\n  /** RegularExpression Id. */\n  int MINUS = 68;\n  /** RegularExpression Id. */\n  int CARET = 69;\n  /** RegularExpression Id. */\n  int STAR = 70;\n  /** RegularExpression Id. */\n  int SLASH = 71;\n  /** RegularExpression Id. */\n  int TILDE = 72;\n  /** RegularExpression Id. */\n  int CONS = 73;\n  /** RegularExpression Id. */\n  int AT = 74;\n  /** RegularExpression Id. */\n  int ELLIPSIS = 75;\n  /** RegularExpression Id. */\n  int QUOTE = 76;\n  /** RegularExpression Id. */\n  int DOUBLE_QUOTE = 77;\n  /** RegularExpression Id. */\n  int SINGLE_LINE_COMMENT = 85;\n  /** RegularExpression Id. */\n  int END_COMMENT = 86;\n  /** RegularExpression Id. */\n  int COLLATION_ID = 88;\n  /** RegularExpression Id. */\n  int IDENTIFIER = 89;\n  /** RegularExpression Id. */\n  int QUOTED_IDENTIFIER = 90;\n  /** RegularExpression Id. */\n  int TY_VAR = 91;\n  /** RegularExpression Id. */\n  int LABEL = 92;\n  /** RegularExpression Id. */\n  int LETTER = 93;\n  /** RegularExpression Id. */\n  int DIGIT = 94;\n\n  /** Lexical state. */\n  int DEFAULT = 0;\n  /** Lexical state. */\n  int IN_LINE_COMMENT = 1;\n  /** Lexical state. */\n  int IN_COMMENT = 2;\n\n  /** Literal token values. */\n  String[] tokenImage = {\n    \"<EOF>\",\n    \"\\\"_\\\"\",\n    \"\\\"and\\\"\",\n    \"\\\"andalso\\\"\",\n    \"\\\"as\\\"\",\n    \"\\\"case\\\"\",\n    \"\\\"datatype\\\"\",\n    \"\\\"div\\\"\",\n    \"\\\"elem\\\"\",\n    \"\\\"else\\\"\",\n    \"\\\"except\\\"\",\n    \"\\\"end\\\"\",\n    \"\\\"fn\\\"\",\n    \"\\\"fun\\\"\",\n    \"\\\"if\\\"\",\n    \"\\\"in\\\"\",\n    \"\\\"intersect\\\"\",\n    \"\\\"let\\\"\",\n    \"\\\"mod\\\"\",\n    \"\\\"notelem\\\"\",\n    \"\\\"o\\\"\",\n    \"\\\"of\\\"\",\n    \"\\\"orelse\\\"\",\n    \"\\\"rec\\\"\",\n    \"\\\"then\\\"\",\n    \"\\\"union\\\"\",\n    \"\\\"val\\\"\",\n    \"\\\"compute\\\"\",\n    \"\\\"desc\\\"\",\n    \"\\\"from\\\"\",\n    \"\\\"group\\\"\",\n    \"\\\"into\\\"\",\n    \"\\\"join\\\"\",\n    \"\\\"on\\\"\",\n    \"\\\"order\\\"\",\n    \"\\\"skip\\\"\",\n    \"\\\"take\\\"\",\n    \"\\\"through\\\"\",\n    \"\\\"where\\\"\",\n    \"\\\"yield\\\"\",\n    \"<NON_NEGATIVE_INTEGER_LITERAL>\",\n    \"<NEGATIVE_INTEGER_LITERAL>\",\n    \"<REAL_LITERAL>\",\n    \"<SCIENTIFIC_LITERAL>\",\n    \"<HEXDIGIT>\",\n    \"<WHITESPACE>\",\n    \"<QUOTED_STRING>\",\n    \"<CHAR_LITERAL>\",\n    \"\\\"(\\\"\",\n    \"\\\")\\\"\",\n    \"\\\"{\\\"\",\n    \"\\\"}\\\"\",\n    \"\\\"[\\\"\",\n    \"\\\"]\\\"\",\n    \"\\\";\\\"\",\n    \"\\\"|\\\"\",\n    \"\\\".\\\"\",\n    \"\\\",\\\"\",\n    \"\\\"=>\\\"\",\n    \"\\\"->\\\"\",\n    \"\\\"=\\\"\",\n    \"\\\">\\\"\",\n    \"\\\"<\\\"\",\n    \"\\\":\\\"\",\n    \"\\\"<=\\\"\",\n    \"\\\">=\\\"\",\n    \"\\\"<>\\\"\",\n    \"\\\"+\\\"\",\n    \"\\\"-\\\"\",\n    \"\\\"^\\\"\",\n    \"\\\"*\\\"\",\n    \"\\\"/\\\"\",\n    \"\\\"~\\\"\",\n    \"\\\"::\\\"\",\n    \"\\\"@\\\"\",\n    \"\\\"...\\\"\",\n    \"\\\"\\\\\\'\\\"\",\n    \"\\\"\\\\\\\"\\\"\",\n    \"\\\" \\\"\",\n    \"\\\"\\\\t\\\"\",\n    \"\\\"\\\\n\\\"\",\n    \"\\\"\\\\r\\\"\",\n    \"\\\"\\\\f\\\"\",\n    \"\\\"(*)\\\"\",\n    \"\\\"(*\\\"\",\n    \"<SINGLE_LINE_COMMENT>\",\n    \"<END_COMMENT>\",\n    \"<token of kind 87>\",\n    \"<COLLATION_ID>\",\n    \"<IDENTIFIER>\",\n    \"<QUOTED_IDENTIFIER>\",\n    \"<TY_VAR>\",\n    \"<LABEL>\",\n    \"<LETTER>\",\n    \"<DIGIT>\",\n  };\n\n}"}]