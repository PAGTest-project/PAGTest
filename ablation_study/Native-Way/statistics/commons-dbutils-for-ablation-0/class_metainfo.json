[{"uris": "src/test/java/org/apache/commons/dbutils/BeanProcessorTest.java.BeanProcessorTest", "name": "BeanProcessorTest", "file_path": "src/test/java/org/apache/commons/dbutils/BeanProcessorTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testCheckAnnotationOnMissingReadMethod()", "[void]testIndexedPropertyDescriptor()", "[void]testMapColumnToAnnotationField()", "[void]testMapColumnToProperties()", "[void]testMapColumnToPropertiesWithOverrides()", "[void]testProcessWithPopulateBean()", "[void]testProcessWithToBean()", "[void]testWrongSetterParamCount()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/BeanProcessorTest.java.BeanProcessorTest.[void]testCheckAnnotationOnMissingReadMethod()", "src/test/java/org/apache/commons/dbutils/BeanProcessorTest.java.BeanProcessorTest.[void]testIndexedPropertyDescriptor()", "src/test/java/org/apache/commons/dbutils/BeanProcessorTest.java.BeanProcessorTest.[void]testMapColumnToAnnotationField()", "src/test/java/org/apache/commons/dbutils/BeanProcessorTest.java.BeanProcessorTest.[void]testMapColumnToProperties()", "src/test/java/org/apache/commons/dbutils/BeanProcessorTest.java.BeanProcessorTest.[void]testMapColumnToPropertiesWithOverrides()", "src/test/java/org/apache/commons/dbutils/BeanProcessorTest.java.BeanProcessorTest.[void]testProcessWithPopulateBean()", "src/test/java/org/apache/commons/dbutils/BeanProcessorTest.java.BeanProcessorTest.[void]testProcessWithToBean()", "src/test/java/org/apache/commons/dbutils/BeanProcessorTest.java.BeanProcessorTest.[void]testWrongSetterParamCount()"], "overrides": null, "attributes": [{"original_string": "    private static final class IndexedPropertyTestClass {\n        private String name;\n        // Indexed variable with indexed getter and setter\n        private List<String> things;\n        // Indexed variable without indexed getter or setter\n        private List<String> stuff;\n\n        public String getName() {\n            return name;\n        }\n\n        public List<String> getStuff() {\n            return stuff;\n        }\n\n        public String getThing(final int idx) {\n            return things.get(idx);\n        }\n\n        public List<String> getThings() {\n            return things;\n        }\n\n        public void setName(final String name) {\n            this.name = name;\n        }\n\n        public void setStuff(final List<String> stuff) {\n            this.stuff = stuff;\n        }\n\n        public void setThing(final int idx, final String thing) {\n            this.things.set(idx, thing);\n        }\n\n        public void setThings(final List<String> things) {\n            this.things = things;\n        }\n    }", "definition": "    private static final class IndexedPropertyTestClass", "class_docstring": "", "name": "IndexedPropertyTestClass", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private String name;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "private List<String> things;", "docstring": " Indexed variable with indexed getter and setter", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "things", "syntax_pass": true}, {"attribute_expression": "private List<String> stuff;", "docstring": " Indexed variable without indexed getter or setter", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "stuff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String getName() {\n            return name;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getName", "params": [], "body": "                                {\n            return name;\n        }", "signature": "public String getName()"}, {"syntax_pass": true, "original_string": "        public List<String> getStuff() {\n            return stuff;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getStuff", "params": [], "body": "                                       {\n            return stuff;\n        }", "signature": "public List<String> getStuff()"}, {"syntax_pass": true, "original_string": "        public String getThing(final int idx) {\n            return things.get(idx);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getThing", "params": [{"name": "idx", "type": "int"}], "body": "                                              {\n            return things.get(idx);\n        }", "signature": "public String getThing(final int idx)"}, {"syntax_pass": true, "original_string": "        public List<String> getThings() {\n            return things;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getThings", "params": [], "body": "                                        {\n            return things;\n        }", "signature": "public List<String> getThings()"}, {"syntax_pass": true, "original_string": "        public void setName(final String name) {\n            this.name = name;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setName", "params": [{"name": "name", "type": "String"}], "body": "                                               {\n            this.name = name;\n        }", "signature": "public void setName(final String name)"}, {"syntax_pass": true, "original_string": "        public void setStuff(final List<String> stuff) {\n            this.stuff = stuff;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setStuff", "params": [{"name": "stuff", "type": "List<String>"}], "body": "                                                       {\n            this.stuff = stuff;\n        }", "signature": "public void setStuff(final List<String> stuff)"}, {"syntax_pass": true, "original_string": "        public void setThing(final int idx, final String thing) {\n            this.things.set(idx, thing);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setThing", "params": [{"name": "idx", "type": "int"}, {"name": "thing", "type": "String"}], "body": "                                                                {\n            this.things.set(idx, thing);\n        }", "signature": "public void setThing(final int idx, final String thing)"}, {"syntax_pass": true, "original_string": "        public void setThings(final List<String> things) {\n            this.things = things;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setThings", "params": [{"name": "things", "type": "List<String>"}], "body": "                                                         {\n            this.things = things;\n        }", "signature": "public void setThings(final List<String> things)"}]}, {"original_string": "    public static class MapColumnToAnnotationFieldBean {\n        private String one;\n\n        private String two;\n\n        private String three;\n\n        private String four;\n\n        public String getFour() {\n            return four;\n        }\n\n        public String getOne() {\n            return one;\n        }\n\n        @Column(name = \"three_\")\n        public String getThree() {\n            return three;\n        }\n\n        public String getTwo() {\n            return two;\n        }\n\n        public void setFour(final String four) {\n            this.four = four;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final String three) {\n            this.three = three;\n        }\n\n        public void setTwo(final String two) {\n            this.two = two;\n        }\n    }", "definition": "    public static class MapColumnToAnnotationFieldBean", "class_docstring": "", "name": "MapColumnToAnnotationFieldBean", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private String one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "one", "syntax_pass": true}, {"attribute_expression": "private String two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "two", "syntax_pass": true}, {"attribute_expression": "private String three;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "three", "syntax_pass": true}, {"attribute_expression": "private String four;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "four", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String getFour() {\n            return four;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getFour", "params": [], "body": "                                {\n            return four;\n        }", "signature": "public String getFour()"}, {"syntax_pass": true, "original_string": "        public String getOne() {\n            return one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOne", "params": [], "body": "                               {\n            return one;\n        }", "signature": "public String getOne()"}, {"syntax_pass": true, "original_string": "        @Column(name = \"three_\")\n        public String getThree() {\n            return three;\n        }", "docstring": "", "attributes": {"modifiers": "@Column(name = \"three_\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@Column(name = \"three_\")", "public"], "comments": [], "return_type": "String", "classes": []}, "name": "getThree", "params": [], "body": "                                 {\n            return three;\n        }", "signature": "@Column(name = \"three_\")\n        public String getThree()"}, {"syntax_pass": true, "original_string": "        public String getTwo() {\n            return two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getTwo", "params": [], "body": "                               {\n            return two;\n        }", "signature": "public String getTwo()"}, {"syntax_pass": true, "original_string": "        public void setFour(final String four) {\n            this.four = four;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setFour", "params": [{"name": "four", "type": "String"}], "body": "                                               {\n            this.four = four;\n        }", "signature": "public void setFour(final String four)"}, {"syntax_pass": true, "original_string": "        public void setOne(final String one) {\n            this.one = one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setOne", "params": [{"name": "one", "type": "String"}], "body": "                                             {\n            this.one = one;\n        }", "signature": "public void setOne(final String one)"}, {"syntax_pass": true, "original_string": "        public void setThree(final String three) {\n            this.three = three;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setThree", "params": [{"name": "three", "type": "String"}], "body": "                                                 {\n            this.three = three;\n        }", "signature": "public void setThree(final String three)"}, {"syntax_pass": true, "original_string": "        public void setTwo(final String two) {\n            this.two = two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setTwo", "params": [{"name": "two", "type": "String"}], "body": "                                             {\n            this.two = two;\n        }", "signature": "public void setTwo(final String two)"}]}, {"original_string": "    public static class MapColumnToPropertiesBean {\n        private String one;\n\n        private String two;\n\n        private String three;\n\n        private String four;\n\n        public String getFour() {\n            return four;\n        }\n\n        public String getOne() {\n            return one;\n        }\n\n        public String getThree() {\n            return three;\n        }\n\n        public String getTwo() {\n            return two;\n        }\n\n        public void setFour(final String four) {\n            this.four = four;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final String three) {\n            this.three = three;\n        }\n\n        public void setTwo(final String two) {\n            this.two = two;\n        }\n    }", "definition": "    public static class MapColumnToPropertiesBean", "class_docstring": "", "name": "MapColumnToPropertiesBean", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private String one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "one", "syntax_pass": true}, {"attribute_expression": "private String two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "two", "syntax_pass": true}, {"attribute_expression": "private String three;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "three", "syntax_pass": true}, {"attribute_expression": "private String four;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "four", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String getFour() {\n            return four;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getFour", "params": [], "body": "                                {\n            return four;\n        }", "signature": "public String getFour()"}, {"syntax_pass": true, "original_string": "        public String getOne() {\n            return one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOne", "params": [], "body": "                               {\n            return one;\n        }", "signature": "public String getOne()"}, {"syntax_pass": true, "original_string": "        public String getThree() {\n            return three;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getThree", "params": [], "body": "                                 {\n            return three;\n        }", "signature": "public String getThree()"}, {"syntax_pass": true, "original_string": "        public String getTwo() {\n            return two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getTwo", "params": [], "body": "                               {\n            return two;\n        }", "signature": "public String getTwo()"}, {"syntax_pass": true, "original_string": "        public void setFour(final String four) {\n            this.four = four;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setFour", "params": [{"name": "four", "type": "String"}], "body": "                                               {\n            this.four = four;\n        }", "signature": "public void setFour(final String four)"}, {"syntax_pass": true, "original_string": "        public void setOne(final String one) {\n            this.one = one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setOne", "params": [{"name": "one", "type": "String"}], "body": "                                             {\n            this.one = one;\n        }", "signature": "public void setOne(final String one)"}, {"syntax_pass": true, "original_string": "        public void setThree(final String three) {\n            this.three = three;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setThree", "params": [{"name": "three", "type": "String"}], "body": "                                                 {\n            this.three = three;\n        }", "signature": "public void setThree(final String three)"}, {"syntax_pass": true, "original_string": "        public void setTwo(final String two) {\n            this.two = two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setTwo", "params": [{"name": "two", "type": "String"}], "body": "                                             {\n            this.two = two;\n        }", "signature": "public void setTwo(final String two)"}]}, {"original_string": "    private static final class TestNoGetter {\n        private String testField;\n\n        /**\n         * Add setter to trigger JavaBeans to populate a PropertyDescriptor\n         *\n         * @param testField The new testField value\n         */\n        public void setTestField(final String testField) {\n            this.testField = testField;\n        }\n    }", "definition": "    private static final class TestNoGetter", "class_docstring": "", "name": "TestNoGetter", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private String testField;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "testField", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public void setTestField(final String testField) {\n            this.testField = testField;\n        }", "docstring": "\nAdd setter to trigger JavaBeans to populate a PropertyDescriptor\n\n@param testField The new testField value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setTestField", "params": [{"name": "testField", "type": "String"}], "body": "                                                         {\n            this.testField = testField;\n        }", "signature": "public void setTestField(final String testField)"}]}, {"original_string": "    private static final class TestWrongSetter {\n        private Integer testField;\n\n        public Integer getTestField() {\n            return testField;\n        }\n\n        /**\n         * dbutils checks for a setter with exactly 1 param. This tests resilience to a found setter that doesn't match expectations.\n         *\n         * @param idx\n         * @param testField\n         */\n        public void setTestField(final int idx, final Integer testField) {\n            this.testField = testField;\n        }\n    }", "definition": "    private static final class TestWrongSetter", "class_docstring": "", "name": "TestWrongSetter", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private Integer testField;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "testField", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Integer getTestField() {\n            return testField;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "getTestField", "params": [], "body": "                                      {\n            return testField;\n        }", "signature": "public Integer getTestField()"}, {"syntax_pass": true, "original_string": "        public void setTestField(final int idx, final Integer testField) {\n            this.testField = testField;\n        }", "docstring": "\ndbutils checks for a setter with exactly 1 param. This tests resilience to a found setter that doesn't match expectations.\n\n@param idx\n@param testField\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setTestField", "params": [{"name": "idx", "type": "int"}, {"name": "testField", "type": "Integer"}], "body": "                                                                         {\n            this.testField = testField;\n        }", "signature": "public void setTestField(final int idx, final Integer testField)"}]}], "class_docstring": "", "original_string": "public class BeanProcessorTest extends BaseTestCase {\n\n    private static final class IndexedPropertyTestClass {\n        private String name;\n        // Indexed variable with indexed getter and setter\n        private List<String> things;\n        // Indexed variable without indexed getter or setter\n        private List<String> stuff;\n\n        public String getName() {\n            return name;\n        }\n\n        public List<String> getStuff() {\n            return stuff;\n        }\n\n        public String getThing(final int idx) {\n            return things.get(idx);\n        }\n\n        public List<String> getThings() {\n            return things;\n        }\n\n        public void setName(final String name) {\n            this.name = name;\n        }\n\n        public void setStuff(final List<String> stuff) {\n            this.stuff = stuff;\n        }\n\n        public void setThing(final int idx, final String thing) {\n            this.things.set(idx, thing);\n        }\n\n        public void setThings(final List<String> things) {\n            this.things = things;\n        }\n    }\n\n    public static class MapColumnToAnnotationFieldBean {\n        private String one;\n\n        private String two;\n\n        private String three;\n\n        private String four;\n\n        public String getFour() {\n            return four;\n        }\n\n        public String getOne() {\n            return one;\n        }\n\n        @Column(name = \"three_\")\n        public String getThree() {\n            return three;\n        }\n\n        public String getTwo() {\n            return two;\n        }\n\n        public void setFour(final String four) {\n            this.four = four;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final String three) {\n            this.three = three;\n        }\n\n        public void setTwo(final String two) {\n            this.two = two;\n        }\n    }\n\n    public static class MapColumnToPropertiesBean {\n        private String one;\n\n        private String two;\n\n        private String three;\n\n        private String four;\n\n        public String getFour() {\n            return four;\n        }\n\n        public String getOne() {\n            return one;\n        }\n\n        public String getThree() {\n            return three;\n        }\n\n        public String getTwo() {\n            return two;\n        }\n\n        public void setFour(final String four) {\n            this.four = four;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final String three) {\n            this.three = three;\n        }\n\n        public void setTwo(final String two) {\n            this.two = two;\n        }\n    }\n\n    private static final class TestNoGetter {\n        private String testField;\n\n        /**\n         * Add setter to trigger JavaBeans to populate a PropertyDescriptor\n         *\n         * @param testField The new testField value\n         */\n        public void setTestField(final String testField) {\n            this.testField = testField;\n        }\n    }\n\n    private static final class TestWrongSetter {\n        private Integer testField;\n\n        public Integer getTestField() {\n            return testField;\n        }\n\n        /**\n         * dbutils checks for a setter with exactly 1 param. This tests resilience to a found setter that doesn't match expectations.\n         *\n         * @param idx\n         * @param testField\n         */\n        public void setTestField(final int idx, final Integer testField) {\n            this.testField = testField;\n        }\n    }\n\n    private static final BeanProcessor beanProc = new BeanProcessor();\n\n    public void testCheckAnnotationOnMissingReadMethod() throws Exception {\n        final String[] colNames = { \"testField\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final String testField = \"first\";\n        final Object[][] rows = { new Object[] { testField } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        TestNoGetter testCls = new TestNoGetter();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertEquals(testCls.testField, \"first\");\n    }\n\n    /**\n     * Based on the report in DBUTILS-150. This test validates that indexed property descriptors are not used, and indexed getter/setter methods are not\n     * inspected.\n     *\n     * @throws Exception\n     * @see <a href=\"https://issues.apache.org/jira/browse/DBUTILS-150\">DBUTILS-150</a>\n     */\n    public void testIndexedPropertyDescriptor() throws Exception {\n        final String[] colNames = { \"name\", \"things\", \"stuff\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final String name = \"first\";\n        final List<String> things = Arrays.asList(\"1\", \"2\", \"3\", \"4\");\n        final List<String> stuff = things;\n        final Object[][] rows = { new Object[] { name, things, stuff } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        IndexedPropertyTestClass testCls = new IndexedPropertyTestClass();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertEquals(name, testCls.getName());\n        assertArrayEquals(things.toArray(), testCls.getThings().toArray());\n        assertArrayEquals(stuff.toArray(), testCls.getStuff().toArray());\n    }\n\n    public void testMapColumnToAnnotationField() throws Exception {\n        final String[] columnNames = { \"test\", \"test\", \"three_\" };\n        final String[] columnLabels = { \"one\", \"two\", null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToAnnotationFieldBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }\n\n    public void testMapColumnToProperties() throws Exception {\n        final String[] columnNames = { \"test\", \"test\", \"three\" };\n        final String[] columnLabels = { \"one\", \"two\", null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToPropertiesBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }\n\n    public void testMapColumnToPropertiesWithOverrides() throws Exception {\n        final Map<String, String> columnToPropertyOverrides = new HashMap<>();\n        columnToPropertyOverrides.put(\"five\", \"four\");\n        final BeanProcessor beanProc = new BeanProcessor(columnToPropertyOverrides);\n        final String[] columnNames = { \"test\", \"test\", \"three\", \"five\" };\n        final String[] columnLabels = { \"one\", \"two\", null, null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToPropertiesBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }\n\n    public void testProcessWithPopulateBean() throws SQLException {\n        TestBean b = new TestBean();\n        final ResultSet rs = getResultSet();\n        assertTrue(rs.next());\n        b = beanProc.populateBean(rs, b);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.THREE);\n\n        assertTrue(rs.next());\n        b = beanProc.populateBean(rs, b);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.SIX);\n\n        assertFalse(rs.next());\n    }\n\n    public void testProcessWithToBean() throws SQLException {\n        final ResultSet rs = getResultSet();\n        assertTrue(rs.next());\n        TestBean b = beanProc.toBean(rs, TestBean.class);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.THREE);\n\n        assertTrue(rs.next());\n        b = beanProc.toBean(rs, TestBean.class);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.SIX);\n\n        assertFalse(rs.next());\n    }\n\n    public void testWrongSetterParamCount() throws Exception {\n        final String[] colNames = { \"testField\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final Integer testField = 1;\n        final Object[][] rows = { new Object[] { testField } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        TestWrongSetter testCls = new TestWrongSetter();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertNull(testCls.testField);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final BeanProcessor beanProc = new BeanProcessor();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "BeanProcessor", "name": "beanProc = new BeanProcessor()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet", "name": "MockResultSet", "file_path": "src/test/java/org/apache/commons/dbutils/MockResultSet.java", "superclasses": "", "methods": ["[ResultSet]create(ResultSetMetaData,Object[][])", "[]MockResultSet(ResultSetMetaData,Object[][])", "[int]columnIndex(Object[])", "[int]columnNameToIndex(String)", "[Object]getBoolean(int)", "[Object]getByte(int)", "[Object]getDouble(int)", "[Object]getFloat(int)", "[Object]getInt(int)", "[Object]getLong(int)", "[ResultSetMetaData]getMetaData()", "[Object]getObject(int)", "[Object]getShort(int)", "[String]getString(int)", "[Object]handleColumnMethod(String,Object[])", "[Object]handleNonColumnMethod(String,Object,Object[])", "[Object]invoke(Object,Method,Object[])", "[boolean]isColumnMethod(String)", "[Boolean]isLast()", "[Boolean]next()", "[void]setWasNull(Object)", "[Boolean]wasNull()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[ResultSet]create(ResultSetMetaData,Object[][])", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[]MockResultSet(ResultSetMetaData,Object[][])", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[int]columnIndex(Object[])", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[int]columnNameToIndex(String)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Object]getBoolean(int)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Object]getByte(int)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Object]getDouble(int)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Object]getFloat(int)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Object]getInt(int)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Object]getLong(int)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[ResultSetMetaData]getMetaData()", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Object]getObject(int)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Object]getShort(int)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[String]getString(int)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Object]handleColumnMethod(String,Object[])", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Object]handleNonColumnMethod(String,Object,Object[])", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Object]invoke(Object,Method,Object[])", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[boolean]isColumnMethod(String)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Boolean]isLast()", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Boolean]next()", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[void]setWasNull(Object)", "src/test/java/org/apache/commons/dbutils/MockResultSet.java.MockResultSet.[Boolean]wasNull()"], "overrides": null, "attributes": [], "class_docstring": "\nMockResultSet dynamically implements the ResultSet interface.\n", "original_string": "public class MockResultSet implements InvocationHandler {\n\n    private static final Set<String> METHOD_NAMES = Set.of(\"isLast\", \"hashCode\", \"toString\", \"equals\");\n\n    /**\n     * Create a {@code MockResultSet} proxy object. This is equivalent to:\n     *\n     * <pre>\n     * ProxyFactory.instance().createResultSet(new MockResultSet(metaData, rows));\n     * </pre>\n     *\n     * @param metaData\n     * @param rows     A null value indicates an empty {@code ResultSet}.\n     */\n    public static ResultSet create(final ResultSetMetaData metaData, final Object[][] rows) {\n        return ProxyFactory.instance().createResultSet(new MockResultSet(metaData, rows));\n    }\n\n    private Object[] currentRow;\n\n    private Iterator<Object[]> iter;\n\n    private final ResultSetMetaData metaData;\n\n    private Boolean wasNull = Boolean.FALSE;\n\n    /**\n     * MockResultSet constructor.\n     *\n     * @param metaData\n     * @param rows     A null value indicates an empty {@code ResultSet}.\n     */\n    public MockResultSet(final ResultSetMetaData metaData, final Object[][] rows) {\n        this.metaData = metaData;\n        if (rows == null) {\n            final List<Object[]> empty = Collections.emptyList();\n            this.iter = empty.iterator();\n        } else {\n            this.iter = Arrays.asList(rows).iterator();\n        }\n    }\n\n    /**\n     * The get* methods can have an int column index or a String column name as the parameter. This method handles both cases and returns the column index that\n     * the client is trying to get at.\n     *\n     * @param args\n     * @return A column index.\n     * @throws SQLException if a database access error occurs\n     */\n    private int columnIndex(final Object[] args) throws SQLException {\n\n        if (args[0] instanceof Integer) {\n            return ((Integer) args[0]).intValue();\n\n        }\n        if (args[0] instanceof String) {\n            return columnNameToIndex((String) args[0]);\n\n        }\n        throw new SQLException(args[0] + \" must be Integer or String\");\n    }\n\n    /**\n     * Returns the column index for the given column name.\n     *\n     * @return A 1 based index\n     * @throws SQLException if the column name is invalid\n     */\n    private int columnNameToIndex(final String columnName) throws SQLException {\n        for (int i = 0; i < this.currentRow.length; i++) {\n            final int c = i + 1;\n            if (this.metaData.getColumnName(c).equalsIgnoreCase(columnName)) {\n                return c;\n            }\n        }\n\n        throw new SQLException(columnName + \" is not a valid column name.\");\n    }\n\n    /**\n     * Gets the boolean value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getBoolean(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Boolean.FALSE : Boolean.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the byte value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getByte(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Byte.valueOf((byte) 0) : Byte.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the double value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getDouble(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Double.valueOf(0) : Double.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the float value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getFloat(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Float.valueOf(0) : Float.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the int value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getInt(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Integer.valueOf(0) : Integer.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the long value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getLong(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Long.valueOf(0) : Long.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected ResultSetMetaData getMetaData() throws SQLException {\n        return this.metaData;\n    }\n\n    /**\n     * Gets the object at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getObject(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n        return obj;\n    }\n\n    /**\n     * Gets the short value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getShort(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Short.valueOf((short) 0) : Short.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the String at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected String getString(final int columnIndex) throws SQLException {\n        final Object obj = getObject(columnIndex);\n        setWasNull(obj);\n        return Objects.toString(obj, null);\n    }\n\n    private Object handleColumnMethod(final String methodName, final Object[] args) throws SQLException {\n        switch (methodName) {\n            case \"getBoolean\":\n                return getBoolean(columnIndex(args));\n            case \"getByte\":\n                return getByte(columnIndex(args));\n            case \"getDouble\":\n                return getDouble(columnIndex(args));\n            case \"getFloat\":\n                return getFloat(columnIndex(args));\n            case \"getInt\":\n                return getInt(columnIndex(args));\n            case \"getLong\":\n                return getLong(columnIndex(args));\n            case \"getObject\":\n                return getObject(columnIndex(args));\n            case \"getShort\":\n                return getShort(columnIndex(args));\n            case \"getString\":\n                return getString(columnIndex(args));\n            case \"wasNull\":\n                return wasNull();\n            default:\n                throw new UnsupportedOperationException(\"Unsupported column method: \" + methodName);\n        }\n    }\n\n    private Object handleNonColumnMethod(final String methodName, final Object proxy, final Object[] args) throws SQLException {\n        switch (methodName) {\n            case \"isLast\":\n                return isLast();\n            case \"hashCode\":\n                return Integer.valueOf(System.identityHashCode(proxy));\n            case \"toString\":\n                return \"MockResultSet \" + System.identityHashCode(proxy);\n            case \"equals\":\n                return Boolean.valueOf(proxy == args[0]);\n            default:\n                throw new UnsupportedOperationException(\"Unsupported non-column method: \" + methodName);\n        }\n    }\n\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        final String methodName = method.getName();\n        switch (methodName) {\n        case \"getMetaData\":\n            return getMetaData();\n        case \"next\":\n            return next();\n        case \"previous\":\n            break;\n        case \"close\":\n            break;\n        default:\n            if (isColumnMethod(methodName)) {\n                return handleColumnMethod(methodName, args);\n            } else if (METHOD_NAMES.contains(methodName)) {\n                return handleNonColumnMethod(methodName, proxy, args);\n            }\n            break;\n        }\n        throw new UnsupportedOperationException(\"Unsupported method: \" + methodName);\n    }\n\n    private boolean isColumnMethod(final String methodName) {\n        return methodName.startsWith(\"get\") || methodName.equals(\"wasNull\");\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected Boolean isLast() throws SQLException {\n        return this.iter.hasNext() ? Boolean.FALSE : Boolean.TRUE;\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected Boolean next() throws SQLException {\n        if (!this.iter.hasNext()) {\n            return Boolean.FALSE;\n        }\n        this.currentRow = iter.next();\n        return Boolean.TRUE;\n    }\n\n    /**\n     * Assigns this.wasNull a Boolean value based on the object passed in.\n     *\n     * @param isNull\n     */\n    private void setWasNull(final Object isNull) {\n        this.wasNull = isNull == null ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected Boolean wasNull() throws SQLException {\n        return this.wasNull;\n    }\n}", "super_interfaces": ["InvocationHandler"], "fields": [{"attribute_expression": "private static final Set<String> METHOD_NAMES = Set.of(\"isLast\", \"hashCode\", \"toString\", \"equals\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Set<String>", "name": "METHOD_NAMES = Set.of(\"isLast\", \"hashCode\", \"toString\", \"equals\")", "syntax_pass": true}, {"attribute_expression": "private Object[] currentRow;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Object[]", "name": "currentRow", "syntax_pass": true}, {"attribute_expression": "private Iterator<Object[]> iter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<Object[]>", "name": "iter", "syntax_pass": true}, {"attribute_expression": "private final ResultSetMetaData metaData;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ResultSetMetaData", "name": "metaData", "syntax_pass": true}, {"attribute_expression": "private Boolean wasNull = Boolean.FALSE;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Boolean", "name": "wasNull = Boolean.FALSE", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/ProxyFactoryTest.java.ProxyFactoryTest", "name": "ProxyFactoryTest", "file_path": "src/test/java/org/apache/commons/dbutils/ProxyFactoryTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testCreateCallableStatement()", "[void]testCreateConnection()", "[void]testCreateDriver()", "[void]testCreatePreparedStatement()", "[void]testCreateResultSet()", "[void]testCreateResultSetMetaData()", "[void]testCreateStatement()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/ProxyFactoryTest.java.ProxyFactoryTest.[void]testCreateCallableStatement()", "src/test/java/org/apache/commons/dbutils/ProxyFactoryTest.java.ProxyFactoryTest.[void]testCreateConnection()", "src/test/java/org/apache/commons/dbutils/ProxyFactoryTest.java.ProxyFactoryTest.[void]testCreateDriver()", "src/test/java/org/apache/commons/dbutils/ProxyFactoryTest.java.ProxyFactoryTest.[void]testCreatePreparedStatement()", "src/test/java/org/apache/commons/dbutils/ProxyFactoryTest.java.ProxyFactoryTest.[void]testCreateResultSet()", "src/test/java/org/apache/commons/dbutils/ProxyFactoryTest.java.ProxyFactoryTest.[void]testCreateResultSetMetaData()", "src/test/java/org/apache/commons/dbutils/ProxyFactoryTest.java.ProxyFactoryTest.[void]testCreateStatement()"], "overrides": null, "attributes": [], "class_docstring": "\nProxyFactoryTest performs simple type checking on proxy objects returned from a ProxyFactory.\n", "original_string": "public class ProxyFactoryTest extends BaseTestCase {\n\n    private static final InvocationHandler stub = (proxy, method, args) -> null;\n\n    public void testCreateCallableStatement() {\n        assertNotNull(ProxyFactory.instance().createCallableStatement(stub));\n    }\n\n    public void testCreateConnection() {\n        assertNotNull(ProxyFactory.instance().createConnection(stub));\n    }\n\n    public void testCreateDriver() {\n        assertNotNull(ProxyFactory.instance().createDriver(stub));\n    }\n\n    public void testCreatePreparedStatement() {\n        assertNotNull(ProxyFactory.instance().createPreparedStatement(stub));\n    }\n\n    public void testCreateResultSet() {\n        assertNotNull(ProxyFactory.instance().createResultSet(stub));\n    }\n\n    public void testCreateResultSetMetaData() {\n        assertNotNull(ProxyFactory.instance().createResultSetMetaData(stub));\n    }\n\n    public void testCreateStatement() {\n        assertNotNull(ProxyFactory.instance().createStatement(stub));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final InvocationHandler stub = (proxy, method, args) -> null;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "InvocationHandler", "name": "stub = (proxy, method, args) -> null", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/BaseTestCase.java.BaseTestCase", "name": "BaseTestCase", "file_path": "src/test/java/org/apache/commons/dbutils/BaseTestCase.java", "superclasses": "TestCase", "methods": ["[ResultSet]createMockResultSet()", "[ResultSet]getEmptyResultSet()", "[ResultSet]getResultSet()", "[void]setResultSet(ResultSet)", "[void]setUp()", "[void]testCheckDataSizes()", "[void]testResultSets()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/BaseTestCase.java.BaseTestCase.[ResultSet]createMockResultSet()", "src/test/java/org/apache/commons/dbutils/BaseTestCase.java.BaseTestCase.[ResultSet]getEmptyResultSet()", "src/test/java/org/apache/commons/dbutils/BaseTestCase.java.BaseTestCase.[ResultSet]getResultSet()", "src/test/java/org/apache/commons/dbutils/BaseTestCase.java.BaseTestCase.[void]setResultSet(ResultSet)", "src/test/java/org/apache/commons/dbutils/BaseTestCase.java.BaseTestCase.[void]setUp()", "src/test/java/org/apache/commons/dbutils/BaseTestCase.java.BaseTestCase.[void]testCheckDataSizes()", "src/test/java/org/apache/commons/dbutils/BaseTestCase.java.BaseTestCase.[void]testResultSets()"], "overrides": null, "attributes": [], "class_docstring": "\nBaseTestCase is the base class for all test cases as well as the \"all tests\" runner.\n", "original_string": "public class BaseTestCase extends TestCase {\n\n    private static final String[] columnNames = { \"one\", \"two\", \"three\", \"notInBean\", \"intTest\", \"integerTest\", \"nullObjectTest\", \"nullPrimitiveTest\",\n            \"notDate\", \"columnProcessorDoubleTest\", null };\n\n    /**\n     * The number of columns in the MockResultSet.\n     */\n    protected static final int COLS = columnNames.length;\n\n    protected static final ResultSetMetaData metaData = MockResultSetMetaData.create(columnNames);\n\n    /**\n     * A Timestamp for test purposes having 9 decimals\n     */\n    static final Timestamp ts789456123;\n\n    static {\n        ts789456123 = new Timestamp(new Date().getTime());\n        ts789456123.setNanos(789456123);\n    }\n\n    private static final Object[] row1 = { \"1\", \"2\", \"THREE\", \"  notInBean  \", Integer.valueOf(1), Integer.valueOf(2), null, null, new Date(),\n            BigInteger.valueOf(13), null };\n\n    private static final Object[] row2 = { \"4\", \"5\", \"SIX\", \"  notInBean  \", Integer.valueOf(3), Integer.valueOf(4), null, null, ts789456123,\n            BigInteger.valueOf(13), null };\n\n    private static final Object[][] rows = { row1, row2 };\n\n    /**\n     * The number of rows in the MockResultSet.\n     */\n    protected static final int ROWS = rows.length;\n\n    /**\n     * The ResultSet all test methods will use.\n     */\n    private ResultSet rs;\n\n    /**\n     * A ResultSet with 0 rows.\n     */\n    private ResultSet emptyResultSet;\n\n    /**\n     * Creates a freshly initialized ResultSet.\n     */\n    protected ResultSet createMockResultSet() {\n        return MockResultSet.create(metaData, rows);\n    }\n\n    public ResultSet getEmptyResultSet() {\n        return this.emptyResultSet;\n    }\n\n    public ResultSet getResultSet() {\n        return this.rs;\n    }\n\n    public void setResultSet(final ResultSet resultSet) {\n        this.rs = resultSet;\n    }\n\n    /**\n     * This is called before each test method so ResultSet will be fresh each time.\n     *\n     * @see junit.framework.TestCase#setUp()\n     */\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n\n        rs = createMockResultSet();\n        emptyResultSet = MockResultSet.create(metaData, null);\n    }\n\n    // Test which allows Eclipse to be run on full project (avoids no tests found)\n    // check that the rows are valid for the column definition\n    public void testCheckDataSizes() {\n        assertEquals(\"Row 1 must contain correct number of columns\", columnNames.length, row1.length);\n        assertEquals(\"Row 1 must contain correct number of columns\", columnNames.length, row2.length);\n    }\n\n    public void testResultSets() throws Exception {\n        assertFalse(\"emptyResultSet should be empty\", emptyResultSet.next());\n        // fails in SqlNullCheckedResultSetTest assertTrue(\"rs should not be empty\", rs.next());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String[] columnNames = { \"one\", \"two\", \"three\", \"notInBean\", \"intTest\", \"integerTest\", \"nullObjectTest\", \"nullPrimitiveTest\",\n            \"notDate\", \"columnProcessorDoubleTest\", null };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "columnNames = { \"one\", \"two\", \"three\", \"notInBean\", \"intTest\", \"integerTest\", \"nullObjectTest\", \"nullPrimitiveTest\",\n            \"notDate\", \"columnProcessorDoubleTest\", null }", "syntax_pass": true}, {"attribute_expression": "protected static final int COLS = columnNames.length;", "docstring": "\nThe number of columns in the MockResultSet.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "COLS = columnNames.length", "syntax_pass": true}, {"attribute_expression": "protected static final ResultSetMetaData metaData = MockResultSetMetaData.create(columnNames);", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "ResultSetMetaData", "name": "metaData = MockResultSetMetaData.create(columnNames)", "syntax_pass": true}, {"attribute_expression": "static final Timestamp ts789456123;", "docstring": "\nA Timestamp for test purposes having 9 decimals\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Timestamp", "name": "ts789456123", "syntax_pass": true}, {"attribute_expression": "private static final Object[] row1 = { \"1\", \"2\", \"THREE\", \"  notInBean  \", Integer.valueOf(1), Integer.valueOf(2), null, null, new Date(),\n            BigInteger.valueOf(13), null };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object[]", "name": "row1 = { \"1\", \"2\", \"THREE\", \"  notInBean  \", Integer.valueOf(1), Integer.valueOf(2), null, null, new Date(),\n            BigInteger.valueOf(13), null }", "syntax_pass": true}, {"attribute_expression": "private static final Object[] row2 = { \"4\", \"5\", \"SIX\", \"  notInBean  \", Integer.valueOf(3), Integer.valueOf(4), null, null, ts789456123,\n            BigInteger.valueOf(13), null };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object[]", "name": "row2 = { \"4\", \"5\", \"SIX\", \"  notInBean  \", Integer.valueOf(3), Integer.valueOf(4), null, null, ts789456123,\n            BigInteger.valueOf(13), null }", "syntax_pass": true}, {"attribute_expression": "private static final Object[][] rows = { row1, row2 };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object[][]", "name": "rows = { row1, row2 }", "syntax_pass": true}, {"attribute_expression": "protected static final int ROWS = rows.length;", "docstring": "\nThe number of rows in the MockResultSet.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "ROWS = rows.length", "syntax_pass": true}, {"attribute_expression": "private ResultSet rs;", "docstring": "\nThe ResultSet all test methods will use.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "rs", "syntax_pass": true}, {"attribute_expression": "private ResultSet emptyResultSet;", "docstring": "\nA ResultSet with 0 rows.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "emptyResultSet", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/BasicRowProcessorTest.java.BasicRowProcessorTest", "name": "BasicRowProcessorTest", "file_path": "src/test/java/org/apache/commons/dbutils/BasicRowProcessorTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testPutAllContainsKeyAndRemove()", "[void]testToArray()", "[void]testToBean()", "[void]testToBeanList()", "[void]testToMap()", "[void]testToMapOrdering()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/BasicRowProcessorTest.java.BasicRowProcessorTest.[void]testPutAllContainsKeyAndRemove()", "src/test/java/org/apache/commons/dbutils/BasicRowProcessorTest.java.BasicRowProcessorTest.[void]testToArray()", "src/test/java/org/apache/commons/dbutils/BasicRowProcessorTest.java.BasicRowProcessorTest.[void]testToBean()", "src/test/java/org/apache/commons/dbutils/BasicRowProcessorTest.java.BasicRowProcessorTest.[void]testToBeanList()", "src/test/java/org/apache/commons/dbutils/BasicRowProcessorTest.java.BasicRowProcessorTest.[void]testToMap()", "src/test/java/org/apache/commons/dbutils/BasicRowProcessorTest.java.BasicRowProcessorTest.[void]testToMapOrdering()"], "overrides": null, "attributes": [], "class_docstring": "\nTest the BasicRowProcessor class.\n", "original_string": "public class BasicRowProcessorTest extends BaseTestCase {\n\n    private static final RowProcessor processor = new BasicRowProcessor();\n\n    /**\n     * Format that matches Date.toString(). Sun Mar 14 15:19:15 MST 2004\n     */\n    private static final DateFormat datef = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\", Locale.US);\n\n    public void testPutAllContainsKeyAndRemove() throws Exception {\n        final Map<String, Object> test = new HashMap<>(3);\n        test.put(\"fiRst\", \"thing\");\n        test.put(\"seCond\", \"another\");\n        test.put(\"thIrd\", \"more\");\n        final Map<String, Object> brpMap = BasicRowProcessor.createCaseInsensitiveHashMap(3);\n        brpMap.putAll(test);\n\n        assertEquals(test, brpMap);\n        assertTrue(brpMap.containsKey(\"fiRst\"));\n        assertTrue(brpMap.containsKey(\"first\"));\n\n        brpMap.remove(\"first\");\n        assertFalse(brpMap.containsKey(\"first\"));\n    }\n\n    public void testToArray() throws SQLException {\n\n        Object[] a;\n        assertTrue(getResultSet().next());\n        a = processor.toArray(getResultSet());\n        assertEquals(COLS, a.length);\n        assertEquals(\"1\", a[0]);\n        assertEquals(\"2\", a[1]);\n        assertEquals(\"THREE\", a[2]);\n\n        assertTrue(getResultSet().next());\n        a = processor.toArray(getResultSet());\n        assertEquals(COLS, a.length);\n\n        assertEquals(\"4\", a[0]);\n        assertEquals(\"5\", a[1]);\n        assertEquals(\"SIX\", a[2]);\n\n        assertFalse(getResultSet().next());\n    }\n\n    public void testToBean() throws SQLException, ParseException {\n\n        assertTrue(getResultSet().next());\n        TestBean row = processor.toBean(getResultSet(), TestBean.class);\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(getResultSet().next());\n        row = processor.toBean(getResultSet(), TestBean.class);\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n        assertEquals(3, row.getIntTest());\n        assertEquals(Integer.valueOf(4), row.getIntegerTest());\n        assertNull(row.getNullObjectTest());\n        assertEquals(0, row.getNullPrimitiveTest());\n        // test date -> string handling\n        assertNotNull(row.getNotDate());\n        assertTrue(!\"not a date\".equals(row.getNotDate()));\n        assertTrue(row.getNotDate().endsWith(\"789456123\"));\n\n        assertFalse(getResultSet().next());\n\n    }\n\n    public void testToBeanList() throws SQLException, ParseException {\n\n        final List<TestBean> list = processor.toBeanList(getResultSet(), TestBean.class);\n        assertNotNull(list);\n        assertEquals(ROWS, list.size());\n\n        TestBean b = list.get(0);\n        assertEquals(\"1\", b.getOne());\n        assertEquals(\"2\", b.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, b.getThree());\n        assertEquals(\"not set\", b.getDoNotSet());\n        datef.parse(b.getNotDate());\n\n        b = list.get(1);\n        assertEquals(\"4\", b.getOne());\n        assertEquals(\"5\", b.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, b.getThree());\n        assertEquals(\"not set\", b.getDoNotSet());\n        assertEquals(3, b.getIntTest());\n        assertEquals(Integer.valueOf(4), b.getIntegerTest());\n        assertNull(b.getNullObjectTest());\n        assertEquals(0, b.getNullPrimitiveTest());\n        // test date -> string handling\n        assertNotNull(b.getNotDate());\n        assertTrue(!\"not a date\".equals(b.getNotDate()));\n        assertTrue(b.getNotDate().endsWith(\"789456123\"));\n    }\n\n    public void testToMap() throws SQLException {\n\n        assertTrue(getResultSet().next());\n        Map<String, Object> m = processor.toMap(getResultSet());\n        assertEquals(COLS, m.size());\n        assertEquals(\"1\", m.get(\"one\"));\n        assertEquals(\"2\", m.get(\"TWO\"));\n        assertEquals(\"THREE\", m.get(\"Three\"));\n\n        assertTrue(getResultSet().next());\n        m = processor.toMap(getResultSet());\n        assertEquals(COLS, m.size());\n\n        assertEquals(\"4\", m.get(\"One\")); // case shouldn't matter\n        assertEquals(\"5\", m.get(\"two\"));\n        assertEquals(\"SIX\", m.get(\"THREE\"));\n\n        assertFalse(getResultSet().next());\n    }\n\n    public void testToMapOrdering() throws SQLException {\n\n        assertTrue(getResultSet().next());\n        final Map<String, Object> m = processor.toMap(getResultSet());\n\n        final Iterator<String> itr = m.keySet().iterator();\n        assertEquals(\"one\", itr.next());\n        assertEquals(\"two\", itr.next());\n        assertEquals(\"three\", itr.next());\n        assertEquals(\"notInBean\", itr.next());\n        assertEquals(\"intTest\", itr.next());\n        assertEquals(\"integerTest\", itr.next());\n        assertEquals(\"nullObjectTest\", itr.next());\n        assertEquals(\"nullPrimitiveTest\", itr.next());\n        assertEquals(\"notDate\", itr.next());\n        assertEquals(\"columnProcessorDoubleTest\", itr.next());\n        assertEquals(\"11\", itr.next());\n\n        assertFalse(itr.hasNext());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final RowProcessor processor = new BasicRowProcessor();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "RowProcessor", "name": "processor = new BasicRowProcessor()", "syntax_pass": true}, {"attribute_expression": "private static final DateFormat datef = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\", Locale.US);", "docstring": "\nFormat that matches Date.toString(). Sun Mar 14 15:19:15 MST 2004\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "DateFormat", "name": "datef = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\", Locale.US)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/QueryLoaderTest.java.QueryLoaderTest", "name": "QueryLoaderTest", "file_path": "src/test/java/org/apache/commons/dbutils/QueryLoaderTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testLoad()", "[void]testLoadThrowsIllegalArgumentException()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/QueryLoaderTest.java.QueryLoaderTest.[void]testLoad()", "src/test/java/org/apache/commons/dbutils/QueryLoaderTest.java.QueryLoaderTest.[void]testLoadThrowsIllegalArgumentException()"], "overrides": null, "attributes": [], "class_docstring": "\nQueryLoaderTest\n", "original_string": "public class QueryLoaderTest extends BaseTestCase {\n\n    private static final String QUERIES = \"/org/apache/commons/dbutils/TestQueries.properties\";\n\n    public void testLoad() throws IOException {\n        final QueryLoader loader = QueryLoader.instance();\n        final Map<String, String> q = loader.load(QUERIES);\n        final Map<String, String> q2 = loader.load(QUERIES);\n        assertSame(q, q2); // pointer comparison should return true\n        assertEquals(\"SELECT * FROM SomeTable\", q.get(\"test.query\"));\n\n        loader.unload(QUERIES);\n        final Map<String, String> q3 = loader.load(QUERIES);\n        assertTrue(q != q3); // pointer comparison should return false\n    }\n\n    public void testLoadThrowsIllegalArgumentException() throws IOException {\n\n        final QueryLoader queryLoader = QueryLoader.instance();\n\n        try {\n            queryLoader.load(\"e\");\n            fail(\"Expecting exception: IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(\"e not found.\", e.getMessage());\n            assertEquals(QueryLoader.class.getName(), e.getStackTrace()[0].getClassName());\n        }\n\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String QUERIES = \"/org/apache/commons/dbutils/TestQueries.properties\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "QUERIES = \"/org/apache/commons/dbutils/TestQueries.properties\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/MockResultSetMetaData.java.MockResultSetMetaData", "name": "MockResultSetMetaData", "file_path": "src/test/java/org/apache/commons/dbutils/MockResultSetMetaData.java", "superclasses": "", "methods": ["[ResultSetMetaData]create(String[])", "[]MockResultSetMetaData(String[])", "[]MockResultSetMetaData(String[],String[])", "[Object]invoke(Object,Method,Object[])"], "method_uris": ["src/test/java/org/apache/commons/dbutils/MockResultSetMetaData.java.MockResultSetMetaData.[ResultSetMetaData]create(String[])", "src/test/java/org/apache/commons/dbutils/MockResultSetMetaData.java.MockResultSetMetaData.[]MockResultSetMetaData(String[])", "src/test/java/org/apache/commons/dbutils/MockResultSetMetaData.java.MockResultSetMetaData.[]MockResultSetMetaData(String[],String[])", "src/test/java/org/apache/commons/dbutils/MockResultSetMetaData.java.MockResultSetMetaData.[Object]invoke(Object,Method,Object[])"], "overrides": null, "attributes": [], "class_docstring": "\nMockResultSetMetaData dynamically implements the ResultSetMetaData interface.\n", "original_string": "public class MockResultSetMetaData implements InvocationHandler {\n\n    /**\n     * Create a {@code MockResultSetMetaData} proxy object. This is equivalent to:\n     *\n     * <pre>\n     * ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames));\n     * </pre>\n     *\n     * @param columnNames\n     * @return the proxy object\n     */\n    public static ResultSetMetaData create(final String[] columnNames) {\n        return ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames));\n    }\n\n    private final String[] columnNames;\n\n    private final String[] columnLabels;\n\n    public MockResultSetMetaData(final String[] columnNames) {\n        this.columnNames = columnNames;\n        this.columnLabels = new String[columnNames.length];\n\n    }\n\n    public MockResultSetMetaData(final String[] columnNames, final String[] columnLabels) {\n        this.columnNames = columnNames;\n        this.columnLabels = columnLabels;\n    }\n\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n        final String methodName = method.getName();\n        switch (methodName) {\n        case \"getColumnCount\":\n            return Integer.valueOf(this.columnNames.length);\n        case \"getColumnName\":\n            final int col1 = ((Integer) args[0]).intValue() - 1;\n            return this.columnNames[col1];\n        case \"getColumnLabel\":\n            final int col2 = ((Integer) args[0]).intValue() - 1;\n            return this.columnLabels[col2];\n        case \"hashCode\":\n            return Integer.valueOf(System.identityHashCode(proxy));\n        case \"toString\":\n            return \"MockResultSetMetaData \" + System.identityHashCode(proxy);\n        case \"equals\":\n            return Boolean.valueOf(proxy == args[0]);\n        default:\n            break;\n        }\n        throw new UnsupportedOperationException(\"Unsupported method: \" + methodName);\n    }\n}", "super_interfaces": ["InvocationHandler"], "fields": [{"attribute_expression": "private final String[] columnNames;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "columnNames", "syntax_pass": true}, {"attribute_expression": "private final String[] columnLabels;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "columnLabels", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean", "name": "TestBean", "file_path": "src/test/java/org/apache/commons/dbutils/TestBean.java", "superclasses": "", "methods": ["[]TestBean()", "[double]getColumnProcessorDoubleTest()", "[String]getDoNotSet()", "[Integer]getIntegerTest()", "[int]getIntTest()", "[String]getNotDate()", "[Object]getNullObjectTest()", "[int]getNullPrimitiveTest()", "[String]getOne()", "[Ordinal]getThree()", "[String]getTwo()", "[void]setColumnProcessorDoubleTest(double)", "[void]setDoNotSet(String)", "[void]setIntegerTest(Integer)", "[void]setIntTest(int)", "[void]setNotDate(String)", "[void]setNullObjectTest(Object)", "[void]setNullPrimitiveTest(int)", "[void]setOne(String)", "[void]setThree(Ordinal)", "[void]setTwo(String)"], "method_uris": ["src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[]TestBean()", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[double]getColumnProcessorDoubleTest()", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[String]getDoNotSet()", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[Integer]getIntegerTest()", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[int]getIntTest()", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[String]getNotDate()", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[Object]getNullObjectTest()", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[int]getNullPrimitiveTest()", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[String]getOne()", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[Ordinal]getThree()", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[String]getTwo()", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[void]setColumnProcessorDoubleTest(double)", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[void]setDoNotSet(String)", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[void]setIntegerTest(Integer)", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[void]setIntTest(int)", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[void]setNotDate(String)", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[void]setNullObjectTest(Object)", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[void]setNullPrimitiveTest(int)", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[void]setOne(String)", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[void]setThree(Ordinal)", "src/test/java/org/apache/commons/dbutils/TestBean.java.TestBean.[void]setTwo(String)"], "overrides": null, "attributes": [], "class_docstring": "\nA bean to use in testing toBean() and toBeanList().\n", "original_string": "public class TestBean {\n\n    public enum Ordinal {\n\n        THREE, SIX;\n\n    }\n\n    private String one;\n\n    private String two;\n\n    private Ordinal three;\n\n    private int intTest;\n\n    private Integer integerTest = Integer.valueOf(0);\n\n    // UNUSED private Timestamp timestamp;\n\n    private String doNotSet = \"not set\";\n\n    /**\n     * toBean() should set primitive fields to their defaults (ie. 0) when null is returned from the ResultSet.\n     */\n    private int nullPrimitiveTest = 7;\n\n    /**\n     * toBean() should set Object fields to null when null is returned from the ResultSet\n     */\n    private Object nullObjectTest = \"overwrite\";\n\n    /**\n     * A Date will be returned from the ResultSet but the property is a String. BeanProcessor should create a String from the Date and set this property.\n     */\n    private String notDate = \"not a date\";\n\n    /**\n     * The ResultSet will have a BigDecimal in this column and the BasicColumnProcessor should convert that to a double and store the value in this property.\n     */\n    private double columnProcessorDoubleTest = -1;\n\n    /**\n     * Constructor for TestBean.\n     */\n    public TestBean() {\n    }\n\n    public double getColumnProcessorDoubleTest() {\n        return columnProcessorDoubleTest;\n    }\n\n    public String getDoNotSet() {\n        return doNotSet;\n    }\n\n    public Integer getIntegerTest() {\n        return integerTest;\n    }\n\n    public int getIntTest() {\n        return intTest;\n    }\n\n    public String getNotDate() {\n        return notDate;\n    }\n\n    public Object getNullObjectTest() {\n        return nullObjectTest;\n    }\n\n    public int getNullPrimitiveTest() {\n        return nullPrimitiveTest;\n    }\n\n    public String getOne() {\n        return one;\n    }\n\n    public Ordinal getThree() {\n        return three;\n    }\n\n    public String getTwo() {\n        return two;\n    }\n\n    public void setColumnProcessorDoubleTest(final double d) {\n        columnProcessorDoubleTest = d;\n    }\n\n    public void setDoNotSet(final String string) {\n        doNotSet = string;\n    }\n\n    public void setIntegerTest(final Integer integer) {\n        integerTest = integer;\n    }\n\n    public void setIntTest(final int i) {\n        intTest = i;\n    }\n\n    public void setNotDate(final String string) {\n        notDate = string;\n    }\n\n    public void setNullObjectTest(final Object object) {\n        nullObjectTest = object;\n    }\n\n    public void setNullPrimitiveTest(final int i) {\n        nullPrimitiveTest = i;\n    }\n\n    public void setOne(final String string) {\n        one = string;\n    }\n\n    public void setThree(final Ordinal ordinal) {\n        three = ordinal;\n    }\n\n    public void setTwo(final String string) {\n        two = string;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private String one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "one", "syntax_pass": true}, {"attribute_expression": "private String two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "two", "syntax_pass": true}, {"attribute_expression": "private Ordinal three;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Ordinal", "name": "three", "syntax_pass": true}, {"attribute_expression": "private int intTest;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "intTest", "syntax_pass": true}, {"attribute_expression": "private Integer integerTest = Integer.valueOf(0);", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "integerTest = Integer.valueOf(0)", "syntax_pass": true}, {"attribute_expression": "private String doNotSet = \"not set\";", "docstring": " UNUSED private Timestamp timestamp;", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "doNotSet = \"not set\"", "syntax_pass": true}, {"attribute_expression": "private int nullPrimitiveTest = 7;", "docstring": "\ntoBean() should set primitive fields to their defaults (ie. 0) when null is returned from the ResultSet.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "nullPrimitiveTest = 7", "syntax_pass": true}, {"attribute_expression": "private Object nullObjectTest = \"overwrite\";", "docstring": "\ntoBean() should set Object fields to null when null is returned from the ResultSet\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Object", "name": "nullObjectTest = \"overwrite\"", "syntax_pass": true}, {"attribute_expression": "private String notDate = \"not a date\";", "docstring": "\nA Date will be returned from the ResultSet but the property is a String. BeanProcessor should create a String from the Date and set this property.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "notDate = \"not a date\"", "syntax_pass": true}, {"attribute_expression": "private double columnProcessorDoubleTest = -1;", "docstring": "\nThe ResultSet will have a BigDecimal in this column and the BasicColumnProcessor should convert that to a double and store the value in this property.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "double", "name": "columnProcessorDoubleTest = -1", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/ArrayHandlerTest.java.ArrayHandlerTest", "name": "ArrayHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/ArrayHandlerTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testEmptyResultSetHandle()", "[void]testHandle()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/ArrayHandlerTest.java.ArrayHandlerTest.[void]testEmptyResultSetHandle()", "src/test/java/org/apache/commons/dbutils/handlers/ArrayHandlerTest.java.ArrayHandlerTest.[void]testHandle()"], "overrides": null, "attributes": [], "class_docstring": "\nArrayHandlerTest\n", "original_string": "public class ArrayHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Object[]> h = new ArrayHandler();\n        final Object[] results = h.handle(getEmptyResultSet());\n\n        assertEquals(0, results.length);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<Object[]> h = new ArrayHandler();\n        final Object[] results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(COLS, results.length);\n        assertEquals(\"1\", results[0]);\n        assertEquals(\"2\", results[1]);\n        assertEquals(\"THREE\", results[2]);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/BeanHandlerTest.java.BeanHandlerTest", "name": "BeanHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/BeanHandlerTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testEmptyResultSetHandle()", "[void]testHandle()", "[void]testHandleToInterface()", "[void]testHandleToSuperClass()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/BeanHandlerTest.java.BeanHandlerTest.[void]testEmptyResultSetHandle()", "src/test/java/org/apache/commons/dbutils/handlers/BeanHandlerTest.java.BeanHandlerTest.[void]testHandle()", "src/test/java/org/apache/commons/dbutils/handlers/BeanHandlerTest.java.BeanHandlerTest.[void]testHandleToInterface()", "src/test/java/org/apache/commons/dbutils/handlers/BeanHandlerTest.java.BeanHandlerTest.[void]testHandleToSuperClass()"], "overrides": null, "attributes": [{"original_string": "    public static class SubTestBean extends TestBean implements SubTestBeanInterface {\n    }", "definition": "    public static class SubTestBean extends TestBean implements SubTestBeanInterface", "class_docstring": "", "name": "SubTestBean", "super_interfaces": ["SubTestBeanInterface"], "superclasses": "TestBean", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": []}], "class_docstring": "\nBeanHandlerTest\n", "original_string": "public class BeanHandlerTest extends BaseTestCase {\n\n    public static class SubTestBean extends TestBean implements SubTestBeanInterface {\n    }\n\n    public interface SubTestBeanInterface {\n        String getDoNotSet();\n\n        String getOne();\n\n        TestBean.Ordinal getThree();\n\n        String getTwo();\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(TestBean.class);\n        final TestBean results = h.handle(getEmptyResultSet());\n\n        assertNull(results);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(TestBean.class);\n        final TestBean results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }\n\n    public void testHandleToInterface() throws SQLException {\n        final ResultSetHandler<SubTestBeanInterface> h = new BeanHandler<>(SubTestBean.class);\n        final SubTestBeanInterface results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }\n\n    public void testHandleToSuperClass() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(SubTestBean.class);\n        final TestBean results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/MapHandlerTest.java.MapHandlerTest", "name": "MapHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/MapHandlerTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testEmptyResultSetHandle()", "[void]testHandle()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/MapHandlerTest.java.MapHandlerTest.[void]testEmptyResultSetHandle()", "src/test/java/org/apache/commons/dbutils/handlers/MapHandlerTest.java.MapHandlerTest.[void]testHandle()"], "overrides": null, "attributes": [], "class_docstring": "\nMapHandlerTest\n", "original_string": "public class MapHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Object>> h = new MapHandler();\n        final Map<String, Object> results = h.handle(getEmptyResultSet());\n\n        assertNull(results);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Object>> h = new MapHandler();\n        final Map<String, Object> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(COLS, results.size());\n        assertEquals(\"1\", results.get(\"ONE\"));\n        assertEquals(\"2\", results.get(\"two\"));\n        assertEquals(\"THREE\", results.get(\"Three\"));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/KeyedHandlerTest.java.KeyedHandlerTest", "name": "KeyedHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/KeyedHandlerTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testColumnIndexHandle()", "[void]testColumnNameHandle()", "[void]testEmptyResultSetHandle()", "[void]testHandle()", "[void]testInjectedRowProcess()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/KeyedHandlerTest.java.KeyedHandlerTest.[void]testColumnIndexHandle()", "src/test/java/org/apache/commons/dbutils/handlers/KeyedHandlerTest.java.KeyedHandlerTest.[void]testColumnNameHandle()", "src/test/java/org/apache/commons/dbutils/handlers/KeyedHandlerTest.java.KeyedHandlerTest.[void]testEmptyResultSetHandle()", "src/test/java/org/apache/commons/dbutils/handlers/KeyedHandlerTest.java.KeyedHandlerTest.[void]testHandle()", "src/test/java/org/apache/commons/dbutils/handlers/KeyedHandlerTest.java.KeyedHandlerTest.[void]testInjectedRowProcess()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class KeyedHandlerTest extends BaseTestCase {\n\n    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>(2);\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(\"5\");\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n    }\n\n    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<Map<Integer, Map<String, Object>>> h = new KeyedHandler<>(\"intTest\");\n        final Map<Integer, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<Integer, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(Integer.valueOf(3));\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>();\n        final Map<String, Map<String, Object>> results = h.handle(getEmptyResultSet());\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>();\n\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(\"1\");\n        assertEquals(\"1\", row.get(\"one\"));\n        assertEquals(\"2\", row.get(\"TWO\"));\n        assertEquals(\"THREE\", row.get(\"Three\"));\n    }\n\n    public void testInjectedRowProcess() throws Exception {\n        final RowProcessor mockProc = mock(RowProcessor.class);\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>(mockProc);\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            row = entry.getValue();\n            assertNotNull(row);\n            assertTrue(row.isEmpty());\n            assertEquals(0, row.size());\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/ArrayListHandlerTest.java.ArrayListHandlerTest", "name": "ArrayListHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/ArrayListHandlerTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testEmptyResultSetHandle()", "[void]testHandle()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/ArrayListHandlerTest.java.ArrayListHandlerTest.[void]testEmptyResultSetHandle()", "src/test/java/org/apache/commons/dbutils/handlers/ArrayListHandlerTest.java.ArrayListHandlerTest.[void]testHandle()"], "overrides": null, "attributes": [], "class_docstring": "\nArrayListHandlerTest\n", "original_string": "public class ArrayListHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<Object[]>> h = new ArrayListHandler();\n        final List<Object[]> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<Object[]>> h = new ArrayListHandler();\n        final List<Object[]> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<Object[]> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        Object[] row = iter.next();\n        assertEquals(COLS, row.length);\n        assertEquals(\"1\", row[0]);\n        assertEquals(\"2\", row[1]);\n        assertEquals(\"THREE\", row[2]);\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.length);\n\n        assertEquals(\"4\", row[0]);\n        assertEquals(\"5\", row[1]);\n        assertEquals(\"SIX\", row[2]);\n\n        assertFalse(iter.hasNext());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/ColumnListHandlerTest.java.ColumnListHandlerTest", "name": "ColumnListHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/ColumnListHandlerTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testColumnIndexHandle()", "[void]testColumnNameHandle()", "[void]testEmptyResultSetHandle()", "[void]testHandle()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/ColumnListHandlerTest.java.ColumnListHandlerTest.[void]testColumnIndexHandle()", "src/test/java/org/apache/commons/dbutils/handlers/ColumnListHandlerTest.java.ColumnListHandlerTest.[void]testColumnNameHandle()", "src/test/java/org/apache/commons/dbutils/handlers/ColumnListHandlerTest.java.ColumnListHandlerTest.[void]testEmptyResultSetHandle()", "src/test/java/org/apache/commons/dbutils/handlers/ColumnListHandlerTest.java.ColumnListHandlerTest.[void]testHandle()"], "overrides": null, "attributes": [], "class_docstring": "\nColumnListHandlerTest\n", "original_string": "public class ColumnListHandlerTest extends BaseTestCase {\n\n    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>(2);\n        final List<String> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(\"2\", results.get(0));\n        assertEquals(\"5\", results.get(1));\n    }\n\n    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<List<Integer>> h = new ColumnListHandler<>(\"intTest\");\n        final List<Integer> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(Integer.valueOf(1), results.get(0));\n        assertEquals(Integer.valueOf(3), results.get(1));\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>();\n        final List<String> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>();\n        final List<String> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(\"1\", results.get(0));\n        assertEquals(\"4\", results.get(1));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/ScalarHandlerTest.java.ScalarHandlerTest", "name": "ScalarHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/ScalarHandlerTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testColumnIndexHandle()", "[void]testColumnNameHandle()", "[void]testEmptyResultSetHandle()", "[void]testHandle()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/ScalarHandlerTest.java.ScalarHandlerTest.[void]testColumnIndexHandle()", "src/test/java/org/apache/commons/dbutils/handlers/ScalarHandlerTest.java.ScalarHandlerTest.[void]testColumnNameHandle()", "src/test/java/org/apache/commons/dbutils/handlers/ScalarHandlerTest.java.ScalarHandlerTest.[void]testEmptyResultSetHandle()", "src/test/java/org/apache/commons/dbutils/handlers/ScalarHandlerTest.java.ScalarHandlerTest.[void]testHandle()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ScalarHandlerTest extends BaseTestCase {\n\n    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>(2);\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(\"2\", results);\n    }\n\n    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<Integer> h = new ScalarHandler<>(\"intTest\");\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(Integer.valueOf(1), results);\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>();\n        final Object results = h.handle(getEmptyResultSet());\n        assertNull(results);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>();\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(\"1\", results);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/BeanListHandlerTest.java.BeanListHandlerTest", "name": "BeanListHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/BeanListHandlerTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testEmptyResultSetHandle()", "[void]testHandle()", "[void]testHandleToInterface()", "[void]testHandleToSuperClass()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/BeanListHandlerTest.java.BeanListHandlerTest.[void]testEmptyResultSetHandle()", "src/test/java/org/apache/commons/dbutils/handlers/BeanListHandlerTest.java.BeanListHandlerTest.[void]testHandle()", "src/test/java/org/apache/commons/dbutils/handlers/BeanListHandlerTest.java.BeanListHandlerTest.[void]testHandleToInterface()", "src/test/java/org/apache/commons/dbutils/handlers/BeanListHandlerTest.java.BeanListHandlerTest.[void]testHandleToSuperClass()"], "overrides": null, "attributes": [{"original_string": "    public static class SubTestBean extends TestBean implements SubTestBeanInterface {\n    }", "definition": "    public static class SubTestBean extends TestBean implements SubTestBeanInterface", "class_docstring": "", "name": "SubTestBean", "super_interfaces": ["SubTestBeanInterface"], "superclasses": "TestBean", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": []}], "class_docstring": "\nBeanListHandlerTest\n", "original_string": "public class BeanListHandlerTest extends BaseTestCase {\n\n    public static class SubTestBean extends TestBean implements SubTestBeanInterface {\n    }\n\n    public interface SubTestBeanInterface {\n        String getDoNotSet();\n\n        String getOne();\n\n        TestBean.Ordinal getThree();\n\n        String getTwo();\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(TestBean.class);\n        final List<TestBean> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(TestBean.class);\n        final List<TestBean> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<TestBean> iter = results.iterator();\n        TestBean row;\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }\n\n    public void testHandleToInterface() throws SQLException {\n        final ResultSetHandler<List<SubTestBeanInterface>> h = new BeanListHandler<>(SubTestBean.class);\n        final List<SubTestBeanInterface> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<SubTestBeanInterface> iter = results.iterator();\n        SubTestBeanInterface row;\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }\n\n    public void testHandleToSuperClass() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(SubTestBean.class);\n        final List<TestBean> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<TestBean> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        TestBean row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/MapListHandlerTest.java.MapListHandlerTest", "name": "MapListHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/MapListHandlerTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testEmptyResultSetHandle()", "[void]testHandle()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/MapListHandlerTest.java.MapListHandlerTest.[void]testEmptyResultSetHandle()", "src/test/java/org/apache/commons/dbutils/handlers/MapListHandlerTest.java.MapListHandlerTest.[void]testHandle()"], "overrides": null, "attributes": [], "class_docstring": "\nMapListHandlerTest\n", "original_string": "public class MapListHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<Map<String, Object>>> h = new MapListHandler();\n        final List<Map<String, Object>> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<Map<String, Object>>> h = new MapListHandler();\n        final List<Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<Map<String, Object>> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        Map<String, Object> row = iter.next();\n        assertEquals(COLS, row.size());\n        assertEquals(\"1\", row.get(\"one\"));\n        assertEquals(\"2\", row.get(\"TWO\"));\n        assertEquals(\"THREE\", row.get(\"Three\"));\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.size());\n\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n\n        assertFalse(iter.hasNext());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/columns/TestColumnHandler.java.TestColumnHandler", "name": "TestColumnHandler", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/TestColumnHandler.java", "superclasses": "", "methods": ["[Object]apply(ResultSet,int)", "[boolean]match(Class<?>)"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/columns/TestColumnHandler.java.TestColumnHandler.[Object]apply(ResultSet,int)", "src/test/java/org/apache/commons/dbutils/handlers/columns/TestColumnHandler.java.TestColumnHandler.[boolean]match(Class<?>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TestColumnHandler implements ColumnHandler<Object> {\n\n    @Override\n    public Object apply(final ResultSet rs, final int columnIndex) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return false;\n    }\n}", "super_interfaces": ["ColumnHandler<Object>"], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/properties/TestPropertyHandler.java.TestPropertyHandler", "name": "TestPropertyHandler", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/TestPropertyHandler.java", "superclasses": "", "methods": ["[Object]apply(Class<?>,Object)", "[boolean]match(Class<?>,Object)"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/properties/TestPropertyHandler.java.TestPropertyHandler.[Object]apply(Class<?>,Object)", "src/test/java/org/apache/commons/dbutils/handlers/properties/TestPropertyHandler.java.TestPropertyHandler.[boolean]match(Class<?>,Object)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TestPropertyHandler implements PropertyHandler {\n\n    @Override\n    public Object apply(final Class<?> parameter, final Object value) {\n        return null;\n    }\n\n    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        return false;\n    }\n}", "super_interfaces": ["PropertyHandler"], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob", "name": "SqlNullCheckedResultSetMockBlob", "file_path": "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java", "superclasses": "", "methods": ["[void]free()", "[InputStream]getBinaryStream()", "[InputStream]getBinaryStream(long,long)", "[byte[]]getBytes(long,int)", "[long]length()", "[long]position(Blob,long)", "[long]position(byte[],long)", "[OutputStream]setBinaryStream(long)", "[int]setBytes(long,byte[])", "[int]setBytes(long,byte[],int,int)", "[void]truncate(long)"], "method_uris": ["src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob.[void]free()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob.[InputStream]getBinaryStream()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob.[InputStream]getBinaryStream(long,long)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob.[byte[]]getBytes(long,int)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob.[long]length()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob.[long]position(Blob,long)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob.[long]position(byte[],long)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob.[OutputStream]setBinaryStream(long)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob.[int]setBytes(long,byte[])", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob.[int]setBytes(long,byte[],int,int)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockBlob.[void]truncate(long)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class SqlNullCheckedResultSetMockBlob implements Blob {\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public void free() throws SQLException {\n\n    }\n\n    @Override\n    public InputStream getBinaryStream() throws SQLException {\n        return new ByteArrayInputStream(new byte[0]);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public InputStream getBinaryStream(final long pos, final long length) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public byte[] getBytes(final long param, final int param1) throws SQLException {\n        return new byte[0];\n    }\n\n    @Override\n    public long length() throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final Blob blob, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final byte[] values, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public OutputStream setBinaryStream(final long pos) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public int setBytes(final long pos, final byte[] bytes) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public int setBytes(final long pos, final byte[] bytes, final int offset, final int len) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public void truncate(final long len) throws SQLException {\n\n    }\n\n}", "super_interfaces": ["Blob"], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob", "name": "SqlNullCheckedResultSetMockClob", "file_path": "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java", "superclasses": "", "methods": ["[void]free()", "[InputStream]getAsciiStream()", "[Reader]getCharacterStream()", "[Reader]getCharacterStream(long,long)", "[String]getSubString(long,int)", "[long]length()", "[long]position(Clob,long)", "[long]position(String,long)", "[OutputStream]setAsciiStream(long)", "[Writer]setCharacterStream(long)", "[int]setString(long,String)", "[int]setString(long,String,int,int)", "[void]truncate(long)"], "method_uris": ["src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[void]free()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[InputStream]getAsciiStream()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[Reader]getCharacterStream()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[Reader]getCharacterStream(long,long)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[String]getSubString(long,int)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[long]length()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[long]position(Clob,long)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[long]position(String,long)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[OutputStream]setAsciiStream(long)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[Writer]setCharacterStream(long)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[int]setString(long,String)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[int]setString(long,String,int,int)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockClob.[void]truncate(long)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class SqlNullCheckedResultSetMockClob implements Clob {\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public void free() throws SQLException {\n\n    }\n\n    @Override\n    public InputStream getAsciiStream() throws SQLException {\n        return null;\n    }\n\n    @Override\n    public Reader getCharacterStream() throws SQLException {\n        return null;\n    }\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public Reader getCharacterStream(final long pos, final long length) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public String getSubString(final long param, final int param1) throws SQLException {\n        return \"\";\n    }\n\n    @Override\n    public long length() throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final Clob clob, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final String str, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public OutputStream setAsciiStream(final long pos) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public Writer setCharacterStream(final long pos) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public int setString(final long pos, final String str) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public int setString(final long pos, final String str, final int offset, final int len) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public void truncate(final long len) throws SQLException {\n\n    }\n\n}", "super_interfaces": ["Clob"], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockRef", "name": "SqlNullCheckedResultSetMockRef", "file_path": "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java", "superclasses": "", "methods": ["[String]getBaseTypeName()", "[Object]getObject()", "[Object]getObject(Map<String, Class<?>>)", "[void]setObject(Object)"], "method_uris": ["src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockRef.[String]getBaseTypeName()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockRef.[Object]getObject()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockRef.[Object]getObject(Map<String, Class<?>>)", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetMockRef.[void]setObject(Object)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class SqlNullCheckedResultSetMockRef implements Ref {\n\n    @Override\n    public String getBaseTypeName() throws SQLException {\n        return \"\";\n    }\n\n    @Override\n    public Object getObject() throws SQLException {\n        return null;\n    }\n\n    @Override\n    public Object getObject(final Map<String, Class<?>> map) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public void setObject(final Object value) throws SQLException {\n        // no-op\n    }\n\n}", "super_interfaces": ["Ref"], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest", "name": "SqlNullCheckedResultSetTest", "file_path": "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java", "superclasses": "BaseTestCase", "methods": ["[void]assertArrayEquals(byte[],byte[])", "[void]setUp()", "[void]testGetAsciiStream()", "[void]testGetBigDecimal()", "[void]testGetBinaryStream()", "[void]testGetBlob()", "[void]testGetBoolean()", "[void]testGetByte()", "[void]testGetBytes()", "[void]testGetCharacterStream()", "[void]testGetClob()", "[void]testGetDate()", "[void]testGetDouble()", "[void]testGetFloat()", "[void]testGetInt()", "[void]testGetLong()", "[void]testGetObject()", "[void]testGetRef()", "[void]testGetShort()", "[void]testGetString()", "[void]testGetTime()", "[void]testGetTimestamp()", "[void]testSetNullAsciiStream()", "[void]testSetNullBigDecimal()", "[void]testSetNullBinaryStream()", "[void]testSetNullBlob()", "[void]testSetNullBoolean()", "[void]testSetNullByte()", "[void]testSetNullBytes()", "[void]testSetNullCharacterStream()", "[void]testSetNullClob()", "[void]testSetNullDate()", "[void]testSetNullDouble()", "[void]testSetNullFloat()", "[void]testSetNullInt()", "[void]testSetNullLong()", "[void]testSetNullObject()", "[void]testSetNullRef()", "[void]testSetNullShort()", "[void]testSetNullString()", "[void]testSetNullTime()", "[void]testSetNullTimestamp()", "[void]testURL()", "[void]testWrapResultSet()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]assertArrayEquals(byte[],byte[])", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]setUp()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetAsciiStream()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetBigDecimal()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetBinaryStream()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetBlob()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetBoolean()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetByte()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetBytes()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetCharacterStream()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetClob()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetDate()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetDouble()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetFloat()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetInt()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetLong()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetObject()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetRef()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetShort()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetString()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetTime()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testGetTimestamp()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullAsciiStream()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullBigDecimal()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullBinaryStream()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullBlob()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullBoolean()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullByte()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullBytes()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullCharacterStream()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullClob()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullDate()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullDouble()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullFloat()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullInt()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullLong()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullObject()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullRef()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullShort()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullString()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullTime()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testSetNullTimestamp()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testURL()", "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullCheckedResultSetTest.[void]testWrapResultSet()"], "overrides": null, "attributes": [], "class_docstring": "\nTest cases for {@code SqlNullCheckedResultSet} class.\n", "original_string": "public class SqlNullCheckedResultSetTest extends BaseTestCase {\n\n    private static ResultSet rs;\n\n    private static void assertArrayEquals(final byte[] expected, final byte[] actual) {\n        if (expected == actual) {\n            return;\n        }\n        if (expected.length != actual.length) {\n            failNotEquals(null, Arrays.toString(expected), Arrays.toString(actual));\n        }\n        for (int i = 0; i < expected.length; i++) {\n            final byte expectedItem = expected[i];\n            final byte actualItem = actual[i];\n            assertEquals(\"Array not equal at index \" + i, expectedItem, actualItem);\n        }\n    }\n    private SqlNullCheckedResultSet rs2;\n\n    /**\n     * Sets up instance variables required by this test case.\n     */\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n\n        rs2 = new SqlNullCheckedResultSet(ProxyFactory.instance().createResultSet(new SqlNullUncheckedMockResultSet()));\n\n        setResultSet(ProxyFactory.instance().createResultSet(rs2)); // Override superclass field\n        rs = getResultSet();\n    }\n\n    /**\n     * Tests the getAsciiStream implementation.\n     */\n    public void testGetAsciiStream() throws SQLException {\n\n        assertNull(rs.getAsciiStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getAsciiStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullAsciiStream(stream);\n        assertNotNull(rs.getAsciiStream(1));\n        assertEquals(stream, rs.getAsciiStream(1));\n        assertNotNull(rs.getAsciiStream(\"column\"));\n        assertEquals(stream, rs.getAsciiStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBigDecimal implementation.\n     */\n    public void testGetBigDecimal() throws SQLException {\n\n        assertNull(rs.getBigDecimal(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBigDecimal(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final BigDecimal bd = new BigDecimal(5.0);\n        rs2.setNullBigDecimal(bd);\n        assertNotNull(rs.getBigDecimal(1));\n        assertEquals(bd, rs.getBigDecimal(1));\n        assertNotNull(rs.getBigDecimal(\"column\"));\n        assertEquals(bd, rs.getBigDecimal(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBinaryStream implementation.\n     */\n    public void testGetBinaryStream() throws SQLException {\n\n        assertNull(rs.getBinaryStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBinaryStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullBinaryStream(stream);\n        assertNotNull(rs.getBinaryStream(1));\n        assertEquals(stream, rs.getBinaryStream(1));\n        assertNotNull(rs.getBinaryStream(\"column\"));\n        assertEquals(stream, rs.getBinaryStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBlob implementation.\n     */\n    public void testGetBlob() throws SQLException {\n\n        assertNull(rs.getBlob(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBlob(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Blob blob = new SqlNullCheckedResultSetMockBlob();\n        rs2.setNullBlob(blob);\n        assertNotNull(rs.getBlob(1));\n        assertEquals(blob, rs.getBlob(1));\n        assertNotNull(rs.getBlob(\"column\"));\n        assertEquals(blob, rs.getBlob(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBoolean implementation.\n     */\n    public void testGetBoolean() throws SQLException {\n\n        assertFalse(rs.getBoolean(1));\n        assertTrue(rs.wasNull());\n        assertFalse(rs.getBoolean(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        rs2.setNullBoolean(true);\n        assertTrue( rs.getBoolean(1));\n        assertTrue( rs.getBoolean(\"column\"));\n\n    }\n\n    /**\n     * Tests the getByte implementation.\n     */\n    public void testGetByte() throws SQLException {\n\n        assertEquals((byte) 0, rs.getByte(1));\n        assertTrue(rs.wasNull());\n        assertEquals((byte) 0, rs.getByte(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final byte b = (byte) 10;\n        rs2.setNullByte(b);\n        assertEquals(b, rs.getByte(1));\n        assertEquals(b, rs.getByte(\"column\"));\n\n    }\n\n    /**\n     * Tests the getByte implementation.\n     */\n    public void testGetBytes() throws SQLException {\n\n        assertNull(rs.getBytes(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBytes(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final byte[] b = new byte[5];\n        for (int i = 0; i < 5; i++) {\n            b[0] = (byte) i;\n        }\n        rs2.setNullBytes(b);\n        assertNotNull(rs.getBytes(1));\n        assertArrayEquals(b, rs.getBytes(1));\n        assertNotNull(rs.getBytes(\"column\"));\n        assertArrayEquals(b, rs.getBytes(\"column\"));\n\n    }\n\n    /**\n     * Tests the getCharacterStream implementation.\n     */\n    public void testGetCharacterStream() throws SQLException {\n\n        assertNull(rs.getCharacterStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getCharacterStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Reader reader = new CharArrayReader(\"this is a string\".toCharArray());\n        rs2.setNullCharacterStream(reader);\n        assertNotNull(rs.getCharacterStream(1));\n        assertEquals(reader, rs.getCharacterStream(1));\n        assertNotNull(rs.getCharacterStream(\"column\"));\n        assertEquals(reader, rs.getCharacterStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the getClob implementation.\n     */\n    public void testGetClob() throws SQLException {\n\n        assertNull(rs.getClob(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getClob(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Clob clob = new SqlNullCheckedResultSetMockClob();\n        rs2.setNullClob(clob);\n        assertNotNull(rs.getClob(1));\n        assertEquals(clob, rs.getClob(1));\n        assertNotNull(rs.getClob(\"column\"));\n        assertEquals(clob, rs.getClob(\"column\"));\n\n    }\n\n    /**\n     * Tests the getDate implementation.\n     */\n    public void testGetDate() throws SQLException {\n\n        assertNull(rs.getDate(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final java.sql.Date date = new java.sql.Date(new java.util.Date().getTime());\n        rs2.setNullDate(date);\n        assertNotNull(rs.getDate(1));\n        assertEquals(date, rs.getDate(1));\n        assertNotNull(rs.getDate(\"column\"));\n        assertEquals(date, rs.getDate(\"column\"));\n        assertNotNull(rs.getDate(1, Calendar.getInstance()));\n        assertEquals(date, rs.getDate(1, Calendar.getInstance()));\n        assertNotNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertEquals(date, rs.getDate(\"column\", Calendar.getInstance()));\n\n    }\n\n    /**\n     * Tests the getDouble implementation.\n     */\n    public void testGetDouble() throws SQLException {\n\n        assertEquals(0.0, rs.getDouble(1), 0.0);\n        assertTrue(rs.wasNull());\n        assertEquals(0.0, rs.getDouble(\"column\"), 0.0);\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final double d = 10.0;\n        rs2.setNullDouble(d);\n        assertEquals(d, rs.getDouble(1), 0.0);\n        assertEquals(d, rs.getDouble(\"column\"), 0.0);\n\n    }\n\n    /**\n     * Tests the getFloat implementation.\n     */\n    public void testGetFloat() throws SQLException {\n        assertEquals(0, rs.getFloat(1), 0.0);\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getFloat(\"column\"), 0.0);\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final float f = 10;\n        rs2.setNullFloat(f);\n        assertEquals(f, rs.getFloat(1), 0.0);\n        assertEquals(f, rs.getFloat(\"column\"), 0.0);\n    }\n\n    /**\n     * Tests the getInt implementation.\n     */\n    public void testGetInt() throws SQLException {\n        assertEquals(0, rs.getInt(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getInt(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final int i = 10;\n        rs2.setNullInt(i);\n        assertEquals(i, rs.getInt(1));\n        assertEquals(i, rs.getInt(\"column\"));\n    }\n\n    /**\n     * Tests the getLong implementation.\n     */\n    public void testGetLong() throws SQLException {\n        assertEquals(0, rs.getLong(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getLong(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final long l = 10;\n        rs2.setNullLong(l);\n        assertEquals(l, rs.getLong(1));\n        assertEquals(l, rs.getLong(\"column\"));\n    }\n\n    /**\n     * Tests the getObject implementation.\n     */\n    public void testGetObject() throws SQLException {\n\n        assertNull(rs.getObject(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Object o = new Object();\n        rs2.setNullObject(o);\n        assertNotNull(rs.getObject(1));\n        assertEquals(o, rs.getObject(1));\n        assertNotNull(rs.getObject(\"column\"));\n        assertEquals(o, rs.getObject(\"column\"));\n        assertNotNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(1, (Map<String, Class<?>>) null));\n        assertNotNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(\"column\", (Map<String, Class<?>>) null));\n\n    }\n\n    /**\n     * Tests the getRef implementation.\n     */\n    public void testGetRef() throws SQLException {\n\n        assertNull(rs.getRef(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getRef(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Ref ref = new SqlNullCheckedResultSetMockRef();\n        rs2.setNullRef(ref);\n        assertNotNull(rs.getRef(1));\n        assertEquals(ref, rs.getRef(1));\n        assertNotNull(rs.getRef(\"column\"));\n        assertEquals(ref, rs.getRef(\"column\"));\n\n    }\n\n    /**\n     * Tests the getShort implementation.\n     */\n    public void testGetShort() throws SQLException {\n\n        assertEquals((short) 0, rs.getShort(1));\n        assertTrue(rs.wasNull());\n        assertEquals((short) 0, rs.getShort(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final short s = (short) 10;\n        rs2.setNullShort(s);\n        assertEquals(s, rs.getShort(1));\n        assertEquals(s, rs.getShort(\"column\"));\n    }\n\n    /**\n     * Tests the getString implementation.\n     */\n    public void testGetString() throws SQLException {\n        assertNull(rs.getString(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getString(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final String s = \"hello, world\";\n        rs2.setNullString(s);\n        assertEquals(s, rs.getString(1));\n        assertEquals(s, rs.getString(\"column\"));\n    }\n\n    /**\n     * Tests the getTime implementation.\n     */\n    public void testGetTime() throws SQLException {\n\n        assertNull(rs.getTime(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Time time = new Time(new java.util.Date().getTime());\n        rs2.setNullTime(time);\n        assertNotNull(rs.getTime(1));\n        assertEquals(time, rs.getTime(1));\n        assertNotNull(rs.getTime(\"column\"));\n        assertEquals(time, rs.getTime(\"column\"));\n        assertNotNull(rs.getTime(1, Calendar.getInstance()));\n        assertEquals(time, rs.getTime(1, Calendar.getInstance()));\n        assertNotNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertEquals(time, rs.getTime(\"column\", Calendar.getInstance()));\n\n    }\n\n    /**\n     * Tests the getTimestamp implementation.\n     */\n    public void testGetTimestamp() throws SQLException {\n\n        assertNull(rs.getTimestamp(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Timestamp ts = new Timestamp(new java.util.Date().getTime());\n        rs2.setNullTimestamp(ts);\n        assertNotNull(rs.getTimestamp(1));\n        assertEquals(ts, rs.getTimestamp(1));\n        assertNotNull(rs.getTimestamp(\"column\"));\n        assertEquals(ts, rs.getTimestamp(\"column\"));\n        assertNotNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(1, Calendar.getInstance()));\n        assertNotNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(\"column\", Calendar.getInstance()));\n    }\n\n    /**\n     * Tests the setNullAsciiStream implementation.\n     */\n    public void testSetNullAsciiStream() throws SQLException {\n\n        assertNull(rs2.getNullAsciiStream());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullAsciiStream(stream);\n        assertNotNull(rs.getAsciiStream(1));\n        assertEquals(stream, rs.getAsciiStream(1));\n        assertNotNull(rs.getAsciiStream(\"column\"));\n        assertEquals(stream, rs.getAsciiStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBigDecimal implementation.\n     */\n    public void testSetNullBigDecimal() throws SQLException {\n\n        assertNull(rs2.getNullBigDecimal());\n        // Set what gets returned to something other than the default\n        final BigDecimal bd = new BigDecimal(5.0);\n        rs2.setNullBigDecimal(bd);\n        assertNotNull(rs.getBigDecimal(1));\n        assertEquals(bd, rs.getBigDecimal(1));\n        assertNotNull(rs.getBigDecimal(\"column\"));\n        assertEquals(bd, rs.getBigDecimal(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBinaryStream implementation.\n     */\n    public void testSetNullBinaryStream() throws SQLException {\n\n        assertNull(rs2.getNullBinaryStream());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullBinaryStream(stream);\n        assertNotNull(rs.getBinaryStream(1));\n        assertEquals(stream, rs.getBinaryStream(1));\n        assertNotNull(rs.getBinaryStream(\"column\"));\n        assertEquals(stream, rs.getBinaryStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBlob implementation.\n     */\n    public void testSetNullBlob() throws SQLException {\n\n        assertNull(rs2.getNullBlob());\n        // Set what gets returned to something other than the default\n        final Blob blob = new SqlNullCheckedResultSetMockBlob();\n        rs2.setNullBlob(blob);\n        assertNotNull(rs.getBlob(1));\n        assertEquals(blob, rs.getBlob(1));\n        assertNotNull(rs.getBlob(\"column\"));\n        assertEquals(blob, rs.getBlob(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBoolean implementation.\n     */\n    public void testSetNullBoolean() throws SQLException {\n\n        assertFalse(rs2.getNullBoolean());\n        // Set what gets returned to something other than the default\n        rs2.setNullBoolean(true);\n        assertTrue( rs.getBoolean(1));\n        assertTrue( rs.getBoolean(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullByte implementation.\n     */\n    public void testSetNullByte() throws SQLException {\n\n        assertEquals((byte) 0, rs2.getNullByte());\n        // Set what gets returned to something other than the default\n        final byte b = (byte) 10;\n        rs2.setNullByte(b);\n        assertEquals(b, rs.getByte(1));\n        assertEquals(b, rs.getByte(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullByte implementation.\n     */\n    public void testSetNullBytes() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullBytes());\n\n        // test that setting null is safe\n        rs2.setNullBytes(null);\n        assertNull(rs2.getNullBytes());\n\n        // Set what gets returned to something other than the default\n        final byte[] b = new byte[5];\n        for (int i = 0; i < 5; i++) {\n            b[0] = (byte) i;\n        }\n        rs2.setNullBytes(b);\n        assertNotNull(rs.getBytes(1));\n        assertArrayEquals(b, rs.getBytes(1));\n        assertNotNull(rs.getBytes(\"column\"));\n        assertArrayEquals(b, rs.getBytes(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullCharacterStream implementation.\n     */\n    public void testSetNullCharacterStream() throws SQLException {\n\n        assertNull(rs2.getNullCharacterStream());\n        // Set what gets returned to something other than the default\n        final Reader reader = new CharArrayReader(\"this is a string\".toCharArray());\n        rs2.setNullCharacterStream(reader);\n        assertNotNull(rs.getCharacterStream(1));\n        assertEquals(reader, rs.getCharacterStream(1));\n        assertNotNull(rs.getCharacterStream(\"column\"));\n        assertEquals(reader, rs.getCharacterStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullClob implementation.\n     */\n    public void testSetNullClob() throws SQLException {\n\n        assertNull(rs2.getNullClob());\n        // Set what gets returned to something other than the default\n        final Clob clob = new SqlNullCheckedResultSetMockClob();\n        rs2.setNullClob(clob);\n        assertNotNull(rs.getClob(1));\n        assertEquals(clob, rs.getClob(1));\n        assertNotNull(rs.getClob(\"column\"));\n        assertEquals(clob, rs.getClob(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullDate implementation.\n     */\n    public void testSetNullDate() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullDate());\n\n        // test that setting null is safe\n        rs2.setNullDate(null);\n        assertNull(rs2.getNullDate());\n\n        // Set what gets returned to something other than the default\n        final java.sql.Date date = new java.sql.Date(new java.util.Date().getTime());\n        rs2.setNullDate(date);\n        assertNotNull(rs.getDate(1));\n        assertEquals(date, rs.getDate(1));\n        assertNotNull(rs.getDate(\"column\"));\n        assertEquals(date, rs.getDate(\"column\"));\n        assertNotNull(rs.getDate(1, Calendar.getInstance()));\n        assertEquals(date, rs.getDate(1, Calendar.getInstance()));\n        assertNotNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertEquals(date, rs.getDate(\"column\", Calendar.getInstance()));\n\n    }\n\n    /**\n     * Tests the setNullDouble implementation.\n     */\n    public void testSetNullDouble() throws SQLException {\n        assertEquals(0.0, rs2.getNullDouble(), 0.0);\n        // Set what gets returned to something other than the default\n        final double d = 10.0;\n        rs2.setNullDouble(d);\n        assertEquals(d, rs.getDouble(1), 0.0);\n        assertEquals(d, rs.getDouble(\"column\"), 0.0);\n    }\n\n    /**\n     * Tests the setNullFloat implementation.\n     */\n    public void testSetNullFloat() throws SQLException {\n        assertEquals((float) 0.0, rs2.getNullFloat(), 0.0);\n        // Set what gets returned to something other than the default\n        final float f = (float) 10.0;\n        rs2.setNullFloat(f);\n        assertEquals(f, rs.getFloat(1), 0.0);\n        assertEquals(f, rs.getFloat(\"column\"), 0.0);\n    }\n\n    /**\n     * Tests the setNullInt implementation.\n     */\n    public void testSetNullInt() throws SQLException {\n        assertEquals(0, rs2.getNullInt());\n        assertEquals(0, rs.getInt(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getInt(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final int i = 10;\n        rs2.setNullInt(i);\n        assertEquals(i, rs.getInt(1));\n        assertEquals(i, rs.getInt(\"column\"));\n    }\n\n    /**\n     * Tests the setNullLong implementation.\n     */\n    public void testSetNullLong() throws SQLException {\n        assertEquals(0, rs2.getNullLong());\n        // Set what gets returned to something other than the default\n        final long l = 10;\n        rs2.setNullLong(l);\n        assertEquals(l, rs.getLong(1));\n        assertEquals(l, rs.getLong(\"column\"));\n    }\n\n    /**\n     * Tests the setNullObject implementation.\n     */\n    public void testSetNullObject() throws SQLException {\n        assertNull(rs2.getNullObject());\n        // Set what gets returned to something other than the default\n        final Object o = new Object();\n        rs2.setNullObject(o);\n        assertNotNull(rs.getObject(1));\n        assertEquals(o, rs.getObject(1));\n        assertNotNull(rs.getObject(\"column\"));\n        assertEquals(o, rs.getObject(\"column\"));\n        assertNotNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(1, (Map<String, Class<?>>) null));\n        assertNotNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(\"column\", (Map<String, Class<?>>) null));\n    }\n\n    /**\n     * Tests the setNullRef implementation.\n     */\n    public void testSetNullRef() throws SQLException {\n        assertNull(rs2.getNullRef());\n        // Set what gets returned to something other than the default\n        final Ref ref = new SqlNullCheckedResultSetMockRef();\n        rs2.setNullRef(ref);\n        assertNotNull(rs.getRef(1));\n        assertEquals(ref, rs.getRef(1));\n        assertNotNull(rs.getRef(\"column\"));\n        assertEquals(ref, rs.getRef(\"column\"));\n    }\n\n    /**\n     * Tests the setNullShort implementation.\n     */\n    public void testSetNullShort() throws SQLException {\n\n        assertEquals((short) 0, rs2.getNullShort());\n        // Set what gets returned to something other than the default\n        final short s = (short) 10;\n        rs2.setNullShort(s);\n        assertEquals(s, rs.getShort(1));\n        assertEquals(s, rs.getShort(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullString implementation.\n     */\n    public void testSetNullString() throws SQLException {\n        assertNull(rs2.getNullString());\n        // Set what gets returned to something other than the default\n        final String s = \"hello, world\";\n        rs2.setNullString(s);\n        assertEquals(s, rs.getString(1));\n        assertEquals(s, rs.getString(\"column\"));\n    }\n\n    /**\n     * Tests the setNullTime implementation.\n     */\n    public void testSetNullTime() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullTime());\n\n        // test that setting null is safe\n        rs2.setNullTime(null);\n        assertNull(rs2.getNullTime());\n\n        // Set what gets returned to something other than the default\n        final Time time = new Time(new java.util.Date().getTime());\n        rs2.setNullTime(time);\n        assertNotNull(rs.getTime(1));\n        assertEquals(time, rs.getTime(1));\n        assertNotNull(rs.getTime(\"column\"));\n        assertEquals(time, rs.getTime(\"column\"));\n        assertNotNull(rs.getTime(1, Calendar.getInstance()));\n        assertEquals(time, rs.getTime(1, Calendar.getInstance()));\n        assertNotNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertEquals(time, rs.getTime(\"column\", Calendar.getInstance()));\n    }\n\n    /**\n     * Tests the setNullTimestamp implementation.\n     */\n    public void testSetNullTimestamp() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullTimestamp());\n\n        // test that setting null is safe\n        rs2.setNullTimestamp(null);\n        assertNull(rs2.getNullTimestamp());\n\n        // Set what gets returned to something other than the default\n        final Timestamp ts = new Timestamp(new java.util.Date().getTime());\n        rs2.setNullTimestamp(ts);\n        assertNotNull(rs.getTimestamp(1));\n        assertEquals(ts, rs.getTimestamp(1));\n        assertNotNull(rs.getTimestamp(\"column\"));\n        assertEquals(ts, rs.getTimestamp(\"column\"));\n        assertNotNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(1, Calendar.getInstance()));\n        assertNotNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(\"column\", Calendar.getInstance()));\n    }\n\n    /**\n     * Tests the getURL and setNullURL implementations.\n     */\n    public void testURL() throws SQLException, MalformedURLException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n        assertNull(rs.getURL(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getURL(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final URL u = new URL(\"http://www.apache.org\");\n        rs2.setNullURL(u);\n        assertEquals(u, rs.getURL(1));\n        assertEquals(u, rs.getURL(\"column\"));\n    }\n\n    public void testWrapResultSet() throws SQLException {\n        final ResultSet wrappedRs = mock(ResultSet.class);\n        final ResultSet rs = SqlNullCheckedResultSet.wrap(wrappedRs);\n        rs.beforeFirst();\n        verify(wrappedRs).beforeFirst();\n        rs.next();\n        verify(wrappedRs).next();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static ResultSet rs;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "ResultSet", "name": "rs", "syntax_pass": true}, {"attribute_expression": "private SqlNullCheckedResultSet rs2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SqlNullCheckedResultSet", "name": "rs2", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullUncheckedMockResultSet", "name": "SqlNullUncheckedMockResultSet", "file_path": "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java", "superclasses": "", "methods": ["[Object]invoke(Object,Method,Object[])"], "method_uris": ["src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java.SqlNullUncheckedMockResultSet.[Object]invoke(Object,Method,Object[])"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class SqlNullUncheckedMockResultSet implements InvocationHandler {\n\n    /**\n     * Always return false for booleans, 0 for numerics, and null for Objects.\n     *\n     * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n     */\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n\n        final Class<?> returnType = method.getReturnType();\n\n        if (method.getName().equals(\"wasNull\")) {\n            return Boolean.TRUE;\n\n        }\n        if (returnType.equals(Boolean.TYPE)) {\n            return Boolean.FALSE;\n\n        }\n        if (returnType.equals(Integer.TYPE)) {\n            return Integer.valueOf(0);\n\n        }\n        if (returnType.equals(Short.TYPE)) {\n            return Short.valueOf((short) 0);\n\n        }\n        if (returnType.equals(Double.TYPE)) {\n            return Double.valueOf(0);\n\n        }\n        if (returnType.equals(Long.TYPE)) {\n            return Long.valueOf(0);\n\n        }\n        if (returnType.equals(Byte.TYPE)) {\n            return Byte.valueOf((byte) 0);\n\n        }\n        if (returnType.equals(Float.TYPE)) {\n            return Float.valueOf(0);\n\n        }\n        return null;\n    }\n}", "super_interfaces": ["InvocationHandler"], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSetTest.java.StringTrimmedResultSetTest", "name": "StringTrimmedResultSetTest", "file_path": "src/test/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSetTest.java", "superclasses": "BaseTestCase", "methods": ["[void]setUp()", "[void]testGetObject()", "[void]testGetString()", "[void]testMultipleWrappers()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSetTest.java.StringTrimmedResultSetTest.[void]setUp()", "src/test/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSetTest.java.StringTrimmedResultSetTest.[void]testGetObject()", "src/test/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSetTest.java.StringTrimmedResultSetTest.[void]testGetString()", "src/test/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSetTest.java.StringTrimmedResultSetTest.[void]testMultipleWrappers()"], "overrides": null, "attributes": [], "class_docstring": "\nStringTrimmedResultSetTest\n", "original_string": "public class StringTrimmedResultSetTest extends BaseTestCase {\n\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n        setResultSet(StringTrimmedResultSet.wrap(getResultSet()));\n    }\n\n    public void testGetObject() throws SQLException {\n        getResultSet().next();\n        assertEquals(\"notInBean\", getResultSet().getObject(4));\n    }\n\n    public void testGetString() throws SQLException {\n        getResultSet().next();\n        assertEquals(\"notInBean\", getResultSet().getString(4));\n    }\n\n    /**\n     * Make sure 2 wrappers work together.\n     *\n     * @throws SQLException if a database access error occurs\n     */\n    public void testMultipleWrappers() throws Exception {\n        // Create a ResultSet with data\n        final Object[][] rows = { { null } };\n        ResultSet rs = MockResultSet.create(metaData, rows);\n\n        // Wrap the ResultSet with a null checked version\n        final SqlNullCheckedResultSet ncrs = new SqlNullCheckedResultSet(rs);\n        ncrs.setNullString(\"   trim this   \");\n        rs = ProxyFactory.instance().createResultSet(ncrs);\n\n        // Wrap the wrapper with a string trimmed version\n        rs = StringTrimmedResultSet.wrap(rs);\n\n        rs.next();\n        assertEquals(\"trim this\", rs.getString(1));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration", "name": "StatementConfiguration", "file_path": "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java", "superclasses": "", "methods": ["[]StatementConfiguration(Integer,Integer,Integer,Integer,Duration)", "[]StatementConfiguration(Integer,Integer,Integer,Integer,Integer)", "[void]finalize()", "[Integer]getFetchDirection()", "[Integer]getFetchSize()", "[Integer]getMaxFieldSize()", "[Integer]getMaxRows()", "[Integer]getQueryTimeout()", "[Duration]getQueryTimeoutDuration()", "[boolean]isFetchDirectionSet()", "[boolean]isFetchSizeSet()", "[boolean]isMaxFieldSizeSet()", "[boolean]isMaxRowsSet()", "[boolean]isQueryTimeoutSet()"], "method_uris": ["src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[]StatementConfiguration(Integer,Integer,Integer,Integer,Duration)", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[]StatementConfiguration(Integer,Integer,Integer,Integer,Integer)", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[void]finalize()", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[Integer]getFetchDirection()", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[Integer]getFetchSize()", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[Integer]getMaxFieldSize()", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[Integer]getMaxRows()", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[Integer]getQueryTimeout()", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[Duration]getQueryTimeoutDuration()", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[boolean]isFetchDirectionSet()", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[boolean]isFetchSizeSet()", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[boolean]isMaxFieldSizeSet()", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[boolean]isMaxRowsSet()", "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java.StatementConfiguration.[boolean]isQueryTimeoutSet()"], "overrides": null, "attributes": [{"original_string": "    public static final class Builder {\n        private Integer fetchDirection;\n        private Integer fetchSize;\n        private Integer maxRows;\n        private Duration queryTimeout;\n        private Integer maxFieldSize;\n\n        /**\n         * @return A new and configured {@link StatementConfiguration}.\n         */\n        public StatementConfiguration build() {\n            return new StatementConfiguration(fetchDirection, fetchSize, maxFieldSize, maxRows, queryTimeout);\n        }\n\n        /**\n         * @param fetchDirection The direction for fetching rows from database tables.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getFetchDirection()\n         */\n        public Builder fetchDirection(final Integer fetchDirection) {\n            this.fetchDirection = fetchDirection;\n            return this;\n        }\n\n        /**\n         * @param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getFetchSize()\n         */\n        public Builder fetchSize(final Integer fetchSize) {\n            this.fetchSize = fetchSize;\n            return this;\n        }\n\n        /**\n         * @param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getMaxFieldSize()\n         */\n        public Builder maxFieldSize(final Integer maxFieldSize) {\n            this.maxFieldSize = maxFieldSize;\n            return this;\n        }\n\n        /**\n         * @param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getMaxRows()\n         */\n        public Builder maxRows(final Integer maxRows) {\n            this.maxRows = maxRows;\n            return this;\n        }\n\n        /**\n         * @param queryTimeout The number of seconds the driver will wait for execution.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getQueryTimeoutDuration()\n         * @since 1.8.0\n         */\n        public Builder queryTimeout(final Duration queryTimeout) {\n            this.queryTimeout = queryTimeout;\n            return this;\n        }\n\n        /**\n         * @param queryTimeout The number of seconds the driver will wait for execution.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getQueryTimeout()\n         * @deprecated Use {@link #queryTimeout(Duration)}.\n         */\n        @Deprecated\n        public Builder queryTimeout(final Integer queryTimeout) {\n            this.queryTimeout = queryTimeout != null ? Duration.ofSeconds(queryTimeout) : null;\n            return this;\n        }\n    }", "definition": "    public static final class Builder", "class_docstring": "\nBuilder class for {@code StatementConfiguration} for more flexible construction.\n", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private Integer fetchDirection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "fetchDirection", "syntax_pass": true}, {"attribute_expression": "private Integer fetchSize;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "fetchSize", "syntax_pass": true}, {"attribute_expression": "private Integer maxRows;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "maxRows", "syntax_pass": true}, {"attribute_expression": "private Duration queryTimeout;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Duration", "name": "queryTimeout", "syntax_pass": true}, {"attribute_expression": "private Integer maxFieldSize;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "maxFieldSize", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public StatementConfiguration build() {\n            return new StatementConfiguration(fetchDirection, fetchSize, maxFieldSize, maxRows, queryTimeout);\n        }", "docstring": "\n@return A new and configured {@link StatementConfiguration}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StatementConfiguration", "classes": []}, "name": "build", "params": [], "body": "                                              {\n            return new StatementConfiguration(fetchDirection, fetchSize, maxFieldSize, maxRows, queryTimeout);\n        }", "signature": "public StatementConfiguration build()"}, {"syntax_pass": true, "original_string": "        public Builder fetchDirection(final Integer fetchDirection) {\n            this.fetchDirection = fetchDirection;\n            return this;\n        }", "docstring": "\n@param fetchDirection The direction for fetching rows from database tables.\n@return This builder for chaining.\n@see StatementConfiguration#getFetchDirection()\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "fetchDirection", "params": [{"name": "fetchDirection", "type": "Integer"}], "body": "                                                                    {\n            this.fetchDirection = fetchDirection;\n            return this;\n        }", "signature": "public Builder fetchDirection(final Integer fetchDirection)"}, {"syntax_pass": true, "original_string": "        public Builder fetchSize(final Integer fetchSize) {\n            this.fetchSize = fetchSize;\n            return this;\n        }", "docstring": "\n@param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n@return This builder for chaining.\n@see StatementConfiguration#getFetchSize()\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "fetchSize", "params": [{"name": "fetchSize", "type": "Integer"}], "body": "                                                          {\n            this.fetchSize = fetchSize;\n            return this;\n        }", "signature": "public Builder fetchSize(final Integer fetchSize)"}, {"syntax_pass": true, "original_string": "        public Builder maxFieldSize(final Integer maxFieldSize) {\n            this.maxFieldSize = maxFieldSize;\n            return this;\n        }", "docstring": "\n@param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n@return This builder for chaining.\n@see StatementConfiguration#getMaxFieldSize()\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "maxFieldSize", "params": [{"name": "maxFieldSize", "type": "Integer"}], "body": "                                                                {\n            this.maxFieldSize = maxFieldSize;\n            return this;\n        }", "signature": "public Builder maxFieldSize(final Integer maxFieldSize)"}, {"syntax_pass": true, "original_string": "        public Builder maxRows(final Integer maxRows) {\n            this.maxRows = maxRows;\n            return this;\n        }", "docstring": "\n@param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n@return This builder for chaining.\n@see StatementConfiguration#getMaxRows()\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "maxRows", "params": [{"name": "maxRows", "type": "Integer"}], "body": "                                                      {\n            this.maxRows = maxRows;\n            return this;\n        }", "signature": "public Builder maxRows(final Integer maxRows)"}, {"syntax_pass": true, "original_string": "        public Builder queryTimeout(final Duration queryTimeout) {\n            this.queryTimeout = queryTimeout;\n            return this;\n        }", "docstring": "\n@param queryTimeout The number of seconds the driver will wait for execution.\n@return This builder for chaining.\n@see StatementConfiguration#getQueryTimeoutDuration()\n@since 1.8.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "queryTimeout", "params": [{"name": "queryTimeout", "type": "Duration"}], "body": "                                                                 {\n            this.queryTimeout = queryTimeout;\n            return this;\n        }", "signature": "public Builder queryTimeout(final Duration queryTimeout)"}, {"syntax_pass": true, "original_string": "        @Deprecated\n        public Builder queryTimeout(final Integer queryTimeout) {\n            this.queryTimeout = queryTimeout != null ? Duration.ofSeconds(queryTimeout) : null;\n            return this;\n        }", "docstring": "\n@param queryTimeout The number of seconds the driver will wait for execution.\n@return This builder for chaining.\n@see StatementConfiguration#getQueryTimeout()\n@deprecated Use {@link #queryTimeout(Duration)}.\n", "attributes": {"modifiers": "@Deprecated\n        public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "queryTimeout", "params": [{"name": "queryTimeout", "type": "Integer"}], "body": "                                                                {\n            this.queryTimeout = queryTimeout != null ? Duration.ofSeconds(queryTimeout) : null;\n            return this;\n        }", "signature": "@Deprecated\n        public Builder queryTimeout(final Integer queryTimeout)"}]}], "class_docstring": "\nConfiguration options for a {@link java.sql.Statement} when preparing statements in {@code QueryRunner}.\n", "original_string": "public class StatementConfiguration {\n    /**\n     * Builder class for {@code StatementConfiguration} for more flexible construction.\n     */\n    public static final class Builder {\n        private Integer fetchDirection;\n        private Integer fetchSize;\n        private Integer maxRows;\n        private Duration queryTimeout;\n        private Integer maxFieldSize;\n\n        /**\n         * @return A new and configured {@link StatementConfiguration}.\n         */\n        public StatementConfiguration build() {\n            return new StatementConfiguration(fetchDirection, fetchSize, maxFieldSize, maxRows, queryTimeout);\n        }\n\n        /**\n         * @param fetchDirection The direction for fetching rows from database tables.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getFetchDirection()\n         */\n        public Builder fetchDirection(final Integer fetchDirection) {\n            this.fetchDirection = fetchDirection;\n            return this;\n        }\n\n        /**\n         * @param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getFetchSize()\n         */\n        public Builder fetchSize(final Integer fetchSize) {\n            this.fetchSize = fetchSize;\n            return this;\n        }\n\n        /**\n         * @param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getMaxFieldSize()\n         */\n        public Builder maxFieldSize(final Integer maxFieldSize) {\n            this.maxFieldSize = maxFieldSize;\n            return this;\n        }\n\n        /**\n         * @param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getMaxRows()\n         */\n        public Builder maxRows(final Integer maxRows) {\n            this.maxRows = maxRows;\n            return this;\n        }\n\n        /**\n         * @param queryTimeout The number of seconds the driver will wait for execution.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getQueryTimeoutDuration()\n         * @since 1.8.0\n         */\n        public Builder queryTimeout(final Duration queryTimeout) {\n            this.queryTimeout = queryTimeout;\n            return this;\n        }\n\n        /**\n         * @param queryTimeout The number of seconds the driver will wait for execution.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getQueryTimeout()\n         * @deprecated Use {@link #queryTimeout(Duration)}.\n         */\n        @Deprecated\n        public Builder queryTimeout(final Integer queryTimeout) {\n            this.queryTimeout = queryTimeout != null ? Duration.ofSeconds(queryTimeout) : null;\n            return this;\n        }\n    }\n\n    private final Integer fetchDirection;\n    private final Integer fetchSize;\n    private final Integer maxFieldSize;\n    private final Integer maxRows;\n    private final Duration queryTimeout;\n\n    /**\n     * Constructor for {@code StatementConfiguration}.  For more flexibility, use {@link Builder}.\n     *\n     * @param fetchDirection The direction for fetching rows from database tables.\n     * @param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n     * @param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n     * @param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n     * @param queryTimeout The number of seconds the driver will wait for execution.\n     * @since 1.8.0\n     */\n    public StatementConfiguration(final Integer fetchDirection, final Integer fetchSize,\n                                  final Integer maxFieldSize, final Integer maxRows,\n                                  final Duration queryTimeout) {\n        this.fetchDirection = fetchDirection;\n        this.fetchSize = fetchSize;\n        this.maxFieldSize = maxFieldSize;\n        this.maxRows = maxRows;\n        if (queryTimeout != null && queryTimeout.getSeconds() > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(String.format(\"queryTimeout overflow: %d > %,d\", queryTimeout.getSeconds(), Integer.MAX_VALUE));\n        }\n        this.queryTimeout = queryTimeout;\n    }\n\n    /**\n     * Constructor for {@code StatementConfiguration}.  For more flexibility, use {@link Builder}.\n     *\n     * @param fetchDirection The direction for fetching rows from database tables.\n     * @param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n     * @param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n     * @param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n     * @param queryTimeout The number of seconds the driver will wait for execution.\n     * @deprecated Use {@link StatementConfiguration#StatementConfiguration(Integer, Integer, Integer, Integer, Duration)}.\n     */\n    @Deprecated\n    public StatementConfiguration(final Integer fetchDirection, final Integer fetchSize,\n                                  final Integer maxFieldSize, final Integer maxRows,\n                                  final Integer queryTimeout) {\n        this(fetchDirection, fetchSize, maxFieldSize, maxRows, Duration.ofSeconds(queryTimeout));\n    }\n\n    /** Does nothing. */\n    @Override\n    protected final void finalize() {\n        // SpotBugs CT_CONSTRUCTOR_THROW\n    }\n\n    /**\n     * Gets the fetch direction.\n     *\n     * @return The direction to fetch or null if not set.\n     */\n    public Integer getFetchDirection() {\n        return fetchDirection;\n    }\n\n    /**\n     * Gets the fetch size.\n     *\n     * @return The fetch size or null if not set.\n     */\n    public Integer getFetchSize() {\n        return fetchSize;\n    }\n\n    /**\n     * Gets the max field size.\n     *\n     * @return The max field size or null if not set.\n     */\n    public Integer getMaxFieldSize() {\n        return maxFieldSize;\n    }\n\n    /**\n     * Gets the max rows.\n     *\n     * @return The max rows or null if not set.\n     */\n    public Integer getMaxRows() {\n        return maxRows;\n    }\n\n    /**\n     * Gets the query timeout.\n     *\n     * @return The query timeout or null if not set.\n     * @deprecated Use {@link #getQueryTimeoutDuration()}.\n     */\n    @Deprecated\n    public Integer getQueryTimeout() {\n        return queryTimeout != null ? (int) queryTimeout.getSeconds() : null;\n    }\n\n    /**\n     * Gets the query timeout.\n     *\n     * @return The query timeout or null if not set.\n     * @since 1.8.0\n     */\n    public Duration getQueryTimeoutDuration() {\n        return queryTimeout;\n    }\n\n    /**\n     * Whether fetch direction is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isFetchDirectionSet() {\n        return fetchDirection != null;\n    }\n\n    /**\n     * Whether fetch size is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isFetchSizeSet() {\n        return fetchSize != null;\n    }\n\n    /**\n     * Whether max field size is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isMaxFieldSizeSet() {\n        return maxFieldSize != null;\n    }\n\n    /**\n     * Whether max rows is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isMaxRowsSet() {\n        return maxRows != null;\n    }\n\n    /**\n     * Whether query timeout is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isQueryTimeoutSet() {\n        return queryTimeout != null;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Integer fetchDirection;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Integer", "name": "fetchDirection", "syntax_pass": true}, {"attribute_expression": "private final Integer fetchSize;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Integer", "name": "fetchSize", "syntax_pass": true}, {"attribute_expression": "private final Integer maxFieldSize;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Integer", "name": "maxFieldSize", "syntax_pass": true}, {"attribute_expression": "private final Integer maxRows;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Integer", "name": "maxRows", "syntax_pass": true}, {"attribute_expression": "private final Duration queryTimeout;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Duration", "name": "queryTimeout", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/ResultSetIterator.java.ResultSetIterator", "name": "ResultSetIterator", "file_path": "src/main/java/org/apache/commons/dbutils/ResultSetIterator.java", "superclasses": "", "methods": ["[Iterable<Object[]>]iterable(ResultSet)", "[]ResultSetIterator(ResultSet)", "[]ResultSetIterator(ResultSet,RowProcessor)", "[boolean]hasNext()", "[Object[]]next()", "[void]remove()", "[void]rethrow(SQLException)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/ResultSetIterator.java.ResultSetIterator.[Iterable<Object[]>]iterable(ResultSet)", "src/main/java/org/apache/commons/dbutils/ResultSetIterator.java.ResultSetIterator.[]ResultSetIterator(ResultSet)", "src/main/java/org/apache/commons/dbutils/ResultSetIterator.java.ResultSetIterator.[]ResultSetIterator(ResultSet,RowProcessor)", "src/main/java/org/apache/commons/dbutils/ResultSetIterator.java.ResultSetIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/dbutils/ResultSetIterator.java.ResultSetIterator.[Object[]]next()", "src/main/java/org/apache/commons/dbutils/ResultSetIterator.java.ResultSetIterator.[void]remove()", "src/main/java/org/apache/commons/dbutils/ResultSetIterator.java.ResultSetIterator.[void]rethrow(SQLException)"], "overrides": null, "attributes": [], "class_docstring": "\n<p>\nWraps a {@code ResultSet} in an {@code Iterator&lt;Object[]&gt;}.  This is useful\nwhen you want to present a non-database application layer with domain\nneutral data.\n</p>\n\n<p>\nThis implementation requires the {@code ResultSet.isLast()} method\nto be implemented.\n</p>\n", "original_string": "public class ResultSetIterator implements Iterator<Object[]> {\n\n    /**\n     * Generates an {@code Iterable}, suitable for use in for-each loops.\n     *\n     * @param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n     * @return an {@code Iterable}, suitable for use in for-each loops.\n     */\n    public static Iterable<Object[]> iterable(final ResultSet resultSet) {\n        return () -> new ResultSetIterator(resultSet);\n    }\n\n    /**\n     * The wrapped {@code ResultSet}.\n     */\n    private final ResultSet resultSet;\n\n    /**\n     * The processor to use when converting a row into an Object[].\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Constructor for ResultSetIterator.\n     * @param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n     */\n    public ResultSetIterator(final ResultSet resultSet) {\n        this(resultSet, new BasicRowProcessor());\n    }\n\n    /**\n     * Constructor for ResultSetIterator.\n     * @param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n     * @param convert The processor to use when converting a row into an\n     * {@code Object[]}.  Defaults to a\n     * {@code BasicRowProcessor}.\n     */\n    public ResultSetIterator(final ResultSet resultSet, final RowProcessor convert) {\n        this.resultSet = resultSet;\n        this.convert = convert;\n    }\n\n    /**\n     * Returns true if there are more rows in the ResultSet.\n     * @return boolean {@code true} if there are more rows\n     * @throws RuntimeException if an SQLException occurs.\n     */\n    @Override\n    public boolean hasNext() {\n        try {\n            return !resultSet.isLast();\n        } catch (final SQLException e) {\n            rethrow(e);\n            return false;\n        }\n    }\n\n    /**\n     * Returns the next row as an {@code Object[]}.\n     * @return An {@code Object[]} with the same number of elements as\n     * columns in the {@code ResultSet}.\n     * @see java.util.Iterator#next()\n     * @throws RuntimeException if an SQLException occurs.\n     */\n    @Override\n    public Object[] next() {\n        try {\n            return resultSet.next() ? this.convert.toArray(resultSet) : new Object[0];\n        } catch (final SQLException e) {\n            rethrow(e);\n            return null;\n        }\n    }\n\n    /**\n     * Deletes the current row from the {@code ResultSet}.\n     * @see java.util.Iterator#remove()\n     * @throws RuntimeException if an SQLException occurs.\n     */\n    @Override\n    public void remove() {\n        try {\n            this.resultSet.deleteRow();\n        } catch (final SQLException e) {\n            rethrow(e);\n        }\n    }\n\n    /**\n     * Rethrow the SQLException as a RuntimeException.  This implementation\n     * creates a new RuntimeException with the SQLException's error message.\n     * @param e SQLException to rethrow\n     * @since 1.1\n     */\n    protected void rethrow(final SQLException e) {\n        throw new RuntimeException(e.getMessage());\n    }\n\n}", "super_interfaces": ["Iterator<Object[]>"], "fields": [{"attribute_expression": "private final ResultSet resultSet;", "docstring": "\nThe wrapped {@code ResultSet}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ResultSet", "name": "resultSet", "syntax_pass": true}, {"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe processor to use when converting a row into an Object[].\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/ProxyFactory.java.ProxyFactory", "name": "ProxyFactory", "file_path": "src/main/java/org/apache/commons/dbutils/ProxyFactory.java", "superclasses": "", "methods": ["[ProxyFactory]instance()", "[]ProxyFactory()", "[CallableStatement]createCallableStatement(InvocationHandler)", "[Connection]createConnection(InvocationHandler)", "[Driver]createDriver(InvocationHandler)", "[PreparedStatement]createPreparedStatement(InvocationHandler)", "[ResultSet]createResultSet(InvocationHandler)", "[ResultSetMetaData]createResultSetMetaData(InvocationHandler)", "[Statement]createStatement(InvocationHandler)", "[T]newProxyInstance(Class<T>,InvocationHandler)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/ProxyFactory.java.ProxyFactory.[ProxyFactory]instance()", "src/main/java/org/apache/commons/dbutils/ProxyFactory.java.ProxyFactory.[]ProxyFactory()", "src/main/java/org/apache/commons/dbutils/ProxyFactory.java.ProxyFactory.[CallableStatement]createCallableStatement(InvocationHandler)", "src/main/java/org/apache/commons/dbutils/ProxyFactory.java.ProxyFactory.[Connection]createConnection(InvocationHandler)", "src/main/java/org/apache/commons/dbutils/ProxyFactory.java.ProxyFactory.[Driver]createDriver(InvocationHandler)", "src/main/java/org/apache/commons/dbutils/ProxyFactory.java.ProxyFactory.[PreparedStatement]createPreparedStatement(InvocationHandler)", "src/main/java/org/apache/commons/dbutils/ProxyFactory.java.ProxyFactory.[ResultSet]createResultSet(InvocationHandler)", "src/main/java/org/apache/commons/dbutils/ProxyFactory.java.ProxyFactory.[ResultSetMetaData]createResultSetMetaData(InvocationHandler)", "src/main/java/org/apache/commons/dbutils/ProxyFactory.java.ProxyFactory.[Statement]createStatement(InvocationHandler)", "src/main/java/org/apache/commons/dbutils/ProxyFactory.java.ProxyFactory.[T]newProxyInstance(Class<T>,InvocationHandler)"], "overrides": null, "attributes": [], "class_docstring": "\nCreates proxy implementations of JDBC interfaces.  This avoids\nincompatibilities between the JDBC 2 and JDBC 3 interfaces.  This class is\nthread safe.\n\n@see java.lang.reflect.Proxy\n@see java.lang.reflect.InvocationHandler\n", "original_string": "public class ProxyFactory {\n\n    /**\n     * The Singleton instance of this class.\n     */\n    private static final ProxyFactory INSTANCE = new ProxyFactory();\n\n    /**\n     * Returns the Singleton instance of this class.\n     *\n     * @return singleton instance\n     */\n    public static ProxyFactory instance() {\n        return INSTANCE;\n    }\n\n    /**\n     * Protected constructor for ProxyFactory subclasses to use.\n     */\n    protected ProxyFactory() {\n    }\n\n    /**\n     * Creates a new proxy {@code CallableStatement} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied CallableStatement\n     */\n    public CallableStatement createCallableStatement(final InvocationHandler handler) {\n        return newProxyInstance(CallableStatement.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code Connection} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied Connection\n     */\n    public Connection createConnection(final InvocationHandler handler) {\n        return newProxyInstance(Connection.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code Driver} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied Driver\n     */\n    public Driver createDriver(final InvocationHandler handler) {\n        return newProxyInstance(Driver.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code PreparedStatement} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied PreparedStatement\n     */\n    public PreparedStatement createPreparedStatement(final InvocationHandler handler) {\n        return newProxyInstance(PreparedStatement.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code ResultSet} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied ResultSet\n     */\n    public ResultSet createResultSet(final InvocationHandler handler) {\n        return newProxyInstance(ResultSet.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code ResultSetMetaData} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied ResultSetMetaData\n     */\n    public ResultSetMetaData createResultSetMetaData(final InvocationHandler handler) {\n        return newProxyInstance(ResultSetMetaData.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code Statement} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied Statement\n     */\n    public Statement createStatement(final InvocationHandler handler) {\n        return newProxyInstance(Statement.class, handler);\n    }\n\n    /**\n     * Convenience method to generate a single-interface proxy using the handler's classloader\n     *\n     * @param <T> The type of object to proxy\n     * @param type The type of object to proxy\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied object\n     */\n    public <T> T newProxyInstance(final Class<T> type, final InvocationHandler handler) {\n        return type.cast(Proxy.newProxyInstance(handler.getClass().getClassLoader(), new Class<?>[] {type}, handler));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final ProxyFactory INSTANCE = new ProxyFactory();", "docstring": "\nThe Singleton instance of this class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ProxyFactory", "name": "INSTANCE = new ProxyFactory()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner", "name": "QueryRunner", "file_path": "src/main/java/org/apache/commons/dbutils/QueryRunner.java", "superclasses": "AbstractQueryRunner", "methods": ["[]QueryRunner()", "[]QueryRunner(boolean)", "[]QueryRunner(DataSource)", "[]QueryRunner(DataSource,boolean)", "[]QueryRunner(DataSource,boolean,StatementConfiguration)", "[]QueryRunner(DataSource,StatementConfiguration)", "[]QueryRunner(StatementConfiguration)", "[int[]]batch(Connection,String,Object[][])", "[int[]]batch(String,Object[][])", "[int]execute(Connection,String)", "[List<T>]execute(Connection,String,ResultSetHandler<T>)", "[int]execute(String)", "[List<T>]execute(String,ResultSetHandler<T>)", "[T]insert(Connection,String,ResultSetHandler<T>)", "[T]insert(Connection,String,ResultSetHandler<T>)", "[T]insert(String,ResultSetHandler<T>)", "[T]insert(String,ResultSetHandler<T>)", "[T]insertBatch(Connection,String,ResultSetHandler<T>,Object[][])", "[T]insertBatch(String,ResultSetHandler<T>,Object[][])", "[T]query(Connection,String,Object,ResultSetHandler<T>)", "[T]query(Connection,String,Object[],ResultSetHandler<T>)", "[T]query(Connection,String,ResultSetHandler<T>)", "[T]query(Connection,String,ResultSetHandler<T>)", "[T]query(String,Object,ResultSetHandler<T>)", "[T]query(String,Object[],ResultSetHandler<T>)", "[T]query(String,ResultSetHandler<T>)", "[T]query(String,ResultSetHandler<T>)", "[void]retrieveOutParameters(CallableStatement,Object[])", "[int]update(Connection,String)", "[int]update(Connection,String,Object)", "[int]update(Connection,String)", "[int]update(String)", "[int]update(String,Object)", "[int]update(String)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[]QueryRunner()", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[]QueryRunner(boolean)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[]QueryRunner(DataSource)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[]QueryRunner(DataSource,boolean)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[]QueryRunner(DataSource,boolean,StatementConfiguration)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[]QueryRunner(DataSource,StatementConfiguration)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[]QueryRunner(StatementConfiguration)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[int[]]batch(Connection,String,Object[][])", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[int[]]batch(String,Object[][])", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[int]execute(Connection,String)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[List<T>]execute(Connection,String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[int]execute(String)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[List<T>]execute(String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]insert(Connection,String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]insert(Connection,String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]insert(String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]insert(String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]insertBatch(Connection,String,ResultSetHandler<T>,Object[][])", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]insertBatch(String,ResultSetHandler<T>,Object[][])", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]query(Connection,String,Object,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]query(Connection,String,Object[],ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]query(Connection,String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]query(Connection,String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]query(String,Object,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]query(String,Object[],ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]query(String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[T]query(String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[void]retrieveOutParameters(CallableStatement,Object[])", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[int]update(Connection,String)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[int]update(Connection,String,Object)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[int]update(Connection,String)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[int]update(String)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[int]update(String,Object)", "src/main/java/org/apache/commons/dbutils/QueryRunner.java.QueryRunner.[int]update(String)"], "overrides": null, "attributes": [], "class_docstring": "\nExecutes SQL queries with pluggable strategies for handling\n{@code ResultSet}s.  This class is thread safe.\n\n@see ResultSetHandler\n", "original_string": "public class QueryRunner extends AbstractQueryRunner {\n\n    /**\n     * Constructor for QueryRunner.\n     */\n    public QueryRunner() {\n    }\n\n    /**\n     * Constructor for QueryRunner that controls the use of {@code ParameterMetaData}.\n     *\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     */\n    public QueryRunner(final boolean pmdKnownBroken) {\n        super(pmdKnownBroken);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource} to use.\n     *\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     */\n    public QueryRunner(final DataSource ds) {\n        super(ds);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource} and controls the use of {@code ParameterMetaData}.\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     */\n    public QueryRunner(final DataSource ds, final boolean pmdKnownBroken) {\n        super(ds, pmdKnownBroken);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource}, a {@code StatementConfiguration}, and\n     * controls the use of {@code ParameterMetaData}.  Methods that do not take a {@code Connection} parameter\n     * will retrieve connections from this {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public QueryRunner(final DataSource ds, final boolean pmdKnownBroken, final StatementConfiguration stmtConfig) {\n        super(ds, pmdKnownBroken, stmtConfig);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource} to use and a {@code StatementConfiguration}.\n     *\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public QueryRunner(final DataSource ds, final StatementConfiguration stmtConfig) {\n        super(ds, stmtConfig);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code StatementConfiguration} to configure statements when\n     * preparing them.\n     *\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public QueryRunner(final StatementConfiguration stmtConfig) {\n        super(stmtConfig);\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.\n     *\n     * @param conn The Connection to use to run the query.  The caller is\n     * responsible for closing this Connection.\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return The number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     * @since 1.1\n     */\n    public int[] batch(final Connection conn, final String sql, final Object[][] params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (params == null) {\n            throw new SQLException(\"Null parameters. If parameters aren't need, pass an empty array.\");\n        }\n\n        PreparedStatement stmt = null;\n        ParameterMetaData pmd = null;\n        int[] rows = null;\n        try {\n            stmt = this.prepareStatement(conn, sql);\n            // When the batch size is large, prefetching parameter metadata before filling\n            // the statement can reduce lots of JDBC communications.\n            pmd = getParameterMetaData(stmt);\n\n            for (final Object[] param : params) {\n                this.fillStatement(stmt, pmd, param);\n                stmt.addBatch();\n            }\n            rows = stmt.executeBatch();\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, (Object[])params);\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return The number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     * @since 1.1\n     */\n    public int[] batch(final String sql, final Object[][] params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.batch(conn, sql, params);\n        }\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which does\n     * not return any result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when invoking a stored procedure with OUT parameters\n     * that does not return any result sets.  If you are not invoking a stored\n     * procedure, or the stored procedure has no OUT parameters, consider using\n     * {@link #update(java.sql.Connection, String, Object...) }.\n     * If the stored procedure returns result sets, use\n     * {@link #execute(java.sql.Connection, String, org.apache.commons.dbutils.ResultSetHandler, Object...) }.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param params The query replacement parameters.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int execute(final Connection conn, final String sql, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        CallableStatement stmt = null;\n        int rows = 0;\n\n        try {\n            stmt = prepareCall(conn, sql);\n            this.fillStatement(stmt, params);\n            stmt.execute();\n            rows = stmt.getUpdateCount();\n            retrieveOutParameters(stmt, params);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which\n     * returns one or more result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when: a) running SQL statements that return multiple\n     * result sets; b) invoking a stored procedure that return result\n     * sets and OUT parameters.  Otherwise you may wish to use\n     * {@link #query(java.sql.Connection, String, org.apache.commons.dbutils.ResultSetHandler, Object...) }\n     * (if there are no OUT parameters) or\n     * {@link #execute(java.sql.Connection, String, Object...) }\n     * (if there are no result sets).\n     *\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The result set handler\n     * @param params The query replacement parameters.\n     * @return A list of objects generated by the handler\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> List<T> execute(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        CallableStatement stmt = null;\n        final List<T> results = new LinkedList<>();\n\n        try {\n            stmt = prepareCall(conn, sql);\n            this.fillStatement(stmt, params);\n            boolean moreResultSets = stmt.execute();\n            // Handle multiple result sets by passing them through the handler\n            // retaining the final result\n            while (moreResultSets) {\n                try (@SuppressWarnings(\"resource\")\n                // assume the ResultSet wrapper properly closes\n                ResultSet resultSet = wrap(stmt.getResultSet())) {\n                    results.add(rsh.handle(resultSet));\n                    moreResultSets = stmt.getMoreResults();\n                }\n            }\n            retrieveOutParameters(stmt, params);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return results;\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which does\n     * not return any result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when invoking a stored procedure with OUT parameters\n     * that does not return any result sets.  If you are not invoking a stored\n     * procedure, or the stored procedure has no OUT parameters, consider using\n     * {@link #update(String, Object...) }.\n     * If the stored procedure returns result sets, use\n     * {@link #execute(String, org.apache.commons.dbutils.ResultSetHandler, Object...) }.\n     * <p>\n     * The {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param params Initializes the CallableStatement's parameters (i.e. '?').\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int execute(final String sql, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.execute(conn, sql, params);\n        }\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which\n     * returns one or more result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when: a) running SQL statements that return multiple\n     * result sets; b) invoking a stored procedure that return result\n     * sets and OUT parameters.  Otherwise you may wish to use\n     * {@link #query(String, org.apache.commons.dbutils.ResultSetHandler, Object...) }\n     * (if there are no OUT parameters) or\n     * {@link #execute(String, Object...) }\n     * (if there are no result sets).\n     *\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL to execute.\n     * @param rsh The result set handler\n     * @param params The query replacement parameters.\n     * @return A list of objects generated by the handler\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> List<T> execute(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.execute(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Execute an SQL INSERT query without replacement parameters.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return insert(conn, sql, rsh, (Object[]) null);\n    }\n\n    /**\n     * Execute an SQL INSERT query.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params The query replacement parameters.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        Statement stmt = null;\n        T generatedKeys = null;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                ps.executeUpdate();\n            } else {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);\n            }\n            try (ResultSet resultSet = stmt.getGeneratedKeys()) {\n                generatedKeys = rsh.handle(resultSet);\n            }\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n        } finally {\n            close(stmt);\n        }\n\n        return generatedKeys;\n    }\n\n    /**\n     * Executes the given INSERT SQL without any replacement parameters.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insert(conn, sql, rsh, (Object[]) null);\n        }\n    }\n\n    /**\n     * Executes the given INSERT SQL statement. The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the insert will not be saved.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insert(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Executes the given batch of INSERT SQL statements.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params The query replacement parameters.\n     * @return The result generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insertBatch(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (params == null) {\n            throw new SQLException(\"Null parameters. If parameters aren't need, pass an empty array.\");\n        }\n\n        PreparedStatement stmt = null;\n        T generatedKeys = null;\n        try {\n            stmt = this.prepareStatement(conn, sql, Statement.RETURN_GENERATED_KEYS);\n\n            for (final Object[] param : params) {\n                this.fillStatement(stmt, param);\n                stmt.addBatch();\n            }\n            stmt.executeBatch();\n            try (ResultSet resultSet = stmt.getGeneratedKeys()) {\n                generatedKeys = rsh.handle(resultSet);\n            }\n        } catch (final SQLException e) {\n            rethrow(e, sql, (Object[])params);\n        } finally {\n            close(stmt);\n        }\n\n        return generatedKeys;\n    }\n\n    /**\n     * Executes the given batch of INSERT SQL statements. The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the insert will not be saved.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * @return The result generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insertBatch(final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insertBatch(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Execute an SQL SELECT query with a single replacement parameter. The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param param The replacement parameter.\n     * @param rsh The handler that converts the results into an object.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(Connection, String, ResultSetHandler, Object...)}\n     */\n    @Deprecated\n    public <T> T query(final Connection conn, final String sql, final Object param, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, param);\n    }\n\n    /**\n     * Execute an SQL SELECT query with replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param params The replacement parameters.\n     * @param rsh The handler that converts the results into an object.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(Connection,String,ResultSetHandler,Object...)} instead\n     */\n    @Deprecated\n    public <T> T query(final Connection conn, final String sql, final Object[] params, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, params);\n    }\n\n    /**\n     * Execute an SQL SELECT query without any replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, (Object[]) null);\n    }\n\n    /**\n     * Execute an SQL SELECT query with replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @param params The replacement parameters.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        Statement stmt = null;\n        ResultSet resultSet = null;\n        T result = null;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = this.prepareStatement(conn, sql);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                resultSet = wrap(ps.executeQuery());\n            } else {\n                stmt = conn.createStatement();\n                resultSet = wrap(stmt.executeQuery(sql));\n            }\n            result = rsh.handle(resultSet);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            closeQuietly(resultSet);\n            closeQuietly(stmt);\n        }\n\n        return result;\n    }\n\n    /**\n     * Executes the given SELECT SQL with a single replacement parameter.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param param The replacement parameter.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(String, ResultSetHandler, Object...)}\n     */\n    @Deprecated\n    public <T> T query(final String sql, final Object param, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, param);\n        }\n    }\n\n    /**\n     * Executes the given SELECT SQL query and returns a result object.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param params Initialize the PreparedStatement's IN parameters with\n     * this array.\n     *\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(String, ResultSetHandler, Object...)}\n     */\n    @Deprecated\n    public <T> T query(final String sql, final Object[] params, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Executes the given SELECT SQL without any replacement parameters.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, (Object[]) null);\n        }\n    }\n\n    /**\n     * Executes the given SELECT SQL query and returns a result object.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     * @param params Initialize the PreparedStatement's IN parameters with\n     * this array.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Set the value on all the {@link OutParameter} instances in the\n     * {@code params} array using the OUT parameter values from the\n     * {@code stmt}.\n     * @param stmt the statement from which to retrieve OUT parameter values\n     * @param params the parameter array for the statement invocation\n     * @throws SQLException when the value could not be retrieved from the\n     * statement.\n     */\n    private void retrieveOutParameters(final CallableStatement stmt, final Object[] params) throws SQLException {\n        if (params != null) {\n            for (int i = 0; i < params.length; i++) {\n                if (params[i] instanceof OutParameter) {\n                    ((OutParameter<?>) params[i]).setValue(stmt, i + 1);\n                }\n            }\n        }\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query without replacement\n     * parameters.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int update(final Connection conn, final String sql) throws SQLException {\n        return this.update(conn, sql, (Object[]) null);\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query with a single replacement\n     * parameter.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param param The replacement parameter.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int update(final Connection conn, final String sql, final Object param) throws SQLException {\n        return this.update(conn, sql, new Object[] { param });\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param params The query replacement parameters.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int update(final Connection conn, final String sql, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        Statement stmt = null;\n        int rows = 0;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = this.prepareStatement(conn, sql);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                rows = ps.executeUpdate();\n            } else {\n                stmt = conn.createStatement();\n                rows = stmt.executeUpdate(sql);\n            }\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement without\n     * any replacement parameters. The {@code Connection} is retrieved\n     * from the {@code DataSource} set in the constructor.  This\n     * {@code Connection} must be in auto-commit mode or the update will\n     * not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int update(final String sql) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, (Object[]) null);\n        }\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement with\n     * a single replacement parameter.  The {@code Connection} is\n     * retrieved from the {@code DataSource} set in the constructor.\n     * This {@code Connection} must be in auto-commit mode or the\n     * update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param param The replacement parameter.\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int update(final String sql, final Object param) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, param);\n        }\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * parameters.\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int update(final String sql, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, params);\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils", "name": "DbUtils", "file_path": "src/main/java/org/apache/commons/dbutils/DbUtils.java", "superclasses": "", "methods": ["[void]close(Connection)", "[void]close(ResultSet)", "[void]close(Statement)", "[void]closeQuietly(Connection)", "[void]closeQuietly(Connection,Statement,ResultSet)", "[void]closeQuietly(ResultSet)", "[void]closeQuietly(Statement)", "[void]commitAndClose(Connection)", "[void]commitAndCloseQuietly(Connection)", "[boolean]loadDriver(ClassLoader,String)", "[boolean]loadDriver(String)", "[void]printStackTrace(SQLException)", "[void]printStackTrace(SQLException,PrintWriter)", "[void]printWarnings(Connection)", "[void]printWarnings(Connection,PrintWriter)", "[void]rollback(Connection)", "[void]rollbackAndClose(Connection)", "[void]rollbackAndCloseQuietly(Connection)", "[void]rollbackQuietly(Connection)", "[]DbUtils()"], "method_uris": ["src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]close(Connection)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]close(ResultSet)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]close(Statement)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]closeQuietly(Connection)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]closeQuietly(Connection,Statement,ResultSet)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]closeQuietly(ResultSet)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]closeQuietly(Statement)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]commitAndClose(Connection)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]commitAndCloseQuietly(Connection)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[boolean]loadDriver(ClassLoader,String)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[boolean]loadDriver(String)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]printStackTrace(SQLException)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]printStackTrace(SQLException,PrintWriter)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]printWarnings(Connection)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]printWarnings(Connection,PrintWriter)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]rollback(Connection)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]rollbackAndClose(Connection)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]rollbackAndCloseQuietly(Connection)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[void]rollbackQuietly(Connection)", "src/main/java/org/apache/commons/dbutils/DbUtils.java.DbUtils.[]DbUtils()"], "overrides": null, "attributes": [{"original_string": "    static final class DriverProxy implements Driver {\n\n        /**\n         * The adapted JDBC Driver loaded dynamically.\n         */\n        private final Driver adapted;\n\n        /**\n         * Creates a new JDBC Driver that adapts a JDBC Driver loaded dynamically.\n         *\n         * @param adapted the adapted JDBC Driver loaded dynamically.\n         */\n        public DriverProxy(final Driver adapted) {\n            this.adapted = adapted;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean acceptsURL(final String url) throws SQLException {\n            return adapted.acceptsURL(url);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Connection connect(final String url, final Properties info) throws SQLException {\n            return adapted.connect(url, info);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getMajorVersion() {\n            return adapted.getMajorVersion();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getMinorVersion() {\n            return adapted.getMinorVersion();\n        }\n\n        /**\n         * Java 1.7 method.\n         */\n        @Override\n        public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n            return adapted.getParentLogger();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public DriverPropertyInfo[] getPropertyInfo(final String url, final Properties info) throws SQLException {\n            return adapted.getPropertyInfo(url, info);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean jdbcCompliant() {\n            return adapted.jdbcCompliant();\n        }\n\n    }", "definition": "    static final class DriverProxy implements Driver", "class_docstring": "\nSimple {@link Driver} proxy class that proxies a JDBC Driver loaded dynamically.\n\n@since 1.6\n", "name": "DriverProxy", "super_interfaces": ["Driver"], "superclasses": "", "attributes": {"modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Driver adapted;", "docstring": "\nThe adapted JDBC Driver loaded dynamically.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Driver", "name": "adapted", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public DriverProxy(final Driver adapted) {\n            this.adapted = adapted;\n        }", "docstring": "\nCreates a new JDBC Driver that adapts a JDBC Driver loaded dynamically.\n\n@param adapted the adapted JDBC Driver loaded dynamically.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "DriverProxy", "params": [{"name": "adapted", "type": "Driver"}], "body": "                                                 {\n            this.adapted = adapted;\n        }", "signature": "public DriverProxy(final Driver adapted)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean acceptsURL(final String url) throws SQLException {\n            return adapted.acceptsURL(url);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "acceptsURL", "params": [{"name": "url", "type": "String"}], "body": "                                                                        {\n            return adapted.acceptsURL(url);\n        }", "signature": "@Override\n        public boolean acceptsURL(final String url)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Connection connect(final String url, final Properties info) throws SQLException {\n            return adapted.connect(url, info);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection", "classes": []}, "name": "connect", "params": [{"name": "url", "type": "String"}, {"name": "info", "type": "Properties"}], "body": "                                                                                               {\n            return adapted.connect(url, info);\n        }", "signature": "@Override\n        public Connection connect(final String url, final Properties info)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int getMajorVersion() {\n            return adapted.getMajorVersion();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getMajorVersion", "params": [], "body": "                                     {\n            return adapted.getMajorVersion();\n        }", "signature": "@Override\n        public int getMajorVersion()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int getMinorVersion() {\n            return adapted.getMinorVersion();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getMinorVersion", "params": [], "body": "                                     {\n            return adapted.getMinorVersion();\n        }", "signature": "@Override\n        public int getMinorVersion()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n            return adapted.getParentLogger();\n        }", "docstring": "\nJava 1.7 method.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Logger", "classes": []}, "name": "getParentLogger", "params": [], "body": "                                                                               {\n            return adapted.getParentLogger();\n        }", "signature": "@Override\n        public Logger getParentLogger()"}, {"syntax_pass": true, "original_string": "        @Override\n        public DriverPropertyInfo[] getPropertyInfo(final String url, final Properties info) throws SQLException {\n            return adapted.getPropertyInfo(url, info);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DriverPropertyInfo[]", "classes": []}, "name": "getPropertyInfo", "params": [{"name": "url", "type": "String"}, {"name": "info", "type": "Properties"}], "body": "                                                                                                                 {\n            return adapted.getPropertyInfo(url, info);\n        }", "signature": "@Override\n        public DriverPropertyInfo[] getPropertyInfo(final String url, final Properties info)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean jdbcCompliant() {\n            return adapted.jdbcCompliant();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "jdbcCompliant", "params": [], "body": "                                       {\n            return adapted.jdbcCompliant();\n        }", "signature": "@Override\n        public boolean jdbcCompliant()"}]}], "class_docstring": "\nA collection of JDBC helper methods.  This class is thread safe.\n", "original_string": "public final class DbUtils {\n\n    /**\n     * Simple {@link Driver} proxy class that proxies a JDBC Driver loaded dynamically.\n     *\n     * @since 1.6\n     */\n    static final class DriverProxy implements Driver {\n\n        /**\n         * The adapted JDBC Driver loaded dynamically.\n         */\n        private final Driver adapted;\n\n        /**\n         * Creates a new JDBC Driver that adapts a JDBC Driver loaded dynamically.\n         *\n         * @param adapted the adapted JDBC Driver loaded dynamically.\n         */\n        public DriverProxy(final Driver adapted) {\n            this.adapted = adapted;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean acceptsURL(final String url) throws SQLException {\n            return adapted.acceptsURL(url);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Connection connect(final String url, final Properties info) throws SQLException {\n            return adapted.connect(url, info);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getMajorVersion() {\n            return adapted.getMajorVersion();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getMinorVersion() {\n            return adapted.getMinorVersion();\n        }\n\n        /**\n         * Java 1.7 method.\n         */\n        @Override\n        public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n            return adapted.getParentLogger();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public DriverPropertyInfo[] getPropertyInfo(final String url, final Properties info) throws SQLException {\n            return adapted.getPropertyInfo(url, info);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean jdbcCompliant() {\n            return adapted.jdbcCompliant();\n        }\n\n    }\n\n    /**\n     * Close a {@code Connection}, avoid closing if null.\n     *\n     * @param conn Connection to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void close(final Connection conn) throws SQLException {\n        if (conn != null) {\n            conn.close();\n        }\n    }\n\n    /**\n     * Close a {@code ResultSet}, avoid closing if null.\n     *\n     * @param resultSet ResultSet to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void close(final ResultSet resultSet) throws SQLException {\n        if (resultSet != null) {\n            resultSet.close();\n        }\n    }\n\n    /**\n     * Close a {@code Statement}, avoid closing if null.\n     *\n     * @param stmt Statement to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void close(final Statement stmt) throws SQLException {\n        if (stmt != null) {\n            stmt.close();\n        }\n    }\n\n    /**\n     * Close a {@code Connection}, avoid closing if null and hide\n     * any SQLExceptions that occur.\n     *\n     * @param conn Connection to close.\n     */\n    public static void closeQuietly(final Connection conn) {\n        try {\n            close(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Close a {@code Connection}, {@code Statement} and\n     * {@code ResultSet}.  Avoid closing if null and hide any\n     * SQLExceptions that occur.\n     *\n     * @param conn Connection to close.\n     * @param stmt Statement to close.\n     * @param rs ResultSet to close.\n     */\n    public static void closeQuietly(final Connection conn, final Statement stmt,\n            final ResultSet rs) {\n\n        try {\n            closeQuietly(rs);\n        } finally {\n            try {\n                closeQuietly(stmt);\n            } finally {\n                closeQuietly(conn);\n            }\n        }\n\n    }\n\n    /**\n     * Close a {@code ResultSet}, avoid closing if null and hide any\n     * SQLExceptions that occur.\n     *\n     * @param resultSet ResultSet to close.\n     */\n    public static void closeQuietly(final ResultSet resultSet) {\n        try {\n            close(resultSet);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Close a {@code Statement}, avoid closing if null and hide\n     * any SQLExceptions that occur.\n     *\n     * @param stmt Statement to close.\n     */\n    public static void closeQuietly(final Statement stmt) {\n        try {\n            close(stmt);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Commits a {@code Connection} then closes it, avoid closing if null.\n     *\n     * @param conn Connection to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void commitAndClose(final Connection conn) throws SQLException {\n        if (conn != null) {\n            try {\n                conn.commit();\n            } finally {\n                conn.close();\n            }\n        }\n    }\n\n    /**\n     * Commits a {@code Connection} then closes it, avoid closing if null\n     * and hide any SQLExceptions that occur.\n     *\n     * @param conn Connection to close.\n     */\n    public static void commitAndCloseQuietly(final Connection conn) {\n        try {\n            commitAndClose(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Loads and registers a database driver class.\n     * If this succeeds, it returns true, else it returns false.\n     *\n     * @param classLoader the class loader used to load the driver class\n     * @param driverClassName of driver to load\n     * @return boolean {@code true} if the driver was found, otherwise {@code false}\n     * @since 1.4\n     */\n    public static boolean loadDriver(final ClassLoader classLoader, final String driverClassName) {\n        try {\n            final Class<?> loadedClass = classLoader.loadClass(driverClassName);\n\n            if (!Driver.class.isAssignableFrom(loadedClass)) {\n                return false;\n            }\n\n            @SuppressWarnings(\"unchecked\") // guarded by previous check\n            final\n            Class<Driver> driverClass = (Class<Driver>) loadedClass;\n            final Constructor<Driver> driverConstructor = driverClass.getConstructor();\n\n            // make Constructor accessible if it is private\n            @SuppressWarnings(\"deprecation\")\n            // TODO This is deprecated in Java9 and canAccess() should be used. Adding suppression for building on\n            //      later JDKs without a warning.\n            final boolean isConstructorAccessible = driverConstructor.isAccessible();\n            if (!isConstructorAccessible) {\n                driverConstructor.setAccessible(true);\n            }\n\n            try {\n                final Driver driver = driverConstructor.newInstance();\n                registerDriver(new DriverProxy(driver));\n            } finally {\n                driverConstructor.setAccessible(isConstructorAccessible);\n            }\n\n            return true;\n        } catch (final Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * Loads and registers a database driver class.\n     * If this succeeds, it returns true, else it returns false.\n     *\n     * @param driverClassName of driver to load\n     * @return boolean {@code true} if the driver was found, otherwise {@code false}\n     */\n    public static boolean loadDriver(final String driverClassName) {\n        return loadDriver(DbUtils.class.getClassLoader(), driverClassName);\n    }\n\n    /**\n     * Print the stack trace for a SQLException to STDERR.\n     *\n     * @param e SQLException to print stack trace of\n     */\n    public static void printStackTrace(final SQLException e) {\n        printStackTrace(e, new PrintWriter(System.err));\n    }\n\n    /**\n     * Print the stack trace for a SQLException to a\n     * specified PrintWriter.\n     *\n     * @param e SQLException to print stack trace of\n     * @param pw PrintWriter to print to\n     */\n    public static void printStackTrace(final SQLException e, final PrintWriter pw) {\n\n        SQLException next = e;\n        while (next != null) {\n            next.printStackTrace(pw);\n            next = next.getNextException();\n            if (next != null) {\n                pw.println(\"Next SQLException:\");\n            }\n        }\n    }\n\n    /**\n     * Print warnings on a Connection to STDERR.\n     *\n     * @param conn Connection to print warnings from\n     */\n    public static void printWarnings(final Connection conn) {\n        printWarnings(conn, new PrintWriter(System.err));\n    }\n\n    /**\n     * Print warnings on a Connection to a specified PrintWriter.\n     *\n     * @param conn Connection to print warnings from\n     * @param pw PrintWriter to print to\n     */\n    public static void printWarnings(final Connection conn, final PrintWriter pw) {\n        if (conn != null) {\n            try {\n                printStackTrace(conn.getWarnings(), pw);\n            } catch (final SQLException e) {\n                printStackTrace(e, pw);\n            }\n        }\n    }\n\n    /**\n     * Rollback any changes made on the given connection.\n     * @param conn Connection to rollback.  A null value is legal.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void rollback(final Connection conn) throws SQLException {\n        if (conn != null) {\n            conn.rollback();\n        }\n    }\n\n    /**\n     * Performs a rollback on the {@code Connection} then closes it,\n     * avoid closing if null.\n     *\n     * @param conn Connection to rollback.  A null value is legal.\n     * @throws SQLException if a database access error occurs\n     * @since 1.1\n     */\n    public static void rollbackAndClose(final Connection conn) throws SQLException {\n        if (conn != null) {\n            try {\n                conn.rollback();\n            } finally {\n                conn.close();\n            }\n        }\n    }\n\n    /**\n     * Performs a rollback on the {@code Connection} then closes it,\n     * avoid closing if null and hide any SQLExceptions that occur.\n     *\n     * @param conn Connection to rollback.  A null value is legal.\n     * @since 1.1\n     */\n    public static void rollbackAndCloseQuietly(final Connection conn) {\n        try {\n            rollbackAndClose(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Performs a rollback on the {@code Connection}, avoid\n     * closing if null and hide any SQLExceptions that occur.\n     *\n     * @param conn Connection to rollback.  A null value is legal.\n     * @since DbUtils 2.0\n     */\n    public static void rollbackQuietly(final Connection conn) {\n        try {\n            rollback(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Default constructor.\n     *\n     * Utility classes should not have a public or default constructor,\n     * but this one preserves retro-compatibility.\n     *\n     * @since 1.4\n     */\n    public DbUtils() {\n        // do nothing\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/QueryLoader.java.QueryLoader", "name": "QueryLoader", "file_path": "src/main/java/org/apache/commons/dbutils/QueryLoader.java", "superclasses": "", "methods": ["[QueryLoader]instance()", "[]QueryLoader()", "[Map<String, String>]load(String)", "[Map<String, String>]loadQueries(String)", "[void]unload(String)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/QueryLoader.java.QueryLoader.[QueryLoader]instance()", "src/main/java/org/apache/commons/dbutils/QueryLoader.java.QueryLoader.[]QueryLoader()", "src/main/java/org/apache/commons/dbutils/QueryLoader.java.QueryLoader.[Map<String, String>]load(String)", "src/main/java/org/apache/commons/dbutils/QueryLoader.java.QueryLoader.[Map<String, String>]loadQueries(String)", "src/main/java/org/apache/commons/dbutils/QueryLoader.java.QueryLoader.[void]unload(String)"], "overrides": null, "attributes": [], "class_docstring": "\n{@code QueryLoader} is a registry for sets of queries so\nthat multiple copies of the same queries aren't loaded into memory.\nThis implementation loads properties files filled with query name to\nSQL mappings.  This class is thread safe.\n", "original_string": "public class QueryLoader {\n\n    /**\n     * The Singleton INSTANCE of this class.\n     */\n    private static final QueryLoader INSTANCE = new QueryLoader();\n\n    /**\n     * Matches .xml file extensions.\n     */\n    private static final Pattern dotXml = Pattern.compile(\".+\\\\.[xX][mM][lL]\");\n\n    /**\n     * Return an INSTANCE of this class.\n     * @return The Singleton INSTANCE.\n     */\n    public static QueryLoader instance() {\n        return INSTANCE;\n    }\n\n    /**\n     * Maps query set names to Maps of their queries.\n     */\n    private final Map<String, Map<String, String>> queries = new HashMap<>();\n\n    /**\n     * QueryLoader constructor.\n     */\n    protected QueryLoader() {\n    }\n\n    /**\n     * Loads a Map of query names to SQL values.  The Maps are cached so a\n     * subsequent request to load queries from the same path will return\n     * the cached Map.  The properties file to load can be in either\n     * line-oriented or XML format.  XML formatted properties files must use a\n     * {@code .xml} file extension.\n     *\n     * @param path The path that the ClassLoader will use to find the file.\n     * This is <strong>not</strong> a file system path.  If you had a jarred\n     * Queries.properties file in the com.yourcorp.app.jdbc package you would\n     * pass \"/com/yourcorp/app/jdbc/Queries.properties\" to this method.\n     * @throws IOException if a file access error occurs\n     * @throws IllegalArgumentException if the ClassLoader can't find a file at\n     * the given path.\n     * @throws java.util.InvalidPropertiesFormatException if the XML properties file is\n     * invalid\n     * @return Map of query names to SQL values\n     * @see java.util.Properties\n     */\n    public synchronized Map<String, String> load(final String path) throws IOException {\n\n        Map<String, String> queryMap = this.queries.get(path);\n\n        if (queryMap == null) {\n            queryMap = loadQueries(path);\n            this.queries.put(path, queryMap);\n        }\n\n        return queryMap;\n    }\n\n    /**\n     * Loads a set of named queries into a Map object.  This implementation\n     * reads a properties file at the given path.  The properties file can be\n     * in either line-oriented or XML format.  XML formatted properties files\n     * must use a {@code .xml} file extension.\n\n     * @param path The path that the ClassLoader will use to find the file.\n     * @throws IOException if a file access error occurs\n     * @throws IllegalArgumentException if the ClassLoader can't find a file at\n     * the given path.\n     * @throws java.util.InvalidPropertiesFormatException if the XML properties file is\n     * invalid\n     * @since 1.1\n     * @return Map of query names to SQL values\n     * @see java.util.Properties\n     */\n    protected Map<String, String> loadQueries(final String path) throws IOException {\n        // Findbugs flags getClass().getResource as a bad practice; maybe we should change the API?\n        final Properties props;\n        try (InputStream in = getClass().getResourceAsStream(path)) {\n\n            if (in == null) {\n                throw new IllegalArgumentException(path + \" not found.\");\n            }\n            props = new Properties();\n            if (dotXml.matcher(path).matches()) {\n                props.loadFromXML(in);\n            } else {\n                props.load(in);\n            }\n        }\n\n        // Copy to HashMap for better performance\n\n        @SuppressWarnings({\"rawtypes\", \"unchecked\" }) // load() always creates <String,String> entries\n        final HashMap<String, String> hashMap = new HashMap(props);\n        return hashMap;\n    }\n\n    /**\n     * Removes the queries for the given path from the cache.\n     * @param path The path that the queries were loaded from.\n     */\n    public synchronized void unload(final String path) {\n        this.queries.remove(path);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final QueryLoader INSTANCE = new QueryLoader();", "docstring": "\nThe Singleton INSTANCE of this class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "QueryLoader", "name": "INSTANCE = new QueryLoader()", "syntax_pass": true}, {"attribute_expression": "private static final Pattern dotXml = Pattern.compile(\".+\\\\.[xX][mM][lL]\");", "docstring": "\nMatches .xml file extensions.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "dotXml = Pattern.compile(\".+\\\\.[xX][mM][lL]\")", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Map<String, String>> queries = new HashMap<>();", "docstring": "\nMaps query set names to Maps of their queries.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Map<String, String>>", "name": "queries = new HashMap<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner", "name": "AsyncQueryRunner", "file_path": "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java", "superclasses": "AbstractQueryRunner", "methods": ["[]AsyncQueryRunner(boolean,ExecutorService)", "[]AsyncQueryRunner(DataSource,boolean,ExecutorService)", "[]AsyncQueryRunner(DataSource,ExecutorService)", "[]AsyncQueryRunner(ExecutorService)", "[]AsyncQueryRunner(ExecutorService,QueryRunner)", "[Future<int[]>]batch(Connection,String,Object[][])", "[Future<int[]>]batch(String,Object[][])", "[Future<T>]insert(Connection,String,ResultSetHandler<T>)", "[Future<T>]insert(Connection,String,ResultSetHandler<T>)", "[Future<T>]insert(String,ResultSetHandler<T>)", "[Future<T>]insert(String,ResultSetHandler<T>)", "[Future<T>]insertBatch(Connection,String,ResultSetHandler<T>,Object[][])", "[Future<T>]insertBatch(String,ResultSetHandler<T>,Object[][])", "[Future<T>]query(Connection,String,ResultSetHandler<T>)", "[Future<T>]query(Connection,String,ResultSetHandler<T>)", "[Future<T>]query(String,ResultSetHandler<T>)", "[Future<T>]query(String,ResultSetHandler<T>)", "[Future<Integer>]update(Connection,String)", "[Future<Integer>]update(Connection,String,Object)", "[Future<Integer>]update(Connection,String)", "[Future<Integer>]update(String)", "[Future<Integer>]update(String,Object)", "[Future<Integer>]update(String)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[]AsyncQueryRunner(boolean,ExecutorService)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[]AsyncQueryRunner(DataSource,boolean,ExecutorService)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[]AsyncQueryRunner(DataSource,ExecutorService)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[]AsyncQueryRunner(ExecutorService)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[]AsyncQueryRunner(ExecutorService,QueryRunner)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<int[]>]batch(Connection,String,Object[][])", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<int[]>]batch(String,Object[][])", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<T>]insert(Connection,String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<T>]insert(Connection,String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<T>]insert(String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<T>]insert(String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<T>]insertBatch(Connection,String,ResultSetHandler<T>,Object[][])", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<T>]insertBatch(String,ResultSetHandler<T>,Object[][])", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<T>]query(Connection,String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<T>]query(Connection,String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<T>]query(String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<T>]query(String,ResultSetHandler<T>)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<Integer>]update(Connection,String)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<Integer>]update(Connection,String,Object)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<Integer>]update(Connection,String)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<Integer>]update(String)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<Integer>]update(String,Object)", "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java.AsyncQueryRunner.[Future<Integer>]update(String)"], "overrides": null, "attributes": [{"original_string": "    @Deprecated\n    protected class BatchCallableStatement implements Callable<int[]> {\n        private final String sql;\n        private final Object[][] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n\n        /**\n         * Creates a new BatchCallableStatement instance.\n         *\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         */\n        public BatchCallableStatement(final String sql, final Object[][] params, final Connection conn, final boolean closeConn, final PreparedStatement ps) {\n            this.sql = sql;\n            this.params = params.clone();\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }\n\n        /**\n         * The actual call to executeBatch.\n         *\n         * @return an array of update counts containing one element for each command in the batch.\n         * @throws SQLException if a database access error occurs or one of the commands sent to the database fails.\n         * @see PreparedStatement#executeBatch()\n         */\n        @Override\n        public int[] call() throws SQLException {\n            int[] ret = null;\n\n            try {\n                ret = ps.executeBatch();\n            } catch (final SQLException e) {\n                rethrow(e, sql, (Object[])params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return ret;\n        }\n    }", "definition": "    @Deprecated\n    protected class BatchCallableStatement implements Callable<int[]>", "class_docstring": "\n@deprecated No longer used by this class. Will be removed in a future version.\nClass that encapsulates the continuation for batch calls.\n", "name": "BatchCallableStatement", "super_interfaces": ["Callable<int[]>"], "superclasses": "", "attributes": {"modifiers": "@Deprecated\n    protected", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["protected"], "comments": [], "fields": [{"attribute_expression": "private final String sql;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "sql", "syntax_pass": true}, {"attribute_expression": "private final Object[][] params;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[][]", "name": "params", "syntax_pass": true}, {"attribute_expression": "private final Connection conn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Connection", "name": "conn", "syntax_pass": true}, {"attribute_expression": "private final boolean closeConn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "closeConn", "syntax_pass": true}, {"attribute_expression": "private final PreparedStatement ps;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PreparedStatement", "name": "ps", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public BatchCallableStatement(final String sql, final Object[][] params, final Connection conn, final boolean closeConn, final PreparedStatement ps) {\n            this.sql = sql;\n            this.params = params.clone();\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }", "docstring": "\nCreates a new BatchCallableStatement instance.\n\n@param sql The SQL statement to execute.\n@param params An array of query replacement parameters.  Each row in\n       this array is one set of batch replacement values.\n@param conn The connection to use for the batch call.\n@param closeConn True if the connection should be closed, false otherwise.\n@param ps The {@link PreparedStatement} to be executed.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BatchCallableStatement", "params": [{"name": "sql", "type": "String"}, {"name": "params", "type": "Object[][]"}, {"name": "conn", "type": "Connection"}, {"name": "closeConn", "type": "boolean"}, {"name": "ps", "type": "PreparedStatement"}], "body": "                                                                                                                                                             {\n            this.sql = sql;\n            this.params = params.clone();\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }", "signature": "public BatchCallableStatement(final String sql, final Object[][] params, final Connection conn, final boolean closeConn, final PreparedStatement ps)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int[] call() throws SQLException {\n            int[] ret = null;\n\n            try {\n                ret = ps.executeBatch();\n            } catch (final SQLException e) {\n                rethrow(e, sql, (Object[])params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return ret;\n        }", "docstring": "\nThe actual call to executeBatch.\n\n@return an array of update counts containing one element for each command in the batch.\n@throws SQLException if a database access error occurs or one of the commands sent to the database fails.\n@see PreparedStatement#executeBatch()\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int[]", "classes": []}, "name": "call", "params": [], "body": "                                                {\n            int[] ret = null;\n\n            try {\n                ret = ps.executeBatch();\n            } catch (final SQLException e) {\n                rethrow(e, sql, (Object[])params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return ret;\n        }", "signature": "@Override\n        public int[] call()"}]}, {"original_string": "    protected class QueryCallableStatement<T> implements Callable<T> {\n        private final String sql;\n        private final Object[] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n        private final ResultSetHandler<T> rsh;\n\n        /**\n         * Creates a new {@code QueryCallableStatement} instance.\n         *\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         * @param rsh The handler that converts the results into an object.\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         */\n        public QueryCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps,\n                final ResultSetHandler<T> rsh, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n            this.rsh = rsh;\n        }\n\n        /**\n         * The actual call to {@code handle()} method.\n         *\n         * @return an array of update counts containing one element for each command in the batch.\n         * @throws SQLException if a database access error occurs.\n         * @see ResultSetHandler#handle(ResultSet)\n         */\n        @Override\n        public T call() throws SQLException {\n            ResultSet resultSet = null;\n            T ret = null;\n\n            try {\n                resultSet = wrap(ps.executeQuery());\n                ret = rsh.handle(resultSet);\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                try {\n                    close(resultSet);\n                } finally {\n                    close(ps);\n                    if (closeConn) {\n                        close(conn);\n                    }\n                }\n            }\n\n            return ret;\n        }\n\n    }", "definition": "    protected class QueryCallableStatement<T> implements Callable<T>", "class_docstring": "\nClass that encapsulates the continuation for query calls.\n@param <T> The type of the result from the call to handle.\n", "name": "QueryCallableStatement", "super_interfaces": ["Callable<T>"], "superclasses": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "fields": [{"attribute_expression": "private final String sql;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "sql", "syntax_pass": true}, {"attribute_expression": "private final Object[] params;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[]", "name": "params", "syntax_pass": true}, {"attribute_expression": "private final Connection conn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Connection", "name": "conn", "syntax_pass": true}, {"attribute_expression": "private final boolean closeConn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "closeConn", "syntax_pass": true}, {"attribute_expression": "private final PreparedStatement ps;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PreparedStatement", "name": "ps", "syntax_pass": true}, {"attribute_expression": "private final ResultSetHandler<T> rsh;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ResultSetHandler<T>", "name": "rsh", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public QueryCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps,\n                final ResultSetHandler<T> rsh, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n            this.rsh = rsh;\n        }", "docstring": "\nCreates a new {@code QueryCallableStatement} instance.\n\n@param conn The connection to use for the batch call.\n@param closeConn True if the connection should be closed, false otherwise.\n@param ps The {@link PreparedStatement} to be executed.\n@param rsh The handler that converts the results into an object.\n@param sql The SQL statement to execute.\n@param params An array of query replacement parameters.  Each row in\n       this array is one set of batch replacement values.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "QueryCallableStatement", "params": [{"name": "conn", "type": "Connection"}, {"name": "closeConn", "type": "boolean"}, {"name": "ps", "type": "PreparedStatement"}, {"name": "rsh", "type": "ResultSetHandler<T>"}, {"name": "sql", "type": "String"}], "body": "                                                                                         {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n            this.rsh = rsh;\n        }", "signature": "public QueryCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps,\n                final ResultSetHandler<T> rsh, final String sql, final Object... params)"}, {"syntax_pass": true, "original_string": "        @Override\n        public T call() throws SQLException {\n            ResultSet resultSet = null;\n            T ret = null;\n\n            try {\n                resultSet = wrap(ps.executeQuery());\n                ret = rsh.handle(resultSet);\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                try {\n                    close(resultSet);\n                } finally {\n                    close(ps);\n                    if (closeConn) {\n                        close(conn);\n                    }\n                }\n            }\n\n            return ret;\n        }", "docstring": "\nThe actual call to {@code handle()} method.\n\n@return an array of update counts containing one element for each command in the batch.\n@throws SQLException if a database access error occurs.\n@see ResultSetHandler#handle(ResultSet)\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "call", "params": [], "body": "                                            {\n            ResultSet resultSet = null;\n            T ret = null;\n\n            try {\n                resultSet = wrap(ps.executeQuery());\n                ret = rsh.handle(resultSet);\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                try {\n                    close(resultSet);\n                } finally {\n                    close(ps);\n                    if (closeConn) {\n                        close(conn);\n                    }\n                }\n            }\n\n            return ret;\n        }", "signature": "@Override\n        public T call()"}]}, {"original_string": "    @Deprecated\n    protected class UpdateCallableStatement implements Callable<Integer> {\n        private final String sql;\n        private final Object[] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         */\n        public UpdateCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }\n\n        /**\n         * The actual call to {@code executeUpdate()} method.\n         *\n         * @return either (1) the row count for SQL Data Manipulation Language (DML) statements or\n         *                (2) 0 for SQL statements that return nothing\n         * @throws SQLException if a database access error occurs.\n         * @see PreparedStatement#executeUpdate()\n         */\n        @Override\n        public Integer call() throws SQLException {\n            int rows = 0;\n\n            try {\n                rows = ps.executeUpdate();\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return Integer.valueOf(rows);\n        }\n\n    }", "definition": "    @Deprecated\n    protected class UpdateCallableStatement implements Callable<Integer>", "class_docstring": "\nClass that encapsulates the continuation for update calls.\n\n@deprecated No longer used by this class. Will be removed in a future version.\n", "name": "UpdateCallableStatement", "super_interfaces": ["Callable<Integer>"], "superclasses": "", "attributes": {"modifiers": "@Deprecated\n    protected", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["protected"], "comments": [], "fields": [{"attribute_expression": "private final String sql;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "sql", "syntax_pass": true}, {"attribute_expression": "private final Object[] params;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[]", "name": "params", "syntax_pass": true}, {"attribute_expression": "private final Connection conn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Connection", "name": "conn", "syntax_pass": true}, {"attribute_expression": "private final boolean closeConn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "closeConn", "syntax_pass": true}, {"attribute_expression": "private final PreparedStatement ps;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PreparedStatement", "name": "ps", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public UpdateCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }", "docstring": "\nConstructs a new instance.\n\n@param conn The connection to use for the batch call.\n@param closeConn True if the connection should be closed, false otherwise.\n@param ps The {@link PreparedStatement} to be executed.\n@param sql The SQL statement to execute.\n@param params An array of query replacement parameters.  Each row in\n       this array is one set of batch replacement values.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "UpdateCallableStatement", "params": [{"name": "conn", "type": "Connection"}, {"name": "closeConn", "type": "boolean"}, {"name": "ps", "type": "PreparedStatement"}, {"name": "sql", "type": "String"}], "body": "                                                                                                                                                             {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }", "signature": "public UpdateCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps, final String sql, final Object... params)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Integer call() throws SQLException {\n            int rows = 0;\n\n            try {\n                rows = ps.executeUpdate();\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return Integer.valueOf(rows);\n        }", "docstring": "\nThe actual call to {@code executeUpdate()} method.\n\n@return either (1) the row count for SQL Data Manipulation Language (DML) statements or\n               (2) 0 for SQL statements that return nothing\n@throws SQLException if a database access error occurs.\n@see PreparedStatement#executeUpdate()\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "call", "params": [], "body": "                                                  {\n            int rows = 0;\n\n            try {\n                rows = ps.executeUpdate();\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return Integer.valueOf(rows);\n        }", "signature": "@Override\n        public Integer call()"}]}], "class_docstring": "\nExecutes SQL queries with pluggable strategies for handling\n{@code ResultSet}s.  This class is thread safe.\n\n@see ResultSetHandler\n@since 1.4\n", "original_string": "public class AsyncQueryRunner extends AbstractQueryRunner {\n\n    /**\n     * @deprecated No longer used by this class. Will be removed in a future version.\n     * Class that encapsulates the continuation for batch calls.\n     */\n    @Deprecated\n    protected class BatchCallableStatement implements Callable<int[]> {\n        private final String sql;\n        private final Object[][] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n\n        /**\n         * Creates a new BatchCallableStatement instance.\n         *\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         */\n        public BatchCallableStatement(final String sql, final Object[][] params, final Connection conn, final boolean closeConn, final PreparedStatement ps) {\n            this.sql = sql;\n            this.params = params.clone();\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }\n\n        /**\n         * The actual call to executeBatch.\n         *\n         * @return an array of update counts containing one element for each command in the batch.\n         * @throws SQLException if a database access error occurs or one of the commands sent to the database fails.\n         * @see PreparedStatement#executeBatch()\n         */\n        @Override\n        public int[] call() throws SQLException {\n            int[] ret = null;\n\n            try {\n                ret = ps.executeBatch();\n            } catch (final SQLException e) {\n                rethrow(e, sql, (Object[])params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return ret;\n        }\n    }\n    /**\n     * Class that encapsulates the continuation for query calls.\n     * @param <T> The type of the result from the call to handle.\n     */\n    protected class QueryCallableStatement<T> implements Callable<T> {\n        private final String sql;\n        private final Object[] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n        private final ResultSetHandler<T> rsh;\n\n        /**\n         * Creates a new {@code QueryCallableStatement} instance.\n         *\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         * @param rsh The handler that converts the results into an object.\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         */\n        public QueryCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps,\n                final ResultSetHandler<T> rsh, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n            this.rsh = rsh;\n        }\n\n        /**\n         * The actual call to {@code handle()} method.\n         *\n         * @return an array of update counts containing one element for each command in the batch.\n         * @throws SQLException if a database access error occurs.\n         * @see ResultSetHandler#handle(ResultSet)\n         */\n        @Override\n        public T call() throws SQLException {\n            ResultSet resultSet = null;\n            T ret = null;\n\n            try {\n                resultSet = wrap(ps.executeQuery());\n                ret = rsh.handle(resultSet);\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                try {\n                    close(resultSet);\n                } finally {\n                    close(ps);\n                    if (closeConn) {\n                        close(conn);\n                    }\n                }\n            }\n\n            return ret;\n        }\n\n    }\n\n    /**\n     * Class that encapsulates the continuation for update calls.\n     *\n     * @deprecated No longer used by this class. Will be removed in a future version.\n     */\n    @Deprecated\n    protected class UpdateCallableStatement implements Callable<Integer> {\n        private final String sql;\n        private final Object[] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         */\n        public UpdateCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }\n\n        /**\n         * The actual call to {@code executeUpdate()} method.\n         *\n         * @return either (1) the row count for SQL Data Manipulation Language (DML) statements or\n         *                (2) 0 for SQL statements that return nothing\n         * @throws SQLException if a database access error occurs.\n         * @see PreparedStatement#executeUpdate()\n         */\n        @Override\n        public Integer call() throws SQLException {\n            int rows = 0;\n\n            try {\n                rows = ps.executeUpdate();\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return Integer.valueOf(rows);\n        }\n\n    }\n\n    private final ExecutorService executorService;\n\n    private final QueryRunner queryRunner;\n\n    /**\n     * @deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\n     * Constructor for AsyncQueryRunner that controls the use of {@code ParameterMetaData}.\n     *\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    @Deprecated\n    public AsyncQueryRunner(final boolean pmdKnownBroken, final ExecutorService executorService) {\n        this(null, pmdKnownBroken, executorService);\n    }\n\n    /**\n     * @deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\n     * Constructor for AsyncQueryRunner that take a {@code DataSource} and controls the use of {@code ParameterMetaData}.\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    @Deprecated\n    public AsyncQueryRunner(final DataSource ds, final boolean pmdKnownBroken, final ExecutorService executorService) {\n        super(ds, pmdKnownBroken);\n        this.executorService = executorService;\n        this.queryRunner = new QueryRunner(ds, pmdKnownBroken);\n    }\n\n    /**\n     * @deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\n     * Constructor for AsyncQueryRunner that takes a {@code DataSource}.\n     *\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    @Deprecated\n    public AsyncQueryRunner(final DataSource ds, final ExecutorService executorService) {\n        this(ds, false, executorService);\n    }\n\n    /**\n     * Constructor for AsyncQueryRunner.\n     *\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    public AsyncQueryRunner(final ExecutorService executorService) {\n        this(null, false, executorService);\n    }\n\n    /**\n     * Constructor for AsyncQueryRunner which uses a provided ExecutorService and underlying QueryRunner.\n     *\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     * @param queryRunner the {@code QueryRunner} instance to use for the queries.\n     * @since 1.5\n     */\n    public AsyncQueryRunner(final ExecutorService executorService, final QueryRunner queryRunner) {\n        this.executorService = executorService;\n        this.queryRunner = queryRunner;\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.\n     *\n     * @param conn The {@code Connection} to use to run the query.  The caller is\n     * responsible for closing this Connection.\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return A {@code Future} which returns the number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<int[]> batch(final Connection conn, final String sql, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.batch(conn, sql, params));\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return A {@code Future} which returns the number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<int[]> batch(final String sql, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.batch(sql, params));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(Connection, String, ResultSetHandler)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param conn {@link Connection} to use to execute the SQL statement\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(Connection, String, ResultSetHandler)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(conn, sql, rsh));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(Connection, String, ResultSetHandler, Object...)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param conn {@link Connection} to use to execute the SQL statement\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params Parameter values for substitution in the SQL statement\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(Connection, String, ResultSetHandler, Object...)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(conn, sql, rsh, params));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(String, ResultSetHandler)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(String, ResultSetHandler)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(sql, rsh));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(String, ResultSetHandler, Object...)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params Parameter values for substitution in the SQL statement\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(String, ResultSetHandler, Object...)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(sql, rsh, params));\n    }\n\n    /**\n     * {@link QueryRunner#insertBatch(Connection, String, ResultSetHandler, Object[][])} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param conn {@link Connection} to use to execute the SQL statement\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params An array of query replacement parameters.  Each row in\n     *        this array is one set of batch replacement values.\n     * @return {@link Future} that executes a query runner batch insert\n     * @see QueryRunner#insertBatch(Connection, String, ResultSetHandler, Object[][])\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insertBatch(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insertBatch(conn, sql, rsh, params));\n    }\n\n    /**\n     * {@link QueryRunner#insertBatch(String, ResultSetHandler, Object[][])} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params An array of query replacement parameters.  Each row in\n     *        this array is one set of batch replacement values.\n     * @return {@link Future} that executes a query runner batch insert\n     * @see QueryRunner#insertBatch(String, ResultSetHandler, Object[][])\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insertBatch(final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insertBatch(sql, rsh, params));\n    }\n\n    /**\n     * Execute an SQL SELECT query without any replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(conn, sql, rsh));\n    }\n\n    /**\n     * Execute an SQL SELECT query with replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @param params The replacement parameters.\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params)\n            throws SQLException {\n        return executorService.submit(() -> queryRunner.query(conn, sql, rsh, params));\n    }\n\n    /**\n     * Executes the given SELECT SQL without any replacement parameters.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(sql, rsh));\n    }\n\n    /**\n     * Executes the given SELECT SQL query and returns a result object.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     * @param params Initialize the PreparedStatement's IN parameters with\n     * this array.\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(sql, rsh, params));\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query without replacement\n     * parameters.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @return A {@code Future} which returns the number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<Integer> update(final Connection conn, final String sql) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql)));\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query with a single replacement\n     * parameter.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param param The replacement parameter.\n     * @return A {@code Future} which returns the number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<Integer> update(final Connection conn, final String sql, final Object param) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql, param)));\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param params The query replacement parameters.\n     * @return A {@code Future} which returns the number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<Integer> update(final Connection conn, final String sql, final Object... params) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql, params)));\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement without\n     * any replacement parameters. The {@code Connection} is retrieved\n     * from the {@code DataSource} set in the constructor.  This\n     * {@code Connection} must be in auto-commit mode or the update will\n     * not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @throws SQLException if a database access error occurs\n     * @return A {@code Future} which returns the number of rows updated.\n     */\n    public Future<Integer> update(final String sql) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql)));\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement with\n     * a single replacement parameter.  The {@code Connection} is\n     * retrieved from the {@code DataSource} set in the constructor.\n     * This {@code Connection} must be in auto-commit mode or the\n     * update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param param The replacement parameter.\n     * @throws SQLException if a database access error occurs\n     * @return A {@code Future} which returns the number of rows updated.\n     */\n    public Future<Integer> update(final String sql, final Object param) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql, param)));\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * parameters.\n     * @throws SQLException if a database access error occurs\n     * @return A {@code Future} which returns the number of rows updated.\n     */\n    public Future<Integer> update(final String sql, final Object... params) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql, params)));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final ExecutorService executorService;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ExecutorService", "name": "executorService", "syntax_pass": true}, {"attribute_expression": "private final QueryRunner queryRunner;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "QueryRunner", "name": "queryRunner", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/BasicRowProcessor.java.BasicRowProcessor", "name": "BasicRowProcessor", "file_path": "src/main/java/org/apache/commons/dbutils/BasicRowProcessor.java", "superclasses": "", "methods": ["[Map<String, Object>]createCaseInsensitiveHashMap(int)", "[BasicRowProcessor]instance()", "[]BasicRowProcessor()", "[]BasicRowProcessor(BeanProcessor)", "[Object[]]toArray(ResultSet)", "[T]toBean(ResultSet,Class<? extends T>)", "[List<T>]toBeanList(ResultSet,Class<? extends T>)", "[Map<String, Object>]toMap(ResultSet)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/BasicRowProcessor.java.BasicRowProcessor.[Map<String, Object>]createCaseInsensitiveHashMap(int)", "src/main/java/org/apache/commons/dbutils/BasicRowProcessor.java.BasicRowProcessor.[BasicRowProcessor]instance()", "src/main/java/org/apache/commons/dbutils/BasicRowProcessor.java.BasicRowProcessor.[]BasicRowProcessor()", "src/main/java/org/apache/commons/dbutils/BasicRowProcessor.java.BasicRowProcessor.[]BasicRowProcessor(BeanProcessor)", "src/main/java/org/apache/commons/dbutils/BasicRowProcessor.java.BasicRowProcessor.[Object[]]toArray(ResultSet)", "src/main/java/org/apache/commons/dbutils/BasicRowProcessor.java.BasicRowProcessor.[T]toBean(ResultSet,Class<? extends T>)", "src/main/java/org/apache/commons/dbutils/BasicRowProcessor.java.BasicRowProcessor.[List<T>]toBeanList(ResultSet,Class<? extends T>)", "src/main/java/org/apache/commons/dbutils/BasicRowProcessor.java.BasicRowProcessor.[Map<String, Object>]toMap(ResultSet)"], "overrides": null, "attributes": [{"original_string": "    private static final class CaseInsensitiveHashMap extends LinkedHashMap<String, Object> {\n\n        /**\n         * Required for serialization support.\n         *\n         * @see java.io.Serializable\n         */\n        private static final long serialVersionUID = -2848100435296897392L;\n\n        /**\n         * The internal mapping from lowercase keys to the real keys.\n         *\n         * <p>\n         * Any query operation using the key\n         * ({@link #get(Object)}, {@link #containsKey(Object)})\n         * is done in three steps:\n         * <ul>\n         * <li>convert the parameter key to lower case</li>\n         * <li>get the actual key that corresponds to the lower case key</li>\n         * <li>query the map with the actual key</li>\n         * </ul>\n         * </p>\n         */\n        private final Map<String, String> lowerCaseMap = new HashMap<>();\n\n        private CaseInsensitiveHashMap(final int initialCapacity) {\n            super(initialCapacity);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean containsKey(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.containsKey(realKey);\n            // Possible optimization here:\n            // Since the lowerCaseMap contains a mapping for all the keys,\n            // we could just do this:\n            // return lowerCaseMap.containsKey(key.toString().toLowerCase());\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object get(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.get(realKey);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object put(final String key, final Object value) {\n            /*\n             * In order to keep the map and lowerCaseMap synchronized,\n             * we have to remove the old mapping before putting the\n             * new one. Indeed, oldKey and key are not necessarily equals.\n             * (That's why we call super.remove(oldKey) and not just\n             * super.put(key, value))\n             */\n            final Object oldKey = lowerCaseMap.put(key.toLowerCase(Locale.ROOT), key);\n            final Object oldValue = super.remove(oldKey);\n            super.put(key, value);\n            return oldValue;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void putAll(final Map<? extends String, ?> m) {\n            m.forEach(this::put);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object remove(final Object key) {\n            final Object realKey = lowerCaseMap.remove(key.toString().toLowerCase(Locale.ROOT));\n            return super.remove(realKey);\n        }\n    }", "definition": "    private static final class CaseInsensitiveHashMap extends LinkedHashMap<String, Object>", "class_docstring": "\nA Map that converts all keys to lowercase Strings for case insensitive\nlookups.  This is needed for the toMap() implementation because\ndatabases don't consistently handle the casing of column names.\n\n<p>The keys are stored as they are given [BUG #DBUTILS-34], so we maintain\nan internal mapping from lowercase keys to the real keys in order to\nachieve the case insensitive lookup.\n\n<p>Note: This implementation does not allow {@code null}\nfor key, whereas {@link LinkedHashMap} does, because of the code:\n<pre>\nkey.toString().toLowerCase()\n</pre>\n", "name": "CaseInsensitiveHashMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2848100435296897392L;", "docstring": "\nRequired for serialization support.\n\n@see java.io.Serializable\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2848100435296897392L", "syntax_pass": true}, {"attribute_expression": "private final Map<String, String> lowerCaseMap = new HashMap<>();", "docstring": "\nThe internal mapping from lowercase keys to the real keys.\n\n<p>\nAny query operation using the key\n({@link #get(Object)}, {@link #containsKey(Object)})\nis done in three steps:\n<ul>\n<li>convert the parameter key to lower case</li>\n<li>get the actual key that corresponds to the lower case key</li>\n<li>query the map with the actual key</li>\n</ul>\n</p>\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, String>", "name": "lowerCaseMap = new HashMap<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private CaseInsensitiveHashMap(final int initialCapacity) {\n            super(initialCapacity);\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "CaseInsensitiveHashMap", "params": [{"name": "initialCapacity", "type": "int"}], "body": "                                                                  {\n            super(initialCapacity);\n        }", "signature": "private CaseInsensitiveHashMap(final int initialCapacity)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsKey(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.containsKey(realKey);\n            // Possible optimization here:\n            // Since the lowerCaseMap contains a mapping for all the keys,\n            // we could just do this:\n            // return lowerCaseMap.containsKey(key.toString().toLowerCase());\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsKey", "params": [{"name": "key", "type": "Object"}], "body": "                                                     {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.containsKey(realKey);\n            // Possible optimization here:\n            // Since the lowerCaseMap contains a mapping for all the keys,\n            // we could just do this:\n            // return lowerCaseMap.containsKey(key.toString().toLowerCase());\n        }", "signature": "@Override\n        public boolean containsKey(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object get(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.get(realKey);\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "get", "params": [{"name": "key", "type": "Object"}], "body": "                                            {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.get(realKey);\n        }", "signature": "@Override\n        public Object get(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object put(final String key, final Object value) {\n            /*\n             * In order to keep the map and lowerCaseMap synchronized,\n             * we have to remove the old mapping before putting the\n             * new one. Indeed, oldKey and key are not necessarily equals.\n             * (That's why we call super.remove(oldKey) and not just\n             * super.put(key, value))\n             */\n            final Object oldKey = lowerCaseMap.put(key.toLowerCase(Locale.ROOT), key);\n            final Object oldValue = super.remove(oldKey);\n            super.put(key, value);\n            return oldValue;\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "put", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "Object"}], "body": "                                                                {\n            /*\n             * In order to keep the map and lowerCaseMap synchronized,\n             * we have to remove the old mapping before putting the\n             * new one. Indeed, oldKey and key are not necessarily equals.\n             * (That's why we call super.remove(oldKey) and not just\n             * super.put(key, value))\n             */\n            final Object oldKey = lowerCaseMap.put(key.toLowerCase(Locale.ROOT), key);\n            final Object oldValue = super.remove(oldKey);\n            super.put(key, value);\n            return oldValue;\n        }", "signature": "@Override\n        public Object put(final String key, final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void putAll(final Map<? extends String, ?> m) {\n            m.forEach(this::put);\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "putAll", "params": [{"name": "m", "type": "Map<? extends String, ?>"}], "body": "                                                             {\n            m.forEach(this::put);\n        }", "signature": "@Override\n        public void putAll(final Map<? extends String, ?> m)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object remove(final Object key) {\n            final Object realKey = lowerCaseMap.remove(key.toString().toLowerCase(Locale.ROOT));\n            return super.remove(realKey);\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                               {\n            final Object realKey = lowerCaseMap.remove(key.toString().toLowerCase(Locale.ROOT));\n            return super.remove(realKey);\n        }", "signature": "@Override\n        public Object remove(final Object key)"}]}], "class_docstring": "\nBasic implementation of the {@code RowProcessor} interface.\n\n<p>\nThis class is thread-safe.\n</p>\n\n@see RowProcessor\n", "original_string": "public class BasicRowProcessor implements RowProcessor {\n\n    /**\n     * A Map that converts all keys to lowercase Strings for case insensitive\n     * lookups.  This is needed for the toMap() implementation because\n     * databases don't consistently handle the casing of column names.\n     *\n     * <p>The keys are stored as they are given [BUG #DBUTILS-34], so we maintain\n     * an internal mapping from lowercase keys to the real keys in order to\n     * achieve the case insensitive lookup.\n     *\n     * <p>Note: This implementation does not allow {@code null}\n     * for key, whereas {@link LinkedHashMap} does, because of the code:\n     * <pre>\n     * key.toString().toLowerCase()\n     * </pre>\n     */\n    private static final class CaseInsensitiveHashMap extends LinkedHashMap<String, Object> {\n\n        /**\n         * Required for serialization support.\n         *\n         * @see java.io.Serializable\n         */\n        private static final long serialVersionUID = -2848100435296897392L;\n\n        /**\n         * The internal mapping from lowercase keys to the real keys.\n         *\n         * <p>\n         * Any query operation using the key\n         * ({@link #get(Object)}, {@link #containsKey(Object)})\n         * is done in three steps:\n         * <ul>\n         * <li>convert the parameter key to lower case</li>\n         * <li>get the actual key that corresponds to the lower case key</li>\n         * <li>query the map with the actual key</li>\n         * </ul>\n         * </p>\n         */\n        private final Map<String, String> lowerCaseMap = new HashMap<>();\n\n        private CaseInsensitiveHashMap(final int initialCapacity) {\n            super(initialCapacity);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean containsKey(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.containsKey(realKey);\n            // Possible optimization here:\n            // Since the lowerCaseMap contains a mapping for all the keys,\n            // we could just do this:\n            // return lowerCaseMap.containsKey(key.toString().toLowerCase());\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object get(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.get(realKey);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object put(final String key, final Object value) {\n            /*\n             * In order to keep the map and lowerCaseMap synchronized,\n             * we have to remove the old mapping before putting the\n             * new one. Indeed, oldKey and key are not necessarily equals.\n             * (That's why we call super.remove(oldKey) and not just\n             * super.put(key, value))\n             */\n            final Object oldKey = lowerCaseMap.put(key.toLowerCase(Locale.ROOT), key);\n            final Object oldValue = super.remove(oldKey);\n            super.put(key, value);\n            return oldValue;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void putAll(final Map<? extends String, ?> m) {\n            m.forEach(this::put);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object remove(final Object key) {\n            final Object realKey = lowerCaseMap.remove(key.toString().toLowerCase(Locale.ROOT));\n            return super.remove(realKey);\n        }\n    }\n\n    /**\n     * The default BeanProcessor instance to use if not supplied in the\n     * constructor.\n     */\n    private static final BeanProcessor DEFAULT_CONVERTER = new BeanProcessor();\n\n    /**\n     * The Singleton instance of this class.\n     */\n    private static final BasicRowProcessor INSTANCE = new BasicRowProcessor();\n\n    protected static Map<String, Object> createCaseInsensitiveHashMap(final int cols) {\n        return new CaseInsensitiveHashMap(cols);\n    }\n\n    /**\n     * Returns the Singleton instance of this class.\n     *\n     * @return The single instance of this class.\n     * @deprecated Create instances with the constructors instead.  This will\n     * be removed in 2.0.\n     */\n    @Deprecated\n    public static BasicRowProcessor instance() {\n        return INSTANCE;\n    }\n\n    /**\n     * Use this to process beans.\n     */\n    private final BeanProcessor convert;\n\n    /**\n     * BasicRowProcessor constructor.  Bean processing defaults to a\n     * BeanProcessor instance.\n     */\n    public BasicRowProcessor() {\n        this(DEFAULT_CONVERTER);\n    }\n\n    /**\n     * BasicRowProcessor constructor.\n     * @param convert The BeanProcessor to use when converting columns to\n     * bean properties.\n     * @since 1.1\n     */\n    public BasicRowProcessor(final BeanProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into an {@code Object[]}.\n     * This implementation copies column values into the array in the same\n     * order they're returned from the {@code ResultSet}.  Array elements\n     * will be set to {@code null} if the column was SQL NULL.\n     *\n     * @see org.apache.commons.dbutils.RowProcessor#toArray(java.sql.ResultSet)\n     * @param resultSet ResultSet that supplies the array data\n     * @throws SQLException if a database access error occurs\n     * @return the newly created array\n     */\n    @Override\n    public Object[] toArray(final ResultSet resultSet) throws SQLException {\n        final ResultSetMetaData meta = resultSet.getMetaData();\n        final int cols = meta.getColumnCount();\n        final Object[] result = new Object[cols];\n\n        for (int i = 0; i < cols; i++) {\n            result[i] = resultSet.getObject(i + 1);\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into a JavaBean.  This\n     * implementation delegates to a BeanProcessor instance.\n     * @see org.apache.commons.dbutils.RowProcessor#toBean(java.sql.ResultSet, Class)\n     * @see org.apache.commons.dbutils.BeanProcessor#toBean(java.sql.ResultSet, Class)\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return the newly created bean\n     */\n    @Override\n    public <T> T toBean(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        return this.convert.toBean(resultSet, type);\n    }\n\n    /**\n     * Convert a {@code ResultSet} into a {@code List} of JavaBeans.\n     * This implementation delegates to a BeanProcessor instance.\n     * @see org.apache.commons.dbutils.RowProcessor#toBeanList(java.sql.ResultSet, Class)\n     * @see org.apache.commons.dbutils.BeanProcessor#toBeanList(java.sql.ResultSet, Class)\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return A {@code List} of beans with the given type in the order\n     * they were returned by the {@code ResultSet}.\n     */\n    @Override\n    public <T> List<T> toBeanList(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        return this.convert.toBeanList(resultSet, type);\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into a {@code Map}.\n     *\n     * <p>\n     * This implementation returns a {@code Map} with case insensitive column names as keys. Calls to\n     * {@code map.get(\"COL\")} and {@code map.get(\"col\")} return the same value. Furthermore this implementation\n     * will return an ordered map, that preserves the ordering of the columns in the ResultSet, so that iterating over\n     * the entry set of the returned map will return the first column of the ResultSet, then the second and so forth.\n     * </p>\n     *\n     * @param resultSet ResultSet that supplies the map data\n     * @return the newly created Map\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.RowProcessor#toMap(java.sql.ResultSet)\n     */\n    @Override\n    public Map<String, Object> toMap(final ResultSet resultSet) throws SQLException {\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int cols = rsmd.getColumnCount();\n        final Map<String, Object> result = createCaseInsensitiveHashMap(cols);\n\n        for (int i = 1; i <= cols; i++) {\n            String propKey = rsmd.getColumnLabel(i);\n            if (null == propKey || 0 == propKey.length()) {\n              propKey = rsmd.getColumnName(i);\n            }\n            if (null == propKey || 0 == propKey.length()) {\n              // The column index can't be null\n              propKey = Integer.toString(i);\n            }\n            result.put(propKey, resultSet.getObject(i));\n        }\n\n        return result;\n    }\n\n}", "super_interfaces": ["RowProcessor"], "fields": [{"attribute_expression": "private static final BeanProcessor DEFAULT_CONVERTER = new BeanProcessor();", "docstring": "\nThe default BeanProcessor instance to use if not supplied in the\nconstructor.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "BeanProcessor", "name": "DEFAULT_CONVERTER = new BeanProcessor()", "syntax_pass": true}, {"attribute_expression": "private static final BasicRowProcessor INSTANCE = new BasicRowProcessor();", "docstring": "\nThe Singleton instance of this class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "BasicRowProcessor", "name": "INSTANCE = new BasicRowProcessor()", "syntax_pass": true}, {"attribute_expression": "private final BeanProcessor convert;", "docstring": "\nUse this to process beans.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BeanProcessor", "name": "convert", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/GenerousBeanProcessor.java.GenerousBeanProcessor", "name": "GenerousBeanProcessor", "file_path": "src/main/java/org/apache/commons/dbutils/GenerousBeanProcessor.java", "superclasses": "BeanProcessor", "methods": ["[]GenerousBeanProcessor()", "[int[]]mapColumnsToProperties(ResultSetMetaData,PropertyDescriptor[])"], "method_uris": ["src/main/java/org/apache/commons/dbutils/GenerousBeanProcessor.java.GenerousBeanProcessor.[]GenerousBeanProcessor()", "src/main/java/org/apache/commons/dbutils/GenerousBeanProcessor.java.GenerousBeanProcessor.[int[]]mapColumnsToProperties(ResultSetMetaData,PropertyDescriptor[])"], "overrides": null, "attributes": [], "class_docstring": "\nProvides generous name matching (e.g. underscore-aware) from DB\ncolumns to Java Bean properties.\n\n@since 1.6\n", "original_string": "public class GenerousBeanProcessor extends BeanProcessor {\n\n    /**\n     * Default constructor.\n     */\n    public GenerousBeanProcessor() {\n    }\n\n    @Override\n    protected int[] mapColumnsToProperties(final ResultSetMetaData rsmd,\n            final PropertyDescriptor[] props) throws SQLException {\n\n        final int cols = rsmd.getColumnCount();\n        final int[] columnToProperty = new int[cols + 1];\n        Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);\n\n        for (int col = 1; col <= cols; col++) {\n            String columnName = rsmd.getColumnLabel(col);\n\n            if (null == columnName || 0 == columnName.length()) {\n                columnName = rsmd.getColumnName(col);\n            }\n\n            final String generousColumnName = columnName\n                    .replace(\"_\", \"\")   // more idiomatic to Java\n                    .replace(\" \", \"\");  // can't have spaces in property names\n\n            for (int i = 0; i < props.length; i++) {\n                final String propName = props[i].getName();\n\n                // see if either the column name, or the generous one matches\n                if (columnName.equalsIgnoreCase(propName) ||\n                        generousColumnName.equalsIgnoreCase(propName)) {\n                    columnToProperty[col] = i;\n                    break;\n                }\n            }\n        }\n\n        return columnToProperty;\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor", "name": "BeanProcessor", "file_path": "src/main/java/org/apache/commons/dbutils/BeanProcessor.java", "superclasses": "", "methods": ["[]BeanProcessor()", "[]BeanProcessor(Map<String, String>)", "[void]callSetter(Object,PropertyDescriptor,Object)", "[T]createBean(ResultSet,Class<T>,PropertyDescriptor[],int[])", "[void]finalize()", "[Method]getWriteMethod(Object,PropertyDescriptor,Object)", "[boolean]isCompatibleType(Object,Class<?>)", "[int[]]mapColumnsToProperties(ResultSetMetaData,PropertyDescriptor[])", "[boolean]matchesPrimitive(Class<?>,Class<?>)", "[T]newInstance(Class<T>)", "[T]populateBean(ResultSet,T)", "[T]populateBean(ResultSet,T,PropertyDescriptor[],int[])", "[Object]processColumn(ResultSet,int,Class<?>)", "[PropertyDescriptor[]]propertyDescriptors(Class<?>)", "[T]toBean(ResultSet,Class<? extends T>)", "[List<T>]toBeanList(ResultSet,Class<? extends T>)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[]BeanProcessor()", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[]BeanProcessor(Map<String, String>)", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[void]callSetter(Object,PropertyDescriptor,Object)", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[T]createBean(ResultSet,Class<T>,PropertyDescriptor[],int[])", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[void]finalize()", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[Method]getWriteMethod(Object,PropertyDescriptor,Object)", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[boolean]isCompatibleType(Object,Class<?>)", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[int[]]mapColumnsToProperties(ResultSetMetaData,PropertyDescriptor[])", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[boolean]matchesPrimitive(Class<?>,Class<?>)", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[T]newInstance(Class<T>)", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[T]populateBean(ResultSet,T)", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[T]populateBean(ResultSet,T,PropertyDescriptor[],int[])", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[Object]processColumn(ResultSet,int,Class<?>)", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[PropertyDescriptor[]]propertyDescriptors(Class<?>)", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[T]toBean(ResultSet,Class<? extends T>)", "src/main/java/org/apache/commons/dbutils/BeanProcessor.java.BeanProcessor.[List<T>]toBeanList(ResultSet,Class<? extends T>)"], "overrides": null, "attributes": [], "class_docstring": "\n<p>\n{@code BeanProcessor} matches column names to bean property names\nand converts {@code ResultSet} columns into objects for those bean\nproperties.  Subclasses should override the methods in the processing chain\nto customize behavior.\n</p>\n\n<p>\nThis class is thread-safe.\n</p>\n\n@see BasicRowProcessor\n\n@since 1.1\n", "original_string": "public class BeanProcessor {\n\n    /**\n     * Special array value used by {@code mapColumnsToProperties} that\n     * indicates there is no bean property that matches a column from a\n     * {@code ResultSet}.\n     */\n    protected static final int PROPERTY_NOT_FOUND = -1;\n\n    /**\n     * Set a bean's primitive properties to these defaults when SQL NULL\n     * is returned.  These are the same as the defaults that ResultSet get*\n     * methods return in the event of a NULL column.\n     */\n    private static final Map<Class<?>, Object> PRIMITIVE_DEFAULTS = new HashMap<>();\n\n    private static final List<ColumnHandler<?>> COLUMN_HANDLERS = new ArrayList<>();\n\n    private static final List<PropertyHandler> PROPERTY_HANDLERS = new ArrayList<>();\n\n    static {\n        PRIMITIVE_DEFAULTS.put(Integer.TYPE, Integer.valueOf(0));\n        PRIMITIVE_DEFAULTS.put(Short.TYPE, Short.valueOf((short) 0));\n        PRIMITIVE_DEFAULTS.put(Byte.TYPE, Byte.valueOf((byte) 0));\n        PRIMITIVE_DEFAULTS.put(Float.TYPE, Float.valueOf(0f));\n        PRIMITIVE_DEFAULTS.put(Double.TYPE, Double.valueOf(0d));\n        PRIMITIVE_DEFAULTS.put(Long.TYPE, Long.valueOf(0L));\n        PRIMITIVE_DEFAULTS.put(Boolean.TYPE, Boolean.FALSE);\n        PRIMITIVE_DEFAULTS.put(Character.TYPE, Character.valueOf((char) 0));\n\n        // Use a ServiceLoader to find implementations\n        ServiceLoader.load(ColumnHandler.class).forEach(COLUMN_HANDLERS::add);\n\n        // Use a ServiceLoader to find implementations\n        ServiceLoader.load(PropertyHandler.class).forEach(PROPERTY_HANDLERS::add);\n    }\n\n    /**\n     * ResultSet column to bean property name overrides.\n     */\n    private final Map<String, String> columnToPropertyOverrides;\n\n    /**\n     * Constructor for BeanProcessor.\n     */\n    public BeanProcessor() {\n        this(new HashMap<>());\n    }\n\n    /**\n     * Constructor for BeanProcessor configured with column to property name overrides.\n     *\n     * @param columnToPropertyOverrides ResultSet column to bean property name overrides\n     * @since 1.5\n     */\n    public BeanProcessor(final Map<String, String> columnToPropertyOverrides) {\n        if (columnToPropertyOverrides == null) {\n            throw new IllegalArgumentException(\"columnToPropertyOverrides map cannot be null\");\n        }\n        this.columnToPropertyOverrides = columnToPropertyOverrides;\n    }\n\n    /**\n     * Calls the setter method on the target object for the given property.\n     * If no setter method exists for the property, this method does nothing.\n     * @param target The object to set the property on.\n     * @param prop The property to set.\n     * @param value The value to pass into the setter.\n     * @throws SQLException if an error occurs setting the property.\n     */\n    private void callSetter(final Object target, final PropertyDescriptor prop, Object value)\n            throws SQLException {\n\n        final Method setter = getWriteMethod(target, prop, value);\n\n        if (setter == null || setter.getParameterTypes().length != 1) {\n            return;\n        }\n\n        try {\n            final Class<?> firstParam = setter.getParameterTypes()[0];\n            for (final PropertyHandler handler : PROPERTY_HANDLERS) {\n                if (handler.match(firstParam, value)) {\n                    value = handler.apply(firstParam, value);\n                    break;\n                }\n            }\n\n            // Don't call setter if the value object isn't the right type\n            if (!isCompatibleType(value, firstParam)) {\n                throw new SQLException(\n                        \"Cannot set \" + prop.getName() + \": incompatible types, cannot convert \" + value.getClass().getName() + \" to \" + firstParam.getName());\n                // value cannot be null here because isCompatibleType allows null\n            }\n            setter.invoke(target, value);\n\n        } catch (final IllegalArgumentException | IllegalAccessException | InvocationTargetException e) {\n            throw new SQLException(\"Cannot set \" + prop.getName() + \": \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Creates a new object and initializes its fields from the ResultSet.\n     * @param <T> The type of bean to create\n     * @param resultSet The result set.\n     * @param type The bean type (the return type of the object).\n     * @param props The property descriptors.\n     * @param columnToProperty The column indices in the result set.\n     * @return An initialized object.\n     * @throws SQLException if a database error occurs.\n     */\n    private <T> T createBean(final ResultSet resultSet, final Class<T> type, final PropertyDescriptor[] props, final int[] columnToProperty)\n            throws SQLException {\n        return populateBean(resultSet, this.newInstance(type), props, columnToProperty);\n    }\n\n    /** Does nothing. */\n    @Override\n    protected final void finalize() {\n        // SpotBugs CT_CONSTRUCTOR_THROW\n    }\n\n    /**\n     * Gets the write method to use when setting {@code value} to the {@code target}.\n     *\n     * @param target Object where the write method will be called.\n     * @param prop   BeanUtils information.\n     * @param value  The value that will be passed to the write method.\n     * @return The {@link java.lang.reflect.Method} to call on {@code target} to write {@code value} or {@code null} if\n     *         there is no suitable write method.\n     */\n    protected Method getWriteMethod(final Object target, final PropertyDescriptor prop, final Object value) {\n        return prop.getWriteMethod();\n    }\n\n    /**\n     * ResultSet.getObject() returns an Integer object for an INT column.  The\n     * setter method for the property might take an Integer or a primitive int.\n     * This method returns true if the value can be successfully passed into\n     * the setter method.  Remember, Method.invoke() handles the unwrapping\n     * of Integer into an int.\n     *\n     * @param value The value to be passed into the setter method.\n     * @param type The setter's parameter type (non-null)\n     * @return boolean True if the value is compatible (null => true)\n     */\n    private boolean isCompatibleType(final Object value, final Class<?> type) {\n        // Do object check first, then primitives\n        return value == null || type.isInstance(value) || matchesPrimitive(type, value.getClass());\n    }\n\n    /**\n     * The positions in the returned array represent column numbers.  The\n     * values stored at each position represent the index in the\n     * {@code PropertyDescriptor[]} for the bean property that matches\n     * the column name.  If no bean property was found for a column, the\n     * position is set to {@code PROPERTY_NOT_FOUND}.\n     *\n     * @param rsmd The {@code ResultSetMetaData} containing column\n     * information.\n     *\n     * @param props The bean property descriptors.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @return An int[] with column index to property index mappings.  The 0th\n     * element is meaningless because JDBC column indexing starts at 1.\n     */\n    protected int[] mapColumnsToProperties(final ResultSetMetaData rsmd,\n            final PropertyDescriptor[] props) throws SQLException {\n\n        final int cols = rsmd.getColumnCount();\n        final int[] columnToProperty = new int[cols + 1];\n        Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);\n\n        for (int col = 1; col <= cols; col++) {\n            String columnName = rsmd.getColumnLabel(col);\n            if (null == columnName || 0 == columnName.length()) {\n              columnName = rsmd.getColumnName(col);\n            }\n            String propertyName = columnToPropertyOverrides.get(columnName);\n            if (propertyName == null) {\n                propertyName = columnName;\n            }\n            if (propertyName == null) {\n                propertyName = Integer.toString(col);\n            }\n\n            for (int i = 0; i < props.length; i++) {\n                final PropertyDescriptor prop = props[i];\n                final Method reader = prop.getReadMethod();\n\n                // Check for @Column annotations as explicit marks\n                final Column column;\n                if (reader != null) {\n                    column = reader.getAnnotation(Column.class);\n                } else {\n                    column = null;\n                }\n\n                final String propertyColumnName;\n                if (column != null) {\n                    propertyColumnName = column.name();\n                } else {\n                    propertyColumnName = prop.getName();\n                }\n                if (propertyName.equalsIgnoreCase(propertyColumnName)) {\n                    columnToProperty[col] = i;\n                    break;\n                }\n            }\n        }\n\n        return columnToProperty;\n    }\n\n    /**\n     * Check whether a value is of the same primitive type as {@code targetType}.\n     *\n     * @param targetType The primitive type to target.\n     * @param valueType The value to match to the primitive type.\n     * @return Whether {@code valueType} can be coerced (e.g. autoboxed) into {@code targetType}.\n     */\n    private boolean matchesPrimitive(final Class<?> targetType, final Class<?> valueType) {\n        if (!targetType.isPrimitive()) {\n            return false;\n        }\n\n        try {\n            // see if there is a \"TYPE\" field.  This is present for primitive wrappers.\n            final Field typeField = valueType.getField(\"TYPE\");\n            final Object primitiveValueType = typeField.get(valueType);\n\n            if (targetType == primitiveValueType) {\n                return true;\n            }\n        } catch (final NoSuchFieldException | IllegalAccessException ignored) {\n            // an inaccessible TYPE field is a good sign that we're not working with a primitive wrapper.\n            // nothing to do.  we can't match for compatibility\n        }\n        return false;\n    }\n\n    /**\n     * Factory method that returns a new instance of the given Class.  This\n     * is called at the start of the bean creation process and may be\n     * overridden to provide custom behavior like returning a cached bean\n     * instance.\n     * @param <T> The type of object to create\n     * @param c The Class to create an object from.\n     * @return A newly created object of the Class.\n     * @throws SQLException if creation failed.\n     */\n    protected <T> T newInstance(final Class<T> c) throws SQLException {\n        try {\n            return c.getDeclaredConstructor().newInstance();\n\n        } catch (final IllegalAccessException | InstantiationException | InvocationTargetException |\n            NoSuchMethodException e) {\n            throw new SQLException(\"Cannot create \" + c.getName() + \": \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Initializes the fields of the provided bean from the ResultSet.\n     * @param <T> The type of bean\n     * @param resultSet The result set.\n     * @param bean The bean to be populated.\n     * @return An initialized object.\n     * @throws SQLException if a database error occurs.\n     */\n    public <T> T populateBean(final ResultSet resultSet, final T bean) throws SQLException {\n        final PropertyDescriptor[] props = propertyDescriptors(bean.getClass());\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int[] columnToProperty = mapColumnsToProperties(rsmd, props);\n\n        return populateBean(resultSet, bean, props, columnToProperty);\n    }\n\n    /**\n     * This method populates a bean from the ResultSet based upon the underlying meta-data.\n     *\n     * @param <T> The type of bean\n     * @param resultSet The result set.\n     * @param bean The bean to be populated.\n     * @param props The property descriptors.\n     * @param columnToProperty The column indices in the result set.\n     * @return An initialized object.\n     * @throws SQLException if a database error occurs.\n     */\n    private <T> T populateBean(final ResultSet resultSet, final T bean,\n            final PropertyDescriptor[] props, final int[] columnToProperty)\n            throws SQLException {\n\n        for (int i = 1; i < columnToProperty.length; i++) {\n\n            if (columnToProperty[i] == PROPERTY_NOT_FOUND) {\n                continue;\n            }\n\n            final PropertyDescriptor prop = props[columnToProperty[i]];\n            final Class<?> propType = prop.getPropertyType();\n\n            Object value = null;\n            if (propType != null) {\n                value = processColumn(resultSet, i, propType);\n\n                if (value == null && propType.isPrimitive()) {\n                    value = PRIMITIVE_DEFAULTS.get(propType);\n                }\n            }\n\n            callSetter(bean, prop, value);\n        }\n\n        return bean;\n    }\n\n    /**\n     * Convert a {@code ResultSet} column into an object.  Simple\n     * implementations could just call {@code rs.getObject(index)} while\n     * more complex implementations could perform type manipulation to match\n     * the column's type to the bean property type.\n     *\n     * <p>\n     * This implementation calls the appropriate {@code ResultSet} getter\n     * method for the given property type to perform the type conversion.  If\n     * the property type doesn't match one of the supported\n     * {@code ResultSet} types, {@code getObject} is called.\n     * </p>\n     *\n     * @param resultSet The {@code ResultSet} currently being processed.  It is\n     * positioned on a valid row before being passed into this method.\n     *\n     * @param index The current column index being processed.\n     *\n     * @param propType The bean property type that this column needs to be\n     * converted into.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @return The object from the {@code ResultSet} at the given column\n     * index after optional type processing or {@code null} if the column\n     * value was SQL NULL.\n     */\n    protected Object processColumn(final ResultSet resultSet, final int index, final Class<?> propType)\n        throws SQLException {\n\n        Object retval = resultSet.getObject(index);\n\n        if ( !propType.isPrimitive() && retval == null ) {\n            return null;\n        }\n\n        for (final ColumnHandler<?> handler : COLUMN_HANDLERS) {\n            if (handler.match(propType)) {\n                retval = handler.apply(resultSet, index);\n                break;\n            }\n        }\n\n        return retval;\n\n    }\n\n    /**\n     * Returns a PropertyDescriptor[] for the given Class.\n     *\n     * @param c The Class to retrieve PropertyDescriptors for.\n     * @return A PropertyDescriptor[] describing the Class.\n     * @throws SQLException if introspection failed.\n     */\n    private PropertyDescriptor[] propertyDescriptors(final Class<?> c)\n        throws SQLException {\n        // Introspector caches BeanInfo classes for better performance\n        BeanInfo beanInfo = null;\n        try {\n            beanInfo = Introspector.getBeanInfo(c);\n\n        } catch (final IntrospectionException e) {\n            throw new SQLException(\n                \"Bean introspection failed: \" + e.getMessage());\n        }\n\n        return beanInfo.getPropertyDescriptors();\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into a JavaBean.  This\n     * implementation uses reflection and {@code BeanInfo} classes to\n     * match column names to bean property names.  Properties are matched to\n     * columns based on several factors:\n     * &lt;br/&gt;\n     * &lt;ol&gt;\n     *     &lt;li&gt;\n     *     The class has a writable property with the same name as a column.\n     *     The name comparison is case insensitive.\n     *     &lt;/li&gt;\n     *\n     *     &lt;li&gt;\n     *     The column type can be converted to the property's set method\n     *     parameter type with a ResultSet.get* method.  If the conversion fails\n     *     (ie. the property was an int and the column was a Timestamp) an\n     *     SQLException is thrown.\n     *     &lt;/li&gt;\n     * &lt;/ol&gt;\n     *\n     * &lt;p&gt;\n     * Primitive bean properties are set to their defaults when SQL NULL is\n     * returned from the {@code ResultSet}.  Numeric fields are set to 0\n     * and booleans are set to false.  Object bean properties are set to\n     * {@code null} when SQL NULL is returned.  This is the same behavior\n     * as the {@code ResultSet} get* methods.\n     * &lt;/p&gt;\n     * @param <T> The type of bean to create\n     * @param rs ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return the newly created bean\n     */\n    public <T> T toBean(final ResultSet rs, final Class<? extends T> type) throws SQLException {\n        final T bean = this.newInstance(type);\n        return this.populateBean(rs, bean);\n    }\n\n    /**\n     * Convert a {@code ResultSet} into a {@code List} of JavaBeans.\n     * This implementation uses reflection and {@code BeanInfo} classes to\n     * match column names to bean property names. Properties are matched to\n     * columns based on several factors:\n     * &lt;br/&gt;\n     * &lt;ol&gt;\n     *     &lt;li&gt;\n     *     The class has a writable property with the same name as a column.\n     *     The name comparison is case insensitive.\n     *     &lt;/li&gt;\n     *\n     *     &lt;li&gt;\n     *     The column type can be converted to the property's set method\n     *     parameter type with a ResultSet.get* method.  If the conversion fails\n     *     (ie. the property was an int and the column was a Timestamp) an\n     *     SQLException is thrown.\n     *     &lt;/li&gt;\n     * &lt;/ol&gt;\n     *\n     * <p>\n     * Primitive bean properties are set to their defaults when SQL NULL is\n     * returned from the {@code ResultSet}.  Numeric fields are set to 0\n     * and booleans are set to false.  Object bean properties are set to\n     * {@code null} when SQL NULL is returned.  This is the same behavior\n     * as the {@code ResultSet} get* methods.\n     * &lt;/p&gt;\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return the newly created List of beans\n     */\n    public <T> List<T> toBeanList(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        final List<T> results = new ArrayList<>();\n        if (!resultSet.next()) {\n            return results;\n        }\n        final PropertyDescriptor[] props = propertyDescriptors(type);\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int[] columnToProperty = mapColumnsToProperties(rsmd, props);\n        do {\n            results.add(this.createBean(resultSet, type, props, columnToProperty));\n        } while (resultSet.next()); // NOPMD False positive CheckResultSet\n        return results;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final int PROPERTY_NOT_FOUND = -1;", "docstring": "\nSpecial array value used by {@code mapColumnsToProperties} that\nindicates there is no bean property that matches a column from a\n{@code ResultSet}.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "PROPERTY_NOT_FOUND = -1", "syntax_pass": true}, {"attribute_expression": "private static final Map<Class<?>, Object> PRIMITIVE_DEFAULTS = new HashMap<>();", "docstring": "\nSet a bean's primitive properties to these defaults when SQL NULL\nis returned.  These are the same as the defaults that ResultSet get*\nmethods return in the event of a NULL column.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Map<Class<?>, Object>", "name": "PRIMITIVE_DEFAULTS = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private static final List<ColumnHandler<?>> COLUMN_HANDLERS = new ArrayList<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<ColumnHandler<?>>", "name": "COLUMN_HANDLERS = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private static final List<PropertyHandler> PROPERTY_HANDLERS = new ArrayList<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<PropertyHandler>", "name": "PROPERTY_HANDLERS = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, String> columnToPropertyOverrides;", "docstring": "\nResultSet column to bean property name overrides.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, String>", "name": "columnToPropertyOverrides", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/OutParameter.java.OutParameter", "name": "OutParameter", "file_path": "src/main/java/org/apache/commons/dbutils/OutParameter.java", "superclasses": "", "methods": ["[]OutParameter(int,Class<T>)", "[]OutParameter(int,Class<T>,T)", "[Class<T>]getJavaType()", "[int]getSqlType()", "[T]getValue()", "[void]register(CallableStatement,int)", "[void]setValue(CallableStatement,int)", "[void]setValue(T)", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/dbutils/OutParameter.java.OutParameter.[]OutParameter(int,Class<T>)", "src/main/java/org/apache/commons/dbutils/OutParameter.java.OutParameter.[]OutParameter(int,Class<T>,T)", "src/main/java/org/apache/commons/dbutils/OutParameter.java.OutParameter.[Class<T>]getJavaType()", "src/main/java/org/apache/commons/dbutils/OutParameter.java.OutParameter.[int]getSqlType()", "src/main/java/org/apache/commons/dbutils/OutParameter.java.OutParameter.[T]getValue()", "src/main/java/org/apache/commons/dbutils/OutParameter.java.OutParameter.[void]register(CallableStatement,int)", "src/main/java/org/apache/commons/dbutils/OutParameter.java.OutParameter.[void]setValue(CallableStatement,int)", "src/main/java/org/apache/commons/dbutils/OutParameter.java.OutParameter.[void]setValue(T)", "src/main/java/org/apache/commons/dbutils/OutParameter.java.OutParameter.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents an OUT parameter for a stored procedure.  When running a stored\nprocedure with {@link QueryRunner}, pass an instance of\n{@code OutParameter} to indicate that the parameter at that index is an\nOUT parameter.  The value of the parameter may be obtained from the\n{@code OutParameter} instance via {@link #getValue() }.\n<p>\nINOUT parameters are also supported by setting the {@code value} of\nthe {@code OutParameter} instance before invoking the stored procedure.\n\n@param <T> the class of the parameter; should be compatible via cast with the\nclass returned by the {@code CallableStatement.getObject(int)} method.\n", "original_string": "public class OutParameter<T> {\n    private final int sqlType;\n    private final Class<T> javaType;\n    private T value;\n\n    /**\n     * Constructs an {@code OutParameter} for the given JDBC SQL type and\n     * Java type.\n     * @param sqlType the JDBC SQL type of the parameter as in\n     * {@link java.sql.Types}.\n     * @param javaType the Java class of the parameter value, cast compatible\n     * with the type returned by {@code CallableStatement.getObject(int)}\n     * for the JDBC type given by {@code sqlType}.\n     */\n    public OutParameter(final int sqlType, final Class<T> javaType) {\n        this.sqlType = sqlType;\n        this.javaType = javaType;\n    }\n\n    /**\n     * Constructs an {@code OutParameter} for the given JDBC SQL type and\n     * Java type and with the given value.  The parameter will be treated as an\n     * INOUT parameter if the value is null.\n     * @param sqlType the JDBC SQL type of the parameter as in\n     * {@link java.sql.Types}.\n     * @param javaType the Java class of the parameter value, cast compatible\n     * with the type returned by {@code CallableStatement.getObject(int)}\n     * for the JDBC type given by {@code sqlType}.\n     * @param value the IN value of the parameter\n     */\n    public OutParameter(final int sqlType, final Class<T> javaType, final T value) {\n        this.sqlType = sqlType;\n        this.javaType = javaType;\n        this.value = value;\n    }\n\n    /**\n     * Gets the Java class for this OUT parameter.\n     * @return the Java class for this OUT parameter.\n     */\n    public Class<T> getJavaType() {\n        return javaType;\n    }\n\n    /**\n     * Gets the JDBC SQL type for this OUT parameter.\n     * @return the JDBC SQL type for this OUT parameter.\n     */\n    public int getSqlType() {\n        return sqlType;\n    }\n\n    /**\n     * Gets the value of the OUT parameter.  After the stored procedure has\n     * been executed, the value is the value returned via this parameter.\n     * @return the value of the OUT parameter.\n     */\n    public T getValue() {\n        return value;\n    }\n\n    /**\n     * Set up the given statement by registering an OUT parameter at the given\n     * index using the {@code sqlType} and {@code value} of this\n     * {@code OutParameter}.  If the value is not null, the parameter is\n     * treated like an INOUT parameter and the value is set on the statement.\n     * @param stmt the statement the parameter should register on.\n     * @param index the (1-based) index of the parameter.\n     * @throws SQLException if the parameter could not be registered, or if the\n     * value of the parameter could not be set.\n     */\n    void register(final CallableStatement stmt, final int index) throws SQLException {\n        stmt.registerOutParameter(index, sqlType);\n        if (value != null) {\n            stmt.setObject(index, value);\n        }\n    }\n\n    /**\n     * Set the value using the return value of the parameter an the given index\n     * from the given {@code CallableStatement}.\n     * @param stmt the already executed statement\n     * @param index the (1-based) index of the parameter\n     * @throws SQLException when the value could not be retrieved from the\n     * statement.\n     */\n    void setValue(final CallableStatement stmt, final int index) throws SQLException {\n        value = javaType.cast(stmt.getObject(index));\n    }\n\n    /**\n     * Set the value of the OUT parameter.  If the value is not null when the\n     * stored procedure is executed, then the parameter will be treated like an\n     * INOUT parameter.\n     * @param value the new value for the parameter.\n     */\n    public void setValue(final T value) {\n        this.value = value;\n    }\n\n    @Override\n    public String toString() {\n        return \"OutParameter{\" + \"sqlType=\" + sqlType + \", javaType=\"\n            + javaType + \", value=\" + value + '}';\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final int sqlType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "sqlType", "syntax_pass": true}, {"attribute_expression": "private final Class<T> javaType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<T>", "name": "javaType", "syntax_pass": true}, {"attribute_expression": "private T value;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "T", "name": "value", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/MapHandler.java.MapHandler", "name": "MapHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/MapHandler.java", "superclasses": "", "methods": ["[]MapHandler()", "[]MapHandler(RowProcessor)", "[Map<String, Object>]handle(ResultSet)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/MapHandler.java.MapHandler.[]MapHandler()", "src/main/java/org/apache/commons/dbutils/handlers/MapHandler.java.MapHandler.[]MapHandler(RowProcessor)", "src/main/java/org/apache/commons/dbutils/handlers/MapHandler.java.MapHandler.[Map<String, Object>]handle(ResultSet)"], "overrides": null, "attributes": [], "class_docstring": "\n{@code ResultSetHandler} implementation that converts the first\n{@code ResultSet} row into a {@code Map}. This class is thread\nsafe.\n\n@see org.apache.commons.dbutils.ResultSetHandler\n", "original_string": "public class MapHandler implements ResultSetHandler<Map<String, Object>> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Maps.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of MapHandler using a\n     * {@code BasicRowProcessor} for conversion.\n     */\n    public MapHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of MapHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps.\n     */\n    public MapHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Converts the first row in the {@code ResultSet} into a\n     * {@code Map}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return A {@code Map} with the values from the first row or\n     * {@code null} if there are no rows in the {@code ResultSet}.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    @Override\n    public Map<String, Object> handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toMap(resultSet) : null;\n    }\n\n}", "super_interfaces": ["ResultSetHandler<Map<String, Object>>"], "fields": [{"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto Maps.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/BeanMapHandler.java.BeanMapHandler", "name": "BeanMapHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/BeanMapHandler.java", "superclasses": "", "methods": ["[]BeanMapHandler(Class<V>)", "[]BeanMapHandler(Class<V>,int)", "[]BeanMapHandler(Class<V>,RowProcessor)", "[]BeanMapHandler(Class<V>,RowProcessor,int,String)", "[]BeanMapHandler(Class<V>,String)", "[K]createKey(ResultSet)", "[V]createRow(ResultSet)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/BeanMapHandler.java.BeanMapHandler.[]BeanMapHandler(Class<V>)", "src/main/java/org/apache/commons/dbutils/handlers/BeanMapHandler.java.BeanMapHandler.[]BeanMapHandler(Class<V>,int)", "src/main/java/org/apache/commons/dbutils/handlers/BeanMapHandler.java.BeanMapHandler.[]BeanMapHandler(Class<V>,RowProcessor)", "src/main/java/org/apache/commons/dbutils/handlers/BeanMapHandler.java.BeanMapHandler.[]BeanMapHandler(Class<V>,RowProcessor,int,String)", "src/main/java/org/apache/commons/dbutils/handlers/BeanMapHandler.java.BeanMapHandler.[]BeanMapHandler(Class<V>,String)", "src/main/java/org/apache/commons/dbutils/handlers/BeanMapHandler.java.BeanMapHandler.[K]createKey(ResultSet)", "src/main/java/org/apache/commons/dbutils/handlers/BeanMapHandler.java.BeanMapHandler.[V]createRow(ResultSet)"], "overrides": null, "attributes": [], "class_docstring": "\n<p>\n{@code ResultSetHandler} implementation that returns a Map of Beans.\n{@code ResultSet} rows are converted into Beans which are then stored in\na Map under the given key.\n</p>\n<p>\nIf you had a Person table with a primary key column called ID, you could\nretrieve rows from the table like this:\n\n<pre>\nResultSetHandler&lt;Map&lt;Long, Person&gt;&gt; h = new BeanMapHandler&lt;Long, Person&gt;(Person.class, &quot;id&quot;);\nMap&lt;Long, Person&gt; found = queryRunner.query(&quot;select id, name, age from person&quot;, h);\nPerson jane = found.get(1L); // jane's id is 1\nString janesName = jane.getName();\nInteger janesAge = jane.getAge();\n</pre>\n\nNote that the \"id\" passed to BeanMapHandler can be in any case. The data type\nreturned for id is dependent upon how your JDBC driver converts SQL column\ntypes from the Person table into Java types. The \"name\" and \"age\" columns are\nconverted according to their property descriptors by DbUtils.\n&lt;/p&gt;\n<p>\nThis class is thread safe.\n&lt;/p&gt;\n\n@param <K>\n           the type of keys maintained by the returned map\n@param <V>\n           the type of the bean\n@see org.apache.commons.dbutils.ResultSetHandler\n@since 1.5\n", "original_string": "public class BeanMapHandler<K, V> extends AbstractKeyedHandler<K, V> {\n\n    /**\n     * The Class of beans produced by this handler.\n     */\n    private final Class<V> type;\n\n    /**\n     * The RowProcessor implementation to use when converting rows into Objects.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * The column index to retrieve key values from. Defaults to 1.\n     */\n    private final int columnIndex;\n\n    /**\n     * The column name to retrieve key values from. Either columnName or\n     * columnIndex will be used but never both.\n     */\n    private final String columnName;\n\n    /**\n     * Creates a new instance of BeanMapHandler. The value of the first column\n     * of each row will be a key in the Map.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     */\n    public BeanMapHandler(final Class<V> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR, 1, null);\n    }\n\n    /**\n     * Creates a new instance of BeanMapHandler.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     * @param columnIndex\n     *            The values to use as keys in the Map are retrieved from the\n     *            column at this index.\n     */\n    public BeanMapHandler(final Class<V> type, final int columnIndex) {\n        this(type, ArrayHandler.ROW_PROCESSOR, columnIndex, null);\n    }\n\n    /**\n     * Creates a new instance of BeanMapHandler. The value of the first column\n     * of each row will be a key in the Map.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     * @param convert\n     *            The {@code RowProcessor} implementation to use when\n     *            converting rows into Beans\n     */\n    public BeanMapHandler(final Class<V> type, final RowProcessor convert) {\n        this(type, convert, 1, null);\n    }\n\n    /**\n     * Private Helper\n     *\n     * @param convert\n     *            The {@code RowProcessor} implementation to use when\n     *            converting rows into Beans\n     * @param columnIndex\n     *            The values to use as keys in the Map are retrieved from the\n     *            column at this index.\n     * @param columnName\n     *            The values to use as keys in the Map are retrieved from the\n     *            column with this name.\n     */\n    private BeanMapHandler(final Class<V> type, final RowProcessor convert,\n            final int columnIndex, final String columnName) {\n        this.type = type;\n        this.convert = convert;\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of BeanMapHandler.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     * @param columnName\n     *            The values to use as keys in the Map are retrieved from the\n     *            column with this name.\n     */\n    public BeanMapHandler(final Class<V> type, final String columnName) {\n        this(type, ArrayHandler.ROW_PROCESSOR, 1, columnName);\n    }\n\n    /**\n     * This factory method is called by {@code handle()} to retrieve the\n     * key value from the current {@code ResultSet} row.\n     * @param resultSet ResultSet to create a key from\n     *\n     * @return K from the configured key column name/index\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     *\n     * @see org.apache.commons.dbutils.handlers.AbstractKeyedHandler#createKey(ResultSet)\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected K createKey(final ResultSet resultSet) throws SQLException {\n        return columnName == null ?\n               (K) resultSet.getObject(columnIndex) :\n               (K) resultSet.getObject(columnName);\n    }\n\n    @Override\n    protected V createRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toBean(resultSet, type);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Class<V> type;", "docstring": "\nThe Class of beans produced by this handler.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<V>", "name": "type", "syntax_pass": true}, {"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows into Objects.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}, {"attribute_expression": "private final int columnIndex;", "docstring": "\nThe column index to retrieve key values from. Defaults to 1.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "columnIndex", "syntax_pass": true}, {"attribute_expression": "private final String columnName;", "docstring": "\nThe column name to retrieve key values from. Either columnName or\ncolumnIndex will be used but never both.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "columnName", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/ArrayHandler.java.ArrayHandler", "name": "ArrayHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/ArrayHandler.java", "superclasses": "", "methods": ["[]ArrayHandler()", "[]ArrayHandler(RowProcessor)", "[Object[]]handle(ResultSet)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/ArrayHandler.java.ArrayHandler.[]ArrayHandler()", "src/main/java/org/apache/commons/dbutils/handlers/ArrayHandler.java.ArrayHandler.[]ArrayHandler(RowProcessor)", "src/main/java/org/apache/commons/dbutils/handlers/ArrayHandler.java.ArrayHandler.[Object[]]handle(ResultSet)"], "overrides": null, "attributes": [], "class_docstring": "\n{@code ResultSetHandler} implementation that converts a\n{@code ResultSet} into an {@code Object[]}. This class is\nthread safe.\n\n@see org.apache.commons.dbutils.ResultSetHandler\n", "original_string": "public class ArrayHandler implements ResultSetHandler<Object[]> {\n\n    /**\n     * Singleton processor instance that handlers share to save memory.  Notice\n     * the default scoping to allow only classes in this package to use this\n     * instance.\n     */\n    static final RowProcessor ROW_PROCESSOR = new BasicRowProcessor();\n\n    /**\n     * An empty array to return when no more rows are available in the ResultSet.\n     */\n    private static final Object[] EMPTY_ARRAY = {};\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into arrays.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of ArrayHandler using a\n     * {@code BasicRowProcessor} for conversion.\n     */\n    public ArrayHandler() {\n        this(ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of ArrayHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into arrays.\n     */\n    public ArrayHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Places the column values from the first row in an {@code Object[]}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return An Object[]. If there are no rows in the {@code ResultSet}\n     * an empty array will be returned.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    @Override\n    public Object[] handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toArray(resultSet) : EMPTY_ARRAY;\n    }\n\n}", "super_interfaces": ["ResultSetHandler<Object[]>"], "fields": [{"attribute_expression": "static final RowProcessor ROW_PROCESSOR = new BasicRowProcessor();", "docstring": "\nSingleton processor instance that handlers share to save memory.  Notice\nthe default scoping to allow only classes in this package to use this\ninstance.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "RowProcessor", "name": "ROW_PROCESSOR = new BasicRowProcessor()", "syntax_pass": true}, {"attribute_expression": "private static final Object[] EMPTY_ARRAY = {};", "docstring": "\nAn empty array to return when no more rows are available in the ResultSet.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object[]", "name": "EMPTY_ARRAY = {}", "syntax_pass": true}, {"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto arrays.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/ColumnListHandler.java.ColumnListHandler", "name": "ColumnListHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/ColumnListHandler.java", "superclasses": "", "methods": ["[]ColumnListHandler()", "[]ColumnListHandler(int)", "[]ColumnListHandler(int,String)", "[]ColumnListHandler(String)", "[T]handleRow(ResultSet)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/ColumnListHandler.java.ColumnListHandler.[]ColumnListHandler()", "src/main/java/org/apache/commons/dbutils/handlers/ColumnListHandler.java.ColumnListHandler.[]ColumnListHandler(int)", "src/main/java/org/apache/commons/dbutils/handlers/ColumnListHandler.java.ColumnListHandler.[]ColumnListHandler(int,String)", "src/main/java/org/apache/commons/dbutils/handlers/ColumnListHandler.java.ColumnListHandler.[]ColumnListHandler(String)", "src/main/java/org/apache/commons/dbutils/handlers/ColumnListHandler.java.ColumnListHandler.[T]handleRow(ResultSet)"], "overrides": null, "attributes": [], "class_docstring": "\n{@code ResultSetHandler} implementation that converts one\n{@code ResultSet} column into a {@code List} of\n{@code Object}s. This class is thread safe.\n\n@param <T> The type of the column.\n@see org.apache.commons.dbutils.ResultSetHandler\n@since 1.1\n", "original_string": "public class ColumnListHandler<T> extends AbstractListHandler<T> {\n\n    /**\n     * The column number to retrieve.\n     */\n    private final int columnIndex;\n\n    /**\n     * The column name to retrieve.  Either columnName or columnIndex\n     * will be used but never both.\n     */\n    private final String columnName;\n\n    /**\n     * Creates a new instance of ColumnListHandler.  The first column of each\n     * row will be returned from {@code handle()}.\n     */\n    public ColumnListHandler() {\n        this(1, null);\n    }\n\n    /**\n     * Creates a new instance of ColumnListHandler.\n     *\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ColumnListHandler(final int columnIndex) {\n        this(columnIndex, null);\n    }\n\n    /** Private Helper\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    private ColumnListHandler(final int columnIndex, final String columnName) {\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of ColumnListHandler.\n     *\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ColumnListHandler(final String columnName) {\n        this(1, columnName);\n    }\n\n    /**\n     * Returns one {@code ResultSet} column value as {@code Object}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return {@code Object}, never {@code null}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     *\n     * @see org.apache.commons.dbutils.handlers.AbstractListHandler#handle(ResultSet)\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected T handleRow(final ResultSet resultSet) throws SQLException {\n        if (this.columnName == null) {\n            return (T) resultSet.getObject(this.columnIndex);\n        }\n        return (T) resultSet.getObject(this.columnName);\n   }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final int columnIndex;", "docstring": "\nThe column number to retrieve.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "columnIndex", "syntax_pass": true}, {"attribute_expression": "private final String columnName;", "docstring": "\nThe column name to retrieve.  Either columnName or columnIndex\nwill be used but never both.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "columnName", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/BeanListHandler.java.BeanListHandler", "name": "BeanListHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/BeanListHandler.java", "superclasses": "", "methods": ["[]BeanListHandler(Class<? extends T>)", "[]BeanListHandler(Class<? extends T>,RowProcessor)", "[List<T>]handle(ResultSet)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/BeanListHandler.java.BeanListHandler.[]BeanListHandler(Class<? extends T>)", "src/main/java/org/apache/commons/dbutils/handlers/BeanListHandler.java.BeanListHandler.[]BeanListHandler(Class<? extends T>,RowProcessor)", "src/main/java/org/apache/commons/dbutils/handlers/BeanListHandler.java.BeanListHandler.[List<T>]handle(ResultSet)"], "overrides": null, "attributes": [], "class_docstring": "\n{@code ResultSetHandler} implementation that converts a\n{@code ResultSet} into a {@code List} of beans. This class is\nthread safe.\n\n@param <T> the target bean type\n@see org.apache.commons.dbutils.ResultSetHandler\n", "original_string": "public class BeanListHandler<T> implements ResultSetHandler<List<T>> {\n\n    /**\n     * The Class of beans produced by this handler.\n     */\n    private final Class<? extends T> type;\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into beans.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of BeanListHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     */\n    public BeanListHandler(final Class<? extends T> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of BeanListHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into beans.\n     */\n    public BeanListHandler(final Class<? extends T> type, final RowProcessor convert) {\n        this.type = type;\n        this.convert = convert;\n    }\n\n    /**\n     * Convert the whole {@code ResultSet} into a List of beans with\n     * the {@code Class} given in the constructor.\n     *\n     * @param resultSet The {@code ResultSet} to handle.\n     *\n     * @return A List of beans, never {@code null}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.RowProcessor#toBeanList(ResultSet, Class)\n     */\n    @Override\n    public List<T> handle(final ResultSet resultSet) throws SQLException {\n        return this.convert.toBeanList(resultSet, type);\n    }\n}", "super_interfaces": ["ResultSetHandler<List<T>>"], "fields": [{"attribute_expression": "private final Class<? extends T> type;", "docstring": "\nThe Class of beans produced by this handler.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<? extends T>", "name": "type", "syntax_pass": true}, {"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto beans.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/KeyedHandler.java.KeyedHandler", "name": "KeyedHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/KeyedHandler.java", "superclasses": "", "methods": ["[]KeyedHandler()", "[]KeyedHandler(int)", "[]KeyedHandler(RowProcessor)", "[]KeyedHandler(RowProcessor,int,String)", "[]KeyedHandler(String)", "[K]createKey(ResultSet)", "[Map<String, Object>]createRow(ResultSet)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/KeyedHandler.java.KeyedHandler.[]KeyedHandler()", "src/main/java/org/apache/commons/dbutils/handlers/KeyedHandler.java.KeyedHandler.[]KeyedHandler(int)", "src/main/java/org/apache/commons/dbutils/handlers/KeyedHandler.java.KeyedHandler.[]KeyedHandler(RowProcessor)", "src/main/java/org/apache/commons/dbutils/handlers/KeyedHandler.java.KeyedHandler.[]KeyedHandler(RowProcessor,int,String)", "src/main/java/org/apache/commons/dbutils/handlers/KeyedHandler.java.KeyedHandler.[]KeyedHandler(String)", "src/main/java/org/apache/commons/dbutils/handlers/KeyedHandler.java.KeyedHandler.[K]createKey(ResultSet)", "src/main/java/org/apache/commons/dbutils/handlers/KeyedHandler.java.KeyedHandler.[Map<String, Object>]createRow(ResultSet)"], "overrides": null, "attributes": [], "class_docstring": "\n<p>\n{@code ResultSetHandler} implementation that returns a Map of Maps.\n{@code ResultSet} rows are converted into Maps which are then stored\nin a Map under the given key.\n</p>\n<p>\nIf you had a Person table with a primary key column called ID, you could\nretrieve rows from the table like this:\n<pre>\nResultSetHandler h = new KeyedHandler(\"id\");\nMap found = (Map) queryRunner.query(\"select id, name, age from person\", h);\nMap jane = (Map) found.get(new Long(1)); // jane's id is 1\nString janesName = (String) jane.get(\"name\");\nInteger janesAge = (Integer) jane.get(\"age\");\n</pre>\nNote that the \"id\" passed to KeyedHandler and \"name\" and \"age\" passed to the\nreturned Map's get() method can be in any case.  The data types returned for\nname and age are dependent upon how your JDBC driver converts SQL column\ntypes from the Person table into Java types.\n&lt;/p&gt;\n<p>This class is thread safe.</p>\n\n@param <K> The type of the key\n@see org.apache.commons.dbutils.ResultSetHandler\n@since 1.1\n", "original_string": "public class KeyedHandler<K> extends AbstractKeyedHandler<K, Map<String, Object>> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Objects.\n     */\n    protected final RowProcessor convert;\n\n    /**\n     * The column index to retrieve key values from.  Defaults to 1.\n     */\n    protected final int columnIndex;\n\n    /**\n     * The column name to retrieve key values from.  Either columnName or\n     * columnIndex will be used but never both.\n     */\n    protected final String columnName;\n\n    /**\n     * Creates a new instance of KeyedHandler.  The value of the first column\n     * of each row will be a key in the Map.\n     */\n    public KeyedHandler() {\n        this(ArrayHandler.ROW_PROCESSOR, 1, null);\n    }\n\n    /**\n     * Creates a new instance of KeyedHandler.\n     *\n     * @param columnIndex The values to use as keys in the Map are\n     * retrieved from the column at this index.\n     */\n    public KeyedHandler(final int columnIndex) {\n        this(ArrayHandler.ROW_PROCESSOR, columnIndex, null);\n    }\n\n    /**\n     * Creates a new instance of KeyedHandler.  The value of the first column\n     * of each row will be a key in the Map.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps\n     */\n    public KeyedHandler(final RowProcessor convert) {\n        this(convert, 1, null);\n    }\n\n    /** Private Helper\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps\n     * @param columnIndex The values to use as keys in the Map are\n     * retrieved from the column at this index.\n     * @param columnName The values to use as keys in the Map are\n     * retrieved from the column with this name.\n     */\n    private KeyedHandler(final RowProcessor convert, final int columnIndex,\n            final String columnName) {\n        this.convert = convert;\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of KeyedHandler.\n     *\n     * @param columnName The values to use as keys in the Map are\n     * retrieved from the column with this name.\n     */\n    public KeyedHandler(final String columnName) {\n        this(ArrayHandler.ROW_PROCESSOR, 1, columnName);\n    }\n    /**\n     * This factory method is called by {@code handle()} to retrieve the\n     * key value from the current {@code ResultSet} row.  This\n     * implementation returns {@code ResultSet.getObject()} for the\n     * configured key column name or index.\n     * @param rs ResultSet to create a key from\n     * @return Object from the configured key column name/index\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected K createKey(final ResultSet rs) throws SQLException {\n        return columnName == null ?\n               (K) rs.getObject(columnIndex) :\n               (K) rs.getObject(columnName);\n    }\n\n    /**\n     * This factory method is called by {@code handle()} to store the\n     * current {@code ResultSet} row in some object. This\n     * implementation returns a {@code Map} with case insensitive column\n     * names as keys.  Calls to {@code map.get(\"COL\")} and\n     * {@code map.get(\"col\")} return the same value.\n     * @param resultSet ResultSet to create a row from\n     * @return Object typed Map containing column names to values\n     * @throws SQLException if a database access error occurs\n     */\n    @Override\n    protected Map<String, Object> createRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toMap(resultSet);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto Objects.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}, {"attribute_expression": "protected final int columnIndex;", "docstring": "\nThe column index to retrieve key values from.  Defaults to 1.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "int", "name": "columnIndex", "syntax_pass": true}, {"attribute_expression": "protected final String columnName;", "docstring": "\nThe column name to retrieve key values from.  Either columnName or\ncolumnIndex will be used but never both.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "String", "name": "columnName", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/ArrayListHandler.java.ArrayListHandler", "name": "ArrayListHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/ArrayListHandler.java", "superclasses": "", "methods": ["[]ArrayListHandler()", "[]ArrayListHandler(RowProcessor)", "[Object[]]handleRow(ResultSet)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/ArrayListHandler.java.ArrayListHandler.[]ArrayListHandler()", "src/main/java/org/apache/commons/dbutils/handlers/ArrayListHandler.java.ArrayListHandler.[]ArrayListHandler(RowProcessor)", "src/main/java/org/apache/commons/dbutils/handlers/ArrayListHandler.java.ArrayListHandler.[Object[]]handleRow(ResultSet)"], "overrides": null, "attributes": [], "class_docstring": "\n{@code ResultSetHandler} implementation that converts the\n{@code ResultSet} into a {@code List} of {@code Object[]}s.\nThis class is thread safe.\n\n@see org.apache.commons.dbutils.ResultSetHandler\n", "original_string": "public class ArrayListHandler extends AbstractListHandler<Object[]> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Object[]s.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of ArrayListHandler using a\n     * {@code BasicRowProcessor} for conversions.\n     */\n    public ArrayListHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of ArrayListHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Object[]s.\n     */\n    public ArrayListHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Convert row's columns into an {@code Object[]}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return {@code Object[]}, never {@code null}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.handlers.AbstractListHandler#handle(ResultSet)\n     */\n    @Override\n    protected Object[] handleRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toArray(resultSet);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto Object[]s.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/MapListHandler.java.MapListHandler", "name": "MapListHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/MapListHandler.java", "superclasses": "", "methods": ["[]MapListHandler()", "[]MapListHandler(RowProcessor)", "[Map<String, Object>]handleRow(ResultSet)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/MapListHandler.java.MapListHandler.[]MapListHandler()", "src/main/java/org/apache/commons/dbutils/handlers/MapListHandler.java.MapListHandler.[]MapListHandler(RowProcessor)", "src/main/java/org/apache/commons/dbutils/handlers/MapListHandler.java.MapListHandler.[Map<String, Object>]handleRow(ResultSet)"], "overrides": null, "attributes": [], "class_docstring": "\n{@code ResultSetHandler} implementation that converts a\n{@code ResultSet} into a {@code List} of {@code Map}s.\nThis class is thread safe.\n\n@see org.apache.commons.dbutils.ResultSetHandler\n", "original_string": "public class MapListHandler extends AbstractListHandler<Map<String, Object>> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Maps.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of MapListHandler using a\n     * {@code BasicRowProcessor} for conversion.\n     */\n    public MapListHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of MapListHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps.\n     */\n    public MapListHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Converts the {@code ResultSet} row into a {@code Map} object.\n     * @param resultSet {@code ResultSet} to process.\n     * @return A {@code Map}, never null.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @see org.apache.commons.dbutils.handlers.AbstractListHandler#handle(ResultSet)\n     */\n    @Override\n    protected Map<String, Object> handleRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toMap(resultSet);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto Maps.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/BeanHandler.java.BeanHandler", "name": "BeanHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/BeanHandler.java", "superclasses": "", "methods": ["[]BeanHandler(Class<? extends T>)", "[]BeanHandler(Class<? extends T>,RowProcessor)", "[T]handle(ResultSet)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/BeanHandler.java.BeanHandler.[]BeanHandler(Class<? extends T>)", "src/main/java/org/apache/commons/dbutils/handlers/BeanHandler.java.BeanHandler.[]BeanHandler(Class<? extends T>,RowProcessor)", "src/main/java/org/apache/commons/dbutils/handlers/BeanHandler.java.BeanHandler.[T]handle(ResultSet)"], "overrides": null, "attributes": [], "class_docstring": "\n{@code ResultSetHandler} implementation that converts the first\n{@code ResultSet} row into a JavaBean. This class is thread safe.\n\n@param <T> the target bean type\n@see org.apache.commons.dbutils.ResultSetHandler\n", "original_string": "public class BeanHandler<T> implements ResultSetHandler<T> {\n\n    /**\n     * The Class of beans produced by this handler.\n     */\n    private final Class<? extends T> type;\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into beans.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of BeanHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     */\n    public BeanHandler(final Class<? extends T> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of BeanHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into beans.\n     */\n    public BeanHandler(final Class<? extends T> type, final RowProcessor convert) {\n        this.type = type;\n        this.convert = convert;\n    }\n\n    /**\n     * Convert the first row of the {@code ResultSet} into a bean with the\n     * {@code Class} given in the constructor.\n     * @param resultSet {@code ResultSet} to process.\n     * @return An initialized JavaBean or {@code null} if there were no\n     * rows in the {@code ResultSet}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    @Override\n    public T handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toBean(resultSet, this.type) : null;\n    }\n\n}", "super_interfaces": ["ResultSetHandler<T>"], "fields": [{"attribute_expression": "private final Class<? extends T> type;", "docstring": "\nThe Class of beans produced by this handler.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<? extends T>", "name": "type", "syntax_pass": true}, {"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto beans.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/ScalarHandler.java.ScalarHandler", "name": "ScalarHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/ScalarHandler.java", "superclasses": "", "methods": ["[]ScalarHandler()", "[]ScalarHandler(int)", "[]ScalarHandler(int,String)", "[]ScalarHandler(String)", "[T]handle(ResultSet)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/ScalarHandler.java.ScalarHandler.[]ScalarHandler()", "src/main/java/org/apache/commons/dbutils/handlers/ScalarHandler.java.ScalarHandler.[]ScalarHandler(int)", "src/main/java/org/apache/commons/dbutils/handlers/ScalarHandler.java.ScalarHandler.[]ScalarHandler(int,String)", "src/main/java/org/apache/commons/dbutils/handlers/ScalarHandler.java.ScalarHandler.[]ScalarHandler(String)", "src/main/java/org/apache/commons/dbutils/handlers/ScalarHandler.java.ScalarHandler.[T]handle(ResultSet)"], "overrides": null, "attributes": [], "class_docstring": "\n{@code ResultSetHandler} implementation that converts one\n{@code ResultSet} column into an Object. This class is thread safe.\n\n@param <T> The type of the scalar\n@see org.apache.commons.dbutils.ResultSetHandler\n", "original_string": "public class ScalarHandler<T> implements ResultSetHandler<T> {\n\n    /**\n     * The column number to retrieve.\n     */\n    private final int columnIndex;\n\n    /**\n     * The column name to retrieve.  Either columnName or columnIndex\n     * will be used but never both.\n     */\n    private final String columnName;\n\n    /**\n     * Creates a new instance of ScalarHandler.  The first column will\n     * be returned from {@code handle()}.\n     */\n    public ScalarHandler() {\n        this(1, null);\n    }\n\n    /**\n     * Creates a new instance of ScalarHandler.\n     *\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ScalarHandler(final int columnIndex) {\n        this(columnIndex, null);\n    }\n\n    /** Helper constructor\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    private ScalarHandler(final int columnIndex, final String columnName) {\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of ScalarHandler.\n     *\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ScalarHandler(final String columnName) {\n        this(1, columnName);\n    }\n\n    /**\n     * Returns one {@code ResultSet} column as an object via the\n     * {@code ResultSet.getObject()} method that performs type\n     * conversions.\n     * @param resultSet {@code ResultSet} to process.\n     * @return The column or {@code null} if there are no rows in\n     * the {@code ResultSet}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     *\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T handle(final ResultSet resultSet) throws SQLException {\n\n        if (resultSet.next()) {\n            if (this.columnName == null) {\n                return (T) resultSet.getObject(this.columnIndex);\n            }\n            return (T) resultSet.getObject(this.columnName);\n        }\n        return null;\n    }\n}", "super_interfaces": ["ResultSetHandler<T>"], "fields": [{"attribute_expression": "private final int columnIndex;", "docstring": "\nThe column number to retrieve.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "columnIndex", "syntax_pass": true}, {"attribute_expression": "private final String columnName;", "docstring": "\nThe column name to retrieve.  Either columnName or columnIndex\nwill be used but never both.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "columnName", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/columns/DoubleColumnHandler.java.DoubleColumnHandler", "name": "DoubleColumnHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/DoubleColumnHandler.java", "superclasses": "", "methods": ["[Double]apply(ResultSet,int)", "[boolean]match(Class<?>)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/columns/DoubleColumnHandler.java.DoubleColumnHandler.[Double]apply(ResultSet,int)", "src/main/java/org/apache/commons/dbutils/handlers/columns/DoubleColumnHandler.java.DoubleColumnHandler.[boolean]match(Class<?>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DoubleColumnHandler implements ColumnHandler<Double> {\n\n    @Override\n    public Double apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Double.valueOf(resultSet.getDouble(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Double.TYPE) || propType.equals(Double.class);\n    }\n}", "super_interfaces": ["ColumnHandler<Double>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/columns/StringColumnHandler.java.StringColumnHandler", "name": "StringColumnHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/StringColumnHandler.java", "superclasses": "", "methods": ["[String]apply(ResultSet,int)", "[boolean]match(Class<?>)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/columns/StringColumnHandler.java.StringColumnHandler.[String]apply(ResultSet,int)", "src/main/java/org/apache/commons/dbutils/handlers/columns/StringColumnHandler.java.StringColumnHandler.[boolean]match(Class<?>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class StringColumnHandler implements ColumnHandler<String> {\n\n    @Override\n    public String apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getString(columnIndex);\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(String.class);\n    }\n}", "super_interfaces": ["ColumnHandler<String>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/columns/ByteColumnHandler.java.ByteColumnHandler", "name": "ByteColumnHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/ByteColumnHandler.java", "superclasses": "", "methods": ["[Byte]apply(ResultSet,int)", "[boolean]match(Class<?>)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/columns/ByteColumnHandler.java.ByteColumnHandler.[Byte]apply(ResultSet,int)", "src/main/java/org/apache/commons/dbutils/handlers/columns/ByteColumnHandler.java.ByteColumnHandler.[boolean]match(Class<?>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ByteColumnHandler implements ColumnHandler<Byte> {\n\n    @Override\n    public Byte apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Byte.valueOf(resultSet.getByte(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Byte.TYPE) || propType.equals(Byte.class);\n    }\n}", "super_interfaces": ["ColumnHandler<Byte>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/columns/TimestampColumnHandler.java.TimestampColumnHandler", "name": "TimestampColumnHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/TimestampColumnHandler.java", "superclasses": "", "methods": ["[Timestamp]apply(ResultSet,int)", "[boolean]match(Class<?>)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/columns/TimestampColumnHandler.java.TimestampColumnHandler.[Timestamp]apply(ResultSet,int)", "src/main/java/org/apache/commons/dbutils/handlers/columns/TimestampColumnHandler.java.TimestampColumnHandler.[boolean]match(Class<?>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TimestampColumnHandler implements ColumnHandler<Timestamp> {\n\n    @Override\n    public Timestamp apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getTimestamp(columnIndex);\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Timestamp.class);\n    }\n}", "super_interfaces": ["ColumnHandler<Timestamp>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/columns/SQLXMLColumnHandler.java.SQLXMLColumnHandler", "name": "SQLXMLColumnHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/SQLXMLColumnHandler.java", "superclasses": "", "methods": ["[SQLXML]apply(ResultSet,int)", "[boolean]match(Class<?>)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/columns/SQLXMLColumnHandler.java.SQLXMLColumnHandler.[SQLXML]apply(ResultSet,int)", "src/main/java/org/apache/commons/dbutils/handlers/columns/SQLXMLColumnHandler.java.SQLXMLColumnHandler.[boolean]match(Class<?>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SQLXMLColumnHandler implements ColumnHandler<SQLXML> {\n\n    @Override\n    public SQLXML apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getSQLXML(columnIndex);\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(SQLXML.class);\n    }\n}", "super_interfaces": ["ColumnHandler<SQLXML>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/columns/BooleanColumnHandler.java.BooleanColumnHandler", "name": "BooleanColumnHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/BooleanColumnHandler.java", "superclasses": "", "methods": ["[Boolean]apply(ResultSet,int)", "[boolean]match(Class<?>)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/columns/BooleanColumnHandler.java.BooleanColumnHandler.[Boolean]apply(ResultSet,int)", "src/main/java/org/apache/commons/dbutils/handlers/columns/BooleanColumnHandler.java.BooleanColumnHandler.[boolean]match(Class<?>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BooleanColumnHandler implements ColumnHandler<Boolean> {\n\n    @Override\n    public Boolean apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Boolean.valueOf(resultSet.getBoolean(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Boolean.TYPE) || propType.equals(Boolean.class);\n    }\n}", "super_interfaces": ["ColumnHandler<Boolean>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/columns/ShortColumnHandler.java.ShortColumnHandler", "name": "ShortColumnHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/ShortColumnHandler.java", "superclasses": "", "methods": ["[Short]apply(ResultSet,int)", "[boolean]match(Class<?>)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/columns/ShortColumnHandler.java.ShortColumnHandler.[Short]apply(ResultSet,int)", "src/main/java/org/apache/commons/dbutils/handlers/columns/ShortColumnHandler.java.ShortColumnHandler.[boolean]match(Class<?>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ShortColumnHandler implements ColumnHandler<Short> {\n\n    @Override\n    public Short apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Short.valueOf(resultSet.getShort(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Short.TYPE) || propType.equals(Short.class);\n    }\n}", "super_interfaces": ["ColumnHandler<Short>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/columns/FloatColumnHandler.java.FloatColumnHandler", "name": "FloatColumnHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/FloatColumnHandler.java", "superclasses": "", "methods": ["[Float]apply(ResultSet,int)", "[boolean]match(Class<?>)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/columns/FloatColumnHandler.java.FloatColumnHandler.[Float]apply(ResultSet,int)", "src/main/java/org/apache/commons/dbutils/handlers/columns/FloatColumnHandler.java.FloatColumnHandler.[boolean]match(Class<?>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FloatColumnHandler implements ColumnHandler<Float> {\n\n    @Override\n    public Float apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Float.valueOf(resultSet.getFloat(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Float.TYPE) || propType.equals(Float.class);\n    }\n}", "super_interfaces": ["ColumnHandler<Float>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/columns/LongColumnHandler.java.LongColumnHandler", "name": "LongColumnHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/LongColumnHandler.java", "superclasses": "", "methods": ["[Long]apply(ResultSet,int)", "[boolean]match(Class<?>)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/columns/LongColumnHandler.java.LongColumnHandler.[Long]apply(ResultSet,int)", "src/main/java/org/apache/commons/dbutils/handlers/columns/LongColumnHandler.java.LongColumnHandler.[boolean]match(Class<?>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LongColumnHandler implements ColumnHandler<Long> {\n\n    @Override\n    public Long apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Long.valueOf(resultSet.getLong(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Long.TYPE) || propType.equals(Long.class);\n    }\n}", "super_interfaces": ["ColumnHandler<Long>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/columns/IntegerColumnHandler.java.IntegerColumnHandler", "name": "IntegerColumnHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/IntegerColumnHandler.java", "superclasses": "", "methods": ["[Integer]apply(ResultSet,int)", "[boolean]match(Class<?>)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/columns/IntegerColumnHandler.java.IntegerColumnHandler.[Integer]apply(ResultSet,int)", "src/main/java/org/apache/commons/dbutils/handlers/columns/IntegerColumnHandler.java.IntegerColumnHandler.[boolean]match(Class<?>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IntegerColumnHandler implements ColumnHandler<Integer> {\n\n    @Override\n    public Integer apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Integer.valueOf(resultSet.getInt(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Integer.TYPE) || propType.equals(Integer.class);\n    }\n}", "super_interfaces": ["ColumnHandler<Integer>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandler.java.DatePropertyHandler", "name": "DatePropertyHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandler.java", "superclasses": "", "methods": ["[Object]apply(Class<?>,Object)", "[boolean]match(Class<?>,Object)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandler.java.DatePropertyHandler.[Object]apply(Class<?>,Object)", "src/main/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandler.java.DatePropertyHandler.[boolean]match(Class<?>,Object)"], "overrides": null, "attributes": [], "class_docstring": "\n{@link PropertyHandler} for date fields. Will convert {@link java.sql.Date}, {@link java.sql.Time}, and {@link java.sql.Timestamp} from SQL types to Java\ntypes.\n", "original_string": "public class DatePropertyHandler implements PropertyHandler {\n\n    private static final String JAVA_SQL_TIMESTAMP = \"java.sql.Timestamp\";\n    private static final String JAVA_SQL_TIME = \"java.sql.Time\";\n    private static final String JAVA_SQL_DATE = \"java.sql.Date\";\n\n    @Override\n    public Object apply(final Class<?> parameter, Object value) {\n        final String targetType = parameter.getName();\n        final Date dateValue = (Date) value;\n        final long time = dateValue.getTime();\n\n        switch (targetType) {\n        case JAVA_SQL_DATE:\n            value = new java.sql.Date(time);\n            break;\n        case JAVA_SQL_TIME:\n            value = new java.sql.Time(time);\n            break;\n        case JAVA_SQL_TIMESTAMP:\n            value = new Timestamp(time);\n            break;\n        default:\n            break;\n        }\n\n        return value;\n    }\n\n    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        if (value instanceof Date) {\n            final String targetType = parameter.getName();\n            if (JAVA_SQL_DATE.equals(targetType)) {\n                return true;\n            }\n            if (JAVA_SQL_TIME.equals(targetType)) {\n                return true;\n            }\n            if (JAVA_SQL_TIMESTAMP.equals(targetType) && !Timestamp.class.isInstance(value)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}", "super_interfaces": ["PropertyHandler"], "fields": [{"attribute_expression": "private static final String JAVA_SQL_TIMESTAMP = \"java.sql.Timestamp\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "JAVA_SQL_TIMESTAMP = \"java.sql.Timestamp\"", "syntax_pass": true}, {"attribute_expression": "private static final String JAVA_SQL_TIME = \"java.sql.Time\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "JAVA_SQL_TIME = \"java.sql.Time\"", "syntax_pass": true}, {"attribute_expression": "private static final String JAVA_SQL_DATE = \"java.sql.Date\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "JAVA_SQL_DATE = \"java.sql.Date\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/handlers/properties/StringEnumPropertyHandler.java.StringEnumPropertyHandler", "name": "StringEnumPropertyHandler", "file_path": "src/main/java/org/apache/commons/dbutils/handlers/properties/StringEnumPropertyHandler.java", "superclasses": "", "methods": ["[Object]apply(Class<?>,Object)", "[boolean]match(Class<?>,Object)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/handlers/properties/StringEnumPropertyHandler.java.StringEnumPropertyHandler.[Object]apply(Class<?>,Object)", "src/main/java/org/apache/commons/dbutils/handlers/properties/StringEnumPropertyHandler.java.StringEnumPropertyHandler.[boolean]match(Class<?>,Object)"], "overrides": null, "attributes": [], "class_docstring": "\n{@link PropertyHandler} for enums. Will convert strings to enums.\n", "original_string": "public class StringEnumPropertyHandler implements PropertyHandler {\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Object apply(final Class<?> parameter, final Object value) {\n        return Enum.valueOf(parameter.asSubclass(Enum.class), (String) value);\n    }\n\n    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        return value instanceof String && parameter.isEnum();\n    }\n}", "super_interfaces": ["PropertyHandler"], "fields": []}, {"uris": "src/main/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSet.java.StringTrimmedResultSet", "name": "StringTrimmedResultSet", "file_path": "src/main/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSet.java", "superclasses": "", "methods": ["[ResultSet]wrap(ResultSet)", "[]StringTrimmedResultSet(ResultSet)", "[Object]invoke(Object,Method,Object[])"], "method_uris": ["src/main/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSet.java.StringTrimmedResultSet.[ResultSet]wrap(ResultSet)", "src/main/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSet.java.StringTrimmedResultSet.[]StringTrimmedResultSet(ResultSet)", "src/main/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSet.java.StringTrimmedResultSet.[Object]invoke(Object,Method,Object[])"], "overrides": null, "attributes": [], "class_docstring": "\nWraps a {@code ResultSet} to trim strings returned by the\n{@code getString()} and {@code getObject()} methods.\n\n<p>\nUsage Example:\nThis example shows how to decorate ResultSets so processing continues as\nnormal but all Strings are trimmed before being returned from the\n{@code ResultSet}.\n</p>\n\n<pre>\nResultSet resultSet = // somehow get a ResultSet;\n\n// Substitute wrapped ResultSet with additional behavior for real ResultSet\nresultSet = StringTrimmedResultSet.wrap(resultSet);\n\n// Pass wrapped ResultSet to processor\nList list = new BasicRowProcessor().toBeanList(resultSet);\n</pre>\n", "original_string": "public class StringTrimmedResultSet implements InvocationHandler {\n\n    /**\n     * Wraps the {@code ResultSet} in an instance of this class.  This is\n     * equivalent to:\n     * <pre>\n     * ProxyFactory.instance().createResultSet(new StringTrimmedResultSet(resultSet));\n     * </pre>\n     *\n     * @param resultSet The {@code ResultSet} to wrap.\n     * @return wrapped ResultSet\n     */\n    public static ResultSet wrap(final ResultSet resultSet) {\n        return ProxyFactory.instance().createResultSet(new StringTrimmedResultSet(resultSet));\n    }\n\n    /**\n     * The wrapped result.\n     */\n    private final ResultSet resultSet;\n\n    /**\n     * Constructs a new instance of {@code StringTrimmedResultSet}\n     * to wrap the specified {@code ResultSet}.\n     * @param resultSet ResultSet to wrap\n     */\n    public StringTrimmedResultSet(final ResultSet resultSet) {\n        this.resultSet = resultSet;\n    }\n\n    /**\n     * Intercept calls to the {@code getString()} and\n     * {@code getObject()} methods and trim any Strings before they're\n     * returned.\n     *\n     * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n     * @param proxy Not used; all method calls go to the internal result set\n     * @param method The method to invoke on the result set\n     * @param args The arguments to pass to the result set\n     * @return string trimmed result\n     * @throws Throwable error\n     */\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        Object result = method.invoke(this.resultSet, args);\n\n        if (result instanceof String\n                && (method.getName().equals(\"getObject\")\n                || method.getName().equals(\"getString\"))) {\n            result = ((String) result).trim();\n        }\n\n        return result;\n    }\n\n}", "super_interfaces": ["InvocationHandler"], "fields": [{"attribute_expression": "private final ResultSet resultSet;", "docstring": "\nThe wrapped result.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ResultSet", "name": "resultSet", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet", "name": "SqlNullCheckedResultSet", "file_path": "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java", "superclasses": "", "methods": ["[ResultSet]wrap(ResultSet)", "[]SqlNullCheckedResultSet(ResultSet)", "[InputStream]getNullAsciiStream()", "[BigDecimal]getNullBigDecimal()", "[InputStream]getNullBinaryStream()", "[Blob]getNullBlob()", "[boolean]getNullBoolean()", "[byte]getNullByte()", "[byte[]]getNullBytes()", "[Reader]getNullCharacterStream()", "[Clob]getNullClob()", "[Date]getNullDate()", "[double]getNullDouble()", "[float]getNullFloat()", "[int]getNullInt()", "[long]getNullLong()", "[Object]getNullObject()", "[Ref]getNullRef()", "[short]getNullShort()", "[String]getNullString()", "[Time]getNullTime()", "[Timestamp]getNullTimestamp()", "[URL]getNullURL()", "[Object]invoke(Object,Method,Object[])", "[void]setNullAsciiStream(InputStream)", "[void]setNullBigDecimal(BigDecimal)", "[void]setNullBinaryStream(InputStream)", "[void]setNullBlob(Blob)", "[void]setNullBoolean(boolean)", "[void]setNullByte(byte)", "[void]setNullBytes(byte[])", "[void]setNullCharacterStream(Reader)", "[void]setNullClob(Clob)", "[void]setNullDate(Date)", "[void]setNullDouble(double)", "[void]setNullFloat(float)", "[void]setNullInt(int)", "[void]setNullLong(long)", "[void]setNullObject(Object)", "[void]setNullRef(Ref)", "[void]setNullShort(short)", "[void]setNullString(String)", "[void]setNullTime(Time)", "[void]setNullTimestamp(Timestamp)", "[void]setNullURL(URL)"], "method_uris": ["src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[ResultSet]wrap(ResultSet)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[]SqlNullCheckedResultSet(ResultSet)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[InputStream]getNullAsciiStream()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[BigDecimal]getNullBigDecimal()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[InputStream]getNullBinaryStream()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[Blob]getNullBlob()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[boolean]getNullBoolean()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[byte]getNullByte()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[byte[]]getNullBytes()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[Reader]getNullCharacterStream()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[Clob]getNullClob()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[Date]getNullDate()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[double]getNullDouble()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[float]getNullFloat()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[int]getNullInt()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[long]getNullLong()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[Object]getNullObject()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[Ref]getNullRef()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[short]getNullShort()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[String]getNullString()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[Time]getNullTime()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[Timestamp]getNullTimestamp()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[URL]getNullURL()", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[Object]invoke(Object,Method,Object[])", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullAsciiStream(InputStream)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullBigDecimal(BigDecimal)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullBinaryStream(InputStream)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullBlob(Blob)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullBoolean(boolean)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullByte(byte)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullBytes(byte[])", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullCharacterStream(Reader)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullClob(Clob)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullDate(Date)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullDouble(double)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullFloat(float)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullInt(int)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullLong(long)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullObject(Object)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullRef(Ref)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullShort(short)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullString(String)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullTime(Time)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullTimestamp(Timestamp)", "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java.SqlNullCheckedResultSet.[void]setNullURL(URL)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates a {@code ResultSet} with checks for a SQL NULL value on each\n{@code getXXX} method. If a column value obtained by a\n{@code getXXX} method is not SQL NULL, the column value is returned. If\nthe column value is SQL null, an alternate value is returned. The alternate\nvalue defaults to the Java {@code null} value, which can be overridden\nfor instances of the class.\n\n<p>\nUsage example:\n<blockquote>\n<pre>\nConnection conn = // somehow get a connection\nStatement stmt = conn.createStatement();\nResultSet resultSet = stmt.executeQuery(\"SELECT col1, col2 FROM table1\");\n\n// Wrap the result set for SQL NULL checking\nSqlNullCheckedResultSet wrapper = new SqlNullCheckedResultSet(resultSet);\nwrapper.setNullString(\"---N/A---\"); // Set null string\nwrapper.setNullInt(-999); // Set null integer\nresultSet = ProxyFactory.instance().createResultSet(wrapper);\n\nwhile (resultSet.next()) {\n    // If col1 is SQL NULL, value returned will be \"---N/A---\"\n    String col1 = resultSet.getString(\"col1\");\n    // If col2 is SQL NULL, value returned will be -999\n    int col2 = resultSet.getInt(\"col2\");\n}\nresultSet.close();\n</pre>\n</blockquote>\n&lt;/p&gt;\n<p>Unlike some other classes in DbUtils, this class is NOT thread-safe.</p>\n", "original_string": "public class SqlNullCheckedResultSet implements InvocationHandler {\n\n    /**\n     * Maps normal method names (ie. \"getBigDecimal\") to the corresponding null\n     * Method object (ie. getNullBigDecimal).\n     */\n    private static final Map<String, Method> NULL_METHODS = new HashMap<>();\n\n    /**\n     * The {@code getNull} string prefix.\n     * @since 1.4\n     */\n    private static final String GET_NULL_PREFIX = \"getNull\";\n\n    static {\n        final Method[] methods = SqlNullCheckedResultSet.class.getMethods();\n        for (final Method method : methods) {\n            final String methodName = method.getName();\n\n            if (methodName.startsWith(GET_NULL_PREFIX)) {\n                final String normalName = \"get\" + methodName.substring(GET_NULL_PREFIX.length());\n                NULL_METHODS.put(normalName, method);\n            }\n        }\n    }\n\n    /**\n     * The factory to create proxies with.\n     */\n    private static final ProxyFactory factory = ProxyFactory.instance();\n\n    /**\n     * Wraps the {@code ResultSet} in an instance of this class.  This is\n     * equivalent to:\n     * <pre>\n     * ProxyFactory.instance().createResultSet(new SqlNullCheckedResultSet(resultSet));\n     * </pre>\n     *\n     * @param resultSet The {@code ResultSet} to wrap.\n     * @return wrapped ResultSet\n     */\n    public static ResultSet wrap(final ResultSet resultSet) {\n        return factory.createResultSet(new SqlNullCheckedResultSet(resultSet));\n    }\n\n    private InputStream nullAsciiStream;\n    private BigDecimal nullBigDecimal;\n    private InputStream nullBinaryStream;\n    private Blob nullBlob;\n    private boolean nullBoolean;\n    private byte nullByte;\n    private byte[] nullBytes;\n    private Reader nullCharacterStream;\n    private Clob nullClob;\n    private Date nullDate;\n    private double nullDouble;\n    private float nullFloat;\n    private int nullInt;\n    private long nullLong;\n    private Object nullObject;\n    private Ref nullRef;\n    private short nullShort;\n    private String nullString;\n    private Time nullTime;\n    private Timestamp nullTimestamp;\n    private URL nullURL;\n\n    /**\n     * The wrapped result.\n     */\n    private final ResultSet resultSet;\n\n    /**\n     * Constructs a new instance of\n     * {@code SqlNullCheckedResultSet}\n     * to wrap the specified {@code ResultSet}.\n     * @param resultSet ResultSet to wrap\n     */\n    public SqlNullCheckedResultSet(final ResultSet resultSet) {\n        this.resultSet = resultSet;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getAsciiStream} method.\n     *\n     * @return the value\n     */\n    public InputStream getNullAsciiStream() {\n        return this.nullAsciiStream;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBigDecimal} method.\n     *\n     * @return the value\n     */\n    public BigDecimal getNullBigDecimal() {\n        return this.nullBigDecimal;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBinaryStream} method.\n     *\n     * @return the value\n     */\n    public InputStream getNullBinaryStream() {\n        return this.nullBinaryStream;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBlob} method.\n     *\n     * @return the value\n     */\n    public Blob getNullBlob() {\n        return this.nullBlob;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBoolean} method.\n     *\n     * @return the value\n     */\n    public boolean getNullBoolean() {\n        return this.nullBoolean;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getByte} method.\n     *\n     * @return the value\n     */\n    public byte getNullByte() {\n        return this.nullByte;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBytes} method.\n     *\n     * @return the value\n     */\n    public byte[] getNullBytes() {\n        if (this.nullBytes == null) {\n            return null;\n        }\n        return this.nullBytes.clone();\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getCharacterStream} method.\n     *\n     * @return the value\n     */\n    public Reader getNullCharacterStream() {\n        return this.nullCharacterStream;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getClob} method.\n     *\n     * @return the value\n     */\n    public Clob getNullClob() {\n        return this.nullClob;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getDate} method.\n     *\n     * @return the value\n     */\n    public Date getNullDate() {\n        return this.nullDate != null ? new Date(this.nullDate.getTime()) : null;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getDouble} method.\n     *\n     * @return the value\n     */\n    public double getNullDouble() {\n        return this.nullDouble;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getFloat} method.\n     *\n     * @return the value\n     */\n    public float getNullFloat() {\n        return this.nullFloat;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getInt} method.\n     *\n     * @return the value\n     */\n    public int getNullInt() {\n        return this.nullInt;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getLong} method.\n     *\n     * @return the value\n     */\n    public long getNullLong() {\n        return this.nullLong;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getObject} method.\n     *\n     * @return the value\n     */\n    public Object getNullObject() {\n        return this.nullObject;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getRef} method.\n     *\n     * @return the value\n     */\n    public Ref getNullRef() {\n        return this.nullRef;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getShort} method.\n     *\n     * @return the value\n     */\n    public short getNullShort() {\n        return this.nullShort;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getString} method.\n     *\n     * @return the value\n     */\n    public String getNullString() {\n        return this.nullString;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getTime} method.\n     *\n     * @return the value\n     */\n    public Time getNullTime() {\n        return this.nullTime != null ? new Time(this.nullTime.getTime()) : null;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getTimestamp} method.\n     *\n     * @return the value\n     */\n    public Timestamp getNullTimestamp() {\n        if (this.nullTimestamp == null) {\n            return null;\n        }\n\n        final Timestamp ts = new Timestamp(this.nullTimestamp.getTime());\n        ts.setNanos(this.nullTimestamp.getNanos());\n        return ts;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getURL} method.\n     *\n     * @return the value\n     */\n    public URL getNullURL() {\n        return this.nullURL;\n    }\n\n    /**\n     * Intercepts calls to {@code get*} methods and calls the appropriate\n     * {@code getNull*} method if the {@code ResultSet} returned\n     * {@code null}.\n     *\n     * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n     * @param proxy Not used; all method calls go to the internal result set\n     * @param method The method to invoke on the result set\n     * @param args The arguments to pass to the result set\n     * @return null checked result\n     * @throws Throwable error\n     */\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        final Object result = method.invoke(this.resultSet, args);\n\n        final Method nullMethod = NULL_METHODS.get(method.getName());\n\n        // Check nullMethod != null first so that we don't call wasNull()\n        // before a true getter method was invoked on the ResultSet.\n        return nullMethod != null && this.resultSet.wasNull()\n            ? nullMethod.invoke(this, (Object[]) null)\n            : result;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getAsciiStream} method.\n     *\n     * @param nullAsciiStream the value\n     */\n    public void setNullAsciiStream(final InputStream nullAsciiStream) {\n        this.nullAsciiStream = nullAsciiStream;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBigDecimal} method.\n     *\n     * @param nullBigDecimal the value\n     */\n    public void setNullBigDecimal(final BigDecimal nullBigDecimal) {\n        this.nullBigDecimal = nullBigDecimal;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBinaryStream} method.\n     *\n     * @param nullBinaryStream the value\n     */\n    public void setNullBinaryStream(final InputStream nullBinaryStream) {\n        this.nullBinaryStream = nullBinaryStream;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBlob} method.\n     *\n     * @param nullBlob the value\n     */\n    public void setNullBlob(final Blob nullBlob) {\n        this.nullBlob = nullBlob;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBoolean} method.\n     *\n     * @param nullBoolean the value\n     */\n    public void setNullBoolean(final boolean nullBoolean) {\n        this.nullBoolean = nullBoolean;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getByte} method.\n     *\n     * @param nullByte the value\n     */\n    public void setNullByte(final byte nullByte) {\n        this.nullByte = nullByte;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBytes} method.\n     *\n     * @param nullBytes the value\n     */\n    public void setNullBytes(final byte[] nullBytes) {\n        if (nullBytes != null) {\n            this.nullBytes = nullBytes.clone();\n        } else {\n            this.nullBytes = null;\n        }\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getCharacterStream} method.\n     *\n     * @param nullCharacterStream the value\n     */\n    public void setNullCharacterStream(final Reader nullCharacterStream) {\n        this.nullCharacterStream = nullCharacterStream;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getClob} method.\n     *\n     * @param nullClob the value\n     */\n    public void setNullClob(final Clob nullClob) {\n        this.nullClob = nullClob;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getDate} method.\n     *\n     * @param nullDate the value\n     */\n    public void setNullDate(final Date nullDate) {\n        this.nullDate = nullDate != null ? new Date(nullDate.getTime()) : null;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getDouble} method.\n     *\n     * @param nullDouble the value\n     */\n    public void setNullDouble(final double nullDouble) {\n        this.nullDouble = nullDouble;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getFloat} method.\n     *\n     * @param nullFloat the value\n     */\n    public void setNullFloat(final float nullFloat) {\n        this.nullFloat = nullFloat;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getInt} method.\n     *\n     * @param nullInt the value\n     */\n    public void setNullInt(final int nullInt) {\n        this.nullInt = nullInt;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getLong} method.\n     *\n     * @param nullLong the value\n     */\n    public void setNullLong(final long nullLong) {\n        this.nullLong = nullLong;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getObject} method.\n     *\n     * @param nullObject the value\n     */\n    public void setNullObject(final Object nullObject) {\n        this.nullObject = nullObject;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getRef} method.\n     *\n     * @param nullRef the value\n     */\n    public void setNullRef(final Ref nullRef) {\n        this.nullRef = nullRef;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getShort} method.\n     *\n     * @param nullShort the value\n     */\n    public void setNullShort(final short nullShort) {\n        this.nullShort = nullShort;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getString} method.\n     *\n     * @param nullString the value\n     */\n    public void setNullString(final String nullString) {\n        this.nullString = nullString;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getTime} method.\n     *\n     * @param nullTime the value\n     */\n    public void setNullTime(final Time nullTime) {\n        this.nullTime = nullTime != null ? new Time(nullTime.getTime()) : null;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getTimestamp} method.\n     *\n     * @param nullTimestamp the value\n     */\n    public void setNullTimestamp(final Timestamp nullTimestamp) {\n        if (nullTimestamp != null) {\n            this.nullTimestamp = new Timestamp(nullTimestamp.getTime());\n            this.nullTimestamp.setNanos(nullTimestamp.getNanos());\n        } else {\n            this.nullTimestamp = null;\n        }\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getURL} method.\n     *\n     * @param nullURL the value\n     */\n    public void setNullURL(final URL nullURL) {\n        this.nullURL = nullURL;\n    }\n\n}", "super_interfaces": ["InvocationHandler"], "fields": [{"attribute_expression": "private static final Map<String, Method> NULL_METHODS = new HashMap<>();", "docstring": "\nMaps normal method names (ie. \"getBigDecimal\") to the corresponding null\nMethod object (ie. getNullBigDecimal).\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Map<String, Method>", "name": "NULL_METHODS = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private static final String GET_NULL_PREFIX = \"getNull\";", "docstring": "\nThe {@code getNull} string prefix.\n@since 1.4\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "GET_NULL_PREFIX = \"getNull\"", "syntax_pass": true}, {"attribute_expression": "private static final ProxyFactory factory = ProxyFactory.instance();", "docstring": "\nThe factory to create proxies with.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ProxyFactory", "name": "factory = ProxyFactory.instance()", "syntax_pass": true}, {"attribute_expression": "private InputStream nullAsciiStream;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "InputStream", "name": "nullAsciiStream", "syntax_pass": true}, {"attribute_expression": "private BigDecimal nullBigDecimal;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BigDecimal", "name": "nullBigDecimal", "syntax_pass": true}, {"attribute_expression": "private InputStream nullBinaryStream;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "InputStream", "name": "nullBinaryStream", "syntax_pass": true}, {"attribute_expression": "private Blob nullBlob;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Blob", "name": "nullBlob", "syntax_pass": true}, {"attribute_expression": "private boolean nullBoolean;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "nullBoolean", "syntax_pass": true}, {"attribute_expression": "private byte nullByte;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte", "name": "nullByte", "syntax_pass": true}, {"attribute_expression": "private byte[] nullBytes;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "nullBytes", "syntax_pass": true}, {"attribute_expression": "private Reader nullCharacterStream;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Reader", "name": "nullCharacterStream", "syntax_pass": true}, {"attribute_expression": "private Clob nullClob;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Clob", "name": "nullClob", "syntax_pass": true}, {"attribute_expression": "private Date nullDate;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Date", "name": "nullDate", "syntax_pass": true}, {"attribute_expression": "private double nullDouble;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "double", "name": "nullDouble", "syntax_pass": true}, {"attribute_expression": "private float nullFloat;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "float", "name": "nullFloat", "syntax_pass": true}, {"attribute_expression": "private int nullInt;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "nullInt", "syntax_pass": true}, {"attribute_expression": "private long nullLong;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "nullLong", "syntax_pass": true}, {"attribute_expression": "private Object nullObject;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Object", "name": "nullObject", "syntax_pass": true}, {"attribute_expression": "private Ref nullRef;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Ref", "name": "nullRef", "syntax_pass": true}, {"attribute_expression": "private short nullShort;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "short", "name": "nullShort", "syntax_pass": true}, {"attribute_expression": "private String nullString;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "nullString", "syntax_pass": true}, {"attribute_expression": "private Time nullTime;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Time", "name": "nullTime", "syntax_pass": true}, {"attribute_expression": "private Timestamp nullTimestamp;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Timestamp", "name": "nullTimestamp", "syntax_pass": true}, {"attribute_expression": "private URL nullURL;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "URL", "name": "nullURL", "syntax_pass": true}, {"attribute_expression": "private final ResultSet resultSet;", "docstring": "\nThe wrapped result.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ResultSet", "name": "resultSet", "syntax_pass": true}]}]