[{"uris": "src/test/java/org/apache/commons/dbutils/BaseResultSetHandlerTest.java.BaseResultSetHandlerTest", "name": "BaseResultSetHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/BaseResultSetHandlerTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testHandleWithoutExplicitResultSetInvocation()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    private static final class ToMapCollectionHandler extends BaseResultSetHandler<Collection<Map<String, Object>>> {\n\n        @Override\n        protected Collection<Map<String, Object>> handle() throws SQLException {\n            final Collection<Map<String, Object>> result = new LinkedList<>();\n\n            while (next()) {\n                final Map<String, Object> current = new HashMap<>();\n\n                for (int i = 1; i <= getMetaData().getColumnCount(); i++) {\n                    current.put(getMetaData().getColumnName(i), getObject(i));\n                }\n\n                result.add(current);\n            }\n\n            return result;\n        }\n\n    }", "definition": "    private static final class ToMapCollectionHandler extends BaseResultSetHandler<Collection<Map<String, Object>>>", "class_docstring": "", "name": "ToMapCollectionHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        protected Collection<Map<String, Object>> handle() throws SQLException {\n            final Collection<Map<String, Object>> result = new LinkedList<>();\n\n            while (next()) {\n                final Map<String, Object> current = new HashMap<>();\n\n                for (int i = 1; i <= getMetaData().getColumnCount(); i++) {\n                    current.put(getMetaData().getColumnName(i), getObject(i));\n                }\n\n                result.add(current);\n            }\n\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Collection<Map<String, Object>>", "classes": []}, "name": "handle", "params": [], "body": "                                                                               {\n            final Collection<Map<String, Object>> result = new LinkedList<>();\n\n            while (next()) {\n                final Map<String, Object> current = new HashMap<>();\n\n                for (int i = 1; i <= getMetaData().getColumnCount(); i++) {\n                    current.put(getMetaData().getColumnName(i), getObject(i));\n                }\n\n                result.add(current);\n            }\n\n            return result;\n        }", "signature": "@Override\n        protected Collection<Map<String, Object>> handle()"}]}], "class_docstring": "", "original_string": "public final class BaseResultSetHandlerTest extends BaseTestCase {\n\n    private static final class ToMapCollectionHandler extends BaseResultSetHandler<Collection<Map<String, Object>>> {\n\n        @Override\n        protected Collection<Map<String, Object>> handle() throws SQLException {\n            final Collection<Map<String, Object>> result = new LinkedList<>();\n\n            while (next()) {\n                final Map<String, Object> current = new HashMap<>();\n\n                for (int i = 1; i <= getMetaData().getColumnCount(); i++) {\n                    current.put(getMetaData().getColumnName(i), getObject(i));\n                }\n\n                result.add(current);\n            }\n\n            return result;\n        }\n\n    }\n\n    @Test\n    public void testHandleWithoutExplicitResultSetInvocation() throws Exception {\n        final Collection<Map<String, Object>> result = new ToMapCollectionHandler().handle(createMockResultSet());\n\n        assertFalse(result.isEmpty());\n\n        for (final Map<String, Object> current : result) {\n            assertTrue(current.containsKey(\"one\"));\n            assertTrue(current.containsKey(\"two\"));\n            assertTrue(current.containsKey(\"three\"));\n            assertTrue(current.containsKey(\"notInBean\"));\n            assertTrue(current.containsKey(\"intTest\"));\n            assertTrue(current.containsKey(\"integerTest\"));\n            assertTrue(current.containsKey(\"nullObjectTest\"));\n            assertTrue(current.containsKey(\"nullPrimitiveTest\"));\n            assertTrue(current.containsKey(\"notDate\"));\n            assertTrue(current.containsKey(\"columnProcessorDoubleTest\"));\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest", "name": "QueryRunnerTest", "file_path": "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java", "superclasses": "", "methods": ["[void]testAddBatchExceptionOnAdd()", "[void]testBadPrepareConnection()", "[void]testExecuteBatchExceptionOnExec()", "[void]testExecuteException()", "[void]testExecuteQueryException()", "[void]testExecuteUpdateException()", "[void]testExecuteWithMultipleResultSets()", "[void]testExecuteWithResultSetException()", "[void]testFillStatementWithBean()", "[void]testFillStatementWithBeanNullNames()", "[void]testGoodBatch()", "[void]testGoodBatchDefaultConstructor()", "[void]testGoodBatchInsert()", "[void]testGoodBatchPmdTrue()", "[void]testGoodExecute()", "[void]testGoodExecuteDefaultConstructor()", "[void]testGoodExecutePmdTrue()", "[void]testGoodExecuteWithResultSet()", "[void]testGoodExecuteWithResultSetDefaultConstructor()", "[void]testGoodExecuteWithResultSetPmdTrue()", "[void]testGoodInsert()", "[void]testGoodQuery()", "[void]testGoodQueryDefaultConstructor()", "[void]testGoodQueryPmdTrue()", "[void]testGoodUpdate()", "[void]testGoodUpdateDefaultConstructor()", "[void]testGoodUpdatePmdTrue()", "[void]testNoParamsExecute()", "[void]testNoParamsExecuteWithResultSet()", "[void]testNoParamsQuery()", "[void]testNoParamsUpdate()", "[void]testNullConnectionBatch()", "[void]testNullConnectionExecute()", "[void]testNullConnectionExecuteWithResultSet()", "[void]testNullConnectionQuery()", "[void]testNullConnectionUpdate()", "[void]testNullHandlerExecute()", "[void]testNullHandlerExecuteWithResultSet()", "[void]testNullHandlerQuery()", "[void]testNullParamsArgBatch()", "[void]testNullParamsBatch()", "[void]testNullSqlBatch()", "[void]testNullSqlExecute()", "[void]testNullSqlExecuteWithResultSet()", "[void]testNullSqlQuery()", "[void]testNullSqlUpdate()", "[void]testStatementConfiguration()", "[void]testTooFewParamsBatch()", "[void]testTooFewParamsExecute()", "[void]testTooFewParamsExecuteWithResultSet()", "[void]testTooFewParamsQuery()", "[void]testTooFewParamsUpdate()", "[void]testTooManyParamsBatch()", "[void]testTooManyParamsExecute()", "[void]testTooManyParamsExecuteWithResultSet()", "[void]testTooManyParamsQuery()", "[void]testTooManyParamsUpdate()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callBatchWithException(String,Object[][])", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callExecuteWithException()", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callExecuteWithResultSetWithException()", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callGoodBatch(Connection,Object[][])", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callGoodBatch(Object[][])", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callGoodBatch(Object[][],boolean)", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callGoodExecute()", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callGoodExecute(Connection)", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callGoodExecuteWithResultSet()", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callGoodExecuteWithResultSet(Connection)", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callGoodQuery()", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callGoodQuery(Connection)", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callGoodUpdate()", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callGoodUpdate(Connection)", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callQueryWithException()", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]callUpdateWithException()", "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java.QueryRunnerTest.[void]setUp()"], "overrides": null, "attributes": [{"original_string": "    final class MyBean {\n        private int a;\n        private double b;\n        private String c;\n\n        public int getA() {\n            return a;\n        }\n\n        public double getB() {\n            return b;\n        }\n\n        public String getC() {\n            return c;\n        }\n\n        public void setA(final int a) {\n            this.a = a;\n        }\n\n        public void setB(final double b) {\n            this.b = b;\n        }\n\n        public void setC(final String c) {\n            this.c = c;\n        }\n    }", "definition": "    final class MyBean", "class_docstring": "", "name": "MyBean", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private int a;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "a", "syntax_pass": true}, {"attribute_expression": "private double b;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "double", "name": "b", "syntax_pass": true}, {"attribute_expression": "private String c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "c", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public int getA() {\n            return a;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getA", "params": [], "body": "                          {\n            return a;\n        }", "signature": "public int getA()"}, {"syntax_pass": true, "original_string": "        public double getB() {\n            return b;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "getB", "params": [], "body": "                             {\n            return b;\n        }", "signature": "public double getB()"}, {"syntax_pass": true, "original_string": "        public String getC() {\n            return c;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getC", "params": [], "body": "                             {\n            return c;\n        }", "signature": "public String getC()"}, {"syntax_pass": true, "original_string": "        public void setA(final int a) {\n            this.a = a;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setA", "params": [{"name": "a", "type": "int"}], "body": "                                      {\n            this.a = a;\n        }", "signature": "public void setA(final int a)"}, {"syntax_pass": true, "original_string": "        public void setB(final double b) {\n            this.b = b;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setB", "params": [{"name": "b", "type": "double"}], "body": "                                         {\n            this.b = b;\n        }", "signature": "public void setB(final double b)"}, {"syntax_pass": true, "original_string": "        public void setC(final String c) {\n            this.c = c;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setC", "params": [{"name": "c", "type": "String"}], "body": "                                         {\n            this.c = c;\n        }", "signature": "public void setC(final String c)"}]}], "class_docstring": "", "original_string": "@SuppressWarnings(\"boxing\") // test code\n@RunWith(MockitoJUnitRunner.class)\npublic class QueryRunnerTest {\n    //\n    // Random tests\n    //\n    final class MyBean {\n        private int a;\n        private double b;\n        private String c;\n\n        public int getA() {\n            return a;\n        }\n\n        public double getB() {\n            return b;\n        }\n\n        public String getC() {\n            return c;\n        }\n\n        public void setA(final int a) {\n            this.a = a;\n        }\n\n        public void setB(final double b) {\n            this.b = b;\n        }\n\n        public void setC(final String c) {\n            this.c = c;\n        }\n    }\n\n    private QueryRunner runner;\n\n    private ArrayHandler handler;\n\n    @Mock\n    private DataSource dataSource;\n\n    @Mock\n    private Connection conn;\n\n    @Mock\n    private PreparedStatement prepStmt;\n\n    @Mock\n    private Statement stmt;\n\n    @Mock\n    private CallableStatement call;\n\n    @Mock\n    private ParameterMetaData meta;\n\n    @Mock\n    private ResultSet results;\n\n    @Mock\n    private ResultSetMetaData resultsMeta;\n\n    //\n    // Batch test cases\n    //\n\n    // helper method for calling batch when an exception is expected\n    private void callBatchWithException(final String sql, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        boolean caught = false;\n\n        try {\n            runner.batch(sql, params);\n\n            verify(prepStmt, times(1)).getParameterMetaData();\n            verify(prepStmt, times(2)).addBatch();\n            verify(prepStmt, times(1)).executeBatch();\n            verify(prepStmt, times(1)).close();    // make sure the statement is closed\n            verify(conn, times(1)).close();    // make sure the connection is closed\n        } catch (final SQLException e) {\n            System.out.println(\"[TEST] The following exception is expected:\");\n            System.out.println(e);\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling execute when an exception is expected\n    private void callExecuteWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.query(\"{call my_proc(?, ?)}\", handler, params);\n\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling execute when an exception is expected\n    private void callExecuteWithResultSetWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.execute(\"{call my_proc(?, ?)}\", handler, params);\n\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    private void callGoodBatch(final Connection conn, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.batch(conn, \"select * from blah where ? = ?\", params);\n\n        verify(prepStmt, times(1)).getParameterMetaData();\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        // make sure we closed the statement\n        verify(prepStmt, times(1)).close();\n        // make sure we do not close the connection, since QueryRunner.batch(Connection, String, Object[][]) does not close connections\n        verify(conn, times(0)).close();\n    }\n\n    private void callGoodBatch(final Object[][] params) throws Exception {\n        callGoodBatch(params, true);\n    }\n\n    private void callGoodBatch(final Object[][] params, final boolean pmdCheck) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.batch(\"select * from blah where ? = ?\", params);\n\n        verify(prepStmt, times(pmdCheck ? 1 : 0)).getParameterMetaData();\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodExecute() throws Exception {\n        when(call.execute()).thenReturn(false);\n        when(call.getUpdateCount()).thenReturn(3);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        int result = runner.execute(\"{call my_proc(?, ?)}\", \"unit\", \"test\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(1)).execute();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        result = runner.execute(\"{call my_proc()}\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(2)).execute();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        result = runner.execute(\"{?= call my_proc()}\", intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(3)).execute();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        result = runner.execute(\"{?= call my_proc(?, ?)}\", intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(4)).execute();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(4)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        result = runner.execute(\"{?= call my_proc(?, ?)}\", intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(5)).execute();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(5)).close();    // make sure we do not close the connection\n    }\n\n    //\n    // Execute tests\n    //\n    private void callGoodExecute(final Connection conn) throws Exception {\n        when(call.execute()).thenReturn(false);\n        when(call.getUpdateCount()).thenReturn(3);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        int result = runner.execute(conn, \"{call my_proc(?, ?)}\", \"unit\", \"test\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(1)).execute();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        result = runner.execute(conn, \"{call my_proc()}\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(2)).execute();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        result = runner.execute(conn, \"{?= call my_proc()}\", intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(3)).execute();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        result = runner.execute(conn, \"{?= call my_proc(?, ?)}\", intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(4)).execute();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        result = runner.execute(conn, \"{?= call my_proc(?, ?)}\", intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(5)).execute();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n    }\n\n    private void callGoodExecuteWithResultSet() throws Exception {\n        when(call.execute()).thenReturn(true);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.execute(\"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n\n        verify(call, times(1)).execute();\n        verify(results, times(1)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        runner.execute(\"{call my_proc()}\", handler);\n\n        verify(call, times(2)).execute();\n        verify(results, times(2)).close();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        runner.execute(\"{?= call my_proc()}\", handler, intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n\n        verify(call, times(3)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        runner.execute(\"{?= call my_proc(?, ?)}\", handler, intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n\n        verify(call, times(4)).execute();\n        verify(results, times(4)).close();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(4)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        runner.execute(\"{?= call my_proc(?, ?)}\", handler, intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n\n        verify(call, times(5)).execute();\n        verify(results, times(5)).close();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(5)).close();    // make sure we do not close the connection\n    }\n\n    private void callGoodExecuteWithResultSet(final Connection conn) throws Exception {\n        when(call.execute()).thenReturn(true);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.execute(conn, \"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n\n        verify(call, times(1)).execute();\n        verify(results, times(1)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        runner.execute(conn, \"{call my_proc()}\", handler);\n\n        verify(call, times(2)).execute();\n        verify(results, times(2)).close();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        runner.execute(conn, \"{?= call my_proc()}\", handler, intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n\n        verify(call, times(3)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        runner.execute(conn, \"{?= call my_proc(?, ?)}\", handler, intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n\n        verify(call, times(4)).execute();\n        verify(results, times(4)).close();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        runner.execute(conn, \"{?= call my_proc(?, ?)}\", handler, intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n\n        verify(call, times(5)).execute();\n        verify(results, times(5)).close();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n    }\n\n    private void callGoodQuery() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(sql, handler, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(sql, handler);\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Query test cases\n    //\n    private void callGoodQuery(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(conn, sql, handler, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        // make sure we do not close the connection, since QueryRunner.query(Connection, String, ResultSetHandler<T>, Object...) does not close connections\n        verify(conn, times(0)).close();\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(conn, sql, handler);\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n    }\n\n    private void callGoodUpdate() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(sql, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(sql);\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        sql = \"update blah set unit = ?\";\n        runner.update(sql, \"test\");\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Update test cases\n    //\n    private void callGoodUpdate(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.update(conn, \"update blah set ? = ?\", \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        // make sure we do not close the connection, since QueryRunner.update(Connection, String, Object...) does not close connections\n        verify(conn, times(0)).close();\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        final String sql = \"update blah set unit = test\";\n        runner.update(conn, sql);\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        runner.update(conn, \"update blah set unit = ?\", \"test\");\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n    }\n\n    /** Helper method for calling batch when an exception is expected. */\n    private void callQueryWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            final String sql = \"select * from blah where ? = ?\";\n            runner.query(sql, handler, params);\n\n            verify(prepStmt, never()).close(); // make sure the statement is still open\n            verify(prepStmt, times(1)).executeQuery();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(results, times(1)).close();\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling batch when an exception is expected\n    private void callUpdateWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            final String sql = \"select * from blah where ? = ?\";\n            runner.update(sql, params);\n\n            verify(prepStmt, times(1)).executeUpdate();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        when(dataSource.getConnection()).thenReturn(conn);\n\n        when(conn.prepareStatement(any(String.class))).thenReturn(prepStmt);\n        when(prepStmt.getParameterMetaData()).thenReturn(meta);\n        when(prepStmt.executeQuery()).thenReturn(results);\n\n        when(conn.createStatement()).thenReturn(stmt);\n        when(stmt.executeQuery(any(String.class))).thenReturn(results);\n\n        when(conn.prepareCall(any(String.class))).thenReturn(call);\n        when(call.getParameterMetaData()).thenReturn(meta);\n        when(call.getResultSet()).thenReturn(results);\n        when(call.getMoreResults()).thenReturn(false);\n\n        when(results.next()).thenReturn(false);\n\n         handler = new ArrayHandler();\n         runner = new QueryRunner(dataSource);\n    }\n\n    @Test\n    public void testAddBatchExceptionOnAdd() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        doThrow(new SQLException()).when(prepStmt).addBatch();\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testBadPrepareConnection() throws Exception {\n        runner = new QueryRunner();\n        runner.update(\"update blah set unit = test\");\n    }\n\n    @Test\n    public void testExecuteBatchExceptionOnExec() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        doThrow(new SQLException()).when(prepStmt).executeBatch();\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testExecuteException() throws Exception {\n        callExecuteWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteQueryException() throws Exception {\n        callQueryWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteUpdateException() throws Exception {\n        doThrow(new SQLException()).when(prepStmt).executeUpdate();\n\n        callUpdateWithException(\"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteWithMultipleResultSets() throws Exception {\n        when(call.execute()).thenReturn(true);\n        when(call.getMoreResults()).thenAnswer(new Answer<Boolean>() {\n            private int count = 1;\n            @Override\n            public Boolean answer(final InvocationOnMock invocation) {\n                return ++count <= 3;\n            }\n        });\n        when(meta.getParameterCount()).thenReturn(0);\n        final List<Object[]> objects = runner.execute(\"{call my_proc()}\", handler);\n\n        Assert.assertEquals(3, objects.size());\n        verify(call, times(1)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we close the connection\n\n    }\n\n    @Test\n    public void testExecuteWithResultSetException() throws Exception {\n        callExecuteWithResultSetWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testFillStatementWithBean() throws Exception {\n        final MyBean bean = new MyBean();\n        when(meta.getParameterCount()).thenReturn(3);\n        runner.fillStatementWithBean(prepStmt, bean, \"a\", \"b\", \"c\");\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testFillStatementWithBeanNullNames() throws Exception {\n        final MyBean bean = new MyBean();\n        runner.fillStatementWithBean(prepStmt, bean, \"a\", \"b\", null);\n    }\n\n    @Test\n    public void testGoodBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }\n\n    @Test\n    public void testGoodBatchDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(conn, params);\n    }\n\n    @Test\n    public void testGoodBatchInsert() throws Exception {\n        results = mock(ResultSet.class);\n        resultsMeta = mock(ResultSetMetaData.class);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        when(conn.prepareStatement(any(String.class), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(prepStmt);\n        when(prepStmt.getGeneratedKeys()).thenReturn(results);\n        when(results.next()).thenReturn(true).thenReturn(true).thenReturn(false);\n\n        final ResultSetHandler<List<Object>> handler = rs -> {\n            final List<Object> objects = new ArrayList<>();\n            while (rs.next()) {\n                objects.add(new Object());\n            }\n            return objects;\n        };\n\n        final Object[][] params = new Object[2][2];\n        params[0][0] = \"Test\";\n        params[0][1] = \"Blah\";\n        params[1][0] = \"Test2\";\n        params[1][1] = \"Blah2\";\n\n        final List<Object> generatedKeys = runner.insertBatch(\"INSERT INTO blah(col1, col2) VALUES(?,?)\", handler, params);\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close(); // make sure we closed the statement\n        verify(conn, times(1)).close(); // make sure we closed the connection\n\n        Assert.assertEquals(2, generatedKeys.size());\n    }\n\n    @Test\n    public void testGoodBatchPmdTrue() throws Exception {\n        runner = new QueryRunner(dataSource, true);\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params, false);\n    }\n\n    @Test\n    public void testGoodExecute() throws Exception {\n        callGoodExecute();\n    }\n\n    @Test\n    public void testGoodExecuteDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodExecute(conn);\n    }\n\n    @Test\n    public void testGoodExecutePmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodExecute(conn);\n    }\n\n    @Test\n    public void testGoodExecuteWithResultSet() throws Exception {\n        callGoodExecuteWithResultSet();\n    }\n\n    @Test\n    public void testGoodExecuteWithResultSetDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodExecuteWithResultSet(conn);\n    }\n\n    @Test\n    public void testGoodExecuteWithResultSetPmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodExecuteWithResultSet(conn);\n    }\n\n    @Test\n    public void testGoodInsert() throws Exception {\n        results = mock(ResultSet.class);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        when(conn.prepareStatement(any(String.class), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(prepStmt);\n        when(prepStmt.getGeneratedKeys()).thenReturn(results);\n        when(results.next()).thenReturn(true).thenReturn(false);\n        when(results.getObject(1)).thenReturn(1L);\n\n        final Long generatedKey = runner.insert(\"INSERT INTO blah(col1, col2) VALUES(?,?)\", new ScalarHandler<>(), \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close(); // make sure we closed the statement\n        verify(conn, times(1)).close(); // make sure we closed the connection\n\n        Assert.assertEquals(1L, generatedKey.longValue());\n    }\n\n    @Test\n    public void testGoodQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testGoodQueryDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodQuery(conn);\n    }\n\n    @Test\n    public void testGoodQueryPmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodQuery(conn);\n    }\n\n    @Test\n    public void testGoodUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test\n    public void testGoodUpdateDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodUpdate(conn);\n    }\n\n    @Test\n    public void testGoodUpdatePmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodUpdate(conn);\n    }\n\n    @Test\n    public void testNoParamsExecute() throws Exception {\n        callGoodExecute();\n    }\n\n    @Test\n    public void testNoParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException();\n    }\n\n    @Test\n    public void testNoParamsQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testNoParamsUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.batch(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionExecute() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.execute(\"{call my_proc(?, ?)}\", \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionExecuteWithResultSet() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.execute(\"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionQuery() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.query(\"select * from blah where ? = ?\", handler, \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionUpdate() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.update(\"select * from blah where ? = ?\", \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullHandlerExecute() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n\n        runner.execute(\"{call my_proc(?, ?)}\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullHandlerExecuteWithResultSet() throws Exception {\n        runner.execute(\"{call my_proc(?, ?)}\", (ResultSetHandler) null);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullHandlerQuery() throws Exception {\n        runner.query(\"select * from blah where ? = ?\", null);\n    }\n\n    //\n    // Execute with ResultSetHandler\n    //\n\n    @Test(expected = SQLException.class)\n    public void testNullParamsArgBatch() throws Exception {\n        runner.batch(\"select * from blah where ? = ?\", null);\n    }\n\n    @Test\n    public void testNullParamsBatch() throws Exception {\n        final String[][] params = { { null, \"unit\" }, { \"test\", null } };\n\n        callGoodBatch(params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        runner.batch(null, params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlExecute() throws Exception {\n        runner.execute(null);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlExecuteWithResultSet() throws Exception {\n        runner.execute(null, handler);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlQuery() throws Exception {\n        runner.query(null, handler);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlUpdate() throws Exception {\n        runner.update(null);\n    }\n\n    @Test\n    public void testStatementConfiguration() throws Exception {\n        final StatementConfiguration stmtConfig = new StatementConfiguration(1, 2, 3, 4, 5);\n        final QueryRunner queryRunner = new QueryRunner(stmtConfig);\n        queryRunner.prepareStatement(conn, \"select 1\");\n\n        verify(prepStmt).setFetchDirection(eq(1));\n        verify(prepStmt).setFetchSize(eq(2));\n        verify(prepStmt).setMaxFieldSize(eq(3));\n        verify(prepStmt).setMaxRows(eq(4));\n        verify(prepStmt).setQueryTimeout(eq(5));\n    }\n\n    @Test\n    public void testTooFewParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\" }, { \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooFewParamsExecute() throws Exception {\n        callExecuteWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsQuery() throws Exception {\n        callQueryWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooManyParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\", \"unit\" }, { \"test\", \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooManyParamsExecute() throws Exception {\n        callExecuteWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsQuery() throws Exception {\n        callQueryWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\", \"test\", \"fail\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private QueryRunner runner;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "QueryRunner", "name": "runner", "syntax_pass": true}, {"attribute_expression": "private ArrayHandler handler;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayHandler", "name": "handler", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private DataSource dataSource;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "DataSource", "name": "dataSource", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private Connection conn;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "Connection", "name": "conn", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private PreparedStatement prepStmt;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "PreparedStatement", "name": "prepStmt", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private Statement stmt;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "Statement", "name": "stmt", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private CallableStatement call;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "CallableStatement", "name": "call", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ParameterMetaData meta;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterMetaData", "name": "meta", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSet results;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "results", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSetMetaData resultsMeta;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSetMetaData", "name": "resultsMeta", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/StatementConfigurationTest.java.StatementConfigurationTest", "name": "StatementConfigurationTest", "file_path": "src/test/java/org/apache/commons/dbutils/StatementConfigurationTest.java", "superclasses": "", "methods": ["[void]testBuilder()", "[void]testConstructor()", "[void]testEmptyBuilder()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class StatementConfigurationTest {\n    /**\n     * Test that a builder with all values set yields like values in the constructed configuration.\n     */\n    @Test\n    public void testBuilder() {\n        final StatementConfiguration.Builder builder = new StatementConfiguration.Builder().fetchDirection(1).fetchSize(2).maxFieldSize(3).maxRows(4)\n                .queryTimeout(5);\n        final StatementConfiguration config = builder.build();\n\n        assertTrue(config.isFetchDirectionSet());\n        assertEquals(Integer.valueOf(1), config.getFetchDirection());\n\n        assertTrue(config.isFetchSizeSet());\n        assertEquals(Integer.valueOf(2), config.getFetchSize());\n\n        assertTrue(config.isMaxFieldSizeSet());\n        assertEquals(Integer.valueOf(3), config.getMaxFieldSize());\n\n        assertTrue(config.isMaxRowsSet());\n        assertEquals(Integer.valueOf(4), config.getMaxRows());\n\n        assertTrue(config.isQueryTimeoutSet());\n        assertEquals(Integer.valueOf(5), config.getQueryTimeout());\n\n        assertTrue(config.isQueryTimeoutSet());\n        assertEquals(Duration.ofSeconds(5), config.getQueryTimeoutDuration());\n\n        final StatementConfiguration config2 = builder.queryTimeout(Duration.ofSeconds(3)).build();\n\n        assertTrue(config2.isQueryTimeoutSet());\n        assertEquals(Integer.valueOf(3), config2.getQueryTimeout());\n\n        assertTrue(config2.isQueryTimeoutSet());\n        assertEquals(Duration.ofSeconds(3), config2.getQueryTimeoutDuration());\n    }\n\n    /**\n     * Test that the constructor of {@code StatementConfiguration} correctly sets all values.\n     */\n    @Test\n    public void testConstructor() {\n        final StatementConfiguration config = new StatementConfiguration(1, 2, 3, 4, 5);\n\n        assertEquals(Integer.valueOf(1), config.getFetchDirection());\n        assertEquals(Integer.valueOf(2), config.getFetchSize());\n        assertEquals(Integer.valueOf(3), config.getMaxFieldSize());\n        assertEquals(Integer.valueOf(4), config.getMaxRows());\n        assertEquals(Integer.valueOf(5), config.getQueryTimeout());\n    }\n\n    /**\n     * Test that an empty builder yields null values for all configuration settings.\n     */\n    @Test\n    public void testEmptyBuilder() {\n        final StatementConfiguration config = new StatementConfiguration.Builder().build();\n\n        assertFalse(config.isFetchDirectionSet());\n        assertFalse(config.isFetchSizeSet());\n        assertFalse(config.isMaxFieldSizeSet());\n        assertFalse(config.isMaxRowsSet());\n        assertFalse(config.isQueryTimeoutSet());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/ResultSetIteratorTest.java.ResultSetIteratorTest", "name": "ResultSetIteratorTest", "file_path": "src/test/java/org/apache/commons/dbutils/ResultSetIteratorTest.java", "superclasses": "BaseTestCase", "methods": ["[void]testCreatesResultSetIteratorTakingThreeArgumentsAndCallsRemove()", "[void]testRethrowThrowsRuntimeException()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/ResultSetIteratorTest.java.ResultSetIteratorTest.[void]testNext()"], "overrides": null, "attributes": [], "class_docstring": "\nResultSetIteratorTest\n", "original_string": "public class ResultSetIteratorTest extends BaseTestCase {\n\n    @Test\n    public void testCreatesResultSetIteratorTakingThreeArgumentsAndCallsRemove() {\n\n        final ResultSet resultSet = mock(ResultSet.class);\n        final ResultSetIterator resultSetIterator = new ResultSetIterator(resultSet, null);\n        resultSetIterator.remove();\n\n    }\n\n    public void testNext() {\n\n        final Iterator<Object[]> iter = new ResultSetIterator(getResultSet());\n\n        assertTrue(iter.hasNext());\n        Object[] row = iter.next();\n        assertEquals(COLS, row.length);\n        assertEquals(\"1\", row[0]);\n        assertEquals(\"2\", row[1]);\n        assertEquals(\"THREE\", row[2]);\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.length);\n\n        assertEquals(\"4\", row[0]);\n        assertEquals(\"5\", row[1]);\n        assertEquals(\"SIX\", row[2]);\n\n        assertFalse(iter.hasNext());\n        assertTrue(iter.next().length == 0);\n    }\n\n    @Test\n    public void testRethrowThrowsRuntimeException() {\n\n        final ResultSetIterator resultSetIterator = new ResultSetIterator((ResultSet) null);\n        final Throwable throwable = new Throwable();\n        final SQLException sqlException = new SQLException(throwable);\n\n        try {\n            resultSetIterator.rethrow(sqlException);\n            fail(\"Expecting exception: RuntimeException\");\n        } catch (final RuntimeException e) {\n            assertEquals(ResultSetIterator.class.getName(), e.getStackTrace()[0].getClassName());\n        }\n\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/DbUtilsTest.java.DbUtilsTest", "name": "DbUtilsTest", "file_path": "src/test/java/org/apache/commons/dbutils/DbUtilsTest.java", "superclasses": "", "methods": ["[void]testCloseConnection()", "[void]testCloseNullConnection()", "[void]testCloseNullResultSet()", "[void]testCloseNullStatement()", "[void]testCloseQuietlyConnection()", "[void]testCloseQuietlyConnectionResultSetStatement()", "[void]testCloseQuietlyConnectionResultSetStatementThrowingException()", "[void]testCloseQuietlyConnectionResultSetThrowingExceptionStatement()", "[void]testCloseQuietlyConnectionThrowingException()", "[void]testCloseQuietlyConnectionThrowingExceptionResultSetStatement()", "[void]testCloseQuietlyNullConnection()", "[void]testCloseQuietlyNullResultSet()", "[void]testCloseQuietlyNullStatement()", "[void]testCloseQuietlyResultSet()", "[void]testCloseQuietlyResultSetThrowingException()", "[void]testCloseQuietlyStatement()", "[void]testCloseQuietlyStatementThrowingException()", "[void]testCloseResultSet()", "[void]testCloseStatement()", "[void]testCommitAndClose()", "[void]testCommitAndCloseQuietly()", "[void]testCommitAndCloseQuietlyWithException()", "[void]testCommitAndCloseQuietlyWithNullDoesNotThrowAnSQLException()", "[void]testCommitAndCloseWithException()", "[void]testLoadDriverReturnsFalse()", "[void]testRollback()", "[void]testRollbackAndClose()", "[void]testRollbackAndCloseNull()", "[void]testRollbackAndCloseQuietly()", "[void]testRollbackAndCloseQuietlyNull()", "[void]testRollbackAndCloseQuietlyWithException()", "[void]testRollbackAndCloseWithException()", "[void]testRollbackNull()", "[void]testRollbackQuietly()", "[void]testRollbackQuietlyNull()", "[void]testRollbackQuietlyWithException()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    public static class DriverProxyTest {\n        private static final Driver mockedDriver = mock(Driver.class);\n        private DbUtils.DriverProxy proxy;\n\n        @Before\n        public void setUp() {\n            proxy = new DbUtils.DriverProxy(mockedDriver);\n        }\n\n        @After\n        public void tearDown() {\n            reset(mockedDriver);\n        }\n\n        @Test\n        public void testProxiedMethods() throws Exception {\n            proxy.getMajorVersion();\n            verify(mockedDriver).getMajorVersion();\n            proxy.getMinorVersion();\n            verify(mockedDriver).getMinorVersion();\n            proxy.jdbcCompliant();\n            verify(mockedDriver).jdbcCompliant();\n\n            final String url = \"testUrl\";\n            proxy.acceptsURL(url);\n            verify(mockedDriver).acceptsURL(url);\n\n            final Properties props = new Properties();\n            props.setProperty(\"test\", \"true\");\n            proxy.connect(url, props);\n            verify(mockedDriver).connect(url, props);\n            proxy.getPropertyInfo(url, props);\n            verify(mockedDriver).getPropertyInfo(url, props);\n        }\n    }", "definition": "    public static class DriverProxyTest", "class_docstring": "", "name": "DriverProxyTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final Driver mockedDriver = mock(Driver.class);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Driver", "name": "mockedDriver = mock(Driver.class)", "syntax_pass": true}, {"attribute_expression": "private DbUtils.DriverProxy proxy;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DbUtils.DriverProxy", "name": "proxy", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Before\n        public void setUp() {\n            proxy = new DbUtils.DriverProxy(mockedDriver);\n        }", "docstring": "", "attributes": {"modifiers": "@Before\n        public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                            {\n            proxy = new DbUtils.DriverProxy(mockedDriver);\n        }", "signature": "@Before\n        public void setUp()"}, {"syntax_pass": true, "original_string": "        @After\n        public void tearDown() {\n            reset(mockedDriver);\n        }", "docstring": "", "attributes": {"modifiers": "@After\n        public", "marker_annotations": ["@After"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "tearDown", "params": [], "body": "                               {\n            reset(mockedDriver);\n        }", "signature": "@After\n        public void tearDown()"}, {"syntax_pass": true, "original_string": "        @Test\n        public void testProxiedMethods() throws Exception {\n            proxy.getMajorVersion();\n            verify(mockedDriver).getMajorVersion();\n            proxy.getMinorVersion();\n            verify(mockedDriver).getMinorVersion();\n            proxy.jdbcCompliant();\n            verify(mockedDriver).jdbcCompliant();\n\n            final String url = \"testUrl\";\n            proxy.acceptsURL(url);\n            verify(mockedDriver).acceptsURL(url);\n\n            final Properties props = new Properties();\n            props.setProperty(\"test\", \"true\");\n            proxy.connect(url, props);\n            verify(mockedDriver).connect(url, props);\n            proxy.getPropertyInfo(url, props);\n            verify(mockedDriver).getPropertyInfo(url, props);\n        }", "docstring": "", "attributes": {"modifiers": "@Test\n        public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testProxiedMethods", "params": [], "body": "                                                          {\n            proxy.getMajorVersion();\n            verify(mockedDriver).getMajorVersion();\n            proxy.getMinorVersion();\n            verify(mockedDriver).getMinorVersion();\n            proxy.jdbcCompliant();\n            verify(mockedDriver).jdbcCompliant();\n\n            final String url = \"testUrl\";\n            proxy.acceptsURL(url);\n            verify(mockedDriver).acceptsURL(url);\n\n            final Properties props = new Properties();\n            props.setProperty(\"test\", \"true\");\n            proxy.connect(url, props);\n            verify(mockedDriver).connect(url, props);\n            proxy.getPropertyInfo(url, props);\n            verify(mockedDriver).getPropertyInfo(url, props);\n        }", "signature": "@Test\n        public void testProxiedMethods()"}]}], "class_docstring": "", "original_string": "public class DbUtilsTest {\n\n    public static class DriverProxyTest {\n        private static final Driver mockedDriver = mock(Driver.class);\n        private DbUtils.DriverProxy proxy;\n\n        @Before\n        public void setUp() {\n            proxy = new DbUtils.DriverProxy(mockedDriver);\n        }\n\n        @After\n        public void tearDown() {\n            reset(mockedDriver);\n        }\n\n        @Test\n        public void testProxiedMethods() throws Exception {\n            proxy.getMajorVersion();\n            verify(mockedDriver).getMajorVersion();\n            proxy.getMinorVersion();\n            verify(mockedDriver).getMinorVersion();\n            proxy.jdbcCompliant();\n            verify(mockedDriver).jdbcCompliant();\n\n            final String url = \"testUrl\";\n            proxy.acceptsURL(url);\n            verify(mockedDriver).acceptsURL(url);\n\n            final Properties props = new Properties();\n            props.setProperty(\"test\", \"true\");\n            proxy.connect(url, props);\n            verify(mockedDriver).connect(url, props);\n            proxy.getPropertyInfo(url, props);\n            verify(mockedDriver).getPropertyInfo(url, props);\n        }\n    }\n\n    @Test\n    public void testCloseConnection() throws Exception {\n        final Connection mockCon = mock(Connection.class);\n        DbUtils.close(mockCon);\n        verify(mockCon).close();\n    }\n\n    @Test\n    public void testCloseNullConnection() throws Exception {\n        DbUtils.close((Connection) null);\n    }\n\n    @Test\n    public void testCloseNullResultSet() throws Exception {\n        DbUtils.close((ResultSet) null);\n    }\n\n    @Test\n    public void testCloseNullStatement() throws Exception {\n        DbUtils.close((Statement) null);\n    }\n\n    @Test\n    public void testCloseQuietlyConnection() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.closeQuietly(mockConnection);\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionResultSetStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionResultSetStatementThrowingException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        doThrow(SQLException.class).when(mockStatement).close();\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionResultSetThrowingExceptionStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        doThrow(SQLException.class).when(mockResultSet).close();\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionThrowingException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        DbUtils.closeQuietly(mockConnection);\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionThrowingExceptionResultSetStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyNullConnection() throws Exception {\n        DbUtils.closeQuietly((Connection) null);\n    }\n\n    @Test\n    public void testCloseQuietlyNullResultSet() throws Exception {\n        DbUtils.closeQuietly((ResultSet) null);\n    }\n\n    @Test\n    public void testCloseQuietlyNullStatement() throws Exception {\n        DbUtils.closeQuietly((Statement) null);\n    }\n\n    @Test\n    public void testCloseQuietlyResultSet() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        DbUtils.closeQuietly(mockResultSet);\n        verify(mockResultSet).close();\n    }\n\n    @Test\n    public void testCloseQuietlyResultSetThrowingException() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        doThrow(SQLException.class).when(mockResultSet).close();\n        DbUtils.closeQuietly(mockResultSet);\n    }\n\n    @Test\n    public void testCloseQuietlyStatement() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockStatement);\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyStatementThrowingException() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        doThrow(SQLException.class).when(mockStatement).close();\n        DbUtils.closeQuietly(mockStatement);\n    }\n\n    @Test\n    public void testCloseResultSet() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        DbUtils.close(mockResultSet);\n        verify(mockResultSet).close();\n    }\n\n    @Test\n    public void testCloseStatement() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.close(mockStatement);\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCommitAndClose() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.commitAndClose(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCommitAndCloseQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.commitAndClose(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCommitAndCloseQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        DbUtils.commitAndCloseQuietly(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCommitAndCloseQuietlyWithNullDoesNotThrowAnSQLException() {\n\n        DbUtils.commitAndCloseQuietly(null);\n\n    }\n\n    @Test\n    public void testCommitAndCloseWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).commit();\n        try {\n            DbUtils.commitAndClose(mockConnection);\n            fail(\"DbUtils.commitAndClose() swallowed SQLEception!\");\n        } catch (final SQLException e) {\n            // we expect this exception\n        }\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testLoadDriverReturnsFalse() {\n\n        assertFalse(DbUtils.loadDriver(\"\"));\n\n    }\n\n    @Test\n    public void testRollback() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollback(mockConnection);\n        verify(mockConnection).rollback();\n    }\n\n    @Test\n    public void testRollbackAndClose() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackAndClose(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackAndCloseNull() throws Exception {\n        DbUtils.rollbackAndClose(null);\n    }\n\n    @Test\n    public void testRollbackAndCloseQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackAndCloseQuietly(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackAndCloseQuietlyNull() throws Exception {\n        DbUtils.rollbackAndCloseQuietly(null);\n    }\n\n    @Test\n    public void testRollbackAndCloseQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        DbUtils.rollbackAndCloseQuietly(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackAndCloseWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        try {\n            DbUtils.rollbackAndClose(mockConnection);\n            fail(\"DbUtils.rollbackAndClose() swallowed SQLException!\");\n        } catch (final SQLException e) {\n            // we expect this exception\n        }\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackNull() throws Exception {\n        DbUtils.rollback(null);\n    }\n\n    @Test\n    public void testRollbackQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackQuietly(mockConnection);\n        verify(mockConnection).rollback();\n    }\n\n    @Test\n    public void testRollbackQuietlyNull() throws Exception {\n        DbUtils.rollbackQuietly(null);\n    }\n\n    @Test\n    public void testRollbackQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        DbUtils.rollbackQuietly(mockConnection);\n        verify(mockConnection).rollback();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/OutParameterTest.java.OutParameterTest", "name": "OutParameterTest", "file_path": "src/test/java/org/apache/commons/dbutils/OutParameterTest.java", "superclasses": "", "methods": ["[void]testRegister()", "[void]testRegisterAlternateConstructor()", "[void]testSetValue()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/OutParameterTest.java.OutParameterTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class OutParameterTest {\n    private static final int INDEX = 2;\n    private static final int VALUE = 42;\n\n    @Mock\n    private CallableStatement stmt;\n\n    private OutParameter<Number> parameter;\n\n    @Before\n    public void setUp() throws Exception {\n        parameter = new OutParameter<>(Types.INTEGER, Number.class);\n    }\n\n    @Test\n    public void testRegister() throws Exception {\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(1)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(0)).setObject(eq(INDEX), any(Number.class));\n\n        parameter.setValue(VALUE);\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(2)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(1)).setObject(INDEX, VALUE);\n    }\n\n    @Test\n    public void testRegisterAlternateConstructor() throws Exception {\n        parameter = new OutParameter<>(Types.INTEGER, Number.class, VALUE);\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(1)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(1)).setObject(INDEX, VALUE);\n    }\n\n    @Test\n    public void testSetValue() throws Exception {\n        when(stmt.getObject(INDEX)).thenReturn(VALUE);\n\n        parameter.setValue(stmt, INDEX);\n\n        assertEquals(VALUE, parameter.getValue());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int INDEX = 2;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "INDEX = 2", "syntax_pass": true}, {"attribute_expression": "private static final int VALUE = 42;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "VALUE = 42", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private CallableStatement stmt;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "CallableStatement", "name": "stmt", "syntax_pass": true}, {"attribute_expression": "private OutParameter<Number> parameter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OutParameter<Number>", "name": "parameter", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/OutParameter_toStringTest.java.OutParameter_toStringTest", "name": "OutParameter_toStringTest", "file_path": "src/test/java/org/apache/commons/dbutils/OutParameter_toStringTest.java", "superclasses": "", "methods": ["[void]testToString()", "[void]testToStringWithNullValue()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/OutParameter_toStringTest.java.OutParameter_toStringTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class OutParameter_toStringTest {\n    private OutParameter<Number> parameter;\n\n    @Before\n    public void setUp() {\n        parameter = new OutParameter<>(java.sql.Types.INTEGER, Number.class, 42);\n    }\n\n    @Test\n    public void testToString() {\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=42}\";\n        assertEquals(expected, parameter.toString());\n    }\n\n    @Test\n    public void testToStringWithNullValue() {\n        parameter = new OutParameter<>(java.sql.Types.INTEGER, Number.class, null);\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=null}\";\n        assertEquals(expected, parameter.toString());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private OutParameter<Number> parameter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OutParameter<Number>", "name": "parameter", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/GenerousBeanProcessorTest.java.GenerousBeanProcessorTest", "name": "GenerousBeanProcessorTest", "file_path": "src/test/java/org/apache/commons/dbutils/GenerousBeanProcessorTest.java", "superclasses": "", "methods": ["[void]testMapColumnsToPropertiesColumnLabelIsNull()", "[void]testMapColumnsToPropertiesMixedCase()", "[void]testMapColumnsToPropertiesWithOutUnderscores()", "[void]testMapColumnsToPropertiesWithSpaces()", "[void]testMapColumnsToPropertiesWithUnderscores()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/GenerousBeanProcessorTest.java.GenerousBeanProcessorTest.[void]setUp()"], "overrides": null, "attributes": [{"original_string": "    static class TestBean {\n        private String one;\n        private int two;\n        private long three;\n\n        public String getOne() {\n            return one;\n        }\n\n        public long getThree() {\n            return three;\n        }\n\n        public int getTwo() {\n            return two;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final long three) {\n            this.three = three;\n        }\n\n        public void setTwo(final int two) {\n            this.two = two;\n        }\n    }", "definition": "    static class TestBean", "class_docstring": "", "name": "TestBean", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private String one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "one", "syntax_pass": true}, {"attribute_expression": "private int two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "two", "syntax_pass": true}, {"attribute_expression": "private long three;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "three", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String getOne() {\n            return one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOne", "params": [], "body": "                               {\n            return one;\n        }", "signature": "public String getOne()"}, {"syntax_pass": true, "original_string": "        public long getThree() {\n            return three;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "getThree", "params": [], "body": "                               {\n            return three;\n        }", "signature": "public long getThree()"}, {"syntax_pass": true, "original_string": "        public int getTwo() {\n            return two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getTwo", "params": [], "body": "                            {\n            return two;\n        }", "signature": "public int getTwo()"}, {"syntax_pass": true, "original_string": "        public void setOne(final String one) {\n            this.one = one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setOne", "params": [{"name": "one", "type": "String"}], "body": "                                             {\n            this.one = one;\n        }", "signature": "public void setOne(final String one)"}, {"syntax_pass": true, "original_string": "        public void setThree(final long three) {\n            this.three = three;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setThree", "params": [{"name": "three", "type": "long"}], "body": "                                               {\n            this.three = three;\n        }", "signature": "public void setThree(final long three)"}, {"syntax_pass": true, "original_string": "        public void setTwo(final int two) {\n            this.two = two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setTwo", "params": [{"name": "two", "type": "int"}], "body": "                                          {\n            this.two = two;\n        }", "signature": "public void setTwo(final int two)"}]}], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class GenerousBeanProcessorTest {\n\n    static class TestBean {\n        private String one;\n        private int two;\n        private long three;\n\n        public String getOne() {\n            return one;\n        }\n\n        public long getThree() {\n            return three;\n        }\n\n        public int getTwo() {\n            return two;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final long three) {\n            this.three = three;\n        }\n\n        public void setTwo(final int two) {\n            this.two = two;\n        }\n    }\n\n    private final GenerousBeanProcessor processor = new GenerousBeanProcessor();\n    @Mock\n    private ResultSetMetaData metaData;\n\n    private PropertyDescriptor[] propDescriptors;\n\n    @Before\n    public void setUp() throws Exception {\n        propDescriptors = new PropertyDescriptor[3];\n\n        propDescriptors[0] = new PropertyDescriptor(\"one\", TestBean.class);\n        propDescriptors[1] = new PropertyDescriptor(\"two\", TestBean.class);\n        propDescriptors[2] = new PropertyDescriptor(\"three\", TestBean.class);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesColumnLabelIsNull() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(1);\n        when(metaData.getColumnName(1)).thenReturn(\"juhu\");\n        when(metaData.getColumnLabel(1)).thenReturn(null);\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(2, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(-1, ret[1]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesMixedCase() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"tHree\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"One\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"tWO\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithOutUnderscores() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"three\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"one\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"two\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithSpaces() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"th ree\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"o n e\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"t wo\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithUnderscores() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"t_h_r_e_e\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"o_n_e\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"t_w_o\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final GenerousBeanProcessor processor = new GenerousBeanProcessor();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "GenerousBeanProcessor", "name": "processor = new GenerousBeanProcessor()", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSetMetaData metaData;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSetMetaData", "name": "metaData", "syntax_pass": true}, {"attribute_expression": "private PropertyDescriptor[] propDescriptors;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PropertyDescriptor[]", "name": "propDescriptors", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java.AsyncQueryRunnerTest", "name": "AsyncQueryRunnerTest", "file_path": "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java", "superclasses": "", "methods": ["[void]testAddBatchException()", "[void]testBadPrepareConnection()", "[void]testExecuteBatchException()", "[void]testExecuteQueryException()", "[void]testExecuteUpdateException()", "[void]testGoodBatch()", "[void]testGoodBatchDefaultConstructor()", "[void]testGoodBatchPmdTrue()", "[void]testGoodQuery()", "[void]testGoodQueryDefaultConstructor()", "[void]testGoodQueryPmdTrue()", "[void]testGoodUpdate()", "[void]testGoodUpdateDefaultConstructor()", "[void]testGoodUpdatePmdTrue()", "[void]testInsertUsesGivenQueryRunner()", "[void]testNoParamsQuery()", "[void]testNoParamsUpdate()", "[void]testNullConnectionBatch()", "[void]testNullConnectionQuery()", "[void]testNullConnectionUpdate()", "[void]testNullHandlerQuery()", "[void]testNullParamsArgBatch()", "[void]testNullParamsBatch()", "[void]testNullSqlBatch()", "[void]testNullSqlQuery()", "[void]testNullSqlUpdate()", "[void]testTooFewParamsBatch()", "[void]testTooFewParamsQuery()", "[void]testTooFewParamsUpdate()", "[void]testTooManyParamsBatch()", "[void]testTooManyParamsQuery()", "[void]testTooManyParamsUpdate()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java.AsyncQueryRunnerTest.[void]callBatchWithException(String,Object[][])", "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java.AsyncQueryRunnerTest.[void]callGoodBatch(Connection,Object[][])", "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java.AsyncQueryRunnerTest.[void]callGoodBatch(Object[][])", "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java.AsyncQueryRunnerTest.[void]callGoodQuery()", "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java.AsyncQueryRunnerTest.[void]callGoodQuery(Connection)", "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java.AsyncQueryRunnerTest.[void]callGoodUpdate()", "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java.AsyncQueryRunnerTest.[void]callGoodUpdate(Connection)", "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java.AsyncQueryRunnerTest.[void]callQueryWithException()", "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java.AsyncQueryRunnerTest.[void]callUpdateWithException()", "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java.AsyncQueryRunnerTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@SuppressWarnings(\"boxing\") // test code\n@RunWith(MockitoJUnitRunner.class)\npublic class AsyncQueryRunnerTest {\n    private AsyncQueryRunner runner;\n    private ArrayHandler handler;\n\n    @Mock\n    private DataSource dataSource;\n    @Mock\n    private Connection conn;\n    @Mock\n    private PreparedStatement prepStmt;\n    @Mock\n    private Statement stmt;\n    @Mock\n    private ParameterMetaData meta;\n    @Mock\n    private ResultSet results;\n\n    // helper method for calling batch when an exception is expected\n    private void callBatchWithException(final String sql, final Object[][] params) throws Exception {\n        Future<int[]> future = null;\n        boolean caught = false;\n\n        try {\n            future = runner.batch(sql, params);\n\n            future.get();\n\n            verify(prepStmt, times(2)).addBatch();\n            verify(prepStmt, times(1)).executeBatch();\n            verify(prepStmt, times(1)).close(); // make sure the statement is closed\n            verify(conn, times(1)).close(); // make sure the connection is closed\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    //\n    // Batch test cases\n    //\n    private void callGoodBatch(final Connection conn, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        final Future<int[]> future = runner.batch(conn, \"select * from blah where ? = ?\", params);\n\n        future.get();\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodBatch(final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        final Future<int[]> future = runner.batch(\"select * from blah where ? = ?\", params);\n\n        future.get();\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodQuery() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(sql, handler, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(sql, handler).get();\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Query test cases\n    //\n    private void callGoodQuery(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(conn, sql, handler, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(conn, sql, handler).get();\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodUpdate() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(sql, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(sql).get();\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        runner.update(\"update blah set unit = ?\", \"test\").get();\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Update test cases\n    //\n    private void callGoodUpdate(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(conn, sql, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(conn, sql).get();\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        sql = \"update blah set unit = ?\";\n        runner.update(conn, sql, \"test\").get();\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }\n\n    // helper method for calling batch when an exception is expected\n    private void callQueryWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.query(\"select * from blah where ? = ?\", handler, params).get();\n\n            verify(prepStmt, times(1)).executeQuery();\n            verify(results, times(1)).close();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling batch when an exception is expected\n    private void callUpdateWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.update(\"select * from blah where ? = ?\", params).get();\n\n            verify(prepStmt, times(1)).executeUpdate();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        when(dataSource.getConnection()).thenReturn(conn);\n\n        when(conn.prepareStatement(any(String.class))).thenReturn(prepStmt);\n        when(prepStmt.getParameterMetaData()).thenReturn(meta);\n        when(prepStmt.executeQuery()).thenReturn(results);\n\n        when(conn.createStatement()).thenReturn(stmt);\n        when(stmt.executeQuery(any(String.class))).thenReturn(results);\n\n        when(results.next()).thenReturn(false);\n\n         handler = new ArrayHandler();\n         runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1), new QueryRunner(dataSource));\n    }\n\n    @Test\n    public void testAddBatchException() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    //\n    // Random tests\n    //\n    @Test(expected = ExecutionException.class)\n    public void testBadPrepareConnection() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        runner.update(\"update blah set unit = test\").get();\n    }\n\n    @Test\n    public void testExecuteBatchException() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testExecuteQueryException() throws Exception {\n        callQueryWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteUpdateException() throws Exception {\n        doThrow(new SQLException()).when(prepStmt).executeUpdate();\n\n        callUpdateWithException(\"unit\", \"test\");\n    }\n\n    @Test\n    public void testGoodBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }\n\n    @Test\n    public void testGoodBatchDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(conn, params);\n    }\n\n    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodBatchPmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(dataSource, true, Executors.newFixedThreadPool(1));\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }\n\n    @Test\n    public void testGoodQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testGoodQueryDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        callGoodQuery(conn);\n    }\n\n    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodQueryPmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(true, Executors.newFixedThreadPool(1));\n        callGoodQuery(conn);\n    }\n\n    @Test\n    public void testGoodUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test\n    public void testGoodUpdateDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        callGoodUpdate(conn);\n    }\n\n    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodUpdatePmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(true, Executors.newFixedThreadPool(1));\n        callGoodUpdate(conn);\n    }\n\n    @Test\n    public void testInsertUsesGivenQueryRunner() throws Exception {\n        final QueryRunner mockQueryRunner = mock(QueryRunner.class, org.mockito.Mockito.withSettings().verboseLogging() // debug for Continuum\n        );\n        runner = new AsyncQueryRunner(Executors.newSingleThreadExecutor(), mockQueryRunner);\n\n        runner.insert(\"1\", handler);\n        runner.insert(\"2\", handler, \"param1\");\n        runner.insert(conn, \"3\", handler);\n        runner.insert(conn, \"4\", handler, \"param1\");\n\n        // give the Executor time to submit all insert statements. Otherwise the following verify statements will fail from time to time.\n        TimeUnit.MILLISECONDS.sleep(50);\n\n        verify(mockQueryRunner).insert(\"1\", handler);\n        verify(mockQueryRunner).insert(\"2\", handler, \"param1\");\n        verify(mockQueryRunner).insert(conn, \"3\", handler);\n        verify(mockQueryRunner).insert(conn, \"4\", handler, \"param1\");\n    }\n\n    @Test\n    public void testNoParamsQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testNoParamsUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullConnectionBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.batch(\"select * from blah where ? = ?\", params).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullConnectionQuery() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.query(\"select * from blah where ? = ?\", handler, \"unit\", \"test\").get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullConnectionUpdate() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.update(\"select * from blah where ? = ?\", \"unit\", \"test\").get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullHandlerQuery() throws Exception {\n        runner.query(\"select * from blah where ? = ?\", null).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullParamsArgBatch() throws Exception {\n        runner.batch(\"select * from blah where ? = ?\", null).get();\n    }\n\n    @Test\n    public void testNullParamsBatch() throws Exception {\n        final String[][] params = { { null, \"unit\" }, { \"test\", null } };\n\n        callGoodBatch(params);\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullSqlBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        runner.batch(null, params).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullSqlQuery() throws Exception {\n        runner.query(null, handler).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullSqlUpdate() throws Exception {\n        runner.update(null).get();\n    }\n\n    @Test\n    public void testTooFewParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\" }, { \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooFewParamsQuery() throws Exception {\n        callQueryWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooManyParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\", \"unit\" }, { \"test\", \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooManyParamsQuery() throws Exception {\n        callQueryWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\", \"test\", \"fail\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private AsyncQueryRunner runner;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "AsyncQueryRunner", "name": "runner", "syntax_pass": true}, {"attribute_expression": "private ArrayHandler handler;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayHandler", "name": "handler", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private DataSource dataSource;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "DataSource", "name": "dataSource", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private Connection conn;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "Connection", "name": "conn", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private PreparedStatement prepStmt;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "PreparedStatement", "name": "prepStmt", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private Statement stmt;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "Statement", "name": "stmt", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ParameterMetaData meta;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterMetaData", "name": "meta", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSet results;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "results", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/ServiceLoaderTest.java.ServiceLoaderTest", "name": "ServiceLoaderTest", "file_path": "src/test/java/org/apache/commons/dbutils/ServiceLoaderTest.java", "superclasses": "", "methods": ["[void]testFindMoreThanLocalColumns()", "[void]testFindMoreThanLocalProperties()", "[void]testFindsLocalColumnHandler()", "[void]testFindsLocalPropertyHandler()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/ServiceLoaderTest.java.ServiceLoaderTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ServiceLoaderTest {\n    private ServiceLoader<ColumnHandler> columns;\n    private ServiceLoader<PropertyHandler> properties;\n\n    @Before\n    public void setUp() {\n        columns = ServiceLoader.load(ColumnHandler.class);\n        properties = ServiceLoader.load(PropertyHandler.class);\n    }\n\n    /**\n     * Verifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n     */\n    @Test\n    public void testFindMoreThanLocalColumns() {\n        int count = 0;\n        for (final ColumnHandler<?> handler : columns) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }\n\n    /**\n     * Verifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n     */\n    @Test\n    public void testFindMoreThanLocalProperties() {\n        int count = 0;\n        for (final PropertyHandler handler : properties) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }\n\n    @Test\n    public void testFindsLocalColumnHandler() {\n        boolean found = false;\n        for (final ColumnHandler<?> handler : columns) {\n            // this class is defined outside of the main classes in dbutils\n            if (handler instanceof TestColumnHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }\n\n    @Test\n    public void testFindsLocalPropertyHandler() {\n        boolean found = false;\n        for (final PropertyHandler handler : properties) {\n            // this class is defined outside of the main classes in dbutils\n            if (handler instanceof TestPropertyHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ServiceLoader<ColumnHandler> columns;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ServiceLoader<ColumnHandler>", "name": "columns", "syntax_pass": true}, {"attribute_expression": "private ServiceLoader<PropertyHandler> properties;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ServiceLoader<PropertyHandler>", "name": "properties", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/ResultSetIterator_hasNextTest.java.ResultSetIterator_hasNextTest", "name": "ResultSetIterator_hasNextTest", "file_path": "src/test/java/org/apache/commons/dbutils/ResultSetIterator_hasNextTest.java", "superclasses": "", "methods": ["[void]testHasNextReturnsTrueWhenNotLast()", "[void]testHasNextReturnsFalseWhenLast()", "[void]testHasNextThrowsRuntimeExceptionOnSQLException()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/ResultSetIterator_hasNextTest.java.ResultSetIterator_hasNextTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ResultSetIterator_hasNextTest {\n\n    private ResultSet resultSet;\n    private ResultSetIterator resultSetIterator;\n\n    @Before\n    public void setUp() throws SQLException {\n        resultSet = mock(ResultSet.class);\n        resultSetIterator = new ResultSetIterator(resultSet);\n    }\n\n    @Test\n    public void testHasNextReturnsTrueWhenNotLast() throws SQLException {\n        when(resultSet.isLast()).thenReturn(false);\n        assertTrue(resultSetIterator.hasNext());\n    }\n\n    @Test\n    public void testHasNextReturnsFalseWhenLast() throws SQLException {\n        when(resultSet.isLast()).thenReturn(true);\n        assertFalse(resultSetIterator.hasNext());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testHasNextThrowsRuntimeExceptionOnSQLException() throws SQLException {\n        when(resultSet.isLast()).thenThrow(new SQLException(\"Mocked SQLException\"));\n        resultSetIterator.hasNext();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ResultSet resultSet;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "resultSet", "syntax_pass": true}, {"attribute_expression": "private ResultSetIterator resultSetIterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSetIterator", "name": "resultSetIterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/BeanMapHandlerTest.java.BeanMapHandlerTest", "name": "BeanMapHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/BeanMapHandlerTest.java", "superclasses": "", "methods": ["[void]testBeanMapHandlerClassOfV()", "[void]testBeanMapHandlerClassOfVInt()", "[void]testBeanMapHandlerClassOfVRowProcessor()", "[void]testBeanMapHandlerClassOfVString()", "[void]testEmptyResultSet()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/BeanMapHandlerTest.java.BeanMapHandlerTest.[void]handle()", "src/test/java/org/apache/commons/dbutils/handlers/BeanMapHandlerTest.java.BeanMapHandlerTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class BeanMapHandlerTest {\n\n    private BeanMapHandler<Long, TestBean> bmh;\n    private Map<Long, TestBean> res;\n    @Mock\n    private ResultSet rs;\n    @Mock\n    private ResultSetMetaData rsmd;\n    @Mock\n    private RowProcessor rp;\n\n    private void handle() throws Exception {\n        res = bmh.handle(rs);\n        assertNotNull(res.get(Long.valueOf(23L)));\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        when(Boolean.valueOf(rs.next())).thenReturn(Boolean.TRUE, Boolean.FALSE);\n        when(rs.getObject(1)).thenReturn(Long.valueOf(23L));\n        when(rs.getObject(2)).thenReturn(Long.valueOf(23L));\n        when(rs.getObject(\"id\")).thenReturn(Long.valueOf(23L));\n        when(rs.getMetaData()).thenReturn(rsmd);\n        when(rp.toBean(rs, TestBean.class)).thenReturn(new TestBean());\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfV() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class);\n        handle();\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfVInt() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, 2);\n        handle();\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfVRowProcessor() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, rp);\n        handle();\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfVString() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, \"id\");\n        handle();\n    }\n\n    @Test\n    public void testEmptyResultSet() throws Exception {\n        when(Boolean.valueOf(rs.next())).thenReturn(Boolean.FALSE);\n        bmh = new BeanMapHandler<>(TestBean.class);\n        res = bmh.handle(rs);\n        assertNull(res.get(Long.valueOf(23L)));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private BeanMapHandler<Long, TestBean> bmh;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BeanMapHandler<Long, TestBean>", "name": "bmh", "syntax_pass": true}, {"attribute_expression": "private Map<Long, TestBean> res;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<Long, TestBean>", "name": "res", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSet rs;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "rs", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSetMetaData rsmd;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSetMetaData", "name": "rsmd", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private RowProcessor rp;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "RowProcessor", "name": "rp", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/columns/StringColumnHandlerTest.java.StringColumnHandlerTest", "name": "StringColumnHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/StringColumnHandlerTest.java", "superclasses": "", "methods": ["[void]testApplyType()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/columns/StringColumnHandlerTest.java.StringColumnHandlerTest.[]StringColumnHandlerTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class StringColumnHandlerTest extends AbstractTestColumnHandler<String> {\n\n    public StringColumnHandlerTest() {\n        super(new StringColumnHandler(), String.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getString(1)).thenReturn(\"tester\");\n        assertEquals(String.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/columns/ShortColumnHandlerTest.java.ShortColumnHandlerTest", "name": "ShortColumnHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/ShortColumnHandlerTest.java", "superclasses": "", "methods": ["[void]testApplyType()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/columns/ShortColumnHandlerTest.java.ShortColumnHandlerTest.[]ShortColumnHandlerTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class ShortColumnHandlerTest extends AbstractTestColumnHandler<Short> {\n\n    public ShortColumnHandlerTest() {\n        super(new ShortColumnHandler(), Short.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getShort(1)).thenReturn(Short.MIN_VALUE);\n        assertEquals(Short.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/columns/TimestampColumnHandlerTest.java.TimestampColumnHandlerTest", "name": "TimestampColumnHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/TimestampColumnHandlerTest.java", "superclasses": "", "methods": ["[void]testApplyType()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/columns/TimestampColumnHandlerTest.java.TimestampColumnHandlerTest.[]TimestampColumnHandlerTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class TimestampColumnHandlerTest extends AbstractTestColumnHandler<Timestamp> {\n\n    public TimestampColumnHandlerTest() {\n        super(new TimestampColumnHandler(), Timestamp.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getTimestamp(1)).thenReturn(new Timestamp(new Date().getTime()));\n        assertEquals(Timestamp.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/columns/BooleanColumnHandlerTest.java.BooleanColumnHandlerTest", "name": "BooleanColumnHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/BooleanColumnHandlerTest.java", "superclasses": "", "methods": ["[void]testApplyType()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/columns/BooleanColumnHandlerTest.java.BooleanColumnHandlerTest.[]BooleanColumnHandlerTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class BooleanColumnHandlerTest extends AbstractTestColumnHandler<Boolean> {\n\n    public BooleanColumnHandlerTest() {\n        super(new BooleanColumnHandler(), Boolean.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getBoolean(1)).thenReturn(Boolean.TRUE);\n        assertEquals(Boolean.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/columns/DoubleColumnHandlerTest.java.DoubleColumnHandlerTest", "name": "DoubleColumnHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/DoubleColumnHandlerTest.java", "superclasses": "", "methods": ["[void]testApplyType()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/columns/DoubleColumnHandlerTest.java.DoubleColumnHandlerTest.[]DoubleColumnHandlerTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class DoubleColumnHandlerTest extends AbstractTestColumnHandler<Double> {\n\n    public DoubleColumnHandlerTest() {\n        super(new DoubleColumnHandler(), Double.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getDouble(1)).thenReturn(Double.MIN_VALUE);\n        assertEquals(Double.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/columns/LongColumnHandlerTest.java.LongColumnHandlerTest", "name": "LongColumnHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/LongColumnHandlerTest.java", "superclasses": "", "methods": ["[void]testApplyType()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/columns/LongColumnHandlerTest.java.LongColumnHandlerTest.[]LongColumnHandlerTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class LongColumnHandlerTest extends AbstractTestColumnHandler<Long> {\n\n    public LongColumnHandlerTest() {\n        super(new LongColumnHandler(), Long.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getLong(1)).thenReturn(Long.MIN_VALUE);\n        assertEquals(Long.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/columns/SQLXMLColumnHandlerTest.java.SQLXMLColumnHandlerTest", "name": "SQLXMLColumnHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/SQLXMLColumnHandlerTest.java", "superclasses": "", "methods": ["[void]testApplyType()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/columns/SQLXMLColumnHandlerTest.java.SQLXMLColumnHandlerTest.[]SQLXMLColumnHandlerTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class SQLXMLColumnHandlerTest extends AbstractTestColumnHandler<SQLXML> {\n\n    @Mock\n    private SQLXML sqlxml;\n\n    public SQLXMLColumnHandlerTest() {\n        super(new SQLXMLColumnHandler(), SQLXML.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getSQLXML(1)).thenReturn(sqlxml);\n        assertTrue(SQLXML.class.isAssignableFrom(getColumnHandler().apply(getResultSet(), 1).getClass()));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@Mock\n    private SQLXML sqlxml;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "SQLXML", "name": "sqlxml", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/columns/ByteColumnHandlerTest.java.ByteColumnHandlerTest", "name": "ByteColumnHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/ByteColumnHandlerTest.java", "superclasses": "", "methods": ["[void]testApplyType()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/columns/ByteColumnHandlerTest.java.ByteColumnHandlerTest.[]ByteColumnHandlerTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class ByteColumnHandlerTest extends AbstractTestColumnHandler<Byte> {\n\n    public ByteColumnHandlerTest() {\n        super(new ByteColumnHandler(), Byte.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getByte(1)).thenReturn(Byte.MIN_VALUE);\n        assertEquals(Byte.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/columns/IntegerColumnHandlerTest.java.IntegerColumnHandlerTest", "name": "IntegerColumnHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/IntegerColumnHandlerTest.java", "superclasses": "", "methods": ["[void]testApplyType()", "[void]testMatchNegative()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/columns/IntegerColumnHandlerTest.java.IntegerColumnHandlerTest.[]IntegerColumnHandlerTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class IntegerColumnHandlerTest extends AbstractTestColumnHandler<Integer> {\n\n    public IntegerColumnHandlerTest() {\n        super(new IntegerColumnHandler(), Integer.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getInt(1)).thenReturn(Integer.MIN_VALUE);\n        assertEquals(Integer.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n\n    @Override\n    @Test\n    public void testMatchNegative() {\n        assertFalse(getColumnHandler().match(Float.class));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/columns/FloatColumnHandlerTest.java.FloatColumnHandlerTest", "name": "FloatColumnHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/FloatColumnHandlerTest.java", "superclasses": "", "methods": ["[void]testApplyType()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/columns/FloatColumnHandlerTest.java.FloatColumnHandlerTest.[]FloatColumnHandlerTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class FloatColumnHandlerTest extends AbstractTestColumnHandler<Float> {\n\n    public FloatColumnHandlerTest() {\n        super(new FloatColumnHandler(), Float.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getFloat(1)).thenReturn(Float.MIN_VALUE);\n        assertEquals(Float.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/properties/StringEnumPropertyHandler_applyTest.java.StringEnumPropertyHandler_applyTest", "name": "StringEnumPropertyHandler_applyTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/StringEnumPropertyHandler_applyTest.java", "superclasses": "", "methods": ["[void]testApply_ValidEnum()", "[void]testApply_InvalidEnum()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class StringEnumPropertyHandler_applyTest {\n\n    @Test\n    public void testApply_ValidEnum() {\n        StringEnumPropertyHandler handler = new StringEnumPropertyHandler();\n        Object result = handler.apply(TestEnum.class, \"VALUE1\");\n        assertEquals(TestEnum.VALUE1, result);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testApply_InvalidEnum() {\n        StringEnumPropertyHandler handler = new StringEnumPropertyHandler();\n        handler.apply(TestEnum.class, \"INVALID\");\n    }\n\n    private enum TestEnum {\n        VALUE1, VALUE2\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/properties/PropertyHandlerTest.java.PropertyHandlerTest", "name": "PropertyHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/PropertyHandlerTest.java", "superclasses": "", "methods": ["[void]testFoundMoreThanLocal()", "[void]testServiceLoaderFindsMultipleRegistries()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/properties/PropertyHandlerTest.java.PropertyHandlerTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PropertyHandlerTest {\n    private ServiceLoader<PropertyHandler> loader;\n\n    @Before\n    public void setUp() {\n        loader = ServiceLoader.load(PropertyHandler.class);\n    }\n\n    /**\n     * Verifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n     */\n    @Test\n    public void testFoundMoreThanLocal() {\n        int count = 0;\n        for (final PropertyHandler handler : loader) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }\n\n    @Test\n    public void testServiceLoaderFindsMultipleRegistries() {\n        boolean found = false;\n        for (final PropertyHandler handler : loader) {\n            // this class is defined outside of the main classes of dbutils\n            if (handler instanceof TestPropertyHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ServiceLoader<PropertyHandler> loader;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ServiceLoader<PropertyHandler>", "name": "loader", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/properties/StringEnumPropertyHandlerTest.java.StringEnumPropertyHandlerTest", "name": "StringEnumPropertyHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/StringEnumPropertyHandlerTest.java", "superclasses": "", "methods": ["[void]testMatch()", "[void]testMatchNegative()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/properties/StringEnumPropertyHandlerTest.java.StringEnumPropertyHandlerTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class StringEnumPropertyHandlerTest {\n    private StringEnumPropertyHandler handler;\n\n    @Before\n    public void setUp() {\n        this.handler = new StringEnumPropertyHandler();\n    }\n\n    @Test\n    public void testMatch() {\n        assertTrue(handler.match(TestEnum.class, \"test\"));\n    }\n\n    @Test\n    public void testMatchNegative() {\n        assertFalse(handler.match(TestEnum.class, Double.valueOf(1)));\n\n        assertFalse(handler.match(Integer.class, \"\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private StringEnumPropertyHandler handler;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StringEnumPropertyHandler", "name": "handler", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandler_applyTest.java.DatePropertyHandler_applyTest", "name": "DatePropertyHandler_applyTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandler_applyTest.java", "superclasses": "", "methods": ["[void]testApplyWithJavaSqlDate()", "[void]testApplyWithJavaSqlTime()", "[void]testApplyWithJavaSqlTimestamp()", "[void]testApplyWithDefault()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DatePropertyHandler_applyTest {\n\n    private DatePropertyHandler handler = new DatePropertyHandler();\n\n    @Test\n    public void testApplyWithJavaSqlDate() {\n        Date dateValue = new Date(System.currentTimeMillis());\n        Object result = handler.apply(Date.class, dateValue);\n        assertEquals(java.sql.Date.class, result.getClass());\n    }\n\n    @Test\n    public void testApplyWithJavaSqlTime() {\n        Date dateValue = new Date(System.currentTimeMillis());\n        Object result = handler.apply(Time.class, dateValue);\n        assertEquals(java.sql.Time.class, result.getClass());\n    }\n\n    @Test\n    public void testApplyWithJavaSqlTimestamp() {\n        Date dateValue = new Date(System.currentTimeMillis());\n        Object result = handler.apply(Timestamp.class, dateValue);\n        assertEquals(Timestamp.class, result.getClass());\n    }\n\n    @Test\n    public void testApplyWithDefault() {\n        Date dateValue = new Date(System.currentTimeMillis());\n        Object result = handler.apply(String.class, dateValue);\n        assertEquals(Date.class, result.getClass());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DatePropertyHandler handler = new DatePropertyHandler();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DatePropertyHandler", "name": "handler = new DatePropertyHandler()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandler_matchTest.java.DatePropertyHandler_matchTest", "name": "DatePropertyHandler_matchTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandler_matchTest.java", "superclasses": "", "methods": ["[void]testMatch_JavaSqlDate()", "[void]testMatch_JavaSqlTime()", "[void]testMatch_JavaSqlTimestamp_NotTimestampInstance()", "[void]testMatch_JavaSqlTimestamp_IsTimestampInstance()", "[void]testMatch_NonDateValue()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DatePropertyHandler_matchTest {\n\n    private DatePropertyHandler handler = new DatePropertyHandler();\n\n    @Test\n    public void testMatch_JavaSqlDate() {\n        assertTrue(handler.match(java.sql.Date.class, new Date()));\n    }\n\n    @Test\n    public void testMatch_JavaSqlTime() {\n        assertTrue(handler.match(java.sql.Time.class, new Date()));\n    }\n\n    @Test\n    public void testMatch_JavaSqlTimestamp_NotTimestampInstance() {\n        assertTrue(handler.match(Timestamp.class, new Date()));\n    }\n\n    @Test\n    public void testMatch_JavaSqlTimestamp_IsTimestampInstance() {\n        assertFalse(handler.match(Timestamp.class, new Timestamp(System.currentTimeMillis())));\n    }\n\n    @Test\n    public void testMatch_NonDateValue() {\n        assertFalse(handler.match(Date.class, \"not a date\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DatePropertyHandler handler = new DatePropertyHandler();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DatePropertyHandler", "name": "handler = new DatePropertyHandler()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandlerTest.java.DatePropertyHandlerTest", "name": "DatePropertyHandlerTest", "file_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandlerTest.java", "superclasses": "", "methods": ["[void]testApplyTypeOfDate()", "[void]testApplyTypeOfTime()", "[void]testApplyTypeOfTimestamp()", "[void]testMatch()", "[void]testMatchNegative()", "[void]testNotMatch()"], "method_uris": ["src/test/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandlerTest.java.DatePropertyHandlerTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DatePropertyHandlerTest {\n    private DatePropertyHandler handler;\n    private Date testValue;\n\n    @Before\n    public void setUp() {\n        this.handler = new DatePropertyHandler();\n        this.testValue = new Date();\n    }\n\n    @Test\n    public void testApplyTypeOfDate() throws Exception {\n        assertEquals(java.sql.Date.class, handler.apply(java.sql.Date.class, testValue).getClass());\n    }\n\n    @Test\n    public void testApplyTypeOfTime() throws Exception {\n        assertEquals(Time.class, handler.apply(java.sql.Time.class, testValue).getClass());\n    }\n\n    @Test\n    public void testApplyTypeOfTimestamp() throws Exception {\n        assertEquals(Timestamp.class, handler.apply(java.sql.Timestamp.class, testValue).getClass());\n    }\n\n    @Test\n    public void testMatch() {\n        assertTrue(handler.match(java.sql.Date.class, testValue));\n        assertTrue(handler.match(java.sql.Time.class, testValue));\n        assertTrue(handler.match(java.sql.Timestamp.class, testValue));\n    }\n\n    @Test\n    public void testMatchNegative() {\n        assertFalse(handler.match(Float.class, null));\n        assertFalse(handler.match(Float.class, testValue));\n    }\n\n    @Test\n    public void testNotMatch() {\n        final Timestamp ts = new Timestamp(testValue.getTime());\n        assertFalse(handler.match(java.sql.Timestamp.class, ts));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DatePropertyHandler handler;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DatePropertyHandler", "name": "handler", "syntax_pass": true}, {"attribute_expression": "private Date testValue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Date", "name": "testValue", "syntax_pass": true}]}]