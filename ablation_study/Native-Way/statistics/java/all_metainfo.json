[{"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.function.Executable;\n\nimport java.util.Locale;\n\nimport static java.util.Collections.singleton;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.IsEqual.equalTo;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class ExpressionFactoryTest {\n    \n    @Test\n    public void creates_cucumber_expression_for_empty() {\n        assertCucumberExpression(\"\");\n    }\n    \n    @Test\n    public void creates_cucumber_expression_by_default() {\n        assertCucumberExpression(\"strings are cukexp by default\");\n    }\n\n    @Test\n    public void creates_regular_expression_for_anchors() {\n        assertRegularExpression(\"^definitely a regexp$\");\n    }\n\n    @Test\n    public void creates_regular_expression_for_slashes() {\n        assertRegularExpression(\"surely a regexp\", \"/surely a regexp/\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_parenthesis_with_alpha() {\n        assertCucumberExpression(\"this look(s) like a cukexp\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_escaped_parenthesis_with_regex_symbols() {\n        assertCucumberExpression(\"this looks\\\\( i.e: no regex symbols) like a cukexp\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_escaped_parenthesis_with_alpha() {\n        assertCucumberExpression(\"a heavy storm forecast \\\\(BF {int}+)\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_parenthesis_with_regex_symbols() {\n        assertCucumberExpression(\"the temperature is (+){int} degrees celsius\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_only_begin_anchor() {\n        assertRegularExpression(\"^this looks like a regexp\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_only_end_anchor() {\n        assertRegularExpression(\"this looks like a regexp$\");\n    }\n\n    @Test\n    public void creates_regular_expression_for_slashed_anchors() {\n        assertRegularExpression(\"^please remove slashes$\", \"/^please remove slashes$/\");\n    }\n\n    @Test\n    public void explains_cukexp_regexp_mix() {\n        final Executable testMethod = () -> createExpression(\"^the seller has {int} strike(s)$\");\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"You cannot use anchors (^ or $) in Cucumber Expressions. Please remove them from ^the seller has {int} strike(s)$\")));\n    }\n\n    private void assertRegularExpression(String expressionString) {\n        assertRegularExpression(expressionString, expressionString);\n    }\n\n    private void assertRegularExpression(String expectedSource, String expressionString) {\n        assertExpression(RegularExpression.class, expectedSource, expressionString);\n    }\n\n    private void assertCucumberExpression(String expressionString) {\n        assertExpression(CucumberExpression.class, expressionString, expressionString);\n    }\n\n    private void assertExpression(Class<? extends Expression> expectedClass, String expectedSource, String expressionString) {\n        Expression expression = createExpression(expressionString);\n        assertEquals(expectedClass, expression.getClass());\n        if (expectedSource != null) {\n            assertEquals(expectedSource, expression.getSource());\n        }\n    }\n\n    private Expression createExpression(String expressionString) {\n        return new ExpressionFactory(new ParameterTypeRegistry(Locale.ENGLISH)).createExpression(expressionString);\n    }\n\n}\n", "file_hash": "df3245aabf6340e9ea2b7f828bd9fd81951d73a8a08438ffe3da7d8255d4e6bc", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.function.Executable;", "import java.util.Locale;", "import static java.util.Collections.singleton;", "import static org.hamcrest.CoreMatchers.is;", "import static org.hamcrest.MatcherAssert.assertThat;", "import static org.hamcrest.core.IsEqual.equalTo;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertThrows;"], "methods": [], "classes": [{"original_string": "public class ExpressionFactoryTest {\n    \n    @Test\n    public void creates_cucumber_expression_for_empty() {\n        assertCucumberExpression(\"\");\n    }\n    \n    @Test\n    public void creates_cucumber_expression_by_default() {\n        assertCucumberExpression(\"strings are cukexp by default\");\n    }\n\n    @Test\n    public void creates_regular_expression_for_anchors() {\n        assertRegularExpression(\"^definitely a regexp$\");\n    }\n\n    @Test\n    public void creates_regular_expression_for_slashes() {\n        assertRegularExpression(\"surely a regexp\", \"/surely a regexp/\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_parenthesis_with_alpha() {\n        assertCucumberExpression(\"this look(s) like a cukexp\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_escaped_parenthesis_with_regex_symbols() {\n        assertCucumberExpression(\"this looks\\\\( i.e: no regex symbols) like a cukexp\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_escaped_parenthesis_with_alpha() {\n        assertCucumberExpression(\"a heavy storm forecast \\\\(BF {int}+)\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_parenthesis_with_regex_symbols() {\n        assertCucumberExpression(\"the temperature is (+){int} degrees celsius\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_only_begin_anchor() {\n        assertRegularExpression(\"^this looks like a regexp\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_only_end_anchor() {\n        assertRegularExpression(\"this looks like a regexp$\");\n    }\n\n    @Test\n    public void creates_regular_expression_for_slashed_anchors() {\n        assertRegularExpression(\"^please remove slashes$\", \"/^please remove slashes$/\");\n    }\n\n    @Test\n    public void explains_cukexp_regexp_mix() {\n        final Executable testMethod = () -> createExpression(\"^the seller has {int} strike(s)$\");\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"You cannot use anchors (^ or $) in Cucumber Expressions. Please remove them from ^the seller has {int} strike(s)$\")));\n    }\n\n    private void assertRegularExpression(String expressionString) {\n        assertRegularExpression(expressionString, expressionString);\n    }\n\n    private void assertRegularExpression(String expectedSource, String expressionString) {\n        assertExpression(RegularExpression.class, expectedSource, expressionString);\n    }\n\n    private void assertCucumberExpression(String expressionString) {\n        assertExpression(CucumberExpression.class, expressionString, expressionString);\n    }\n\n    private void assertExpression(Class<? extends Expression> expectedClass, String expectedSource, String expressionString) {\n        Expression expression = createExpression(expressionString);\n        assertEquals(expectedClass, expression.getClass());\n        if (expectedSource != null) {\n            assertEquals(expectedSource, expression.getSource());\n        }\n    }\n\n    private Expression createExpression(String expressionString) {\n        return new ExpressionFactory(new ParameterTypeRegistry(Locale.ENGLISH)).createExpression(expressionString);\n    }\n\n}", "definition": "public class ExpressionFactoryTest", "class_docstring": "", "name": "ExpressionFactoryTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void creates_cucumber_expression_for_empty() {\n        assertCucumberExpression(\"\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "creates_cucumber_expression_for_empty", "params": [], "body": "                                                        {\n        assertCucumberExpression(\"\");\n    }", "signature": "@Test\n    public void creates_cucumber_expression_for_empty()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void creates_cucumber_expression_by_default() {\n        assertCucumberExpression(\"strings are cukexp by default\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "creates_cucumber_expression_by_default", "params": [], "body": "                                                         {\n        assertCucumberExpression(\"strings are cukexp by default\");\n    }", "signature": "@Test\n    public void creates_cucumber_expression_by_default()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void creates_regular_expression_for_anchors() {\n        assertRegularExpression(\"^definitely a regexp$\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "creates_regular_expression_for_anchors", "params": [], "body": "                                                         {\n        assertRegularExpression(\"^definitely a regexp$\");\n    }", "signature": "@Test\n    public void creates_regular_expression_for_anchors()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void creates_regular_expression_for_slashes() {\n        assertRegularExpression(\"surely a regexp\", \"/surely a regexp/\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "creates_regular_expression_for_slashes", "params": [], "body": "                                                         {\n        assertRegularExpression(\"surely a regexp\", \"/surely a regexp/\");\n    }", "signature": "@Test\n    public void creates_regular_expression_for_slashes()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void creates_cucumber_expression_for_parenthesis_with_alpha() {\n        assertCucumberExpression(\"this look(s) like a cukexp\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "creates_cucumber_expression_for_parenthesis_with_alpha", "params": [], "body": "                                                                         {\n        assertCucumberExpression(\"this look(s) like a cukexp\");\n    }", "signature": "@Test\n    public void creates_cucumber_expression_for_parenthesis_with_alpha()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void creates_cucumber_expression_for_escaped_parenthesis_with_regex_symbols() {\n        assertCucumberExpression(\"this looks\\\\( i.e: no regex symbols) like a cukexp\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "creates_cucumber_expression_for_escaped_parenthesis_with_regex_symbols", "params": [], "body": "                                                                                         {\n        assertCucumberExpression(\"this looks\\\\( i.e: no regex symbols) like a cukexp\");\n    }", "signature": "@Test\n    public void creates_cucumber_expression_for_escaped_parenthesis_with_regex_symbols()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void creates_cucumber_expression_for_escaped_parenthesis_with_alpha() {\n        assertCucumberExpression(\"a heavy storm forecast \\\\(BF {int}+)\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "creates_cucumber_expression_for_escaped_parenthesis_with_alpha", "params": [], "body": "                                                                                 {\n        assertCucumberExpression(\"a heavy storm forecast \\\\(BF {int}+)\");\n    }", "signature": "@Test\n    public void creates_cucumber_expression_for_escaped_parenthesis_with_alpha()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void creates_cucumber_expression_for_parenthesis_with_regex_symbols() {\n        assertCucumberExpression(\"the temperature is (+){int} degrees celsius\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "creates_cucumber_expression_for_parenthesis_with_regex_symbols", "params": [], "body": "                                                                                 {\n        assertCucumberExpression(\"the temperature is (+){int} degrees celsius\");\n    }", "signature": "@Test\n    public void creates_cucumber_expression_for_parenthesis_with_regex_symbols()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void creates_cucumber_expression_for_only_begin_anchor() {\n        assertRegularExpression(\"^this looks like a regexp\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "creates_cucumber_expression_for_only_begin_anchor", "params": [], "body": "                                                                    {\n        assertRegularExpression(\"^this looks like a regexp\");\n    }", "signature": "@Test\n    public void creates_cucumber_expression_for_only_begin_anchor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void creates_cucumber_expression_for_only_end_anchor() {\n        assertRegularExpression(\"this looks like a regexp$\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "creates_cucumber_expression_for_only_end_anchor", "params": [], "body": "                                                                  {\n        assertRegularExpression(\"this looks like a regexp$\");\n    }", "signature": "@Test\n    public void creates_cucumber_expression_for_only_end_anchor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void creates_regular_expression_for_slashed_anchors() {\n        assertRegularExpression(\"^please remove slashes$\", \"/^please remove slashes$/\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "creates_regular_expression_for_slashed_anchors", "params": [], "body": "                                                                 {\n        assertRegularExpression(\"^please remove slashes$\", \"/^please remove slashes$/\");\n    }", "signature": "@Test\n    public void creates_regular_expression_for_slashed_anchors()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void explains_cukexp_regexp_mix() {\n        final Executable testMethod = () -> createExpression(\"^the seller has {int} strike(s)$\");\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"You cannot use anchors (^ or $) in Cucumber Expressions. Please remove them from ^the seller has {int} strike(s)$\")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "explains_cukexp_regexp_mix", "params": [], "body": "                                             {\n        final Executable testMethod = () -> createExpression(\"^the seller has {int} strike(s)$\");\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"You cannot use anchors (^ or $) in Cucumber Expressions. Please remove them from ^the seller has {int} strike(s)$\")));\n    }", "signature": "@Test\n    public void explains_cukexp_regexp_mix()"}, {"syntax_pass": true, "original_string": "    private void assertRegularExpression(String expressionString) {\n        assertRegularExpression(expressionString, expressionString);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertRegularExpression", "params": [{"name": "expressionString", "type": "String"}], "body": "                                                                  {\n        assertRegularExpression(expressionString, expressionString);\n    }", "signature": "private void assertRegularExpression(String expressionString)"}, {"syntax_pass": true, "original_string": "    private void assertRegularExpression(String expectedSource, String expressionString) {\n        assertExpression(RegularExpression.class, expectedSource, expressionString);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertRegularExpression", "params": [{"name": "expectedSource", "type": "String"}, {"name": "expressionString", "type": "String"}], "body": "                                                                                         {\n        assertExpression(RegularExpression.class, expectedSource, expressionString);\n    }", "signature": "private void assertRegularExpression(String expectedSource, String expressionString)"}, {"syntax_pass": true, "original_string": "    private void assertCucumberExpression(String expressionString) {\n        assertExpression(CucumberExpression.class, expressionString, expressionString);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertCucumberExpression", "params": [{"name": "expressionString", "type": "String"}], "body": "                                                                   {\n        assertExpression(CucumberExpression.class, expressionString, expressionString);\n    }", "signature": "private void assertCucumberExpression(String expressionString)"}, {"syntax_pass": true, "original_string": "    private void assertExpression(Class<? extends Expression> expectedClass, String expectedSource, String expressionString) {\n        Expression expression = createExpression(expressionString);\n        assertEquals(expectedClass, expression.getClass());\n        if (expectedSource != null) {\n            assertEquals(expectedSource, expression.getSource());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertExpression", "params": [{"name": "expectedClass", "type": "Class<? extends Expression>"}, {"name": "expectedSource", "type": "String"}, {"name": "expressionString", "type": "String"}], "body": "                                                                                                                             {\n        Expression expression = createExpression(expressionString);\n        assertEquals(expectedClass, expression.getClass());\n        if (expectedSource != null) {\n            assertEquals(expectedSource, expression.getSource());\n        }\n    }", "signature": "private void assertExpression(Class<? extends Expression> expectedClass, String expectedSource, String expressionString)"}, {"syntax_pass": true, "original_string": "    private Expression createExpression(String expressionString) {\n        return new ExpressionFactory(new ParameterTypeRegistry(Locale.ENGLISH)).createExpression(expressionString);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Expression", "classes": []}, "name": "createExpression", "params": [{"name": "expressionString", "type": "String"}], "body": "                                                                 {\n        return new ExpressionFactory(new ParameterTypeRegistry(Locale.ENGLISH)).createExpression(expressionString);\n    }", "signature": "private Expression createExpression(String expressionString)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ArgumentTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport static java.util.Collections.singletonList;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ArgumentTest {\n    @Test\n    public void exposes_parameter_type() {\n        TreeRegexp treeRegexp = new TreeRegexp(\"three (.*) mice\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        List<Argument<?>> arguments = Argument.build(\n                treeRegexp.match(\"three blind mice\"),\n                singletonList(parameterTypeRegistry.lookupByTypeName(\"string\")));\n        Argument<?> argument = arguments.get(0);\n        assertEquals(\"string\", argument.getParameterType().getName());\n    }\n\n}\n", "file_hash": "2fe369c33cac956dd3f0b5b731f20afb46cca0518e7bc66b2c4d50740a9dad3c", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.util.List;", "import java.util.Locale;", "import static java.util.Collections.singletonList;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class ArgumentTest {\n    @Test\n    public void exposes_parameter_type() {\n        TreeRegexp treeRegexp = new TreeRegexp(\"three (.*) mice\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        List<Argument<?>> arguments = Argument.build(\n                treeRegexp.match(\"three blind mice\"),\n                singletonList(parameterTypeRegistry.lookupByTypeName(\"string\")));\n        Argument<?> argument = arguments.get(0);\n        assertEquals(\"string\", argument.getParameterType().getName());\n    }\n\n}", "definition": "public class ArgumentTest", "class_docstring": "", "name": "ArgumentTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void exposes_parameter_type() {\n        TreeRegexp treeRegexp = new TreeRegexp(\"three (.*) mice\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        List<Argument<?>> arguments = Argument.build(\n                treeRegexp.match(\"three blind mice\"),\n                singletonList(parameterTypeRegistry.lookupByTypeName(\"string\")));\n        Argument<?> argument = arguments.get(0);\n        assertEquals(\"string\", argument.getParameterType().getName());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "exposes_parameter_type", "params": [], "body": "                                         {\n        TreeRegexp treeRegexp = new TreeRegexp(\"three (.*) mice\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        List<Argument<?>> arguments = Argument.build(\n                treeRegexp.match(\"three blind mice\"),\n                singletonList(parameterTypeRegistry.lookupByTypeName(\"string\")));\n        Argument<?> argument = arguments.get(0);\n        assertEquals(\"string\", argument.getParameterType().getName());\n    }", "signature": "@Test\n    public void exposes_parameter_type()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ParameterContext;\nimport org.junit.jupiter.api.function.Executable;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.converter.ArgumentConversionException;\nimport org.junit.jupiter.params.converter.ArgumentConverter;\nimport org.junit.jupiter.params.converter.ConvertWith;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.yaml.snakeyaml.Yaml;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.stream.Collectors;\n\nimport static java.nio.file.Files.newDirectoryStream;\nimport static java.nio.file.Files.newInputStream;\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.singletonList;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass CucumberExpressionTest {\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n            List<Argument<?>> match = expression.match(expectation.text);\n            List<?> values = match == null ? null : match.stream()\n                    .map(Argument::getValue)\n                    .collect(Collectors.toList());\n\n            assertThat(values, CustomMatchers.equalOrCloseTo(expectation.expected_args));\n        } else {\n            Executable executable = () -> {\n                CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n                expression.match(expectation.text);\n            };\n            CucumberExpressionException exception = assertThrows(CucumberExpressionException.class, executable);\n            assertThat(exception.getMessage(), equalTo(expectation.exception));\n        }\n    }\n\n    static class Expectation {\n        public String expression;\n        public String text;\n        public List<?> expected_args;\n        public String exception;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    // Misc tests\n\n    @Test\n    void exposes_source() {\n        String expr = \"I have {int} cuke(s)\";\n        assertEquals(expr, new CucumberExpression(expr, new ParameterTypeRegistry(Locale.ENGLISH)).getSource());\n    }\n\n    // Java-specific\n    @Test\n    void matches_anonymous_parameter_type_with_hint() {\n        assertEquals(singletonList(0.22f), match(\"{}\", \"0.22\", Float.class));\n    }\n\n    @Test\n    void documents_match_arguments() {\n        String expr = \"I have {int} cuke(s)\";\n        Expression expression = new CucumberExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(\"I have 7 cukes\");\n        assertEquals(7, args.get(0).getValue());\n    }\n\n    @Test\n    void matches_byte() {\n        assertEquals(singletonList(Byte.MAX_VALUE), match(\"{byte}\", \"127\"));\n    }\n\n    @Test\n    void matches_short() {\n        assertEquals(singletonList(Short.MAX_VALUE), match(\"{short}\", String.valueOf(Short.MAX_VALUE)));\n    }\n\n    @Test\n    void matches_long() {\n        assertEquals(singletonList(Long.MAX_VALUE), match(\"{long}\", String.valueOf(Long.MAX_VALUE)));\n    }\n\n    @Test\n    void matches_biginteger() {\n        BigInteger bigInteger = BigInteger.valueOf(Long.MAX_VALUE);\n        bigInteger = bigInteger.pow(10);\n        assertEquals(singletonList(bigInteger), match(\"{biginteger}\", bigInteger.toString()));\n    }\n\n    @Test\n    void matches_bigdecimal() {\n        BigDecimal bigDecimal = BigDecimal.valueOf(Math.PI);\n        assertEquals(singletonList(bigDecimal), match(\"{bigdecimal}\", bigDecimal.toString()));\n    }\n\n    @Test\n    void matches_double_with_comma_for_locale_using_comma() {\n        List<?> values = match(\"{double}\", \"1,22\", Locale.FRANCE);\n        assertEquals(singletonList(1.22), values);\n    }\n\n    @Test\n    void matches_float_with_zero() {\n        List<?> values = match(\"{float}\", \"0\", Locale.ENGLISH);\n        assertEquals(0.0f, values.get(0));\n    }\n\n    @Test\n    void unmatched_optional_groups_have_null_values() {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"textAndOrNumber\",\n                singletonList(\"([A-Z]+)?(?: )?([0-9]+)?\"),\n                new TypeReference<List<String>>() {\n                }.getType(),\n                new CaptureGroupTransformer<List<String>>() {\n                    @Override\n                    public List<String> transform(String... args) {\n                        return asList(args);\n                    }\n                },\n                false,\n                false)\n        );\n        assertThat(match(\"{textAndOrNumber}\", \"TLA\", parameterTypeRegistry), is(singletonList(asList(\"TLA\", null))));\n        assertThat(match(\"{textAndOrNumber}\", \"123\", parameterTypeRegistry), is(singletonList(asList(null, \"123\"))));\n    }\n\n    private List<?> match(String expr, String text, Type... typeHints) {\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }\n\n    private List<?> match(String expr, String text, Locale locale, Type... typeHints) {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(locale);\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }\n\n    private List<?> match(String expr, String text, ParameterTypeRegistry parameterTypeRegistry, Type... typeHints) {\n        CucumberExpression expression = new CucumberExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(text, typeHints);\n        if (args == null) {\n            return null;\n        } else {\n            List<Object> list = new ArrayList<>();\n            for (Argument<?> arg : args) {\n                Object value = arg.getValue();\n                list.add(value);\n            }\n            return list;\n        }\n    }\n}\n", "file_hash": "0ec82a5be6db22d598633bd013f75b7de1b9db9a3de2180f3b9f3d96e3c09513", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.extension.ParameterContext;", "import org.junit.jupiter.api.function.Executable;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.converter.ArgumentConversionException;", "import org.junit.jupiter.params.converter.ArgumentConverter;", "import org.junit.jupiter.params.converter.ConvertWith;", "import org.junit.jupiter.params.provider.MethodSource;", "import org.yaml.snakeyaml.Yaml;", "import java.io.IOException;", "import java.io.InputStream;", "import java.lang.reflect.Type;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import java.nio.file.Path;", "import java.nio.file.Paths;", "import java.util.ArrayList;", "import java.util.Comparator;", "import java.util.List;", "import java.util.Locale;", "import java.util.stream.Collectors;", "import static java.nio.file.Files.newDirectoryStream;", "import static java.nio.file.Files.newInputStream;", "import static java.util.Arrays.asList;", "import static java.util.Collections.singletonList;", "import static org.hamcrest.MatcherAssert.assertThat;", "import static org.hamcrest.Matchers.equalTo;", "import static org.hamcrest.core.Is.is;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertThrows;"], "methods": [], "classes": [{"original_string": "class CucumberExpressionTest {\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n            List<Argument<?>> match = expression.match(expectation.text);\n            List<?> values = match == null ? null : match.stream()\n                    .map(Argument::getValue)\n                    .collect(Collectors.toList());\n\n            assertThat(values, CustomMatchers.equalOrCloseTo(expectation.expected_args));\n        } else {\n            Executable executable = () -> {\n                CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n                expression.match(expectation.text);\n            };\n            CucumberExpressionException exception = assertThrows(CucumberExpressionException.class, executable);\n            assertThat(exception.getMessage(), equalTo(expectation.exception));\n        }\n    }\n\n    static class Expectation {\n        public String expression;\n        public String text;\n        public List<?> expected_args;\n        public String exception;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    // Misc tests\n\n    @Test\n    void exposes_source() {\n        String expr = \"I have {int} cuke(s)\";\n        assertEquals(expr, new CucumberExpression(expr, new ParameterTypeRegistry(Locale.ENGLISH)).getSource());\n    }\n\n    // Java-specific\n    @Test\n    void matches_anonymous_parameter_type_with_hint() {\n        assertEquals(singletonList(0.22f), match(\"{}\", \"0.22\", Float.class));\n    }\n\n    @Test\n    void documents_match_arguments() {\n        String expr = \"I have {int} cuke(s)\";\n        Expression expression = new CucumberExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(\"I have 7 cukes\");\n        assertEquals(7, args.get(0).getValue());\n    }\n\n    @Test\n    void matches_byte() {\n        assertEquals(singletonList(Byte.MAX_VALUE), match(\"{byte}\", \"127\"));\n    }\n\n    @Test\n    void matches_short() {\n        assertEquals(singletonList(Short.MAX_VALUE), match(\"{short}\", String.valueOf(Short.MAX_VALUE)));\n    }\n\n    @Test\n    void matches_long() {\n        assertEquals(singletonList(Long.MAX_VALUE), match(\"{long}\", String.valueOf(Long.MAX_VALUE)));\n    }\n\n    @Test\n    void matches_biginteger() {\n        BigInteger bigInteger = BigInteger.valueOf(Long.MAX_VALUE);\n        bigInteger = bigInteger.pow(10);\n        assertEquals(singletonList(bigInteger), match(\"{biginteger}\", bigInteger.toString()));\n    }\n\n    @Test\n    void matches_bigdecimal() {\n        BigDecimal bigDecimal = BigDecimal.valueOf(Math.PI);\n        assertEquals(singletonList(bigDecimal), match(\"{bigdecimal}\", bigDecimal.toString()));\n    }\n\n    @Test\n    void matches_double_with_comma_for_locale_using_comma() {\n        List<?> values = match(\"{double}\", \"1,22\", Locale.FRANCE);\n        assertEquals(singletonList(1.22), values);\n    }\n\n    @Test\n    void matches_float_with_zero() {\n        List<?> values = match(\"{float}\", \"0\", Locale.ENGLISH);\n        assertEquals(0.0f, values.get(0));\n    }\n\n    @Test\n    void unmatched_optional_groups_have_null_values() {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"textAndOrNumber\",\n                singletonList(\"([A-Z]+)?(?: )?([0-9]+)?\"),\n                new TypeReference<List<String>>() {\n                }.getType(),\n                new CaptureGroupTransformer<List<String>>() {\n                    @Override\n                    public List<String> transform(String... args) {\n                        return asList(args);\n                    }\n                },\n                false,\n                false)\n        );\n        assertThat(match(\"{textAndOrNumber}\", \"TLA\", parameterTypeRegistry), is(singletonList(asList(\"TLA\", null))));\n        assertThat(match(\"{textAndOrNumber}\", \"123\", parameterTypeRegistry), is(singletonList(asList(null, \"123\"))));\n    }\n\n    private List<?> match(String expr, String text, Type... typeHints) {\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }\n\n    private List<?> match(String expr, String text, Locale locale, Type... typeHints) {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(locale);\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }\n\n    private List<?> match(String expr, String text, ParameterTypeRegistry parameterTypeRegistry, Type... typeHints) {\n        CucumberExpression expression = new CucumberExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(text, typeHints);\n        if (args == null) {\n            return null;\n        } else {\n            List<Object> list = new ArrayList<>();\n            for (Argument<?> arg : args) {\n                Object value = arg.getValue();\n                list.add(value);\n            }\n            return list;\n        }\n    }\n}", "definition": "class CucumberExpressionTest", "class_docstring": "", "name": "CucumberExpressionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}], "classes": [{"original_string": "    static class Expectation {\n        public String expression;\n        public String text;\n        public List<?> expected_args;\n        public String exception;\n    }", "definition": "    static class Expectation", "class_docstring": "", "name": "Expectation", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String expression;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "public String text;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "text", "syntax_pass": true}, {"attribute_expression": "public List<?> expected_args;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "List<?>", "name": "expected_args", "syntax_pass": true}, {"attribute_expression": "public String exception;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "exception", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }", "definition": "    static class Converter implements ArgumentConverter", "class_docstring": "", "name": "Converter", "super_interfaces": ["ArgumentConverter"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Yaml yaml = new Yaml();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Yaml", "name": "yaml = new Yaml()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expectation", "classes": []}, "name": "convert", "params": [{"name": "source", "type": "Object"}, {"name": "context", "type": "ParameterContext"}], "body": "                                                                                                               {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "signature": "@Override\n        public Expectation convert(Object source, ParameterContext context)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Path>", "classes": []}, "name": "acceptance_tests_pass", "params": [], "body": "                                                                         {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "signature": "private static List<Path> acceptance_tests_pass()"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n            List<Argument<?>> match = expression.match(expectation.text);\n            List<?> values = match == null ? null : match.stream()\n                    .map(Argument::getValue)\n                    .collect(Collectors.toList());\n\n            assertThat(values, CustomMatchers.equalOrCloseTo(expectation.expected_args));\n        } else {\n            Executable executable = () -> {\n                CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n                expression.match(expectation.text);\n            };\n            CucumberExpressionException exception = assertThrows(CucumberExpressionException.class, executable);\n            assertThat(exception.getMessage(), equalTo(expectation.exception));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource", "marker_annotations": ["@ParameterizedTest", "@MethodSource"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "acceptance_tests_pass", "params": [{"name": "expectation", "type": "Expectation"}], "body": "                                                                                      {\n        if (expectation.exception == null) {\n            CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n            List<Argument<?>> match = expression.match(expectation.text);\n            List<?> values = match == null ? null : match.stream()\n                    .map(Argument::getValue)\n                    .collect(Collectors.toList());\n\n            assertThat(values, CustomMatchers.equalOrCloseTo(expectation.expected_args));\n        } else {\n            Executable executable = () -> {\n                CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n                expression.match(expectation.text);\n            };\n            CucumberExpressionException exception = assertThrows(CucumberExpressionException.class, executable);\n            assertThat(exception.getMessage(), equalTo(expectation.exception));\n        }\n    }", "signature": "@ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation)"}, {"syntax_pass": true, "original_string": "    @Test\n    void exposes_source() {\n        String expr = \"I have {int} cuke(s)\";\n        assertEquals(expr, new CucumberExpression(expr, new ParameterTypeRegistry(Locale.ENGLISH)).getSource());\n    }", "docstring": " Misc tests", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "exposes_source", "params": [], "body": "                          {\n        String expr = \"I have {int} cuke(s)\";\n        assertEquals(expr, new CucumberExpression(expr, new ParameterTypeRegistry(Locale.ENGLISH)).getSource());\n    }", "signature": "@Test\n    void exposes_source()"}, {"syntax_pass": true, "original_string": "    @Test\n    void matches_anonymous_parameter_type_with_hint() {\n        assertEquals(singletonList(0.22f), match(\"{}\", \"0.22\", Float.class));\n    }", "docstring": " Java-specific", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "matches_anonymous_parameter_type_with_hint", "params": [], "body": "                                                      {\n        assertEquals(singletonList(0.22f), match(\"{}\", \"0.22\", Float.class));\n    }", "signature": "@Test\n    void matches_anonymous_parameter_type_with_hint()"}, {"syntax_pass": true, "original_string": "    @Test\n    void documents_match_arguments() {\n        String expr = \"I have {int} cuke(s)\";\n        Expression expression = new CucumberExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(\"I have 7 cukes\");\n        assertEquals(7, args.get(0).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "documents_match_arguments", "params": [], "body": "                                     {\n        String expr = \"I have {int} cuke(s)\";\n        Expression expression = new CucumberExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(\"I have 7 cukes\");\n        assertEquals(7, args.get(0).getValue());\n    }", "signature": "@Test\n    void documents_match_arguments()"}, {"syntax_pass": true, "original_string": "    @Test\n    void matches_byte() {\n        assertEquals(singletonList(Byte.MAX_VALUE), match(\"{byte}\", \"127\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "matches_byte", "params": [], "body": "                        {\n        assertEquals(singletonList(Byte.MAX_VALUE), match(\"{byte}\", \"127\"));\n    }", "signature": "@Test\n    void matches_byte()"}, {"syntax_pass": true, "original_string": "    @Test\n    void matches_short() {\n        assertEquals(singletonList(Short.MAX_VALUE), match(\"{short}\", String.valueOf(Short.MAX_VALUE)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "matches_short", "params": [], "body": "                         {\n        assertEquals(singletonList(Short.MAX_VALUE), match(\"{short}\", String.valueOf(Short.MAX_VALUE)));\n    }", "signature": "@Test\n    void matches_short()"}, {"syntax_pass": true, "original_string": "    @Test\n    void matches_long() {\n        assertEquals(singletonList(Long.MAX_VALUE), match(\"{long}\", String.valueOf(Long.MAX_VALUE)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "matches_long", "params": [], "body": "                        {\n        assertEquals(singletonList(Long.MAX_VALUE), match(\"{long}\", String.valueOf(Long.MAX_VALUE)));\n    }", "signature": "@Test\n    void matches_long()"}, {"syntax_pass": true, "original_string": "    @Test\n    void matches_biginteger() {\n        BigInteger bigInteger = BigInteger.valueOf(Long.MAX_VALUE);\n        bigInteger = bigInteger.pow(10);\n        assertEquals(singletonList(bigInteger), match(\"{biginteger}\", bigInteger.toString()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "matches_biginteger", "params": [], "body": "                              {\n        BigInteger bigInteger = BigInteger.valueOf(Long.MAX_VALUE);\n        bigInteger = bigInteger.pow(10);\n        assertEquals(singletonList(bigInteger), match(\"{biginteger}\", bigInteger.toString()));\n    }", "signature": "@Test\n    void matches_biginteger()"}, {"syntax_pass": true, "original_string": "    @Test\n    void matches_bigdecimal() {\n        BigDecimal bigDecimal = BigDecimal.valueOf(Math.PI);\n        assertEquals(singletonList(bigDecimal), match(\"{bigdecimal}\", bigDecimal.toString()));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "matches_bigdecimal", "params": [], "body": "                              {\n        BigDecimal bigDecimal = BigDecimal.valueOf(Math.PI);\n        assertEquals(singletonList(bigDecimal), match(\"{bigdecimal}\", bigDecimal.toString()));\n    }", "signature": "@Test\n    void matches_bigdecimal()"}, {"syntax_pass": true, "original_string": "    @Test\n    void matches_double_with_comma_for_locale_using_comma() {\n        List<?> values = match(\"{double}\", \"1,22\", Locale.FRANCE);\n        assertEquals(singletonList(1.22), values);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "matches_double_with_comma_for_locale_using_comma", "params": [], "body": "                                                            {\n        List<?> values = match(\"{double}\", \"1,22\", Locale.FRANCE);\n        assertEquals(singletonList(1.22), values);\n    }", "signature": "@Test\n    void matches_double_with_comma_for_locale_using_comma()"}, {"syntax_pass": true, "original_string": "    @Test\n    void matches_float_with_zero() {\n        List<?> values = match(\"{float}\", \"0\", Locale.ENGLISH);\n        assertEquals(0.0f, values.get(0));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "matches_float_with_zero", "params": [], "body": "                                   {\n        List<?> values = match(\"{float}\", \"0\", Locale.ENGLISH);\n        assertEquals(0.0f, values.get(0));\n    }", "signature": "@Test\n    void matches_float_with_zero()"}, {"syntax_pass": true, "original_string": "    @Test\n    void unmatched_optional_groups_have_null_values() {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"textAndOrNumber\",\n                singletonList(\"([A-Z]+)?(?: )?([0-9]+)?\"),\n                new TypeReference<List<String>>() {\n                }.getType(),\n                new CaptureGroupTransformer<List<String>>() {\n                    @Override\n                    public List<String> transform(String... args) {\n                        return asList(args);\n                    }\n                },\n                false,\n                false)\n        );\n        assertThat(match(\"{textAndOrNumber}\", \"TLA\", parameterTypeRegistry), is(singletonList(asList(\"TLA\", null))));\n        assertThat(match(\"{textAndOrNumber}\", \"123\", parameterTypeRegistry), is(singletonList(asList(null, \"123\"))));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "unmatched_optional_groups_have_null_values", "params": [], "body": "                                                      {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"textAndOrNumber\",\n                singletonList(\"([A-Z]+)?(?: )?([0-9]+)?\"),\n                new TypeReference<List<String>>() {\n                }.getType(),\n                new CaptureGroupTransformer<List<String>>() {\n                    @Override\n                    public List<String> transform(String... args) {\n                        return asList(args);\n                    }\n                },\n                false,\n                false)\n        );\n        assertThat(match(\"{textAndOrNumber}\", \"TLA\", parameterTypeRegistry), is(singletonList(asList(\"TLA\", null))));\n        assertThat(match(\"{textAndOrNumber}\", \"123\", parameterTypeRegistry), is(singletonList(asList(null, \"123\"))));\n    }", "signature": "@Test\n    void unmatched_optional_groups_have_null_values()"}, {"syntax_pass": true, "original_string": "    private List<?> match(String expr, String text, Type... typeHints) {\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<?>", "classes": []}, "name": "match", "params": [{"name": "expr", "type": "String"}, {"name": "text", "type": "String"}], "body": "                                                                       {\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }", "signature": "private List<?> match(String expr, String text, Type... typeHints)"}, {"syntax_pass": true, "original_string": "    private List<?> match(String expr, String text, Locale locale, Type... typeHints) {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(locale);\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<?>", "classes": []}, "name": "match", "params": [{"name": "expr", "type": "String"}, {"name": "text", "type": "String"}, {"name": "locale", "type": "Locale"}], "body": "                                                                                      {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(locale);\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }", "signature": "private List<?> match(String expr, String text, Locale locale, Type... typeHints)"}, {"syntax_pass": true, "original_string": "    private List<?> match(String expr, String text, ParameterTypeRegistry parameterTypeRegistry, Type... typeHints) {\n        CucumberExpression expression = new CucumberExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(text, typeHints);\n        if (args == null) {\n            return null;\n        } else {\n            List<Object> list = new ArrayList<>();\n            for (Argument<?> arg : args) {\n                Object value = arg.getValue();\n                list.add(value);\n            }\n            return list;\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<?>", "classes": []}, "name": "match", "params": [{"name": "expr", "type": "String"}, {"name": "text", "type": "String"}, {"name": "parameterTypeRegistry", "type": "ParameterTypeRegistry"}], "body": "                                                                                                                    {\n        CucumberExpression expression = new CucumberExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(text, typeHints);\n        if (args == null) {\n            return null;\n        } else {\n            List<Object> list = new ArrayList<>();\n            for (Argument<?> arg : args) {\n                Object value = arg.getValue();\n                list.add(value);\n            }\n            return list;\n        }\n    }", "signature": "private List<?> match(String expr, String text, ParameterTypeRegistry parameterTypeRegistry, Type... typeHints)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/RegularExpression_getSourceTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.regex.Pattern;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class RegularExpression_getSourceTest {\n\n    @Test\n    public void testGetSource() {\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(java.util.Locale.getDefault());\n        RegularExpression regularExpression = new RegularExpression(pattern, parameterTypeRegistry);\n\n        String source = regularExpression.getSource();\n\n        assertEquals(\"\\\\d+\", source);\n    }\n}\n", "file_hash": "80f97f4414ac73b09fe4b8b0bb7a24a9f7f079649ea0db4186c12081f24c9ac6", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.util.regex.Pattern;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class RegularExpression_getSourceTest {\n\n    @Test\n    public void testGetSource() {\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(java.util.Locale.getDefault());\n        RegularExpression regularExpression = new RegularExpression(pattern, parameterTypeRegistry);\n\n        String source = regularExpression.getSource();\n\n        assertEquals(\"\\\\d+\", source);\n    }\n}", "definition": "public class RegularExpression_getSourceTest", "class_docstring": "", "name": "RegularExpression_getSourceTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testGetSource() {\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(java.util.Locale.getDefault());\n        RegularExpression regularExpression = new RegularExpression(pattern, parameterTypeRegistry);\n\n        String source = regularExpression.getSource();\n\n        assertEquals(\"\\\\d+\", source);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetSource", "params": [], "body": "                                {\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(java.util.Locale.getDefault());\n        RegularExpression regularExpression = new RegularExpression(pattern, parameterTypeRegistry);\n\n        String source = regularExpression.getSource();\n\n        assertEquals(\"\\\\d+\", source);\n    }", "signature": "@Test\n    public void testGetSource()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_useRegexpMatchAsStrongTypeHintTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static java.util.Collections.singletonList;\n\npublic class ParameterType_useRegexpMatchAsStrongTypeHintTest {\n\n    @Test\n    public void testUseRegexpMatchAsStrongTypeHintTrue() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false,\n                true\n        );\n        assertTrue(parameterType.useRegexpMatchAsStrongTypeHint());\n    }\n\n    @Test\n    public void testUseRegexpMatchAsStrongTypeHintFalse() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false,\n                false\n        );\n        assertFalse(parameterType.useRegexpMatchAsStrongTypeHint());\n    }\n}\n", "file_hash": "23f53d1c2214188cb34179b0889e7195cbb95b85c3703a4bbe9ce46e80e1d555", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static java.util.Collections.singletonList;"], "methods": [], "classes": [{"original_string": "public class ParameterType_useRegexpMatchAsStrongTypeHintTest {\n\n    @Test\n    public void testUseRegexpMatchAsStrongTypeHintTrue() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false,\n                true\n        );\n        assertTrue(parameterType.useRegexpMatchAsStrongTypeHint());\n    }\n\n    @Test\n    public void testUseRegexpMatchAsStrongTypeHintFalse() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false,\n                false\n        );\n        assertFalse(parameterType.useRegexpMatchAsStrongTypeHint());\n    }\n}", "definition": "public class ParameterType_useRegexpMatchAsStrongTypeHintTest", "class_docstring": "", "name": "ParameterType_useRegexpMatchAsStrongTypeHintTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testUseRegexpMatchAsStrongTypeHintTrue() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false,\n                true\n        );\n        assertTrue(parameterType.useRegexpMatchAsStrongTypeHint());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUseRegexpMatchAsStrongTypeHintTrue", "params": [], "body": "                                                         {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false,\n                true\n        );\n        assertTrue(parameterType.useRegexpMatchAsStrongTypeHint());\n    }", "signature": "@Test\n    public void testUseRegexpMatchAsStrongTypeHintTrue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUseRegexpMatchAsStrongTypeHintFalse() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false,\n                false\n        );\n        assertFalse(parameterType.useRegexpMatchAsStrongTypeHint());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUseRegexpMatchAsStrongTypeHintFalse", "params": [], "body": "                                                          {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false,\n                false\n        );\n        assertFalse(parameterType.useRegexpMatchAsStrongTypeHint());\n    }", "signature": "@Test\n    public void testUseRegexpMatchAsStrongTypeHintFalse()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/EnumParameterTypeTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class EnumParameterTypeTest {\n\n    public enum Mood {\n        happy,\n        meh,\n        sad\n    }\n\n    @Test\n    public void converts_to_enum() {\n        ParameterTypeRegistry registry = new ParameterTypeRegistry(Locale.ENGLISH);\n        registry.defineParameterType(ParameterType.fromEnum(Mood.class));\n\n        CucumberExpression expression = new CucumberExpression(\"I am {Mood}\", registry);\n        List<Argument<?>> args = expression.match(\"I am happy\");\n        assertEquals(Mood.happy, args.get(0).getValue());\n    }\n\n}\n", "file_hash": "9c222494786890f11babdb6d02071aa0d600626dc97a1200c417635ff3467ef1", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.util.List;", "import java.util.Locale;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class EnumParameterTypeTest {\n\n    public enum Mood {\n        happy,\n        meh,\n        sad\n    }\n\n    @Test\n    public void converts_to_enum() {\n        ParameterTypeRegistry registry = new ParameterTypeRegistry(Locale.ENGLISH);\n        registry.defineParameterType(ParameterType.fromEnum(Mood.class));\n\n        CucumberExpression expression = new CucumberExpression(\"I am {Mood}\", registry);\n        List<Argument<?>> args = expression.match(\"I am happy\");\n        assertEquals(Mood.happy, args.get(0).getValue());\n    }\n\n}", "definition": "public class EnumParameterTypeTest", "class_docstring": "", "name": "EnumParameterTypeTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void converts_to_enum() {\n        ParameterTypeRegistry registry = new ParameterTypeRegistry(Locale.ENGLISH);\n        registry.defineParameterType(ParameterType.fromEnum(Mood.class));\n\n        CucumberExpression expression = new CucumberExpression(\"I am {Mood}\", registry);\n        List<Argument<?>> args = expression.match(\"I am happy\");\n        assertEquals(Mood.happy, args.get(0).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "converts_to_enum", "params": [], "body": "                                   {\n        ParameterTypeRegistry registry = new ParameterTypeRegistry(Locale.ENGLISH);\n        registry.defineParameterType(ParameterType.fromEnum(Mood.class));\n\n        CucumberExpression expression = new CucumberExpression(\"I am {Mood}\", registry);\n        List<Argument<?>> args = expression.match(\"I am happy\");\n        assertEquals(Mood.happy, args.get(0).getValue());\n    }", "signature": "@Test\n    public void converts_to_enum()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/GenericParameterTypeTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.singletonList;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class GenericParameterTypeTest {\n\n    @Test\n    public void transforms_to_a_list_of_string() {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"stringlist\",\n                singletonList(\".*\"),\n                new TypeReference<List<String>>() {\n                }.getType(),\n                new CaptureGroupTransformer<List<String>>() {\n                    @Override\n                    public List<String> transform(String... args) {\n                        return asList(args[0].split(\",\"));\n                    }\n                },\n                false,\n                false)\n        );\n        Expression expression = new CucumberExpression(\"I have {stringlist} yay\", parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(\"I have three,blind,mice yay\");\n        assertEquals(asList(\"three\", \"blind\", \"mice\"), args.get(0).getValue());\n    }\n\n}\n", "file_hash": "4f31f8384ca2c5780e9e32ee637e33c5e024d0346fcaa878fbe5967e57b2e22b", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.util.List;", "import java.util.Locale;", "import static java.util.Arrays.asList;", "import static java.util.Collections.singletonList;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class GenericParameterTypeTest {\n\n    @Test\n    public void transforms_to_a_list_of_string() {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"stringlist\",\n                singletonList(\".*\"),\n                new TypeReference<List<String>>() {\n                }.getType(),\n                new CaptureGroupTransformer<List<String>>() {\n                    @Override\n                    public List<String> transform(String... args) {\n                        return asList(args[0].split(\",\"));\n                    }\n                },\n                false,\n                false)\n        );\n        Expression expression = new CucumberExpression(\"I have {stringlist} yay\", parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(\"I have three,blind,mice yay\");\n        assertEquals(asList(\"three\", \"blind\", \"mice\"), args.get(0).getValue());\n    }\n\n}", "definition": "public class GenericParameterTypeTest", "class_docstring": "", "name": "GenericParameterTypeTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void transforms_to_a_list_of_string() {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"stringlist\",\n                singletonList(\".*\"),\n                new TypeReference<List<String>>() {\n                }.getType(),\n                new CaptureGroupTransformer<List<String>>() {\n                    @Override\n                    public List<String> transform(String... args) {\n                        return asList(args[0].split(\",\"));\n                    }\n                },\n                false,\n                false)\n        );\n        Expression expression = new CucumberExpression(\"I have {stringlist} yay\", parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(\"I have three,blind,mice yay\");\n        assertEquals(asList(\"three\", \"blind\", \"mice\"), args.get(0).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "transforms_to_a_list_of_string", "params": [], "body": "                                                 {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"stringlist\",\n                singletonList(\".*\"),\n                new TypeReference<List<String>>() {\n                }.getType(),\n                new CaptureGroupTransformer<List<String>>() {\n                    @Override\n                    public List<String> transform(String... args) {\n                        return asList(args[0].split(\",\"));\n                    }\n                },\n                false,\n                false)\n        );\n        Expression expression = new CucumberExpression(\"I have {stringlist} yay\", parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(\"I have three,blind,mice yay\");\n        assertEquals(asList(\"three\", \"blind\", \"mice\"), args.get(0).getValue());\n    }", "signature": "@Test\n    public void transforms_to_a_list_of_string()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/TreeRegexp_getGroupBuilderTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.regex.Pattern;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nclass TreeRegexp_getGroupBuilderTest {\n\n    @Test\n    void testGetGroupBuilder() {\n        // Given\n        Pattern pattern = Pattern.compile(\"a(b)c\");\n        TreeRegexp treeRegexp = new TreeRegexp(pattern);\n\n        // When\n        GroupBuilder groupBuilder = treeRegexp.getGroupBuilder();\n\n        // Then\n        assertNotNull(groupBuilder);\n    }\n}\n", "file_hash": "7e5a9ee2ec620ee5598ad7cd3b6161ab260ca32fae9e6d8b60d30765f86b2dfb", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.util.regex.Pattern;", "import static org.junit.jupiter.api.Assertions.assertNotNull;"], "methods": [], "classes": [{"original_string": "class TreeRegexp_getGroupBuilderTest {\n\n    @Test\n    void testGetGroupBuilder() {\n        // Given\n        Pattern pattern = Pattern.compile(\"a(b)c\");\n        TreeRegexp treeRegexp = new TreeRegexp(pattern);\n\n        // When\n        GroupBuilder groupBuilder = treeRegexp.getGroupBuilder();\n\n        // Then\n        assertNotNull(groupBuilder);\n    }\n}", "definition": "class TreeRegexp_getGroupBuilderTest", "class_docstring": "", "name": "TreeRegexp_getGroupBuilderTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    void testGetGroupBuilder() {\n        // Given\n        Pattern pattern = Pattern.compile(\"a(b)c\");\n        TreeRegexp treeRegexp = new TreeRegexp(pattern);\n\n        // When\n        GroupBuilder groupBuilder = treeRegexp.getGroupBuilder();\n\n        // Then\n        assertNotNull(groupBuilder);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testGetGroupBuilder", "params": [], "body": "                               {\n        // Given\n        Pattern pattern = Pattern.compile(\"a(b)c\");\n        TreeRegexp treeRegexp = new TreeRegexp(pattern);\n\n        // When\n        GroupBuilder groupBuilder = treeRegexp.getGroupBuilder();\n\n        // Then\n        assertNotNull(groupBuilder);\n    }", "signature": "@Test\n    void testGetGroupBuilder()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.text.DecimalFormatSymbols;\nimport java.util.AbstractMap.SimpleEntry;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.function.Function;\nimport java.util.stream.Stream;\n\nimport static java.util.Comparator.comparing;\nimport static java.util.stream.Collectors.groupingBy;\nimport static java.util.stream.Collectors.toList;\n\nclass KeyboardFriendlyDecimalFormatSymbolsTest {\n\n    @Test\n    void listMinusSigns(){\n        System.out.println(\"Original minus signs:\");\n        listMinusSigns(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly minus signs:\");\n        listMinusSigns(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }\n\n    private static void listMinusSigns(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getMinusSign()))\n                .forEach((c, locales) -> System.out.println(render(c) + \" \" + render(locales)));\n    }\n\n    @Test\n    void listDecimalAndGroupingSeparators(){\n        System.out.println(\"Original decimal and group separators:\");\n        listDecimalAndGroupingSeparators(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly decimal and group separators:\");\n        listDecimalAndGroupingSeparators(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }\n\n    private static void listDecimalAndGroupingSeparators(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> {\n                    DecimalFormatSymbols symbols = supplier.apply(locale);\n                    return new SimpleEntry<>(symbols.getDecimalSeparator(), symbols.getGroupingSeparator());\n                }))\n                .entrySet()\n                .stream()\n                .sorted(comparing(entry -> entry.getKey().getKey()))\n                .forEach((entry) -> {\n                    SimpleEntry<Character, Character> characters = entry.getKey();\n                    List<Locale> locales = entry.getValue();\n                    System.out.println(render(characters.getKey()) + \" \" + render(characters.getValue()) + \" \" + render(locales));\n                });\n    }\n\n    @Test\n    void listExponentSigns(){\n        System.out.println(\"Original exponent signs:\");\n        listExponentSigns(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly exponent signs:\");\n        listExponentSigns(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }\n\n    private static void listExponentSigns(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getExponentSeparator()))\n                .forEach((s, locales) -> {\n                    if (s.length() == 1) {\n                        System.out.println(render(s.charAt(0)) + \" \" + render(locales));\n                    } else {\n                        System.out.println(s + \" \" + render(locales));\n                    }\n                });\n    }\n\n    private static Stream<Locale> getAvailableLocalesAsStream() {\n        return Arrays.stream(DecimalFormatSymbols.getAvailableLocales());\n    }\n\n    private static String render(Character character) {\n        return character + \" (\" + (int) character + \")\";\n    }\n\n    private static String render(List<Locale> locales) {\n        return locales.size() + \": \" + locales.stream()\n                .sorted(comparing(Locale::getDisplayName))\n                .map(Locale::getDisplayName)\n                .collect(toList());\n    }\n\n}\n", "file_hash": "a9ef92645efa8949ee10006d61f42f4b2d18f509be54b590923d041da5158de3", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.text.DecimalFormatSymbols;", "import java.util.AbstractMap.SimpleEntry;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Locale;", "import java.util.function.Function;", "import java.util.stream.Stream;", "import static java.util.Comparator.comparing;", "import static java.util.stream.Collectors.groupingBy;", "import static java.util.stream.Collectors.toList;"], "methods": [], "classes": [{"original_string": "class KeyboardFriendlyDecimalFormatSymbolsTest {\n\n    @Test\n    void listMinusSigns(){\n        System.out.println(\"Original minus signs:\");\n        listMinusSigns(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly minus signs:\");\n        listMinusSigns(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }\n\n    private static void listMinusSigns(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getMinusSign()))\n                .forEach((c, locales) -> System.out.println(render(c) + \" \" + render(locales)));\n    }\n\n    @Test\n    void listDecimalAndGroupingSeparators(){\n        System.out.println(\"Original decimal and group separators:\");\n        listDecimalAndGroupingSeparators(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly decimal and group separators:\");\n        listDecimalAndGroupingSeparators(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }\n\n    private static void listDecimalAndGroupingSeparators(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> {\n                    DecimalFormatSymbols symbols = supplier.apply(locale);\n                    return new SimpleEntry<>(symbols.getDecimalSeparator(), symbols.getGroupingSeparator());\n                }))\n                .entrySet()\n                .stream()\n                .sorted(comparing(entry -> entry.getKey().getKey()))\n                .forEach((entry) -> {\n                    SimpleEntry<Character, Character> characters = entry.getKey();\n                    List<Locale> locales = entry.getValue();\n                    System.out.println(render(characters.getKey()) + \" \" + render(characters.getValue()) + \" \" + render(locales));\n                });\n    }\n\n    @Test\n    void listExponentSigns(){\n        System.out.println(\"Original exponent signs:\");\n        listExponentSigns(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly exponent signs:\");\n        listExponentSigns(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }\n\n    private static void listExponentSigns(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getExponentSeparator()))\n                .forEach((s, locales) -> {\n                    if (s.length() == 1) {\n                        System.out.println(render(s.charAt(0)) + \" \" + render(locales));\n                    } else {\n                        System.out.println(s + \" \" + render(locales));\n                    }\n                });\n    }\n\n    private static Stream<Locale> getAvailableLocalesAsStream() {\n        return Arrays.stream(DecimalFormatSymbols.getAvailableLocales());\n    }\n\n    private static String render(Character character) {\n        return character + \" (\" + (int) character + \")\";\n    }\n\n    private static String render(List<Locale> locales) {\n        return locales.size() + \": \" + locales.stream()\n                .sorted(comparing(Locale::getDisplayName))\n                .map(Locale::getDisplayName)\n                .collect(toList());\n    }\n\n}", "definition": "class KeyboardFriendlyDecimalFormatSymbolsTest", "class_docstring": "", "name": "KeyboardFriendlyDecimalFormatSymbolsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    void listMinusSigns(){\n        System.out.println(\"Original minus signs:\");\n        listMinusSigns(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly minus signs:\");\n        listMinusSigns(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "listMinusSigns", "params": [], "body": "                         {\n        System.out.println(\"Original minus signs:\");\n        listMinusSigns(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly minus signs:\");\n        listMinusSigns(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }", "signature": "@Test\n    void listMinusSigns()"}, {"syntax_pass": true, "original_string": "    private static void listMinusSigns(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getMinusSign()))\n                .forEach((c, locales) -> System.out.println(render(c) + \" \" + render(locales)));\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "listMinusSigns", "params": [{"name": "supplier", "type": "Function<Locale, DecimalFormatSymbols>"}], "body": "                                                                                        {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getMinusSign()))\n                .forEach((c, locales) -> System.out.println(render(c) + \" \" + render(locales)));\n    }", "signature": "private static void listMinusSigns(Function<Locale, DecimalFormatSymbols> supplier)"}, {"syntax_pass": true, "original_string": "    @Test\n    void listDecimalAndGroupingSeparators(){\n        System.out.println(\"Original decimal and group separators:\");\n        listDecimalAndGroupingSeparators(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly decimal and group separators:\");\n        listDecimalAndGroupingSeparators(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "listDecimalAndGroupingSeparators", "params": [], "body": "                                           {\n        System.out.println(\"Original decimal and group separators:\");\n        listDecimalAndGroupingSeparators(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly decimal and group separators:\");\n        listDecimalAndGroupingSeparators(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }", "signature": "@Test\n    void listDecimalAndGroupingSeparators()"}, {"syntax_pass": true, "original_string": "    private static void listDecimalAndGroupingSeparators(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> {\n                    DecimalFormatSymbols symbols = supplier.apply(locale);\n                    return new SimpleEntry<>(symbols.getDecimalSeparator(), symbols.getGroupingSeparator());\n                }))\n                .entrySet()\n                .stream()\n                .sorted(comparing(entry -> entry.getKey().getKey()))\n                .forEach((entry) -> {\n                    SimpleEntry<Character, Character> characters = entry.getKey();\n                    List<Locale> locales = entry.getValue();\n                    System.out.println(render(characters.getKey()) + \" \" + render(characters.getValue()) + \" \" + render(locales));\n                });\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "listDecimalAndGroupingSeparators", "params": [{"name": "supplier", "type": "Function<Locale, DecimalFormatSymbols>"}], "body": "                                                                                                          {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> {\n                    DecimalFormatSymbols symbols = supplier.apply(locale);\n                    return new SimpleEntry<>(symbols.getDecimalSeparator(), symbols.getGroupingSeparator());\n                }))\n                .entrySet()\n                .stream()\n                .sorted(comparing(entry -> entry.getKey().getKey()))\n                .forEach((entry) -> {\n                    SimpleEntry<Character, Character> characters = entry.getKey();\n                    List<Locale> locales = entry.getValue();\n                    System.out.println(render(characters.getKey()) + \" \" + render(characters.getValue()) + \" \" + render(locales));\n                });\n    }", "signature": "private static void listDecimalAndGroupingSeparators(Function<Locale, DecimalFormatSymbols> supplier)"}, {"syntax_pass": true, "original_string": "    @Test\n    void listExponentSigns(){\n        System.out.println(\"Original exponent signs:\");\n        listExponentSigns(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly exponent signs:\");\n        listExponentSigns(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "listExponentSigns", "params": [], "body": "                            {\n        System.out.println(\"Original exponent signs:\");\n        listExponentSigns(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly exponent signs:\");\n        listExponentSigns(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }", "signature": "@Test\n    void listExponentSigns()"}, {"syntax_pass": true, "original_string": "    private static void listExponentSigns(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getExponentSeparator()))\n                .forEach((s, locales) -> {\n                    if (s.length() == 1) {\n                        System.out.println(render(s.charAt(0)) + \" \" + render(locales));\n                    } else {\n                        System.out.println(s + \" \" + render(locales));\n                    }\n                });\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "listExponentSigns", "params": [{"name": "supplier", "type": "Function<Locale, DecimalFormatSymbols>"}], "body": "                                                                                           {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getExponentSeparator()))\n                .forEach((s, locales) -> {\n                    if (s.length() == 1) {\n                        System.out.println(render(s.charAt(0)) + \" \" + render(locales));\n                    } else {\n                        System.out.println(s + \" \" + render(locales));\n                    }\n                });\n    }", "signature": "private static void listExponentSigns(Function<Locale, DecimalFormatSymbols> supplier)"}, {"syntax_pass": true, "original_string": "    private static Stream<Locale> getAvailableLocalesAsStream() {\n        return Arrays.stream(DecimalFormatSymbols.getAvailableLocales());\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Stream<Locale>", "classes": []}, "name": "getAvailableLocalesAsStream", "params": [], "body": "                                                                {\n        return Arrays.stream(DecimalFormatSymbols.getAvailableLocales());\n    }", "signature": "private static Stream<Locale> getAvailableLocalesAsStream()"}, {"syntax_pass": true, "original_string": "    private static String render(Character character) {\n        return character + \" (\" + (int) character + \")\";\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "render", "params": [{"name": "character", "type": "Character"}], "body": "                                                      {\n        return character + \" (\" + (int) character + \")\";\n    }", "signature": "private static String render(Character character)"}, {"syntax_pass": true, "original_string": "    private static String render(List<Locale> locales) {\n        return locales.size() + \": \" + locales.stream()\n                .sorted(comparing(Locale::getDisplayName))\n                .map(Locale::getDisplayName)\n                .collect(toList());\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "render", "params": [{"name": "locales", "type": "List<Locale>"}], "body": "                                                       {\n        return locales.size() + \": \" + locales.stream()\n                .sorted(comparing(Locale::getDisplayName))\n                .map(Locale::getDisplayName)\n                .collect(toList());\n    }", "signature": "private static String render(List<Locale> locales)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionGeneratorTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.singletonList;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\npublic class CucumberExpressionGeneratorTest {\n\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    private final CucumberExpressionGenerator generator = new CucumberExpressionGenerator(parameterTypeRegistry);\n    private static final DateFormat df = DateFormat.getDateInstance();\n\n    @Test\n    public void documents_expression_generation() {\n        CucumberExpressionGenerator generator = new CucumberExpressionGenerator(parameterTypeRegistry);\n        String undefinedStepText = \"I have 2 cucumbers and 1.5 tomato\";\n        GeneratedExpression generatedExpression = generator.generateExpressions(undefinedStepText).get(0);\n        assertEquals(\"I have {int} cucumbers and {double} tomato\", generatedExpression.getSource());\n        assertEquals(Double.class, generatedExpression.getParameterTypes().get(1).getType());\n    }\n\n    @Test\n    public void generates_expression_for_no_args() {\n        assertExpression(\"hello\", Collections.<String>emptyList(), \"hello\");\n    }\n\n    @Test\n    public void generates_expression_with_escaped_left_parenthesis() {\n        assertExpression(\n                \"\\\\(iii)\", Collections.<String>emptyList(),\n                \"(iii)\");\n    }\n\n    @Test\n    public void generates_expression_with_escaped_left_curly_brace() {\n        assertExpression(\n                \"\\\\{iii}\", Collections.<String>emptyList(),\n                \"{iii}\");\n    }\n\n    @Test\n    public void generates_expression_with_escaped_slashes() {\n        assertExpression(\n                \"The {int}\\\\/{int}\\\\/{int} hey\", asList(\"int1\", \"int2\", \"int3\"),\n                \"The 1814/05/17 hey\");\n    }\n\n    @Test\n    public void generates_expression_for_int_double_arg() {\n        assertExpression(\n                \"I have {int} cukes and {double} euro\", asList(\"int1\", \"double1\"),\n                \"I have 2 cukes and 1.5 euro\");\n    }\n\n    @Test\n    public void generates_expression_for_numbers_with_symbols_and_currency() {\n        assertExpression(\n                \"Some ${double} of cukes at {int}\u00b0 Celsius\", asList(\"double1\", \"int1\"),\n                \"Some $5000.00 of cukes at 42\u00b0 Celsius\");\n    }\n\n    @Test\n    public void generates_expression_for_numbers_with_text_on_both_sides() {\n        assertExpression(\n                \"i18n\", asList(),\n                \"i18n\");\n    }\n\n    @Test\n    public void generates_expression_for_strings() {\n        assertExpression(\n                \"I like {string} and {string}\", asList(\"string\", \"string2\"),\n                \"I like \\\"bangers\\\" and 'mash'\");\n    }\n\n    @Test\n    public void generates_expression_with_percent_sign() {\n        assertExpression(\n                \"I am {int}% foobar\", singletonList(\"int1\"),\n                \"I am 20% foobar\");\n    }\n\n    @Test\n    public void generates_expression_for_just_int() {\n        assertExpression(\n                \"{int}\", singletonList(\"int1\"),\n                \"99999\");\n    }\n\n    @Test\n    public void numbers_all_arguments_when_type_is_reserved_keyword() {\n        assertExpression(\n                \"I have {int} cukes and {int} euro\", asList(\"int1\", \"int2\"),\n                \"I have 2 cukes and 5 euro\");\n    }\n\n    @Test\n    public void numbers_only_second_argument_when_type_is_not_reserved_keyword() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"currency\",\n                \"[A-Z]{3}\",\n                Currency.class,\n                new Transformer<Currency>() {\n                    @Override\n                    public Currency transform(String arg) {\n                        return Currency.getInstance(arg);\n                    }\n                }\n        ));\n        assertExpression(\n                \"I have a {currency} account and a {currency} account\", asList(\"currency\", \"currency2\"),\n                \"I have a EUR account and a GBP account\");\n    }\n\n    @Test\n    public void does_not_suggest_parameter_type_when_surrounded_by_alphanum() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"direction\",\n                \"(up|down)\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                },\n                true,\n                false\n        ));\n        assertExpression(\n                \"I like muppets\", Collections.<String>emptyList(),\n                \"I like muppets\");\n    }\n\n    @Test\n    public void does_suggest_parameter_type_when_surrounded_by_space() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"direction\",\n                \"(up|down)\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                },\n                true,\n                false\n        ));\n        assertExpression(\n                \"it went {direction} and {direction}\", asList(\"direction\", \"direction2\"),\n                \"it went up and down\");\n    }\n\n    @Test\n    public void prefers_leftmost_match_when_there_is_overlap() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"right\",\n                \"c d\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"left\",\n                \"b c\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                }\n        ));\n        assertExpression(\n                \"a {left} d e f g\", singletonList(\"left\"),\n                \"a b c d e f g\");\n    }\n\n    @Test\n    public void prefers_widest_match_when_pos_is_same() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"airport\",\n                \"[A-Z]{3}\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"leg\",\n                \"[A-Z]{3}-[A-Z]{3}\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        assertExpression(\n                \"leg {leg}\", singletonList(\"leg\"),\n                \"leg LHR-CDG\");\n    }\n\n    @Test\n    public void generates_all_combinations_of_expressions_when_several_parameter_types_match() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"currency\",\n                \"x\",\n                Currency.class,\n                (Transformer<Currency>) Currency::getInstance,\n                true,\n                true\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"date\",\n                \"x\",\n                Date.class,\n                new Transformer<Date>() {\n                    @Override\n                    public Date transform(String arg) {\n                        try {\n                            return df.parse(arg);\n                        } catch (ParseException e) {\n                            throw new RuntimeException(e);\n                        }\n                    }\n                },\n                true,\n                false\n        ));\n\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"I have x and x and another x\");\n        List<String> expressions = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            expressions.add(source);\n        }\n        assertEquals(asList(\n                \"I have {currency} and {currency} and another {currency}\",\n                \"I have {currency} and {currency} and another {date}\",\n                \"I have {currency} and {date} and another {currency}\",\n                \"I have {currency} and {date} and another {date}\",\n                \"I have {date} and {currency} and another {currency}\",\n                \"I have {date} and {currency} and another {date}\",\n                \"I have {date} and {date} and another {currency}\",\n                \"I have {date} and {date} and another {date}\"\n        ), expressions);\n    }\n\n    @Test\n    public void exposes_transforms_in_generated_expression() {\n        GeneratedExpression generatedExpression = generator.generateExpressions(\"I have 2 cukes and 1.5 euro\").get(0);\n        assertEquals(Integer.class, generatedExpression.getParameterTypes().get(0).getType());\n        assertEquals(Double.class, generatedExpression.getParameterTypes().get(1).getType());\n    }\n\n    @Test\n    public void matches_parameter_types_with_optional_capture_groups() {\n        ParameterType<String> optionalFlight = new ParameterType<>(\n                \"optional-flight\",\n                \"(1st flight)?\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        ParameterType<String> optionalHotel = new ParameterType<>(\n                \"optional-hotel\",\n                \"(1 hotel)?\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n\n        parameterTypeRegistry.defineParameterType(optionalFlight);\n        parameterTypeRegistry.defineParameterType(optionalHotel);\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"I reach Stage 4: 1st flight -1 hotel\");\n        assertEquals(\"I reach Stage {int}: {optional-flight} {int} hotel\", generatedExpressions.get(0).getSource());\n    }\n\n    @Test\n    public void generates_at_most_256_expressions() {\n        for (int i = 0; i < 4; i++) {\n            ParameterType<String> myType = new ParameterType<>(\n                    \"my-type-\" + i,\n                    \"[a-z]\",\n                    String.class,\n                    (Transformer<String>) arg -> arg,\n                    true,\n                    false\n            );\n            parameterTypeRegistry.defineParameterType(myType);\n\n        }\n        // This would otherwise generate 4^11=419430 expressions and consume just shy of 1.5GB.\n        assertEquals(256, generator.generateExpressions(\"a b c d e f g h i j k\").size());\n    }\n\n    @Test\n    public void prefers_expression_with_longest_non_empty_match() {\n        ParameterType<String> zeroOrMore = new ParameterType<>(\n                \"zero-or-more\",\n                \"[a-z]*\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        parameterTypeRegistry.defineParameterType(zeroOrMore);\n        ParameterType<String> exactlyOne = new ParameterType<>(\n                \"exactly-one\",\n                \"[a-z]\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        parameterTypeRegistry.defineParameterType(exactlyOne);\n\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"a simple step\");\n        assertEquals(2, generatedExpressions.size());\n        assertEquals(\"{exactly-one} {zero-or-more} {zero-or-more}\", generatedExpressions.get(0).getSource());\n        assertEquals(\"{zero-or-more} {zero-or-more} {zero-or-more}\", generatedExpressions.get(1).getSource());\n    }\n\n    private void assertExpression(String expectedExpression, List<String> expectedArgumentNames, String text) {\n        GeneratedExpression generatedExpression = generator.generateExpressions(text).get(0);\n        assertEquals(expectedExpression, generatedExpression.getSource());\n        assertEquals(expectedArgumentNames, generatedExpression.getParameterNames());\n\n        // Check that the generated expression matches the text\n        CucumberExpression cucumberExpression = new CucumberExpression(generatedExpression.getSource(), parameterTypeRegistry);\n        List<Argument<?>> match = cucumberExpression.match(text);\n        if (match == null) {\n            fail(String.format(\"Expected text '%s' to match generated expression '%s'\", text, generatedExpression.getSource()));\n        }\n        assertEquals(expectedArgumentNames.size(), match.size());\n    }\n\n}\n", "file_hash": "3a08a479990bc63725a5848a6269100fd466f419adfb3a79981ae92486350a07", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.text.DateFormat;", "import java.text.ParseException;", "import java.util.ArrayList;", "import java.util.Collections;", "import java.util.Currency;", "import java.util.Date;", "import java.util.List;", "import java.util.Locale;", "import static java.util.Arrays.asList;", "import static java.util.Collections.singletonList;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.fail;"], "methods": [], "classes": [{"original_string": "public class CucumberExpressionGeneratorTest {\n\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    private final CucumberExpressionGenerator generator = new CucumberExpressionGenerator(parameterTypeRegistry);\n    private static final DateFormat df = DateFormat.getDateInstance();\n\n    @Test\n    public void documents_expression_generation() {\n        CucumberExpressionGenerator generator = new CucumberExpressionGenerator(parameterTypeRegistry);\n        String undefinedStepText = \"I have 2 cucumbers and 1.5 tomato\";\n        GeneratedExpression generatedExpression = generator.generateExpressions(undefinedStepText).get(0);\n        assertEquals(\"I have {int} cucumbers and {double} tomato\", generatedExpression.getSource());\n        assertEquals(Double.class, generatedExpression.getParameterTypes().get(1).getType());\n    }\n\n    @Test\n    public void generates_expression_for_no_args() {\n        assertExpression(\"hello\", Collections.<String>emptyList(), \"hello\");\n    }\n\n    @Test\n    public void generates_expression_with_escaped_left_parenthesis() {\n        assertExpression(\n                \"\\\\(iii)\", Collections.<String>emptyList(),\n                \"(iii)\");\n    }\n\n    @Test\n    public void generates_expression_with_escaped_left_curly_brace() {\n        assertExpression(\n                \"\\\\{iii}\", Collections.<String>emptyList(),\n                \"{iii}\");\n    }\n\n    @Test\n    public void generates_expression_with_escaped_slashes() {\n        assertExpression(\n                \"The {int}\\\\/{int}\\\\/{int} hey\", asList(\"int1\", \"int2\", \"int3\"),\n                \"The 1814/05/17 hey\");\n    }\n\n    @Test\n    public void generates_expression_for_int_double_arg() {\n        assertExpression(\n                \"I have {int} cukes and {double} euro\", asList(\"int1\", \"double1\"),\n                \"I have 2 cukes and 1.5 euro\");\n    }\n\n    @Test\n    public void generates_expression_for_numbers_with_symbols_and_currency() {\n        assertExpression(\n                \"Some ${double} of cukes at {int}\u00b0 Celsius\", asList(\"double1\", \"int1\"),\n                \"Some $5000.00 of cukes at 42\u00b0 Celsius\");\n    }\n\n    @Test\n    public void generates_expression_for_numbers_with_text_on_both_sides() {\n        assertExpression(\n                \"i18n\", asList(),\n                \"i18n\");\n    }\n\n    @Test\n    public void generates_expression_for_strings() {\n        assertExpression(\n                \"I like {string} and {string}\", asList(\"string\", \"string2\"),\n                \"I like \\\"bangers\\\" and 'mash'\");\n    }\n\n    @Test\n    public void generates_expression_with_percent_sign() {\n        assertExpression(\n                \"I am {int}% foobar\", singletonList(\"int1\"),\n                \"I am 20% foobar\");\n    }\n\n    @Test\n    public void generates_expression_for_just_int() {\n        assertExpression(\n                \"{int}\", singletonList(\"int1\"),\n                \"99999\");\n    }\n\n    @Test\n    public void numbers_all_arguments_when_type_is_reserved_keyword() {\n        assertExpression(\n                \"I have {int} cukes and {int} euro\", asList(\"int1\", \"int2\"),\n                \"I have 2 cukes and 5 euro\");\n    }\n\n    @Test\n    public void numbers_only_second_argument_when_type_is_not_reserved_keyword() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"currency\",\n                \"[A-Z]{3}\",\n                Currency.class,\n                new Transformer<Currency>() {\n                    @Override\n                    public Currency transform(String arg) {\n                        return Currency.getInstance(arg);\n                    }\n                }\n        ));\n        assertExpression(\n                \"I have a {currency} account and a {currency} account\", asList(\"currency\", \"currency2\"),\n                \"I have a EUR account and a GBP account\");\n    }\n\n    @Test\n    public void does_not_suggest_parameter_type_when_surrounded_by_alphanum() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"direction\",\n                \"(up|down)\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                },\n                true,\n                false\n        ));\n        assertExpression(\n                \"I like muppets\", Collections.<String>emptyList(),\n                \"I like muppets\");\n    }\n\n    @Test\n    public void does_suggest_parameter_type_when_surrounded_by_space() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"direction\",\n                \"(up|down)\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                },\n                true,\n                false\n        ));\n        assertExpression(\n                \"it went {direction} and {direction}\", asList(\"direction\", \"direction2\"),\n                \"it went up and down\");\n    }\n\n    @Test\n    public void prefers_leftmost_match_when_there_is_overlap() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"right\",\n                \"c d\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"left\",\n                \"b c\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                }\n        ));\n        assertExpression(\n                \"a {left} d e f g\", singletonList(\"left\"),\n                \"a b c d e f g\");\n    }\n\n    @Test\n    public void prefers_widest_match_when_pos_is_same() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"airport\",\n                \"[A-Z]{3}\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"leg\",\n                \"[A-Z]{3}-[A-Z]{3}\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        assertExpression(\n                \"leg {leg}\", singletonList(\"leg\"),\n                \"leg LHR-CDG\");\n    }\n\n    @Test\n    public void generates_all_combinations_of_expressions_when_several_parameter_types_match() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"currency\",\n                \"x\",\n                Currency.class,\n                (Transformer<Currency>) Currency::getInstance,\n                true,\n                true\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"date\",\n                \"x\",\n                Date.class,\n                new Transformer<Date>() {\n                    @Override\n                    public Date transform(String arg) {\n                        try {\n                            return df.parse(arg);\n                        } catch (ParseException e) {\n                            throw new RuntimeException(e);\n                        }\n                    }\n                },\n                true,\n                false\n        ));\n\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"I have x and x and another x\");\n        List<String> expressions = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            expressions.add(source);\n        }\n        assertEquals(asList(\n                \"I have {currency} and {currency} and another {currency}\",\n                \"I have {currency} and {currency} and another {date}\",\n                \"I have {currency} and {date} and another {currency}\",\n                \"I have {currency} and {date} and another {date}\",\n                \"I have {date} and {currency} and another {currency}\",\n                \"I have {date} and {currency} and another {date}\",\n                \"I have {date} and {date} and another {currency}\",\n                \"I have {date} and {date} and another {date}\"\n        ), expressions);\n    }\n\n    @Test\n    public void exposes_transforms_in_generated_expression() {\n        GeneratedExpression generatedExpression = generator.generateExpressions(\"I have 2 cukes and 1.5 euro\").get(0);\n        assertEquals(Integer.class, generatedExpression.getParameterTypes().get(0).getType());\n        assertEquals(Double.class, generatedExpression.getParameterTypes().get(1).getType());\n    }\n\n    @Test\n    public void matches_parameter_types_with_optional_capture_groups() {\n        ParameterType<String> optionalFlight = new ParameterType<>(\n                \"optional-flight\",\n                \"(1st flight)?\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        ParameterType<String> optionalHotel = new ParameterType<>(\n                \"optional-hotel\",\n                \"(1 hotel)?\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n\n        parameterTypeRegistry.defineParameterType(optionalFlight);\n        parameterTypeRegistry.defineParameterType(optionalHotel);\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"I reach Stage 4: 1st flight -1 hotel\");\n        assertEquals(\"I reach Stage {int}: {optional-flight} {int} hotel\", generatedExpressions.get(0).getSource());\n    }\n\n    @Test\n    public void generates_at_most_256_expressions() {\n        for (int i = 0; i < 4; i++) {\n            ParameterType<String> myType = new ParameterType<>(\n                    \"my-type-\" + i,\n                    \"[a-z]\",\n                    String.class,\n                    (Transformer<String>) arg -> arg,\n                    true,\n                    false\n            );\n            parameterTypeRegistry.defineParameterType(myType);\n\n        }\n        // This would otherwise generate 4^11=419430 expressions and consume just shy of 1.5GB.\n        assertEquals(256, generator.generateExpressions(\"a b c d e f g h i j k\").size());\n    }\n\n    @Test\n    public void prefers_expression_with_longest_non_empty_match() {\n        ParameterType<String> zeroOrMore = new ParameterType<>(\n                \"zero-or-more\",\n                \"[a-z]*\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        parameterTypeRegistry.defineParameterType(zeroOrMore);\n        ParameterType<String> exactlyOne = new ParameterType<>(\n                \"exactly-one\",\n                \"[a-z]\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        parameterTypeRegistry.defineParameterType(exactlyOne);\n\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"a simple step\");\n        assertEquals(2, generatedExpressions.size());\n        assertEquals(\"{exactly-one} {zero-or-more} {zero-or-more}\", generatedExpressions.get(0).getSource());\n        assertEquals(\"{zero-or-more} {zero-or-more} {zero-or-more}\", generatedExpressions.get(1).getSource());\n    }\n\n    private void assertExpression(String expectedExpression, List<String> expectedArgumentNames, String text) {\n        GeneratedExpression generatedExpression = generator.generateExpressions(text).get(0);\n        assertEquals(expectedExpression, generatedExpression.getSource());\n        assertEquals(expectedArgumentNames, generatedExpression.getParameterNames());\n\n        // Check that the generated expression matches the text\n        CucumberExpression cucumberExpression = new CucumberExpression(generatedExpression.getSource(), parameterTypeRegistry);\n        List<Argument<?>> match = cucumberExpression.match(text);\n        if (match == null) {\n            fail(String.format(\"Expected text '%s' to match generated expression '%s'\", text, generatedExpression.getSource()));\n        }\n        assertEquals(expectedArgumentNames.size(), match.size());\n    }\n\n}", "definition": "public class CucumberExpressionGeneratorTest", "class_docstring": "", "name": "CucumberExpressionGeneratorTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}, {"attribute_expression": "private final CucumberExpressionGenerator generator = new CucumberExpressionGenerator(parameterTypeRegistry);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CucumberExpressionGenerator", "name": "generator = new CucumberExpressionGenerator(parameterTypeRegistry)", "syntax_pass": true}, {"attribute_expression": "private static final DateFormat df = DateFormat.getDateInstance();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "DateFormat", "name": "df = DateFormat.getDateInstance()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void documents_expression_generation() {\n        CucumberExpressionGenerator generator = new CucumberExpressionGenerator(parameterTypeRegistry);\n        String undefinedStepText = \"I have 2 cucumbers and 1.5 tomato\";\n        GeneratedExpression generatedExpression = generator.generateExpressions(undefinedStepText).get(0);\n        assertEquals(\"I have {int} cucumbers and {double} tomato\", generatedExpression.getSource());\n        assertEquals(Double.class, generatedExpression.getParameterTypes().get(1).getType());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "documents_expression_generation", "params": [], "body": "                                                  {\n        CucumberExpressionGenerator generator = new CucumberExpressionGenerator(parameterTypeRegistry);\n        String undefinedStepText = \"I have 2 cucumbers and 1.5 tomato\";\n        GeneratedExpression generatedExpression = generator.generateExpressions(undefinedStepText).get(0);\n        assertEquals(\"I have {int} cucumbers and {double} tomato\", generatedExpression.getSource());\n        assertEquals(Double.class, generatedExpression.getParameterTypes().get(1).getType());\n    }", "signature": "@Test\n    public void documents_expression_generation()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_expression_for_no_args() {\n        assertExpression(\"hello\", Collections.<String>emptyList(), \"hello\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_expression_for_no_args", "params": [], "body": "                                                   {\n        assertExpression(\"hello\", Collections.<String>emptyList(), \"hello\");\n    }", "signature": "@Test\n    public void generates_expression_for_no_args()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_expression_with_escaped_left_parenthesis() {\n        assertExpression(\n                \"\\\\(iii)\", Collections.<String>emptyList(),\n                \"(iii)\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_expression_with_escaped_left_parenthesis", "params": [], "body": "                                                                     {\n        assertExpression(\n                \"\\\\(iii)\", Collections.<String>emptyList(),\n                \"(iii)\");\n    }", "signature": "@Test\n    public void generates_expression_with_escaped_left_parenthesis()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_expression_with_escaped_left_curly_brace() {\n        assertExpression(\n                \"\\\\{iii}\", Collections.<String>emptyList(),\n                \"{iii}\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_expression_with_escaped_left_curly_brace", "params": [], "body": "                                                                     {\n        assertExpression(\n                \"\\\\{iii}\", Collections.<String>emptyList(),\n                \"{iii}\");\n    }", "signature": "@Test\n    public void generates_expression_with_escaped_left_curly_brace()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_expression_with_escaped_slashes() {\n        assertExpression(\n                \"The {int}\\\\/{int}\\\\/{int} hey\", asList(\"int1\", \"int2\", \"int3\"),\n                \"The 1814/05/17 hey\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_expression_with_escaped_slashes", "params": [], "body": "                                                            {\n        assertExpression(\n                \"The {int}\\\\/{int}\\\\/{int} hey\", asList(\"int1\", \"int2\", \"int3\"),\n                \"The 1814/05/17 hey\");\n    }", "signature": "@Test\n    public void generates_expression_with_escaped_slashes()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_expression_for_int_double_arg() {\n        assertExpression(\n                \"I have {int} cukes and {double} euro\", asList(\"int1\", \"double1\"),\n                \"I have 2 cukes and 1.5 euro\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_expression_for_int_double_arg", "params": [], "body": "                                                          {\n        assertExpression(\n                \"I have {int} cukes and {double} euro\", asList(\"int1\", \"double1\"),\n                \"I have 2 cukes and 1.5 euro\");\n    }", "signature": "@Test\n    public void generates_expression_for_int_double_arg()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_expression_for_numbers_with_symbols_and_currency() {\n        assertExpression(\n                \"Some ${double} of cukes at {int}\u00b0 Celsius\", asList(\"double1\", \"int1\"),\n                \"Some $5000.00 of cukes at 42\u00b0 Celsius\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_expression_for_numbers_with_symbols_and_currency", "params": [], "body": "                                                                             {\n        assertExpression(\n                \"Some ${double} of cukes at {int}\u00b0 Celsius\", asList(\"double1\", \"int1\"),\n                \"Some $5000.00 of cukes at 42\u00b0 Celsius\");\n    }", "signature": "@Test\n    public void generates_expression_for_numbers_with_symbols_and_currency()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_expression_for_numbers_with_text_on_both_sides() {\n        assertExpression(\n                \"i18n\", asList(),\n                \"i18n\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_expression_for_numbers_with_text_on_both_sides", "params": [], "body": "                                                                           {\n        assertExpression(\n                \"i18n\", asList(),\n                \"i18n\");\n    }", "signature": "@Test\n    public void generates_expression_for_numbers_with_text_on_both_sides()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_expression_for_strings() {\n        assertExpression(\n                \"I like {string} and {string}\", asList(\"string\", \"string2\"),\n                \"I like \\\"bangers\\\" and 'mash'\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_expression_for_strings", "params": [], "body": "                                                   {\n        assertExpression(\n                \"I like {string} and {string}\", asList(\"string\", \"string2\"),\n                \"I like \\\"bangers\\\" and 'mash'\");\n    }", "signature": "@Test\n    public void generates_expression_for_strings()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_expression_with_percent_sign() {\n        assertExpression(\n                \"I am {int}% foobar\", singletonList(\"int1\"),\n                \"I am 20% foobar\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_expression_with_percent_sign", "params": [], "body": "                                                         {\n        assertExpression(\n                \"I am {int}% foobar\", singletonList(\"int1\"),\n                \"I am 20% foobar\");\n    }", "signature": "@Test\n    public void generates_expression_with_percent_sign()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_expression_for_just_int() {\n        assertExpression(\n                \"{int}\", singletonList(\"int1\"),\n                \"99999\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_expression_for_just_int", "params": [], "body": "                                                    {\n        assertExpression(\n                \"{int}\", singletonList(\"int1\"),\n                \"99999\");\n    }", "signature": "@Test\n    public void generates_expression_for_just_int()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void numbers_all_arguments_when_type_is_reserved_keyword() {\n        assertExpression(\n                \"I have {int} cukes and {int} euro\", asList(\"int1\", \"int2\"),\n                \"I have 2 cukes and 5 euro\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "numbers_all_arguments_when_type_is_reserved_keyword", "params": [], "body": "                                                                      {\n        assertExpression(\n                \"I have {int} cukes and {int} euro\", asList(\"int1\", \"int2\"),\n                \"I have 2 cukes and 5 euro\");\n    }", "signature": "@Test\n    public void numbers_all_arguments_when_type_is_reserved_keyword()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void numbers_only_second_argument_when_type_is_not_reserved_keyword() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"currency\",\n                \"[A-Z]{3}\",\n                Currency.class,\n                new Transformer<Currency>() {\n                    @Override\n                    public Currency transform(String arg) {\n                        return Currency.getInstance(arg);\n                    }\n                }\n        ));\n        assertExpression(\n                \"I have a {currency} account and a {currency} account\", asList(\"currency\", \"currency2\"),\n                \"I have a EUR account and a GBP account\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "numbers_only_second_argument_when_type_is_not_reserved_keyword", "params": [], "body": "                                                                                 {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"currency\",\n                \"[A-Z]{3}\",\n                Currency.class,\n                new Transformer<Currency>() {\n                    @Override\n                    public Currency transform(String arg) {\n                        return Currency.getInstance(arg);\n                    }\n                }\n        ));\n        assertExpression(\n                \"I have a {currency} account and a {currency} account\", asList(\"currency\", \"currency2\"),\n                \"I have a EUR account and a GBP account\");\n    }", "signature": "@Test\n    public void numbers_only_second_argument_when_type_is_not_reserved_keyword()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void does_not_suggest_parameter_type_when_surrounded_by_alphanum() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"direction\",\n                \"(up|down)\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                },\n                true,\n                false\n        ));\n        assertExpression(\n                \"I like muppets\", Collections.<String>emptyList(),\n                \"I like muppets\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "does_not_suggest_parameter_type_when_surrounded_by_alphanum", "params": [], "body": "                                                                              {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"direction\",\n                \"(up|down)\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                },\n                true,\n                false\n        ));\n        assertExpression(\n                \"I like muppets\", Collections.<String>emptyList(),\n                \"I like muppets\");\n    }", "signature": "@Test\n    public void does_not_suggest_parameter_type_when_surrounded_by_alphanum()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void does_suggest_parameter_type_when_surrounded_by_space() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"direction\",\n                \"(up|down)\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                },\n                true,\n                false\n        ));\n        assertExpression(\n                \"it went {direction} and {direction}\", asList(\"direction\", \"direction2\"),\n                \"it went up and down\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "does_suggest_parameter_type_when_surrounded_by_space", "params": [], "body": "                                                                       {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"direction\",\n                \"(up|down)\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                },\n                true,\n                false\n        ));\n        assertExpression(\n                \"it went {direction} and {direction}\", asList(\"direction\", \"direction2\"),\n                \"it went up and down\");\n    }", "signature": "@Test\n    public void does_suggest_parameter_type_when_surrounded_by_space()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void prefers_leftmost_match_when_there_is_overlap() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"right\",\n                \"c d\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"left\",\n                \"b c\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                }\n        ));\n        assertExpression(\n                \"a {left} d e f g\", singletonList(\"left\"),\n                \"a b c d e f g\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "prefers_leftmost_match_when_there_is_overlap", "params": [], "body": "                                                               {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"right\",\n                \"c d\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"left\",\n                \"b c\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                }\n        ));\n        assertExpression(\n                \"a {left} d e f g\", singletonList(\"left\"),\n                \"a b c d e f g\");\n    }", "signature": "@Test\n    public void prefers_leftmost_match_when_there_is_overlap()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void prefers_widest_match_when_pos_is_same() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"airport\",\n                \"[A-Z]{3}\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"leg\",\n                \"[A-Z]{3}-[A-Z]{3}\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        assertExpression(\n                \"leg {leg}\", singletonList(\"leg\"),\n                \"leg LHR-CDG\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "prefers_widest_match_when_pos_is_same", "params": [], "body": "                                                        {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"airport\",\n                \"[A-Z]{3}\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"leg\",\n                \"[A-Z]{3}-[A-Z]{3}\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        assertExpression(\n                \"leg {leg}\", singletonList(\"leg\"),\n                \"leg LHR-CDG\");\n    }", "signature": "@Test\n    public void prefers_widest_match_when_pos_is_same()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_all_combinations_of_expressions_when_several_parameter_types_match() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"currency\",\n                \"x\",\n                Currency.class,\n                (Transformer<Currency>) Currency::getInstance,\n                true,\n                true\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"date\",\n                \"x\",\n                Date.class,\n                new Transformer<Date>() {\n                    @Override\n                    public Date transform(String arg) {\n                        try {\n                            return df.parse(arg);\n                        } catch (ParseException e) {\n                            throw new RuntimeException(e);\n                        }\n                    }\n                },\n                true,\n                false\n        ));\n\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"I have x and x and another x\");\n        List<String> expressions = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            expressions.add(source);\n        }\n        assertEquals(asList(\n                \"I have {currency} and {currency} and another {currency}\",\n                \"I have {currency} and {currency} and another {date}\",\n                \"I have {currency} and {date} and another {currency}\",\n                \"I have {currency} and {date} and another {date}\",\n                \"I have {date} and {currency} and another {currency}\",\n                \"I have {date} and {currency} and another {date}\",\n                \"I have {date} and {date} and another {currency}\",\n                \"I have {date} and {date} and another {date}\"\n        ), expressions);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_all_combinations_of_expressions_when_several_parameter_types_match", "params": [], "body": "                                                                                               {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"currency\",\n                \"x\",\n                Currency.class,\n                (Transformer<Currency>) Currency::getInstance,\n                true,\n                true\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"date\",\n                \"x\",\n                Date.class,\n                new Transformer<Date>() {\n                    @Override\n                    public Date transform(String arg) {\n                        try {\n                            return df.parse(arg);\n                        } catch (ParseException e) {\n                            throw new RuntimeException(e);\n                        }\n                    }\n                },\n                true,\n                false\n        ));\n\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"I have x and x and another x\");\n        List<String> expressions = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            expressions.add(source);\n        }\n        assertEquals(asList(\n                \"I have {currency} and {currency} and another {currency}\",\n                \"I have {currency} and {currency} and another {date}\",\n                \"I have {currency} and {date} and another {currency}\",\n                \"I have {currency} and {date} and another {date}\",\n                \"I have {date} and {currency} and another {currency}\",\n                \"I have {date} and {currency} and another {date}\",\n                \"I have {date} and {date} and another {currency}\",\n                \"I have {date} and {date} and another {date}\"\n        ), expressions);\n    }", "signature": "@Test\n    public void generates_all_combinations_of_expressions_when_several_parameter_types_match()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void exposes_transforms_in_generated_expression() {\n        GeneratedExpression generatedExpression = generator.generateExpressions(\"I have 2 cukes and 1.5 euro\").get(0);\n        assertEquals(Integer.class, generatedExpression.getParameterTypes().get(0).getType());\n        assertEquals(Double.class, generatedExpression.getParameterTypes().get(1).getType());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "exposes_transforms_in_generated_expression", "params": [], "body": "                                                             {\n        GeneratedExpression generatedExpression = generator.generateExpressions(\"I have 2 cukes and 1.5 euro\").get(0);\n        assertEquals(Integer.class, generatedExpression.getParameterTypes().get(0).getType());\n        assertEquals(Double.class, generatedExpression.getParameterTypes().get(1).getType());\n    }", "signature": "@Test\n    public void exposes_transforms_in_generated_expression()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_parameter_types_with_optional_capture_groups() {\n        ParameterType<String> optionalFlight = new ParameterType<>(\n                \"optional-flight\",\n                \"(1st flight)?\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        ParameterType<String> optionalHotel = new ParameterType<>(\n                \"optional-hotel\",\n                \"(1 hotel)?\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n\n        parameterTypeRegistry.defineParameterType(optionalFlight);\n        parameterTypeRegistry.defineParameterType(optionalHotel);\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"I reach Stage 4: 1st flight -1 hotel\");\n        assertEquals(\"I reach Stage {int}: {optional-flight} {int} hotel\", generatedExpressions.get(0).getSource());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_parameter_types_with_optional_capture_groups", "params": [], "body": "                                                                       {\n        ParameterType<String> optionalFlight = new ParameterType<>(\n                \"optional-flight\",\n                \"(1st flight)?\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        ParameterType<String> optionalHotel = new ParameterType<>(\n                \"optional-hotel\",\n                \"(1 hotel)?\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n\n        parameterTypeRegistry.defineParameterType(optionalFlight);\n        parameterTypeRegistry.defineParameterType(optionalHotel);\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"I reach Stage 4: 1st flight -1 hotel\");\n        assertEquals(\"I reach Stage {int}: {optional-flight} {int} hotel\", generatedExpressions.get(0).getSource());\n    }", "signature": "@Test\n    public void matches_parameter_types_with_optional_capture_groups()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void generates_at_most_256_expressions() {\n        for (int i = 0; i < 4; i++) {\n            ParameterType<String> myType = new ParameterType<>(\n                    \"my-type-\" + i,\n                    \"[a-z]\",\n                    String.class,\n                    (Transformer<String>) arg -> arg,\n                    true,\n                    false\n            );\n            parameterTypeRegistry.defineParameterType(myType);\n\n        }\n        // This would otherwise generate 4^11=419430 expressions and consume just shy of 1.5GB.\n        assertEquals(256, generator.generateExpressions(\"a b c d e f g h i j k\").size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_at_most_256_expressions", "params": [], "body": "                                                    {\n        for (int i = 0; i < 4; i++) {\n            ParameterType<String> myType = new ParameterType<>(\n                    \"my-type-\" + i,\n                    \"[a-z]\",\n                    String.class,\n                    (Transformer<String>) arg -> arg,\n                    true,\n                    false\n            );\n            parameterTypeRegistry.defineParameterType(myType);\n\n        }\n        // This would otherwise generate 4^11=419430 expressions and consume just shy of 1.5GB.\n        assertEquals(256, generator.generateExpressions(\"a b c d e f g h i j k\").size());\n    }", "signature": "@Test\n    public void generates_at_most_256_expressions()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void prefers_expression_with_longest_non_empty_match() {\n        ParameterType<String> zeroOrMore = new ParameterType<>(\n                \"zero-or-more\",\n                \"[a-z]*\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        parameterTypeRegistry.defineParameterType(zeroOrMore);\n        ParameterType<String> exactlyOne = new ParameterType<>(\n                \"exactly-one\",\n                \"[a-z]\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        parameterTypeRegistry.defineParameterType(exactlyOne);\n\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"a simple step\");\n        assertEquals(2, generatedExpressions.size());\n        assertEquals(\"{exactly-one} {zero-or-more} {zero-or-more}\", generatedExpressions.get(0).getSource());\n        assertEquals(\"{zero-or-more} {zero-or-more} {zero-or-more}\", generatedExpressions.get(1).getSource());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "prefers_expression_with_longest_non_empty_match", "params": [], "body": "                                                                  {\n        ParameterType<String> zeroOrMore = new ParameterType<>(\n                \"zero-or-more\",\n                \"[a-z]*\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        parameterTypeRegistry.defineParameterType(zeroOrMore);\n        ParameterType<String> exactlyOne = new ParameterType<>(\n                \"exactly-one\",\n                \"[a-z]\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        parameterTypeRegistry.defineParameterType(exactlyOne);\n\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"a simple step\");\n        assertEquals(2, generatedExpressions.size());\n        assertEquals(\"{exactly-one} {zero-or-more} {zero-or-more}\", generatedExpressions.get(0).getSource());\n        assertEquals(\"{zero-or-more} {zero-or-more} {zero-or-more}\", generatedExpressions.get(1).getSource());\n    }", "signature": "@Test\n    public void prefers_expression_with_longest_non_empty_match()"}, {"syntax_pass": true, "original_string": "    private void assertExpression(String expectedExpression, List<String> expectedArgumentNames, String text) {\n        GeneratedExpression generatedExpression = generator.generateExpressions(text).get(0);\n        assertEquals(expectedExpression, generatedExpression.getSource());\n        assertEquals(expectedArgumentNames, generatedExpression.getParameterNames());\n\n        // Check that the generated expression matches the text\n        CucumberExpression cucumberExpression = new CucumberExpression(generatedExpression.getSource(), parameterTypeRegistry);\n        List<Argument<?>> match = cucumberExpression.match(text);\n        if (match == null) {\n            fail(String.format(\"Expected text '%s' to match generated expression '%s'\", text, generatedExpression.getSource()));\n        }\n        assertEquals(expectedArgumentNames.size(), match.size());\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertExpression", "params": [{"name": "expectedExpression", "type": "String"}, {"name": "expectedArgumentNames", "type": "List<String>"}, {"name": "text", "type": "String"}], "body": "                                                                                                              {\n        GeneratedExpression generatedExpression = generator.generateExpressions(text).get(0);\n        assertEquals(expectedExpression, generatedExpression.getSource());\n        assertEquals(expectedArgumentNames, generatedExpression.getParameterNames());\n\n        // Check that the generated expression matches the text\n        CucumberExpression cucumberExpression = new CucumberExpression(generatedExpression.getSource(), parameterTypeRegistry);\n        List<Argument<?>> match = cucumberExpression.match(text);\n        if (match == null) {\n            fail(String.format(\"Expected text '%s' to match generated expression '%s'\", text, generatedExpression.getSource()));\n        }\n        assertEquals(expectedArgumentNames.size(), match.size());\n    }", "signature": "private void assertExpression(String expectedExpression, List<String> expectedArgumentNames, String text)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry_setDefaultParameterTransformerTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertSame;\n\nimport java.util.Locale;\nimport java.lang.reflect.Type;\n\npublic class ParameterTypeRegistry_setDefaultParameterTransformerTest {\n\n    private ParameterTypeRegistry parameterTypeRegistry;\n    private ParameterByTypeTransformer mockTransformer;\n\n    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        mockTransformer = new ParameterByTypeTransformer() {\n            @Override\n            public Object transform(String fromValue, Type toValueType) {\n                return null;\n            }\n        };\n    }\n\n    @Test\n    public void testSetDefaultParameterTransformer() {\n        // Given\n        ParameterByTypeTransformer originalTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n\n        // When\n        parameterTypeRegistry.setDefaultParameterTransformer(mockTransformer);\n\n        // Then\n        assertSame(mockTransformer, parameterTypeRegistry.getDefaultParameterTransformer());\n    }\n}\n", "file_hash": "8f93b6016685ce34dbead6bc73b4bfd72e4109b38a37f3e89c86454586fb6dd2", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.assertSame;", "import java.util.Locale;", "import java.lang.reflect.Type;"], "methods": [], "classes": [{"original_string": "public class ParameterTypeRegistry_setDefaultParameterTransformerTest {\n\n    private ParameterTypeRegistry parameterTypeRegistry;\n    private ParameterByTypeTransformer mockTransformer;\n\n    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        mockTransformer = new ParameterByTypeTransformer() {\n            @Override\n            public Object transform(String fromValue, Type toValueType) {\n                return null;\n            }\n        };\n    }\n\n    @Test\n    public void testSetDefaultParameterTransformer() {\n        // Given\n        ParameterByTypeTransformer originalTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n\n        // When\n        parameterTypeRegistry.setDefaultParameterTransformer(mockTransformer);\n\n        // Then\n        assertSame(mockTransformer, parameterTypeRegistry.getDefaultParameterTransformer());\n    }\n}", "definition": "public class ParameterTypeRegistry_setDefaultParameterTransformerTest", "class_docstring": "", "name": "ParameterTypeRegistry_setDefaultParameterTransformerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}, {"attribute_expression": "private ParameterByTypeTransformer mockTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterByTypeTransformer", "name": "mockTransformer", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        mockTransformer = new ParameterByTypeTransformer() {\n            @Override\n            public Object transform(String fromValue, Type toValueType) {\n                return null;\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        mockTransformer = new ParameterByTypeTransformer() {\n            @Override\n            public Object transform(String fromValue, Type toValueType) {\n                return null;\n            }\n        };\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSetDefaultParameterTransformer() {\n        // Given\n        ParameterByTypeTransformer originalTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n\n        // When\n        parameterTypeRegistry.setDefaultParameterTransformer(mockTransformer);\n\n        // Then\n        assertSame(mockTransformer, parameterTypeRegistry.getDefaultParameterTransformer());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetDefaultParameterTransformer", "params": [], "body": "                                                     {\n        // Given\n        ParameterByTypeTransformer originalTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n\n        // When\n        parameterTypeRegistry.setDefaultParameterTransformer(mockTransformer);\n\n        // Then\n        assertSame(mockTransformer, parameterTypeRegistry.getDefaultParameterTransformer());\n    }", "signature": "@Test\n    public void testSetDefaultParameterTransformer()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/RegexpUtils_escapeRegexTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass RegexpUtils_escapeRegexTest {\n\n    @Test\n    void testEscapeRegex_NoSpecialChars() {\n        String input = \"hello world\";\n        String expected = \"hello world\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testEscapeRegex_WithSpecialChars() {\n        String input = \"hello.world$\";\n        String expected = \"hello\\\\.world\\\\$\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testEscapeRegex_AllSpecialChars() {\n        String input = \"^$(){}[].+*?\\\\\";\n        String expected = \"\\\\^\\\\$\\\\(\\\\)\\\\{\\\\}\\\\[\\\\]\\\\.\\\\+\\\\*\\\\?\\\\\\\\\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }\n}\n", "file_hash": "ac84d081874bff26c3be252e1b44f362d3d809ca45c5715b4225fb3521db7859", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "class RegexpUtils_escapeRegexTest {\n\n    @Test\n    void testEscapeRegex_NoSpecialChars() {\n        String input = \"hello world\";\n        String expected = \"hello world\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testEscapeRegex_WithSpecialChars() {\n        String input = \"hello.world$\";\n        String expected = \"hello\\\\.world\\\\$\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testEscapeRegex_AllSpecialChars() {\n        String input = \"^$(){}[].+*?\\\\\";\n        String expected = \"\\\\^\\\\$\\\\(\\\\)\\\\{\\\\}\\\\[\\\\]\\\\.\\\\+\\\\*\\\\?\\\\\\\\\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }\n}", "definition": "class RegexpUtils_escapeRegexTest", "class_docstring": "", "name": "RegexpUtils_escapeRegexTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    void testEscapeRegex_NoSpecialChars() {\n        String input = \"hello world\";\n        String expected = \"hello world\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testEscapeRegex_NoSpecialChars", "params": [], "body": "                                          {\n        String input = \"hello world\";\n        String expected = \"hello world\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }", "signature": "@Test\n    void testEscapeRegex_NoSpecialChars()"}, {"syntax_pass": true, "original_string": "    @Test\n    void testEscapeRegex_WithSpecialChars() {\n        String input = \"hello.world$\";\n        String expected = \"hello\\\\.world\\\\$\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testEscapeRegex_WithSpecialChars", "params": [], "body": "                                            {\n        String input = \"hello.world$\";\n        String expected = \"hello\\\\.world\\\\$\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }", "signature": "@Test\n    void testEscapeRegex_WithSpecialChars()"}, {"syntax_pass": true, "original_string": "    @Test\n    void testEscapeRegex_AllSpecialChars() {\n        String input = \"^$(){}[].+*?\\\\\";\n        String expected = \"\\\\^\\\\$\\\\(\\\\)\\\\{\\\\}\\\\[\\\\]\\\\.\\\\+\\\\*\\\\?\\\\\\\\\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testEscapeRegex_AllSpecialChars", "params": [], "body": "                                           {\n        String input = \"^$(){}[].+*?\\\\\";\n        String expected = \"\\\\^\\\\$\\\\(\\\\)\\\\{\\\\}\\\\[\\\\]\\\\.\\\\+\\\\*\\\\?\\\\\\\\\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }", "signature": "@Test\n    void testEscapeRegex_AllSpecialChars()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/CustomParameterTypeTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.function.Executable;\n\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Pattern;\n\nimport static java.lang.Integer.parseInt;\nimport static java.util.Arrays.asList;\nimport static java.util.regex.Pattern.compile;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.IsEqual.equalTo;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.fail;\n\npublic class CustomParameterTypeTest {\n\n    private ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    public static class Coordinate {\n        private final int x;\n        private final int y;\n        private final int z;\n\n        Coordinate(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Coordinate that = (Coordinate) o;\n            return x == that.x && y == that.y && z == that.z;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            result = 31 * result + z;\n            return result;\n        }\n    }\n\n    @BeforeEach\n    public void create_parameter() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"color\",                                  // name\n                \"red|blue|yellow\",                        // regexp\n                Color.class,                              // type\n                Color::new,                               // transform\n                false,                                    // useForSnippets\n                false                                     // preferForRegexpMatch\n        ));\n    }\n\n    @Test\n    public void throws_exception_for_illegal_character_in_parameter_name() {\n\n        final Executable testMethod = () -> new ParameterType<>(\n                \"(string)\",\n                \".*\",\n                String.class,\n                (Transformer<String>) s -> s,\n                false,\n                false\n        );\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(thrownException.getMessage(), is(equalTo(\"Illegal character in parameter name {(string)}. Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\")));\n    }\n\n    @Test\n    public void matches_CucumberExpression_parameters_with_custom_parameter_type() {\n        Expression expression = new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a red ball\").get(0).getValue();\n        assertEquals(new Color(\"red\"), argumentValue);\n    }\n\n    @Test\n    public void matches_CucumberExpression_parameters_with_multiple_capture_groups() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"coordinate\",\n                \"(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\",\n                Coordinate.class,\n                new CaptureGroupTransformer<Coordinate>() {\n                    @Override\n                    public Coordinate transform(String[] args) {\n                        return new Coordinate(\n                                parseInt(args[0]),\n                                parseInt(args[1]),\n                                parseInt(args[2]));\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"A {int} thick line from {coordinate} to {coordinate}\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n        Integer thick = (Integer) arguments.get(0).getValue();\n        Coordinate from = (Coordinate) arguments.get(1).getValue();\n        Coordinate to = (Coordinate) arguments.get(2).getValue();\n        assertEquals(Integer.valueOf(5), thick);\n        assertEquals(new Coordinate(10, 20, 30), from);\n        assertEquals(new Coordinate(40, 50, 60), to);\n    }\n\n    @Test\n    public void warns_when_CucumberExpression_parameters_with_multiple_capture_groups_has_a_transformer() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"coordinate\",\n                \"(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\",\n                Coordinate.class,\n                new Transformer<Coordinate>() {\n                    @Override\n                    public Coordinate transform(String args) {\n                        throw new IllegalStateException();\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"A {int} thick line from {coordinate} to {coordinate}\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n\n        arguments.get(0).getValue();\n\n        final Executable testMethod = () -> arguments.get(1).getValue();\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"ParameterType {coordinate} was registered with a Transformer but has multiple capture groups [(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)]. \" +\n                        \"Did you mean to use a CaptureGroupTransformer?\"\n        )));\n    }\n\n    @Test\n    public void warns_when_anonymous_parameter_has_multiple_capture_groups() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        Expression expression = new RegularExpression(Pattern.compile(\"^A (\\\\d+) thick line from ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)) to ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+))$\"), parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\",\n                Integer.class, Coordinate.class, Coordinate.class);\n\n        arguments.get(0).getValue();\n\n        final Executable testMethod = () -> arguments.get(1).getValue();\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Anonymous ParameterType has multiple capture groups [(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)]. \" +\n                        \"You can only use a single capture group in an anonymous ParameterType.\"\n        )));\n    }\n\n    @Test\n    public void matches_CucumberExpression_parameters_with_custom_parameter_type_using_optional_group() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"color\",\n                asList(\"red|blue|yellow\", \"(?:dark|light) (?:red|blue|yellow)\"),\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a dark red ball\").get(0).getValue();\n        assertEquals(new Color(\"dark red\"), argumentValue);\n    }\n\n    @Test\n    public void defers_transformation_until_queried_from_argument() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"throwing\",\n                \"bad\",\n                CssColor.class,\n                new Transformer<CssColor>() {\n                    @Override\n                    public CssColor transform(String arg) {\n                        throw new RuntimeException(String.format(\"Can't transform [%s]\", arg));\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"I have a {throwing} parameter\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"I have a bad parameter\");\n        try {\n            arguments.get(0).getValue();\n            fail(\"should have failed\");\n        } catch (RuntimeException expected) {\n            assertEquals(\"ParameterType {throwing} failed to transform [bad] to \" + CssColor.class, expected.getMessage());\n        }\n    }\n\n    @Test\n    public void conflicting_parameter_type_is_detected_for_type_name() {\n        try {\n            parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                    \"color\",\n                    \".*\",\n                    CssColor.class,\n                    CssColor::new,\n                    false,\n                    false\n            ));\n            fail(\"should have failed\");\n        } catch (DuplicateTypeNameException expected) {\n            assertEquals(\"There is already a parameter type with name color\", expected.getMessage());\n        }\n    }\n\n    @Test\n    public void conflicting_parameter_type_is_not_detected_for_type() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"whatever\",\n                \".*\",\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n    }\n\n    ///// Conflicting parameter types\n\n    @Test\n    public void conflicting_parameter_type_is_not_detected_for_regexp() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"css-color\",\n                \"red|blue|yellow\",\n                CssColor.class,\n                CssColor::new,\n                false,\n                false\n        ));\n\n        assertEquals(new CssColor(\"blue\"), new CucumberExpression(\"I have a {css-color} ball\", parameterTypeRegistry).match(\"I have a blue ball\").get(0).getValue());\n        assertEquals(new Color(\"blue\"), new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry).match(\"I have a blue ball\").get(0).getValue());\n    }\n\n    @Test\n    public void matches_RegularExpression_arguments_with_custom_parameter_type_without_name() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                null,\n                \"red|blue|yellow\",\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n\n        Expression expression = new RegularExpression(compile(\"I have a (red|blue|yellow) ball\"), parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a red ball\").get(0).getValue();\n        assertEquals(new Color(\"red\"), argumentValue);\n    }\n\n    ///// RegularExpression\n\n    public static class Color {\n        final String name;\n\n        Color(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof Color && ((Color) obj).name.equals(name);\n        }\n    }\n\n    public static class CssColor {\n        final String name;\n\n        CssColor(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof CssColor && ((CssColor) obj).name.equals(name);\n        }\n    }\n\n}\n", "file_hash": "5c13ac9fa3b200ac7aa29edc42663bed94c0d49556643f14fc3b8fd067f69cd7", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.function.Executable;", "import java.util.List;", "import java.util.Locale;", "import java.util.regex.Pattern;", "import static java.lang.Integer.parseInt;", "import static java.util.Arrays.asList;", "import static java.util.regex.Pattern.compile;", "import static org.hamcrest.CoreMatchers.is;", "import static org.hamcrest.MatcherAssert.assertThat;", "import static org.hamcrest.core.IsEqual.equalTo;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import static org.junit.jupiter.api.Assertions.fail;"], "methods": [], "classes": [{"original_string": "public class CustomParameterTypeTest {\n\n    private ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    public static class Coordinate {\n        private final int x;\n        private final int y;\n        private final int z;\n\n        Coordinate(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Coordinate that = (Coordinate) o;\n            return x == that.x && y == that.y && z == that.z;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            result = 31 * result + z;\n            return result;\n        }\n    }\n\n    @BeforeEach\n    public void create_parameter() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"color\",                                  // name\n                \"red|blue|yellow\",                        // regexp\n                Color.class,                              // type\n                Color::new,                               // transform\n                false,                                    // useForSnippets\n                false                                     // preferForRegexpMatch\n        ));\n    }\n\n    @Test\n    public void throws_exception_for_illegal_character_in_parameter_name() {\n\n        final Executable testMethod = () -> new ParameterType<>(\n                \"(string)\",\n                \".*\",\n                String.class,\n                (Transformer<String>) s -> s,\n                false,\n                false\n        );\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(thrownException.getMessage(), is(equalTo(\"Illegal character in parameter name {(string)}. Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\")));\n    }\n\n    @Test\n    public void matches_CucumberExpression_parameters_with_custom_parameter_type() {\n        Expression expression = new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a red ball\").get(0).getValue();\n        assertEquals(new Color(\"red\"), argumentValue);\n    }\n\n    @Test\n    public void matches_CucumberExpression_parameters_with_multiple_capture_groups() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"coordinate\",\n                \"(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\",\n                Coordinate.class,\n                new CaptureGroupTransformer<Coordinate>() {\n                    @Override\n                    public Coordinate transform(String[] args) {\n                        return new Coordinate(\n                                parseInt(args[0]),\n                                parseInt(args[1]),\n                                parseInt(args[2]));\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"A {int} thick line from {coordinate} to {coordinate}\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n        Integer thick = (Integer) arguments.get(0).getValue();\n        Coordinate from = (Coordinate) arguments.get(1).getValue();\n        Coordinate to = (Coordinate) arguments.get(2).getValue();\n        assertEquals(Integer.valueOf(5), thick);\n        assertEquals(new Coordinate(10, 20, 30), from);\n        assertEquals(new Coordinate(40, 50, 60), to);\n    }\n\n    @Test\n    public void warns_when_CucumberExpression_parameters_with_multiple_capture_groups_has_a_transformer() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"coordinate\",\n                \"(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\",\n                Coordinate.class,\n                new Transformer<Coordinate>() {\n                    @Override\n                    public Coordinate transform(String args) {\n                        throw new IllegalStateException();\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"A {int} thick line from {coordinate} to {coordinate}\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n\n        arguments.get(0).getValue();\n\n        final Executable testMethod = () -> arguments.get(1).getValue();\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"ParameterType {coordinate} was registered with a Transformer but has multiple capture groups [(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)]. \" +\n                        \"Did you mean to use a CaptureGroupTransformer?\"\n        )));\n    }\n\n    @Test\n    public void warns_when_anonymous_parameter_has_multiple_capture_groups() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        Expression expression = new RegularExpression(Pattern.compile(\"^A (\\\\d+) thick line from ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)) to ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+))$\"), parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\",\n                Integer.class, Coordinate.class, Coordinate.class);\n\n        arguments.get(0).getValue();\n\n        final Executable testMethod = () -> arguments.get(1).getValue();\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Anonymous ParameterType has multiple capture groups [(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)]. \" +\n                        \"You can only use a single capture group in an anonymous ParameterType.\"\n        )));\n    }\n\n    @Test\n    public void matches_CucumberExpression_parameters_with_custom_parameter_type_using_optional_group() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"color\",\n                asList(\"red|blue|yellow\", \"(?:dark|light) (?:red|blue|yellow)\"),\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a dark red ball\").get(0).getValue();\n        assertEquals(new Color(\"dark red\"), argumentValue);\n    }\n\n    @Test\n    public void defers_transformation_until_queried_from_argument() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"throwing\",\n                \"bad\",\n                CssColor.class,\n                new Transformer<CssColor>() {\n                    @Override\n                    public CssColor transform(String arg) {\n                        throw new RuntimeException(String.format(\"Can't transform [%s]\", arg));\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"I have a {throwing} parameter\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"I have a bad parameter\");\n        try {\n            arguments.get(0).getValue();\n            fail(\"should have failed\");\n        } catch (RuntimeException expected) {\n            assertEquals(\"ParameterType {throwing} failed to transform [bad] to \" + CssColor.class, expected.getMessage());\n        }\n    }\n\n    @Test\n    public void conflicting_parameter_type_is_detected_for_type_name() {\n        try {\n            parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                    \"color\",\n                    \".*\",\n                    CssColor.class,\n                    CssColor::new,\n                    false,\n                    false\n            ));\n            fail(\"should have failed\");\n        } catch (DuplicateTypeNameException expected) {\n            assertEquals(\"There is already a parameter type with name color\", expected.getMessage());\n        }\n    }\n\n    @Test\n    public void conflicting_parameter_type_is_not_detected_for_type() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"whatever\",\n                \".*\",\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n    }\n\n    ///// Conflicting parameter types\n\n    @Test\n    public void conflicting_parameter_type_is_not_detected_for_regexp() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"css-color\",\n                \"red|blue|yellow\",\n                CssColor.class,\n                CssColor::new,\n                false,\n                false\n        ));\n\n        assertEquals(new CssColor(\"blue\"), new CucumberExpression(\"I have a {css-color} ball\", parameterTypeRegistry).match(\"I have a blue ball\").get(0).getValue());\n        assertEquals(new Color(\"blue\"), new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry).match(\"I have a blue ball\").get(0).getValue());\n    }\n\n    @Test\n    public void matches_RegularExpression_arguments_with_custom_parameter_type_without_name() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                null,\n                \"red|blue|yellow\",\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n\n        Expression expression = new RegularExpression(compile(\"I have a (red|blue|yellow) ball\"), parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a red ball\").get(0).getValue();\n        assertEquals(new Color(\"red\"), argumentValue);\n    }\n\n    ///// RegularExpression\n\n    public static class Color {\n        final String name;\n\n        Color(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof Color && ((Color) obj).name.equals(name);\n        }\n    }\n\n    public static class CssColor {\n        final String name;\n\n        CssColor(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof CssColor && ((CssColor) obj).name.equals(name);\n        }\n    }\n\n}", "definition": "public class CustomParameterTypeTest", "class_docstring": "", "name": "CustomParameterTypeTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}], "classes": [{"original_string": "    public static class Coordinate {\n        private final int x;\n        private final int y;\n        private final int z;\n\n        Coordinate(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Coordinate that = (Coordinate) o;\n            return x == that.x && y == that.y && z == that.z;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            result = 31 * result + z;\n            return result;\n        }\n    }", "definition": "    public static class Coordinate", "class_docstring": "", "name": "Coordinate", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final int x;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "x", "syntax_pass": true}, {"attribute_expression": "private final int y;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "y", "syntax_pass": true}, {"attribute_expression": "private final int z;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "z", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Coordinate(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Coordinate", "params": [{"name": "x", "type": "int"}, {"name": "y", "type": "int"}, {"name": "z", "type": "int"}], "body": "                                        {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }", "signature": "Coordinate(int x, int y, int z)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Coordinate that = (Coordinate) o;\n            return x == that.x && y == that.y && z == that.z;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                        {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Coordinate that = (Coordinate) o;\n            return x == that.x && y == that.y && z == that.z;\n        }", "signature": "@Override\n        public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            result = 31 * result + z;\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            int result = x;\n            result = 31 * result + y;\n            result = 31 * result + z;\n            return result;\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    public static class Color {\n        final String name;\n\n        Color(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof Color && ((Color) obj).name.equals(name);\n        }\n    }", "definition": "    public static class Color", "class_docstring": "// RegularExpression", "name": "Color", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "final String name;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Color(String name) {\n            this.name = name;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Color", "params": [{"name": "name", "type": "String"}], "body": "                           {\n            this.name = name;\n        }", "signature": "Color(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return name.hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof Color && ((Color) obj).name.equals(name);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                          {\n            return obj instanceof Color && ((Color) obj).name.equals(name);\n        }", "signature": "@Override\n        public boolean equals(Object obj)"}]}, {"original_string": "    public static class CssColor {\n        final String name;\n\n        CssColor(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof CssColor && ((CssColor) obj).name.equals(name);\n        }\n    }", "definition": "    public static class CssColor", "class_docstring": "", "name": "CssColor", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "final String name;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        CssColor(String name) {\n            this.name = name;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CssColor", "params": [{"name": "name", "type": "String"}], "body": "                              {\n            this.name = name;\n        }", "signature": "CssColor(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return name.hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof CssColor && ((CssColor) obj).name.equals(name);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                          {\n            return obj instanceof CssColor && ((CssColor) obj).name.equals(name);\n        }", "signature": "@Override\n        public boolean equals(Object obj)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void create_parameter() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"color\",                                  // name\n                \"red|blue|yellow\",                        // regexp\n                Color.class,                              // type\n                Color::new,                               // transform\n                false,                                    // useForSnippets\n                false                                     // preferForRegexpMatch\n        ));\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "create_parameter", "params": [], "body": "                                   {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"color\",                                  // name\n                \"red|blue|yellow\",                        // regexp\n                Color.class,                              // type\n                Color::new,                               // transform\n                false,                                    // useForSnippets\n                false                                     // preferForRegexpMatch\n        ));\n    }", "signature": "@BeforeEach\n    public void create_parameter()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void throws_exception_for_illegal_character_in_parameter_name() {\n\n        final Executable testMethod = () -> new ParameterType<>(\n                \"(string)\",\n                \".*\",\n                String.class,\n                (Transformer<String>) s -> s,\n                false,\n                false\n        );\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(thrownException.getMessage(), is(equalTo(\"Illegal character in parameter name {(string)}. Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "throws_exception_for_illegal_character_in_parameter_name", "params": [], "body": "                                                                           {\n\n        final Executable testMethod = () -> new ParameterType<>(\n                \"(string)\",\n                \".*\",\n                String.class,\n                (Transformer<String>) s -> s,\n                false,\n                false\n        );\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(thrownException.getMessage(), is(equalTo(\"Illegal character in parameter name {(string)}. Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\")));\n    }", "signature": "@Test\n    public void throws_exception_for_illegal_character_in_parameter_name()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_CucumberExpression_parameters_with_custom_parameter_type() {\n        Expression expression = new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a red ball\").get(0).getValue();\n        assertEquals(new Color(\"red\"), argumentValue);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_CucumberExpression_parameters_with_custom_parameter_type", "params": [], "body": "                                                                                   {\n        Expression expression = new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a red ball\").get(0).getValue();\n        assertEquals(new Color(\"red\"), argumentValue);\n    }", "signature": "@Test\n    public void matches_CucumberExpression_parameters_with_custom_parameter_type()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_CucumberExpression_parameters_with_multiple_capture_groups() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"coordinate\",\n                \"(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\",\n                Coordinate.class,\n                new CaptureGroupTransformer<Coordinate>() {\n                    @Override\n                    public Coordinate transform(String[] args) {\n                        return new Coordinate(\n                                parseInt(args[0]),\n                                parseInt(args[1]),\n                                parseInt(args[2]));\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"A {int} thick line from {coordinate} to {coordinate}\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n        Integer thick = (Integer) arguments.get(0).getValue();\n        Coordinate from = (Coordinate) arguments.get(1).getValue();\n        Coordinate to = (Coordinate) arguments.get(2).getValue();\n        assertEquals(Integer.valueOf(5), thick);\n        assertEquals(new Coordinate(10, 20, 30), from);\n        assertEquals(new Coordinate(40, 50, 60), to);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_CucumberExpression_parameters_with_multiple_capture_groups", "params": [], "body": "                                                                                     {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"coordinate\",\n                \"(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\",\n                Coordinate.class,\n                new CaptureGroupTransformer<Coordinate>() {\n                    @Override\n                    public Coordinate transform(String[] args) {\n                        return new Coordinate(\n                                parseInt(args[0]),\n                                parseInt(args[1]),\n                                parseInt(args[2]));\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"A {int} thick line from {coordinate} to {coordinate}\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n        Integer thick = (Integer) arguments.get(0).getValue();\n        Coordinate from = (Coordinate) arguments.get(1).getValue();\n        Coordinate to = (Coordinate) arguments.get(2).getValue();\n        assertEquals(Integer.valueOf(5), thick);\n        assertEquals(new Coordinate(10, 20, 30), from);\n        assertEquals(new Coordinate(40, 50, 60), to);\n    }", "signature": "@Test\n    public void matches_CucumberExpression_parameters_with_multiple_capture_groups()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void warns_when_CucumberExpression_parameters_with_multiple_capture_groups_has_a_transformer() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"coordinate\",\n                \"(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\",\n                Coordinate.class,\n                new Transformer<Coordinate>() {\n                    @Override\n                    public Coordinate transform(String args) {\n                        throw new IllegalStateException();\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"A {int} thick line from {coordinate} to {coordinate}\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n\n        arguments.get(0).getValue();\n\n        final Executable testMethod = () -> arguments.get(1).getValue();\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"ParameterType {coordinate} was registered with a Transformer but has multiple capture groups [(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)]. \" +\n                        \"Did you mean to use a CaptureGroupTransformer?\"\n        )));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "warns_when_CucumberExpression_parameters_with_multiple_capture_groups_has_a_transformer", "params": [], "body": "                                                                                                          {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"coordinate\",\n                \"(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\",\n                Coordinate.class,\n                new Transformer<Coordinate>() {\n                    @Override\n                    public Coordinate transform(String args) {\n                        throw new IllegalStateException();\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"A {int} thick line from {coordinate} to {coordinate}\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n\n        arguments.get(0).getValue();\n\n        final Executable testMethod = () -> arguments.get(1).getValue();\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"ParameterType {coordinate} was registered with a Transformer but has multiple capture groups [(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)]. \" +\n                        \"Did you mean to use a CaptureGroupTransformer?\"\n        )));\n    }", "signature": "@Test\n    public void warns_when_CucumberExpression_parameters_with_multiple_capture_groups_has_a_transformer()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void warns_when_anonymous_parameter_has_multiple_capture_groups() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        Expression expression = new RegularExpression(Pattern.compile(\"^A (\\\\d+) thick line from ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)) to ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+))$\"), parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\",\n                Integer.class, Coordinate.class, Coordinate.class);\n\n        arguments.get(0).getValue();\n\n        final Executable testMethod = () -> arguments.get(1).getValue();\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Anonymous ParameterType has multiple capture groups [(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)]. \" +\n                        \"You can only use a single capture group in an anonymous ParameterType.\"\n        )));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "warns_when_anonymous_parameter_has_multiple_capture_groups", "params": [], "body": "                                                                             {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        Expression expression = new RegularExpression(Pattern.compile(\"^A (\\\\d+) thick line from ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)) to ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+))$\"), parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\",\n                Integer.class, Coordinate.class, Coordinate.class);\n\n        arguments.get(0).getValue();\n\n        final Executable testMethod = () -> arguments.get(1).getValue();\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Anonymous ParameterType has multiple capture groups [(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)]. \" +\n                        \"You can only use a single capture group in an anonymous ParameterType.\"\n        )));\n    }", "signature": "@Test\n    public void warns_when_anonymous_parameter_has_multiple_capture_groups()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_CucumberExpression_parameters_with_custom_parameter_type_using_optional_group() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"color\",\n                asList(\"red|blue|yellow\", \"(?:dark|light) (?:red|blue|yellow)\"),\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a dark red ball\").get(0).getValue();\n        assertEquals(new Color(\"dark red\"), argumentValue);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_CucumberExpression_parameters_with_custom_parameter_type_using_optional_group", "params": [], "body": "                                                                                                        {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"color\",\n                asList(\"red|blue|yellow\", \"(?:dark|light) (?:red|blue|yellow)\"),\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a dark red ball\").get(0).getValue();\n        assertEquals(new Color(\"dark red\"), argumentValue);\n    }", "signature": "@Test\n    public void matches_CucumberExpression_parameters_with_custom_parameter_type_using_optional_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void defers_transformation_until_queried_from_argument() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"throwing\",\n                \"bad\",\n                CssColor.class,\n                new Transformer<CssColor>() {\n                    @Override\n                    public CssColor transform(String arg) {\n                        throw new RuntimeException(String.format(\"Can't transform [%s]\", arg));\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"I have a {throwing} parameter\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"I have a bad parameter\");\n        try {\n            arguments.get(0).getValue();\n            fail(\"should have failed\");\n        } catch (RuntimeException expected) {\n            assertEquals(\"ParameterType {throwing} failed to transform [bad] to \" + CssColor.class, expected.getMessage());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "defers_transformation_until_queried_from_argument", "params": [], "body": "                                                                    {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"throwing\",\n                \"bad\",\n                CssColor.class,\n                new Transformer<CssColor>() {\n                    @Override\n                    public CssColor transform(String arg) {\n                        throw new RuntimeException(String.format(\"Can't transform [%s]\", arg));\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"I have a {throwing} parameter\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"I have a bad parameter\");\n        try {\n            arguments.get(0).getValue();\n            fail(\"should have failed\");\n        } catch (RuntimeException expected) {\n            assertEquals(\"ParameterType {throwing} failed to transform [bad] to \" + CssColor.class, expected.getMessage());\n        }\n    }", "signature": "@Test\n    public void defers_transformation_until_queried_from_argument()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void conflicting_parameter_type_is_detected_for_type_name() {\n        try {\n            parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                    \"color\",\n                    \".*\",\n                    CssColor.class,\n                    CssColor::new,\n                    false,\n                    false\n            ));\n            fail(\"should have failed\");\n        } catch (DuplicateTypeNameException expected) {\n            assertEquals(\"There is already a parameter type with name color\", expected.getMessage());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "conflicting_parameter_type_is_detected_for_type_name", "params": [], "body": "                                                                       {\n        try {\n            parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                    \"color\",\n                    \".*\",\n                    CssColor.class,\n                    CssColor::new,\n                    false,\n                    false\n            ));\n            fail(\"should have failed\");\n        } catch (DuplicateTypeNameException expected) {\n            assertEquals(\"There is already a parameter type with name color\", expected.getMessage());\n        }\n    }", "signature": "@Test\n    public void conflicting_parameter_type_is_detected_for_type_name()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void conflicting_parameter_type_is_not_detected_for_type() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"whatever\",\n                \".*\",\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "conflicting_parameter_type_is_not_detected_for_type", "params": [], "body": "                                                                      {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"whatever\",\n                \".*\",\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n    }", "signature": "@Test\n    public void conflicting_parameter_type_is_not_detected_for_type()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void conflicting_parameter_type_is_not_detected_for_regexp() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"css-color\",\n                \"red|blue|yellow\",\n                CssColor.class,\n                CssColor::new,\n                false,\n                false\n        ));\n\n        assertEquals(new CssColor(\"blue\"), new CucumberExpression(\"I have a {css-color} ball\", parameterTypeRegistry).match(\"I have a blue ball\").get(0).getValue());\n        assertEquals(new Color(\"blue\"), new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry).match(\"I have a blue ball\").get(0).getValue());\n    }", "docstring": "// Conflicting parameter types", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "conflicting_parameter_type_is_not_detected_for_regexp", "params": [], "body": "                                                                        {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"css-color\",\n                \"red|blue|yellow\",\n                CssColor.class,\n                CssColor::new,\n                false,\n                false\n        ));\n\n        assertEquals(new CssColor(\"blue\"), new CucumberExpression(\"I have a {css-color} ball\", parameterTypeRegistry).match(\"I have a blue ball\").get(0).getValue());\n        assertEquals(new Color(\"blue\"), new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry).match(\"I have a blue ball\").get(0).getValue());\n    }", "signature": "@Test\n    public void conflicting_parameter_type_is_not_detected_for_regexp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_RegularExpression_arguments_with_custom_parameter_type_without_name() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                null,\n                \"red|blue|yellow\",\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n\n        Expression expression = new RegularExpression(compile(\"I have a (red|blue|yellow) ball\"), parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a red ball\").get(0).getValue();\n        assertEquals(new Color(\"red\"), argumentValue);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_RegularExpression_arguments_with_custom_parameter_type_without_name", "params": [], "body": "                                                                                              {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                null,\n                \"red|blue|yellow\",\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n\n        Expression expression = new RegularExpression(compile(\"I have a (red|blue|yellow) ball\"), parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a red ball\").get(0).getValue();\n        assertEquals(new Color(\"red\"), argumentValue);\n    }", "signature": "@Test\n    public void matches_RegularExpression_arguments_with_custom_parameter_type_without_name()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTransformationTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.extension.ParameterContext;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.converter.ArgumentConversionException;\nimport org.junit.jupiter.params.converter.ArgumentConverter;\nimport org.junit.jupiter.params.converter.ConvertWith;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.yaml.snakeyaml.Yaml;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Locale;\n\nimport static java.nio.file.Files.newDirectoryStream;\nimport static java.nio.file.Files.newInputStream;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass CucumberExpressionTransformationTest {\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"transformation\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n        assertEquals(expectation.expected_regex, expression.getRegexp().pattern());\n    }\n\n    static class Expectation {\n        public String expression;\n        public String expected_regex;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n}\n", "file_hash": "42ff021888c406eb0a7695d7a65dc7f2b17c7d0f68a656484d78099b327e5ed1", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.extension.ParameterContext;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.converter.ArgumentConversionException;", "import org.junit.jupiter.params.converter.ArgumentConverter;", "import org.junit.jupiter.params.converter.ConvertWith;", "import org.junit.jupiter.params.provider.MethodSource;", "import org.yaml.snakeyaml.Yaml;", "import java.io.IOException;", "import java.io.InputStream;", "import java.nio.file.Path;", "import java.nio.file.Paths;", "import java.util.ArrayList;", "import java.util.Comparator;", "import java.util.List;", "import java.util.Locale;", "import static java.nio.file.Files.newDirectoryStream;", "import static java.nio.file.Files.newInputStream;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "class CucumberExpressionTransformationTest {\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"transformation\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n        assertEquals(expectation.expected_regex, expression.getRegexp().pattern());\n    }\n\n    static class Expectation {\n        public String expression;\n        public String expected_regex;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n}", "definition": "class CucumberExpressionTransformationTest", "class_docstring": "", "name": "CucumberExpressionTransformationTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}], "classes": [{"original_string": "    static class Expectation {\n        public String expression;\n        public String expected_regex;\n    }", "definition": "    static class Expectation", "class_docstring": "", "name": "Expectation", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String expression;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "public String expected_regex;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expected_regex", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }", "definition": "    static class Converter implements ArgumentConverter", "class_docstring": "", "name": "Converter", "super_interfaces": ["ArgumentConverter"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Yaml yaml = new Yaml();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Yaml", "name": "yaml = new Yaml()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expectation", "classes": []}, "name": "convert", "params": [{"name": "source", "type": "Object"}, {"name": "context", "type": "ParameterContext"}], "body": "                                                                                                               {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "signature": "@Override\n        public Expectation convert(Object source, ParameterContext context)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"transformation\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Path>", "classes": []}, "name": "acceptance_tests_pass", "params": [], "body": "                                                                         {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"transformation\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "signature": "private static List<Path> acceptance_tests_pass()"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n        assertEquals(expectation.expected_regex, expression.getRegexp().pattern());\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource", "marker_annotations": ["@ParameterizedTest", "@MethodSource"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "acceptance_tests_pass", "params": [{"name": "expectation", "type": "Expectation"}], "body": "                                                                                      {\n        CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n        assertEquals(expectation.expected_regex, expression.getRegexp().pattern());\n    }", "signature": "@ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_weightTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass ParameterType_weightTest {\n\n    @Test\n    void testWeightForIntegerClass() {\n        ParameterType<Integer> parameterType = new ParameterType<>(\"test\", \"(\\\\d+)\", Integer.class, (String arg) -> Integer.parseInt(arg));\n        assertEquals(1000, parameterType.weight());\n    }\n\n    @Test\n    void testWeightForNonIntegerType() {\n        ParameterType<String> parameterType = new ParameterType<>(\"test\", \"(\\\\w+)\", String.class, (String arg) -> arg);\n        assertEquals(0, parameterType.weight());\n    }\n}\n", "file_hash": "f21b811062b367cf5994cf25ba981feee017b02d5eb96af871f26c35787a5414", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "class ParameterType_weightTest {\n\n    @Test\n    void testWeightForIntegerClass() {\n        ParameterType<Integer> parameterType = new ParameterType<>(\"test\", \"(\\\\d+)\", Integer.class, (String arg) -> Integer.parseInt(arg));\n        assertEquals(1000, parameterType.weight());\n    }\n\n    @Test\n    void testWeightForNonIntegerType() {\n        ParameterType<String> parameterType = new ParameterType<>(\"test\", \"(\\\\w+)\", String.class, (String arg) -> arg);\n        assertEquals(0, parameterType.weight());\n    }\n}", "definition": "class ParameterType_weightTest", "class_docstring": "", "name": "ParameterType_weightTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    void testWeightForIntegerClass() {\n        ParameterType<Integer> parameterType = new ParameterType<>(\"test\", \"(\\\\d+)\", Integer.class, (String arg) -> Integer.parseInt(arg));\n        assertEquals(1000, parameterType.weight());\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testWeightForIntegerClass", "params": [], "body": "                                     {\n        ParameterType<Integer> parameterType = new ParameterType<>(\"test\", \"(\\\\d+)\", Integer.class, (String arg) -> Integer.parseInt(arg));\n        assertEquals(1000, parameterType.weight());\n    }", "signature": "@Test\n    void testWeightForIntegerClass()"}, {"syntax_pass": true, "original_string": "    @Test\n    void testWeightForNonIntegerType() {\n        ParameterType<String> parameterType = new ParameterType<>(\"test\", \"(\\\\w+)\", String.class, (String arg) -> arg);\n        assertEquals(0, parameterType.weight());\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testWeightForNonIntegerType", "params": [], "body": "                                       {\n        ParameterType<String> parameterType = new ParameterType<>(\"test\", \"(\\\\w+)\", String.class, (String arg) -> arg);\n        assertEquals(0, parameterType.weight());\n    }", "signature": "@Test\n    void testWeightForNonIntegerType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getRegexpTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport java.util.Locale;\nimport java.util.regex.Pattern;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CucumberExpression_getRegexpTest {\n\n    private ParameterTypeRegistry parameterTypeRegistry;\n\n    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }\n\n    @Test\n    public void testGetRegexp() {\n        String expression = \"I have {int} cucumbers\";\n        CucumberExpression cucumberExpression = new CucumberExpression(expression, parameterTypeRegistry);\n\n        Pattern expectedPattern = Pattern.compile(\"I have (-?\\\\d+) cucumbers\");\n        assertEquals(expectedPattern.pattern(), cucumberExpression.getRegexp().pattern());\n    }\n}\n", "file_hash": "0253e401899cf9569fadf63628b8431f60c42755ee8540ac93c2f2561e49c34e", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import java.util.Locale;", "import java.util.regex.Pattern;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class CucumberExpression_getRegexpTest {\n\n    private ParameterTypeRegistry parameterTypeRegistry;\n\n    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }\n\n    @Test\n    public void testGetRegexp() {\n        String expression = \"I have {int} cucumbers\";\n        CucumberExpression cucumberExpression = new CucumberExpression(expression, parameterTypeRegistry);\n\n        Pattern expectedPattern = Pattern.compile(\"I have (-?\\\\d+) cucumbers\");\n        assertEquals(expectedPattern.pattern(), cucumberExpression.getRegexp().pattern());\n    }\n}", "definition": "public class CucumberExpression_getRegexpTest", "class_docstring": "", "name": "CucumberExpression_getRegexpTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetRegexp() {\n        String expression = \"I have {int} cucumbers\";\n        CucumberExpression cucumberExpression = new CucumberExpression(expression, parameterTypeRegistry);\n\n        Pattern expectedPattern = Pattern.compile(\"I have (-?\\\\d+) cucumbers\");\n        assertEquals(expectedPattern.pattern(), cucumberExpression.getRegexp().pattern());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetRegexp", "params": [], "body": "                                {\n        String expression = \"I have {int} cucumbers\";\n        CucumberExpression cucumberExpression = new CucumberExpression(expression, parameterTypeRegistry);\n\n        Pattern expectedPattern = Pattern.compile(\"I have (-?\\\\d+) cucumbers\");\n        assertEquals(expectedPattern.pattern(), cucumberExpression.getRegexp().pattern());\n    }", "signature": "@Test\n    public void testGetRegexp()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.function.Executable;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.regex.Pattern;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.IsEqual.equalTo;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class PatternCompilerProviderTest {\n\n    @BeforeEach\n    public void setUp() {\n        PatternCompilerProvider.service = null;\n    }\n\n    @AfterEach\n    public void tearDown() {\n        PatternCompilerProvider.service = null;\n    }\n\n    @Test\n    public void use_default_compiler_if_none_registered() {\n        PatternCompilerProvider.findPatternCompiler(Collections.emptyIterator());\n        assertSame(DefaultPatternCompiler.class, PatternCompilerProvider.service.getClass());\n    }\n\n    @Test\n    public void use_found_pattern_compiler_if_one_provided() {\n        PatternCompiler compiler = getTestCompiler();\n        PatternCompilerProvider.findPatternCompiler(Collections.singletonList(compiler).iterator());\n        assertSame(compiler, PatternCompilerProvider.service);\n    }\n\n    @Test\n    public void throws_error_if_more_than_one_pattern_compiler() {\n\n        final Executable testMethod = () -> PatternCompilerProvider.findPatternCompiler(Arrays.asList(new DefaultPatternCompiler(), getTestCompiler()).iterator());\n\n        final IllegalStateException thrownException = assertThrows(IllegalStateException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"More than one PatternCompiler: [class io.cucumber.cucumberexpressions.DefaultPatternCompiler, class io.cucumber.cucumberexpressions.PatternCompilerProviderTest$1]\")));\n    }\n\n    private PatternCompiler getTestCompiler() {\n        return new PatternCompiler() {\n            @Override\n            public Pattern compile(String regexp, int flags) {\n                return null;\n            }\n        };\n    }\n\n}\n", "file_hash": "4314def69e72a0bb808a9eeee0f232c8dd925237bf0b3404110df9af11aef696", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.AfterEach;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.function.Executable;", "import java.util.Arrays;", "import java.util.Collections;", "import java.util.regex.Pattern;", "import static org.hamcrest.CoreMatchers.is;", "import static org.hamcrest.MatcherAssert.assertThat;", "import static org.hamcrest.core.IsEqual.equalTo;", "import static org.junit.jupiter.api.Assertions.assertSame;", "import static org.junit.jupiter.api.Assertions.assertThrows;"], "methods": [], "classes": [{"original_string": "public class PatternCompilerProviderTest {\n\n    @BeforeEach\n    public void setUp() {\n        PatternCompilerProvider.service = null;\n    }\n\n    @AfterEach\n    public void tearDown() {\n        PatternCompilerProvider.service = null;\n    }\n\n    @Test\n    public void use_default_compiler_if_none_registered() {\n        PatternCompilerProvider.findPatternCompiler(Collections.emptyIterator());\n        assertSame(DefaultPatternCompiler.class, PatternCompilerProvider.service.getClass());\n    }\n\n    @Test\n    public void use_found_pattern_compiler_if_one_provided() {\n        PatternCompiler compiler = getTestCompiler();\n        PatternCompilerProvider.findPatternCompiler(Collections.singletonList(compiler).iterator());\n        assertSame(compiler, PatternCompilerProvider.service);\n    }\n\n    @Test\n    public void throws_error_if_more_than_one_pattern_compiler() {\n\n        final Executable testMethod = () -> PatternCompilerProvider.findPatternCompiler(Arrays.asList(new DefaultPatternCompiler(), getTestCompiler()).iterator());\n\n        final IllegalStateException thrownException = assertThrows(IllegalStateException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"More than one PatternCompiler: [class io.cucumber.cucumberexpressions.DefaultPatternCompiler, class io.cucumber.cucumberexpressions.PatternCompilerProviderTest$1]\")));\n    }\n\n    private PatternCompiler getTestCompiler() {\n        return new PatternCompiler() {\n            @Override\n            public Pattern compile(String regexp, int flags) {\n                return null;\n            }\n        };\n    }\n\n}", "definition": "public class PatternCompilerProviderTest", "class_docstring": "", "name": "PatternCompilerProviderTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        PatternCompilerProvider.service = null;\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        PatternCompilerProvider.service = null;\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @AfterEach\n    public void tearDown() {\n        PatternCompilerProvider.service = null;\n    }", "docstring": "", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "tearDown", "params": [], "body": "                           {\n        PatternCompilerProvider.service = null;\n    }", "signature": "@AfterEach\n    public void tearDown()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void use_default_compiler_if_none_registered() {\n        PatternCompilerProvider.findPatternCompiler(Collections.emptyIterator());\n        assertSame(DefaultPatternCompiler.class, PatternCompilerProvider.service.getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "use_default_compiler_if_none_registered", "params": [], "body": "                                                          {\n        PatternCompilerProvider.findPatternCompiler(Collections.emptyIterator());\n        assertSame(DefaultPatternCompiler.class, PatternCompilerProvider.service.getClass());\n    }", "signature": "@Test\n    public void use_default_compiler_if_none_registered()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void use_found_pattern_compiler_if_one_provided() {\n        PatternCompiler compiler = getTestCompiler();\n        PatternCompilerProvider.findPatternCompiler(Collections.singletonList(compiler).iterator());\n        assertSame(compiler, PatternCompilerProvider.service);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "use_found_pattern_compiler_if_one_provided", "params": [], "body": "                                                             {\n        PatternCompiler compiler = getTestCompiler();\n        PatternCompilerProvider.findPatternCompiler(Collections.singletonList(compiler).iterator());\n        assertSame(compiler, PatternCompilerProvider.service);\n    }", "signature": "@Test\n    public void use_found_pattern_compiler_if_one_provided()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void throws_error_if_more_than_one_pattern_compiler() {\n\n        final Executable testMethod = () -> PatternCompilerProvider.findPatternCompiler(Arrays.asList(new DefaultPatternCompiler(), getTestCompiler()).iterator());\n\n        final IllegalStateException thrownException = assertThrows(IllegalStateException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"More than one PatternCompiler: [class io.cucumber.cucumberexpressions.DefaultPatternCompiler, class io.cucumber.cucumberexpressions.PatternCompilerProviderTest$1]\")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "throws_error_if_more_than_one_pattern_compiler", "params": [], "body": "                                                                 {\n\n        final Executable testMethod = () -> PatternCompilerProvider.findPatternCompiler(Arrays.asList(new DefaultPatternCompiler(), getTestCompiler()).iterator());\n\n        final IllegalStateException thrownException = assertThrows(IllegalStateException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"More than one PatternCompiler: [class io.cucumber.cucumberexpressions.DefaultPatternCompiler, class io.cucumber.cucumberexpressions.PatternCompilerProviderTest$1]\")));\n    }", "signature": "@Test\n    public void throws_error_if_more_than_one_pattern_compiler()"}, {"syntax_pass": true, "original_string": "    private PatternCompiler getTestCompiler() {\n        return new PatternCompiler() {\n            @Override\n            public Pattern compile(String regexp, int flags) {\n                return null;\n            }\n        };\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "PatternCompiler", "classes": []}, "name": "getTestCompiler", "params": [], "body": "                                              {\n        return new PatternCompiler() {\n            @Override\n            public Pattern compile(String regexp, int flags) {\n                return null;\n            }\n        };\n    }", "signature": "private PatternCompiler getTestCompiler()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/CustomMatchers.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.hamcrest.BaseMatcher;\nimport org.hamcrest.Description;\nimport org.hamcrest.Matcher;\nimport org.hamcrest.collection.IsIterableContainingInOrder;\nimport org.hamcrest.core.IsEqual;\nimport org.hamcrest.number.IsCloseTo;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static org.hamcrest.Matchers.equalTo;\n\npublic class CustomMatchers {\n    public static Matcher<Iterable<?>> equalOrCloseTo(List<?> list) {\n        if (list == null || list.isEmpty()) return equalTo(list);\n        List<Matcher<?>> matchers = list.stream().map(EqualOrCloseTo::new).collect(Collectors.toList());\n        return new IsIterableContainingInOrder(matchers);\n    }\n\n    private static class EqualOrCloseTo<T> extends BaseMatcher<T> {\n        private final Object expectedValue;\n\n        public EqualOrCloseTo(Object expectedValue) {\n            this.expectedValue = expectedValue;\n        }\n\n        @Override\n        public boolean matches(Object actual) {\n            if(actual instanceof BigDecimal) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof BigInteger) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof Double || actual instanceof Float) {\n                return new IsCloseTo(((Double)this.expectedValue), 0.0001).matches(((Number)actual).doubleValue());\n            } else if(actual instanceof Byte) {\n                return new IsEqual(((Integer)this.expectedValue).byteValue()).matches(actual);\n            } else if(actual instanceof Short) {\n                return new IsEqual(((Integer)this.expectedValue).shortValue()).matches(actual);\n            } else if(actual instanceof Number || actual instanceof String || actual == null) {\n                return new IsEqual(this.expectedValue).matches(actual);\n            }\n            throw new RuntimeException(\"Unsupported type: \" + actual.getClass());\n        }\n\n        @Override\n        public void describeTo(Description description) {\n            description.appendValue(expectedValue);\n        }\n    }\n}\n", "file_hash": "1342db98f811f56ceb2c8c58e3e8c080fb35c951477c7f86f221c62ddbc85e25", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.hamcrest.BaseMatcher;", "import org.hamcrest.Description;", "import org.hamcrest.Matcher;", "import org.hamcrest.collection.IsIterableContainingInOrder;", "import org.hamcrest.core.IsEqual;", "import org.hamcrest.number.IsCloseTo;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import java.util.List;", "import java.util.stream.Collectors;", "import static org.hamcrest.Matchers.equalTo;"], "methods": [], "classes": [{"original_string": "public class CustomMatchers {\n    public static Matcher<Iterable<?>> equalOrCloseTo(List<?> list) {\n        if (list == null || list.isEmpty()) return equalTo(list);\n        List<Matcher<?>> matchers = list.stream().map(EqualOrCloseTo::new).collect(Collectors.toList());\n        return new IsIterableContainingInOrder(matchers);\n    }\n\n    private static class EqualOrCloseTo<T> extends BaseMatcher<T> {\n        private final Object expectedValue;\n\n        public EqualOrCloseTo(Object expectedValue) {\n            this.expectedValue = expectedValue;\n        }\n\n        @Override\n        public boolean matches(Object actual) {\n            if(actual instanceof BigDecimal) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof BigInteger) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof Double || actual instanceof Float) {\n                return new IsCloseTo(((Double)this.expectedValue), 0.0001).matches(((Number)actual).doubleValue());\n            } else if(actual instanceof Byte) {\n                return new IsEqual(((Integer)this.expectedValue).byteValue()).matches(actual);\n            } else if(actual instanceof Short) {\n                return new IsEqual(((Integer)this.expectedValue).shortValue()).matches(actual);\n            } else if(actual instanceof Number || actual instanceof String || actual == null) {\n                return new IsEqual(this.expectedValue).matches(actual);\n            }\n            throw new RuntimeException(\"Unsupported type: \" + actual.getClass());\n        }\n\n        @Override\n        public void describeTo(Description description) {\n            description.appendValue(expectedValue);\n        }\n    }\n}", "definition": "public class CustomMatchers", "class_docstring": "", "name": "CustomMatchers", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": [{"original_string": "    private static class EqualOrCloseTo<T> extends BaseMatcher<T> {\n        private final Object expectedValue;\n\n        public EqualOrCloseTo(Object expectedValue) {\n            this.expectedValue = expectedValue;\n        }\n\n        @Override\n        public boolean matches(Object actual) {\n            if(actual instanceof BigDecimal) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof BigInteger) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof Double || actual instanceof Float) {\n                return new IsCloseTo(((Double)this.expectedValue), 0.0001).matches(((Number)actual).doubleValue());\n            } else if(actual instanceof Byte) {\n                return new IsEqual(((Integer)this.expectedValue).byteValue()).matches(actual);\n            } else if(actual instanceof Short) {\n                return new IsEqual(((Integer)this.expectedValue).shortValue()).matches(actual);\n            } else if(actual instanceof Number || actual instanceof String || actual == null) {\n                return new IsEqual(this.expectedValue).matches(actual);\n            }\n            throw new RuntimeException(\"Unsupported type: \" + actual.getClass());\n        }\n\n        @Override\n        public void describeTo(Description description) {\n            description.appendValue(expectedValue);\n        }\n    }", "definition": "    private static class EqualOrCloseTo<T> extends BaseMatcher<T>", "class_docstring": "", "name": "EqualOrCloseTo", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Object expectedValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "expectedValue", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public EqualOrCloseTo(Object expectedValue) {\n            this.expectedValue = expectedValue;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "EqualOrCloseTo", "params": [{"name": "expectedValue", "type": "Object"}], "body": "                                                    {\n            this.expectedValue = expectedValue;\n        }", "signature": "public EqualOrCloseTo(Object expectedValue)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Object actual) {\n            if(actual instanceof BigDecimal) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof BigInteger) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof Double || actual instanceof Float) {\n                return new IsCloseTo(((Double)this.expectedValue), 0.0001).matches(((Number)actual).doubleValue());\n            } else if(actual instanceof Byte) {\n                return new IsEqual(((Integer)this.expectedValue).byteValue()).matches(actual);\n            } else if(actual instanceof Short) {\n                return new IsEqual(((Integer)this.expectedValue).shortValue()).matches(actual);\n            } else if(actual instanceof Number || actual instanceof String || actual == null) {\n                return new IsEqual(this.expectedValue).matches(actual);\n            }\n            throw new RuntimeException(\"Unsupported type: \" + actual.getClass());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "actual", "type": "Object"}], "body": "                                              {\n            if(actual instanceof BigDecimal) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof BigInteger) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof Double || actual instanceof Float) {\n                return new IsCloseTo(((Double)this.expectedValue), 0.0001).matches(((Number)actual).doubleValue());\n            } else if(actual instanceof Byte) {\n                return new IsEqual(((Integer)this.expectedValue).byteValue()).matches(actual);\n            } else if(actual instanceof Short) {\n                return new IsEqual(((Integer)this.expectedValue).shortValue()).matches(actual);\n            } else if(actual instanceof Number || actual instanceof String || actual == null) {\n                return new IsEqual(this.expectedValue).matches(actual);\n            }\n            throw new RuntimeException(\"Unsupported type: \" + actual.getClass());\n        }", "signature": "@Override\n        public boolean matches(Object actual)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void describeTo(Description description) {\n            description.appendValue(expectedValue);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "describeTo", "params": [{"name": "description", "type": "Description"}], "body": "                                                        {\n            description.appendValue(expectedValue);\n        }", "signature": "@Override\n        public void describeTo(Description description)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static Matcher<Iterable<?>> equalOrCloseTo(List<?> list) {\n        if (list == null || list.isEmpty()) return equalTo(list);\n        List<Matcher<?>> matchers = list.stream().map(EqualOrCloseTo::new).collect(Collectors.toList());\n        return new IsIterableContainingInOrder(matchers);\n    }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Matcher<Iterable<?>>", "classes": []}, "name": "equalOrCloseTo", "params": [{"name": "list", "type": "List<?>"}], "body": "                                                                    {\n        if (list == null || list.isEmpty()) return equalTo(list);\n        List<Matcher<?>> matchers = list.stream().map(EqualOrCloseTo::new).collect(Collectors.toList());\n        return new IsIterableContainingInOrder(matchers);\n    }", "signature": "public static Matcher<Iterable<?>> equalOrCloseTo(List<?> list)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/TreeRegexpTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\nimport static java.util.Arrays.asList;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class TreeRegexpTest {\n\n    @Test\n    public void exposes_group_source() {\n        TreeRegexp tr = new TreeRegexp(\"(a(?:b)?)(c)\");\n        List<String> list = new ArrayList<>();\n        for (GroupBuilder gb : tr.getGroupBuilder().getChildren()) {\n            String source = gb.getSource();\n            list.add(source);\n        }\n        assertEquals(asList(\"a(?:b)?\", \"c\"), list);\n    }\n\n    @Test\n    public void builds_tree() {\n        TreeRegexp tr = new TreeRegexp(\"(a(b(c))(d))\");\n        Group g = tr.match(\"abcd\");\n        assertEquals(\"abcd\", g.getChildren().get(0).getValue());\n        assertEquals(\"bc\", g.getChildren().get(0).getChildren().get(0).getValue());\n        assertEquals(\"c\", g.getChildren().get(0).getChildren().get(0).getChildren().get(0).getValue());\n        assertEquals(\"d\", g.getChildren().get(0).getChildren().get(1).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_colon_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?:b)(c)\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void ignores_question_mark_exclamation_mark_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?!b)(.+)\");\n        Group g = tr.match(\"aBc\");\n        assertEquals(\"aBc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void ignores_question_mark_equal_sign_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?=b)(.+)\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_less_than_equal_sign_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(.+)(?<=c)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_less_than_exclamation_mark_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(.+)(?<!b)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_greater_then_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?>b)(c)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"c\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void matches_named_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?<name>b)c$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"b\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void matches_optional_group() {\n        TreeRegexp tr = new TreeRegexp(\"^Something( with an optional argument)?\");\n        Group g = tr.match(\"Something\");\n        assertNull(g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void matches_nested_groups() {\n        TreeRegexp tr = new TreeRegexp(\"^A (\\\\d+) thick line from ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)) to ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+))\");\n        Group g = tr.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n\n        assertEquals(\"5\", g.getChildren().get(0).getValue());\n        assertEquals(\"10,20,30\", g.getChildren().get(1).getValue());\n        assertEquals(\"10\", g.getChildren().get(1).getChildren().get(0).getValue());\n        assertEquals(\"20\", g.getChildren().get(1).getChildren().get(1).getValue());\n        assertEquals(\"30\", g.getChildren().get(1).getChildren().get(2).getValue());\n        assertEquals(\"40,50,60\", g.getChildren().get(2).getValue());\n        assertEquals(\"40\", g.getChildren().get(2).getChildren().get(0).getValue());\n        assertEquals(\"50\", g.getChildren().get(2).getChildren().get(1).getValue());\n        assertEquals(\"60\", g.getChildren().get(2).getChildren().get(2).getValue());\n    }\n\n    @Test\n    public void captures_non_capturing_groups_with_capturing_groups_inside() {\n        TreeRegexp tr = new TreeRegexp(\"the stdout(?: from \\\"(.*?)\\\")?\");\n        Group g = tr.match(\"the stdout\");\n        assertEquals(\"the stdout\", g.getValue());\n        assertNull(g.getChildren().get(0).getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void detects_multiple_non_capturing_groups() {\n        TreeRegexp tr = new TreeRegexp(\"(?:a)(:b)(\\\\?c)(d)\");\n        Group g = tr.match(\"a:b?cd\");\n        assertEquals(3, g.getChildren().size());\n    }\n\n    @Test\n    public void works_with_escaped_backslash() {\n        TreeRegexp tr = new TreeRegexp(\"foo\\\\\\\\(bar|baz)\");\n        Group g = tr.match(\"foo\\\\bar\");\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void works_with_slash_which_doesnt_need_escaping_in_java() {\n        TreeRegexp tr = new TreeRegexp(\"^I go to '/(.+)'$\");\n        Group g = tr.match(\"I go to '/hello'\");\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void works_digit_and_word() {\n        TreeRegexp tr = new TreeRegexp(\"^(\\\\d) (\\\\w+) (\\\\w+)$\");\n        Group g = tr.match(\"2 you \u043f\u0440\u0438\u0432\u0435\u0442\");\n        assertEquals(3, g.getChildren().size());\n    }\n\n    @Test\n    public void captures_start_and_end() {\n        TreeRegexp tr = new TreeRegexp(\"^the step \\\"([^\\\"]*)\\\" has status \\\"([^\\\"]*)\\\"$\");\n        Group g = tr.match(\"the step \\\"a pending step\\\" has status \\\"pending\\\"\");\n        assertEquals(10, g.getChildren().get(0).getStart());\n        assertEquals(24, g.getChildren().get(0).getEnd());\n        assertEquals(38, g.getChildren().get(1).getStart());\n        assertEquals(45, g.getChildren().get(1).getEnd());\n    }\n\n    @Test\n    public void doesnt_consider_parenthesis_in_character_class_as_group() {\n        TreeRegexp tr = new TreeRegexp(\"^drawings: ([A-Z_, ()]+)$\");\n        Group g = tr.match(\"drawings: FU(BAR)\");\n        assertEquals(\"drawings: FU(BAR)\", g.getValue());\n        assertEquals(\"FU(BAR)\", g.getChildren().get(0).getValue());\n        assertEquals(0, g.getChildren().get(0).getChildren().size());\n    }\n\n    @Test\n    public void works_with_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"HELLO\", Pattern.CASE_INSENSITIVE));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n    }\n\n    @Test\n    public void works_with_inline_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?i)HELLO\"));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void works_with_non_capturing_inline_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?i:HELLO)\"));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void empty_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"()\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void empty_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?)\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void empty_look_ahead() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?<=)\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void uses_loaded_pattern_compiler_service() {\n        String regexp = \"[0-9]\";\n        TreeRegexp tr = new TreeRegexp(regexp);\n        assertNull(tr.match(\"1a\"));\n\n        PatternCompilerProvider.service = (re, flags) -> Pattern.compile(re + \"[a-z]\", flags);\n\n        tr = new TreeRegexp(regexp);\n        assertEquals(\"1a\", tr.match(\"1a\").getValue());\n        PatternCompilerProvider.service = null;\n    }\n\n}\n", "file_hash": "dcf188e749a2fb0919ad6818fa63a52ba71e37a2bced289e241195413d1c761b", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.regex.Pattern;", "import static java.util.Arrays.asList;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNull;"], "methods": [], "classes": [{"original_string": "public class TreeRegexpTest {\n\n    @Test\n    public void exposes_group_source() {\n        TreeRegexp tr = new TreeRegexp(\"(a(?:b)?)(c)\");\n        List<String> list = new ArrayList<>();\n        for (GroupBuilder gb : tr.getGroupBuilder().getChildren()) {\n            String source = gb.getSource();\n            list.add(source);\n        }\n        assertEquals(asList(\"a(?:b)?\", \"c\"), list);\n    }\n\n    @Test\n    public void builds_tree() {\n        TreeRegexp tr = new TreeRegexp(\"(a(b(c))(d))\");\n        Group g = tr.match(\"abcd\");\n        assertEquals(\"abcd\", g.getChildren().get(0).getValue());\n        assertEquals(\"bc\", g.getChildren().get(0).getChildren().get(0).getValue());\n        assertEquals(\"c\", g.getChildren().get(0).getChildren().get(0).getChildren().get(0).getValue());\n        assertEquals(\"d\", g.getChildren().get(0).getChildren().get(1).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_colon_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?:b)(c)\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void ignores_question_mark_exclamation_mark_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?!b)(.+)\");\n        Group g = tr.match(\"aBc\");\n        assertEquals(\"aBc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void ignores_question_mark_equal_sign_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?=b)(.+)\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_less_than_equal_sign_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(.+)(?<=c)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_less_than_exclamation_mark_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(.+)(?<!b)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_greater_then_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?>b)(c)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"c\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void matches_named_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?<name>b)c$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"b\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void matches_optional_group() {\n        TreeRegexp tr = new TreeRegexp(\"^Something( with an optional argument)?\");\n        Group g = tr.match(\"Something\");\n        assertNull(g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void matches_nested_groups() {\n        TreeRegexp tr = new TreeRegexp(\"^A (\\\\d+) thick line from ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)) to ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+))\");\n        Group g = tr.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n\n        assertEquals(\"5\", g.getChildren().get(0).getValue());\n        assertEquals(\"10,20,30\", g.getChildren().get(1).getValue());\n        assertEquals(\"10\", g.getChildren().get(1).getChildren().get(0).getValue());\n        assertEquals(\"20\", g.getChildren().get(1).getChildren().get(1).getValue());\n        assertEquals(\"30\", g.getChildren().get(1).getChildren().get(2).getValue());\n        assertEquals(\"40,50,60\", g.getChildren().get(2).getValue());\n        assertEquals(\"40\", g.getChildren().get(2).getChildren().get(0).getValue());\n        assertEquals(\"50\", g.getChildren().get(2).getChildren().get(1).getValue());\n        assertEquals(\"60\", g.getChildren().get(2).getChildren().get(2).getValue());\n    }\n\n    @Test\n    public void captures_non_capturing_groups_with_capturing_groups_inside() {\n        TreeRegexp tr = new TreeRegexp(\"the stdout(?: from \\\"(.*?)\\\")?\");\n        Group g = tr.match(\"the stdout\");\n        assertEquals(\"the stdout\", g.getValue());\n        assertNull(g.getChildren().get(0).getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void detects_multiple_non_capturing_groups() {\n        TreeRegexp tr = new TreeRegexp(\"(?:a)(:b)(\\\\?c)(d)\");\n        Group g = tr.match(\"a:b?cd\");\n        assertEquals(3, g.getChildren().size());\n    }\n\n    @Test\n    public void works_with_escaped_backslash() {\n        TreeRegexp tr = new TreeRegexp(\"foo\\\\\\\\(bar|baz)\");\n        Group g = tr.match(\"foo\\\\bar\");\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void works_with_slash_which_doesnt_need_escaping_in_java() {\n        TreeRegexp tr = new TreeRegexp(\"^I go to '/(.+)'$\");\n        Group g = tr.match(\"I go to '/hello'\");\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void works_digit_and_word() {\n        TreeRegexp tr = new TreeRegexp(\"^(\\\\d) (\\\\w+) (\\\\w+)$\");\n        Group g = tr.match(\"2 you \u043f\u0440\u0438\u0432\u0435\u0442\");\n        assertEquals(3, g.getChildren().size());\n    }\n\n    @Test\n    public void captures_start_and_end() {\n        TreeRegexp tr = new TreeRegexp(\"^the step \\\"([^\\\"]*)\\\" has status \\\"([^\\\"]*)\\\"$\");\n        Group g = tr.match(\"the step \\\"a pending step\\\" has status \\\"pending\\\"\");\n        assertEquals(10, g.getChildren().get(0).getStart());\n        assertEquals(24, g.getChildren().get(0).getEnd());\n        assertEquals(38, g.getChildren().get(1).getStart());\n        assertEquals(45, g.getChildren().get(1).getEnd());\n    }\n\n    @Test\n    public void doesnt_consider_parenthesis_in_character_class_as_group() {\n        TreeRegexp tr = new TreeRegexp(\"^drawings: ([A-Z_, ()]+)$\");\n        Group g = tr.match(\"drawings: FU(BAR)\");\n        assertEquals(\"drawings: FU(BAR)\", g.getValue());\n        assertEquals(\"FU(BAR)\", g.getChildren().get(0).getValue());\n        assertEquals(0, g.getChildren().get(0).getChildren().size());\n    }\n\n    @Test\n    public void works_with_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"HELLO\", Pattern.CASE_INSENSITIVE));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n    }\n\n    @Test\n    public void works_with_inline_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?i)HELLO\"));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void works_with_non_capturing_inline_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?i:HELLO)\"));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void empty_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"()\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void empty_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?)\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void empty_look_ahead() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?<=)\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void uses_loaded_pattern_compiler_service() {\n        String regexp = \"[0-9]\";\n        TreeRegexp tr = new TreeRegexp(regexp);\n        assertNull(tr.match(\"1a\"));\n\n        PatternCompilerProvider.service = (re, flags) -> Pattern.compile(re + \"[a-z]\", flags);\n\n        tr = new TreeRegexp(regexp);\n        assertEquals(\"1a\", tr.match(\"1a\").getValue());\n        PatternCompilerProvider.service = null;\n    }\n\n}", "definition": "public class TreeRegexpTest", "class_docstring": "", "name": "TreeRegexpTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void exposes_group_source() {\n        TreeRegexp tr = new TreeRegexp(\"(a(?:b)?)(c)\");\n        List<String> list = new ArrayList<>();\n        for (GroupBuilder gb : tr.getGroupBuilder().getChildren()) {\n            String source = gb.getSource();\n            list.add(source);\n        }\n        assertEquals(asList(\"a(?:b)?\", \"c\"), list);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "exposes_group_source", "params": [], "body": "                                       {\n        TreeRegexp tr = new TreeRegexp(\"(a(?:b)?)(c)\");\n        List<String> list = new ArrayList<>();\n        for (GroupBuilder gb : tr.getGroupBuilder().getChildren()) {\n            String source = gb.getSource();\n            list.add(source);\n        }\n        assertEquals(asList(\"a(?:b)?\", \"c\"), list);\n    }", "signature": "@Test\n    public void exposes_group_source()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void builds_tree() {\n        TreeRegexp tr = new TreeRegexp(\"(a(b(c))(d))\");\n        Group g = tr.match(\"abcd\");\n        assertEquals(\"abcd\", g.getChildren().get(0).getValue());\n        assertEquals(\"bc\", g.getChildren().get(0).getChildren().get(0).getValue());\n        assertEquals(\"c\", g.getChildren().get(0).getChildren().get(0).getChildren().get(0).getValue());\n        assertEquals(\"d\", g.getChildren().get(0).getChildren().get(1).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "builds_tree", "params": [], "body": "                              {\n        TreeRegexp tr = new TreeRegexp(\"(a(b(c))(d))\");\n        Group g = tr.match(\"abcd\");\n        assertEquals(\"abcd\", g.getChildren().get(0).getValue());\n        assertEquals(\"bc\", g.getChildren().get(0).getChildren().get(0).getValue());\n        assertEquals(\"c\", g.getChildren().get(0).getChildren().get(0).getChildren().get(0).getValue());\n        assertEquals(\"d\", g.getChildren().get(0).getChildren().get(1).getValue());\n    }", "signature": "@Test\n    public void builds_tree()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void ignores_question_mark_colon_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?:b)(c)\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "ignores_question_mark_colon_non_capturing_group", "params": [], "body": "                                                                  {\n        TreeRegexp tr = new TreeRegexp(\"a(?:b)(c)\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }", "signature": "@Test\n    public void ignores_question_mark_colon_non_capturing_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void ignores_question_mark_exclamation_mark_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?!b)(.+)\");\n        Group g = tr.match(\"aBc\");\n        assertEquals(\"aBc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "ignores_question_mark_exclamation_mark_non_capturing_group", "params": [], "body": "                                                                             {\n        TreeRegexp tr = new TreeRegexp(\"a(?!b)(.+)\");\n        Group g = tr.match(\"aBc\");\n        assertEquals(\"aBc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }", "signature": "@Test\n    public void ignores_question_mark_exclamation_mark_non_capturing_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void ignores_question_mark_equal_sign_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?=b)(.+)\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "ignores_question_mark_equal_sign_non_capturing_group", "params": [], "body": "                                                                       {\n        TreeRegexp tr = new TreeRegexp(\"a(?=b)(.+)\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }", "signature": "@Test\n    public void ignores_question_mark_equal_sign_non_capturing_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void ignores_question_mark_less_than_equal_sign_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(.+)(?<=c)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "ignores_question_mark_less_than_equal_sign_non_capturing_group", "params": [], "body": "                                                                                 {\n        TreeRegexp tr = new TreeRegexp(\"a(.+)(?<=c)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }", "signature": "@Test\n    public void ignores_question_mark_less_than_equal_sign_non_capturing_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void ignores_question_mark_less_than_exclamation_mark_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(.+)(?<!b)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "ignores_question_mark_less_than_exclamation_mark_non_capturing_group", "params": [], "body": "                                                                                       {\n        TreeRegexp tr = new TreeRegexp(\"a(.+)(?<!b)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }", "signature": "@Test\n    public void ignores_question_mark_less_than_exclamation_mark_non_capturing_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void ignores_question_mark_greater_then_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?>b)(c)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"c\", g.getChildren().get(0).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "ignores_question_mark_greater_then_non_capturing_group", "params": [], "body": "                                                                         {\n        TreeRegexp tr = new TreeRegexp(\"a(?>b)(c)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"c\", g.getChildren().get(0).getValue());\n    }", "signature": "@Test\n    public void ignores_question_mark_greater_then_non_capturing_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_named_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?<name>b)c$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"b\", g.getChildren().get(0).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_named_capturing_group", "params": [], "body": "                                                {\n        TreeRegexp tr = new TreeRegexp(\"a(?<name>b)c$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"b\", g.getChildren().get(0).getValue());\n    }", "signature": "@Test\n    public void matches_named_capturing_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_optional_group() {\n        TreeRegexp tr = new TreeRegexp(\"^Something( with an optional argument)?\");\n        Group g = tr.match(\"Something\");\n        assertNull(g.getChildren().get(0).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_optional_group", "params": [], "body": "                                         {\n        TreeRegexp tr = new TreeRegexp(\"^Something( with an optional argument)?\");\n        Group g = tr.match(\"Something\");\n        assertNull(g.getChildren().get(0).getValue());\n    }", "signature": "@Test\n    public void matches_optional_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_nested_groups() {\n        TreeRegexp tr = new TreeRegexp(\"^A (\\\\d+) thick line from ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)) to ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+))\");\n        Group g = tr.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n\n        assertEquals(\"5\", g.getChildren().get(0).getValue());\n        assertEquals(\"10,20,30\", g.getChildren().get(1).getValue());\n        assertEquals(\"10\", g.getChildren().get(1).getChildren().get(0).getValue());\n        assertEquals(\"20\", g.getChildren().get(1).getChildren().get(1).getValue());\n        assertEquals(\"30\", g.getChildren().get(1).getChildren().get(2).getValue());\n        assertEquals(\"40,50,60\", g.getChildren().get(2).getValue());\n        assertEquals(\"40\", g.getChildren().get(2).getChildren().get(0).getValue());\n        assertEquals(\"50\", g.getChildren().get(2).getChildren().get(1).getValue());\n        assertEquals(\"60\", g.getChildren().get(2).getChildren().get(2).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_nested_groups", "params": [], "body": "                                        {\n        TreeRegexp tr = new TreeRegexp(\"^A (\\\\d+) thick line from ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)) to ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+))\");\n        Group g = tr.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n\n        assertEquals(\"5\", g.getChildren().get(0).getValue());\n        assertEquals(\"10,20,30\", g.getChildren().get(1).getValue());\n        assertEquals(\"10\", g.getChildren().get(1).getChildren().get(0).getValue());\n        assertEquals(\"20\", g.getChildren().get(1).getChildren().get(1).getValue());\n        assertEquals(\"30\", g.getChildren().get(1).getChildren().get(2).getValue());\n        assertEquals(\"40,50,60\", g.getChildren().get(2).getValue());\n        assertEquals(\"40\", g.getChildren().get(2).getChildren().get(0).getValue());\n        assertEquals(\"50\", g.getChildren().get(2).getChildren().get(1).getValue());\n        assertEquals(\"60\", g.getChildren().get(2).getChildren().get(2).getValue());\n    }", "signature": "@Test\n    public void matches_nested_groups()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void captures_non_capturing_groups_with_capturing_groups_inside() {\n        TreeRegexp tr = new TreeRegexp(\"the stdout(?: from \\\"(.*?)\\\")?\");\n        Group g = tr.match(\"the stdout\");\n        assertEquals(\"the stdout\", g.getValue());\n        assertNull(g.getChildren().get(0).getValue());\n        assertEquals(1, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "captures_non_capturing_groups_with_capturing_groups_inside", "params": [], "body": "                                                                             {\n        TreeRegexp tr = new TreeRegexp(\"the stdout(?: from \\\"(.*?)\\\")?\");\n        Group g = tr.match(\"the stdout\");\n        assertEquals(\"the stdout\", g.getValue());\n        assertNull(g.getChildren().get(0).getValue());\n        assertEquals(1, g.getChildren().size());\n    }", "signature": "@Test\n    public void captures_non_capturing_groups_with_capturing_groups_inside()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void detects_multiple_non_capturing_groups() {\n        TreeRegexp tr = new TreeRegexp(\"(?:a)(:b)(\\\\?c)(d)\");\n        Group g = tr.match(\"a:b?cd\");\n        assertEquals(3, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "detects_multiple_non_capturing_groups", "params": [], "body": "                                                        {\n        TreeRegexp tr = new TreeRegexp(\"(?:a)(:b)(\\\\?c)(d)\");\n        Group g = tr.match(\"a:b?cd\");\n        assertEquals(3, g.getChildren().size());\n    }", "signature": "@Test\n    public void detects_multiple_non_capturing_groups()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void works_with_escaped_backslash() {\n        TreeRegexp tr = new TreeRegexp(\"foo\\\\\\\\(bar|baz)\");\n        Group g = tr.match(\"foo\\\\bar\");\n        assertEquals(1, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "works_with_escaped_backslash", "params": [], "body": "                                               {\n        TreeRegexp tr = new TreeRegexp(\"foo\\\\\\\\(bar|baz)\");\n        Group g = tr.match(\"foo\\\\bar\");\n        assertEquals(1, g.getChildren().size());\n    }", "signature": "@Test\n    public void works_with_escaped_backslash()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void works_with_slash_which_doesnt_need_escaping_in_java() {\n        TreeRegexp tr = new TreeRegexp(\"^I go to '/(.+)'$\");\n        Group g = tr.match(\"I go to '/hello'\");\n        assertEquals(1, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "works_with_slash_which_doesnt_need_escaping_in_java", "params": [], "body": "                                                                      {\n        TreeRegexp tr = new TreeRegexp(\"^I go to '/(.+)'$\");\n        Group g = tr.match(\"I go to '/hello'\");\n        assertEquals(1, g.getChildren().size());\n    }", "signature": "@Test\n    public void works_with_slash_which_doesnt_need_escaping_in_java()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void works_digit_and_word() {\n        TreeRegexp tr = new TreeRegexp(\"^(\\\\d) (\\\\w+) (\\\\w+)$\");\n        Group g = tr.match(\"2 you \u043f\u0440\u0438\u0432\u0435\u0442\");\n        assertEquals(3, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "works_digit_and_word", "params": [], "body": "                                       {\n        TreeRegexp tr = new TreeRegexp(\"^(\\\\d) (\\\\w+) (\\\\w+)$\");\n        Group g = tr.match(\"2 you \u043f\u0440\u0438\u0432\u0435\u0442\");\n        assertEquals(3, g.getChildren().size());\n    }", "signature": "@Test\n    public void works_digit_and_word()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void captures_start_and_end() {\n        TreeRegexp tr = new TreeRegexp(\"^the step \\\"([^\\\"]*)\\\" has status \\\"([^\\\"]*)\\\"$\");\n        Group g = tr.match(\"the step \\\"a pending step\\\" has status \\\"pending\\\"\");\n        assertEquals(10, g.getChildren().get(0).getStart());\n        assertEquals(24, g.getChildren().get(0).getEnd());\n        assertEquals(38, g.getChildren().get(1).getStart());\n        assertEquals(45, g.getChildren().get(1).getEnd());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "captures_start_and_end", "params": [], "body": "                                         {\n        TreeRegexp tr = new TreeRegexp(\"^the step \\\"([^\\\"]*)\\\" has status \\\"([^\\\"]*)\\\"$\");\n        Group g = tr.match(\"the step \\\"a pending step\\\" has status \\\"pending\\\"\");\n        assertEquals(10, g.getChildren().get(0).getStart());\n        assertEquals(24, g.getChildren().get(0).getEnd());\n        assertEquals(38, g.getChildren().get(1).getStart());\n        assertEquals(45, g.getChildren().get(1).getEnd());\n    }", "signature": "@Test\n    public void captures_start_and_end()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void doesnt_consider_parenthesis_in_character_class_as_group() {\n        TreeRegexp tr = new TreeRegexp(\"^drawings: ([A-Z_, ()]+)$\");\n        Group g = tr.match(\"drawings: FU(BAR)\");\n        assertEquals(\"drawings: FU(BAR)\", g.getValue());\n        assertEquals(\"FU(BAR)\", g.getChildren().get(0).getValue());\n        assertEquals(0, g.getChildren().get(0).getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "doesnt_consider_parenthesis_in_character_class_as_group", "params": [], "body": "                                                                          {\n        TreeRegexp tr = new TreeRegexp(\"^drawings: ([A-Z_, ()]+)$\");\n        Group g = tr.match(\"drawings: FU(BAR)\");\n        assertEquals(\"drawings: FU(BAR)\", g.getValue());\n        assertEquals(\"FU(BAR)\", g.getChildren().get(0).getValue());\n        assertEquals(0, g.getChildren().get(0).getChildren().size());\n    }", "signature": "@Test\n    public void doesnt_consider_parenthesis_in_character_class_as_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void works_with_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"HELLO\", Pattern.CASE_INSENSITIVE));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "works_with_flags", "params": [], "body": "                                   {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"HELLO\", Pattern.CASE_INSENSITIVE));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n    }", "signature": "@Test\n    public void works_with_flags()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void works_with_inline_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?i)HELLO\"));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "works_with_inline_flags", "params": [], "body": "                                          {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?i)HELLO\"));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }", "signature": "@Test\n    public void works_with_inline_flags()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void works_with_non_capturing_inline_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?i:HELLO)\"));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "works_with_non_capturing_inline_flags", "params": [], "body": "                                                        {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?i:HELLO)\"));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }", "signature": "@Test\n    public void works_with_non_capturing_inline_flags()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void empty_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"()\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "empty_capturing_group", "params": [], "body": "                                        {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"()\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }", "signature": "@Test\n    public void empty_capturing_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void empty_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?)\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "empty_non_capturing_group", "params": [], "body": "                                            {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?)\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }", "signature": "@Test\n    public void empty_non_capturing_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void empty_look_ahead() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?<=)\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "empty_look_ahead", "params": [], "body": "                                   {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?<=)\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }", "signature": "@Test\n    public void empty_look_ahead()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void uses_loaded_pattern_compiler_service() {\n        String regexp = \"[0-9]\";\n        TreeRegexp tr = new TreeRegexp(regexp);\n        assertNull(tr.match(\"1a\"));\n\n        PatternCompilerProvider.service = (re, flags) -> Pattern.compile(re + \"[a-z]\", flags);\n\n        tr = new TreeRegexp(regexp);\n        assertEquals(\"1a\", tr.match(\"1a\").getValue());\n        PatternCompilerProvider.service = null;\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "uses_loaded_pattern_compiler_service", "params": [], "body": "                                                       {\n        String regexp = \"[0-9]\";\n        TreeRegexp tr = new TreeRegexp(regexp);\n        assertNull(tr.match(\"1a\"));\n\n        PatternCompilerProvider.service = (re, flags) -> Pattern.compile(re + \"[a-z]\", flags);\n\n        tr = new TreeRegexp(regexp);\n        assertEquals(\"1a\", tr.match(\"1a\").getValue());\n        PatternCompilerProvider.service = null;\n    }", "signature": "@Test\n    public void uses_loaded_pattern_compiler_service()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_preferForRegexpMatchTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static java.util.Collections.singletonList;\n\npublic class ParameterType_preferForRegexpMatchTest {\n\n    @Test\n    public void testPreferForRegexpMatch_True() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                true\n        );\n        assertTrue(parameterType.preferForRegexpMatch());\n    }\n\n    @Test\n    public void testPreferForRegexpMatch_False() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false\n        );\n        assertFalse(parameterType.preferForRegexpMatch());\n    }\n}\n", "file_hash": "951c2ccb7b3dc27d017bb77b7b40c9ff9be18199802fc49d847c879a86404bdd", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static java.util.Collections.singletonList;"], "methods": [], "classes": [{"original_string": "public class ParameterType_preferForRegexpMatchTest {\n\n    @Test\n    public void testPreferForRegexpMatch_True() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                true\n        );\n        assertTrue(parameterType.preferForRegexpMatch());\n    }\n\n    @Test\n    public void testPreferForRegexpMatch_False() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false\n        );\n        assertFalse(parameterType.preferForRegexpMatch());\n    }\n}", "definition": "public class ParameterType_preferForRegexpMatchTest", "class_docstring": "", "name": "ParameterType_preferForRegexpMatchTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testPreferForRegexpMatch_True() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                true\n        );\n        assertTrue(parameterType.preferForRegexpMatch());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPreferForRegexpMatch_True", "params": [], "body": "                                                {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                true\n        );\n        assertTrue(parameterType.preferForRegexpMatch());\n    }", "signature": "@Test\n    public void testPreferForRegexpMatch_True()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testPreferForRegexpMatch_False() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false\n        );\n        assertFalse(parameterType.preferForRegexpMatch());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPreferForRegexpMatch_False", "params": [], "body": "                                                 {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false\n        );\n        assertFalse(parameterType.preferForRegexpMatch());\n    }", "signature": "@Test\n    public void testPreferForRegexpMatch_False()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionParserTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport io.cucumber.cucumberexpressions.Ast.Node;\nimport org.junit.jupiter.api.extension.ParameterContext;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.converter.ArgumentConversionException;\nimport org.junit.jupiter.params.converter.ArgumentConverter;\nimport org.junit.jupiter.params.converter.ConvertWith;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.yaml.snakeyaml.Yaml;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static java.nio.file.Files.newDirectoryStream;\nimport static java.nio.file.Files.newInputStream;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass CucumberExpressionParserTest {\n\n    private final CucumberExpressionParser parser = new CucumberExpressionParser();\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"parser\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            Node node = parser.parse(expectation.expression);\n            assertThat(node, is(expectation.expected_ast.toNode()));\n        } else {\n            CucumberExpressionException exception = assertThrows(\n                    CucumberExpressionException.class,\n                    () -> parser.parse(expectation.expression));\n            assertThat(exception.getMessage(), is(expectation.exception));\n        }\n    }\n\n    static class Expectation {\n        public String expression;\n        public YamlableNode expected_ast;\n        public String exception;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    static class YamlableNode {\n        public Ast.Node.Type type;\n        public List<YamlableNode> nodes;\n        public String token;\n        public int start;\n        public int end;\n\n        public Node toNode() {\n            if (token != null) {\n                return new Node(type, start, end, token);\n            } else {\n                return new Node(type, start, end, nodes.stream().map(YamlableNode::toNode).collect(Collectors.toList()));\n            }\n        }\n    }\n}\n", "file_hash": "09590b6a53bd18cff2c33a20d112d41c5092a97c826461dd80f1510604c3dbec", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import io.cucumber.cucumberexpressions.Ast.Node;", "import org.junit.jupiter.api.extension.ParameterContext;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.converter.ArgumentConversionException;", "import org.junit.jupiter.params.converter.ArgumentConverter;", "import org.junit.jupiter.params.converter.ConvertWith;", "import org.junit.jupiter.params.provider.MethodSource;", "import org.yaml.snakeyaml.Yaml;", "import java.io.IOException;", "import java.io.InputStream;", "import java.nio.file.Path;", "import java.nio.file.Paths;", "import java.util.ArrayList;", "import java.util.Comparator;", "import java.util.List;", "import java.util.stream.Collectors;", "import static java.nio.file.Files.newDirectoryStream;", "import static java.nio.file.Files.newInputStream;", "import static org.hamcrest.MatcherAssert.assertThat;", "import static org.hamcrest.Matchers.is;", "import static org.junit.jupiter.api.Assertions.assertThrows;"], "methods": [], "classes": [{"original_string": "class CucumberExpressionParserTest {\n\n    private final CucumberExpressionParser parser = new CucumberExpressionParser();\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"parser\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            Node node = parser.parse(expectation.expression);\n            assertThat(node, is(expectation.expected_ast.toNode()));\n        } else {\n            CucumberExpressionException exception = assertThrows(\n                    CucumberExpressionException.class,\n                    () -> parser.parse(expectation.expression));\n            assertThat(exception.getMessage(), is(expectation.exception));\n        }\n    }\n\n    static class Expectation {\n        public String expression;\n        public YamlableNode expected_ast;\n        public String exception;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    static class YamlableNode {\n        public Ast.Node.Type type;\n        public List<YamlableNode> nodes;\n        public String token;\n        public int start;\n        public int end;\n\n        public Node toNode() {\n            if (token != null) {\n                return new Node(type, start, end, token);\n            } else {\n                return new Node(type, start, end, nodes.stream().map(YamlableNode::toNode).collect(Collectors.toList()));\n            }\n        }\n    }\n}", "definition": "class CucumberExpressionParserTest", "class_docstring": "", "name": "CucumberExpressionParserTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "private final CucumberExpressionParser parser = new CucumberExpressionParser();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CucumberExpressionParser", "name": "parser = new CucumberExpressionParser()", "syntax_pass": true}], "classes": [{"original_string": "    static class Expectation {\n        public String expression;\n        public YamlableNode expected_ast;\n        public String exception;\n    }", "definition": "    static class Expectation", "class_docstring": "", "name": "Expectation", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String expression;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "public YamlableNode expected_ast;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "YamlableNode", "name": "expected_ast", "syntax_pass": true}, {"attribute_expression": "public String exception;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "exception", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }", "definition": "    static class Converter implements ArgumentConverter", "class_docstring": "", "name": "Converter", "super_interfaces": ["ArgumentConverter"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Yaml yaml = new Yaml();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Yaml", "name": "yaml = new Yaml()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expectation", "classes": []}, "name": "convert", "params": [{"name": "source", "type": "Object"}, {"name": "context", "type": "ParameterContext"}], "body": "                                                                                                               {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "signature": "@Override\n        public Expectation convert(Object source, ParameterContext context)"}]}, {"original_string": "    static class YamlableNode {\n        public Ast.Node.Type type;\n        public List<YamlableNode> nodes;\n        public String token;\n        public int start;\n        public int end;\n\n        public Node toNode() {\n            if (token != null) {\n                return new Node(type, start, end, token);\n            } else {\n                return new Node(type, start, end, nodes.stream().map(YamlableNode::toNode).collect(Collectors.toList()));\n            }\n        }\n    }", "definition": "    static class YamlableNode", "class_docstring": "", "name": "YamlableNode", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public Ast.Node.Type type;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "Ast.Node.Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "public List<YamlableNode> nodes;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "List<YamlableNode>", "name": "nodes", "syntax_pass": true}, {"attribute_expression": "public String token;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "token", "syntax_pass": true}, {"attribute_expression": "public int start;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "public int end;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Node toNode() {\n            if (token != null) {\n                return new Node(type, start, end, token);\n            } else {\n                return new Node(type, start, end, nodes.stream().map(YamlableNode::toNode).collect(Collectors.toList()));\n            }\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node", "classes": []}, "name": "toNode", "params": [], "body": "                             {\n            if (token != null) {\n                return new Node(type, start, end, token);\n            } else {\n                return new Node(type, start, end, nodes.stream().map(YamlableNode::toNode).collect(Collectors.toList()));\n            }\n        }", "signature": "public Node toNode()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"parser\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Path>", "classes": []}, "name": "acceptance_tests_pass", "params": [], "body": "                                                                         {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"parser\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "signature": "private static List<Path> acceptance_tests_pass()"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            Node node = parser.parse(expectation.expression);\n            assertThat(node, is(expectation.expected_ast.toNode()));\n        } else {\n            CucumberExpressionException exception = assertThrows(\n                    CucumberExpressionException.class,\n                    () -> parser.parse(expectation.expression));\n            assertThat(exception.getMessage(), is(expectation.exception));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource", "marker_annotations": ["@ParameterizedTest", "@MethodSource"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "acceptance_tests_pass", "params": [{"name": "expectation", "type": "Expectation"}], "body": "                                                                                      {\n        if (expectation.exception == null) {\n            Node node = parser.parse(expectation.expression);\n            assertThat(node, is(expectation.expected_ast.toNode()));\n        } else {\n            CucumberExpressionException exception = assertThrows(\n                    CucumberExpressionException.class,\n                    () -> parser.parse(expectation.expression));\n            assertThat(exception.getMessage(), is(expectation.exception));\n        }\n    }", "signature": "@ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizerTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport io.cucumber.cucumberexpressions.Ast.Token;\nimport org.junit.jupiter.api.extension.ParameterContext;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.converter.ArgumentConversionException;\nimport org.junit.jupiter.params.converter.ArgumentConverter;\nimport org.junit.jupiter.params.converter.ConvertWith;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.yaml.snakeyaml.Yaml;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static java.nio.file.Files.newDirectoryStream;\nimport static java.nio.file.Files.newInputStream;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass CucumberExpressionTokenizerTest {\n\n    private final CucumberExpressionTokenizer tokenizer = new CucumberExpressionTokenizer();\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"tokenizer\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            List<Token> tokens = tokenizer.tokenize(expectation.expression);\n            List<Token> expectedTokens = expectation.expected_tokens\n                    .stream()\n                    .map(YamlableToken::toToken)\n                    .collect(Collectors.toList());\n            assertThat(tokens, is(expectedTokens));\n        } else {\n            CucumberExpressionException exception = assertThrows(\n                    CucumberExpressionException.class,\n                    () -> tokenizer.tokenize(expectation.expression));\n            assertThat(exception.getMessage(), is(expectation.exception));\n        }\n    }\n\n    static class Expectation {\n        public String expression;\n        public List<YamlableToken> expected_tokens;\n        public String exception;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    static class YamlableToken {\n        public String text;\n        public Token.Type type;\n        public int start;\n        public int end;\n\n        public Token toToken() {\n            return new Token(text, type, start, end);\n        }\n    }\n}\n", "file_hash": "dd004b555ae4501e7eea44a74e9fc758f62d21b71bea9e9e2a9e1d19112ee3c4", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import io.cucumber.cucumberexpressions.Ast.Token;", "import org.junit.jupiter.api.extension.ParameterContext;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.converter.ArgumentConversionException;", "import org.junit.jupiter.params.converter.ArgumentConverter;", "import org.junit.jupiter.params.converter.ConvertWith;", "import org.junit.jupiter.params.provider.MethodSource;", "import org.yaml.snakeyaml.Yaml;", "import java.io.IOException;", "import java.io.InputStream;", "import java.nio.file.Path;", "import java.nio.file.Paths;", "import java.util.ArrayList;", "import java.util.Comparator;", "import java.util.List;", "import java.util.stream.Collectors;", "import static java.nio.file.Files.newDirectoryStream;", "import static java.nio.file.Files.newInputStream;", "import static org.hamcrest.MatcherAssert.assertThat;", "import static org.hamcrest.Matchers.is;", "import static org.junit.jupiter.api.Assertions.assertThrows;"], "methods": [], "classes": [{"original_string": "class CucumberExpressionTokenizerTest {\n\n    private final CucumberExpressionTokenizer tokenizer = new CucumberExpressionTokenizer();\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"tokenizer\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            List<Token> tokens = tokenizer.tokenize(expectation.expression);\n            List<Token> expectedTokens = expectation.expected_tokens\n                    .stream()\n                    .map(YamlableToken::toToken)\n                    .collect(Collectors.toList());\n            assertThat(tokens, is(expectedTokens));\n        } else {\n            CucumberExpressionException exception = assertThrows(\n                    CucumberExpressionException.class,\n                    () -> tokenizer.tokenize(expectation.expression));\n            assertThat(exception.getMessage(), is(expectation.exception));\n        }\n    }\n\n    static class Expectation {\n        public String expression;\n        public List<YamlableToken> expected_tokens;\n        public String exception;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    static class YamlableToken {\n        public String text;\n        public Token.Type type;\n        public int start;\n        public int end;\n\n        public Token toToken() {\n            return new Token(text, type, start, end);\n        }\n    }\n}", "definition": "class CucumberExpressionTokenizerTest", "class_docstring": "", "name": "CucumberExpressionTokenizerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "private final CucumberExpressionTokenizer tokenizer = new CucumberExpressionTokenizer();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CucumberExpressionTokenizer", "name": "tokenizer = new CucumberExpressionTokenizer()", "syntax_pass": true}], "classes": [{"original_string": "    static class Expectation {\n        public String expression;\n        public List<YamlableToken> expected_tokens;\n        public String exception;\n    }", "definition": "    static class Expectation", "class_docstring": "", "name": "Expectation", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String expression;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "public List<YamlableToken> expected_tokens;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "List<YamlableToken>", "name": "expected_tokens", "syntax_pass": true}, {"attribute_expression": "public String exception;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "exception", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }", "definition": "    static class Converter implements ArgumentConverter", "class_docstring": "", "name": "Converter", "super_interfaces": ["ArgumentConverter"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Yaml yaml = new Yaml();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Yaml", "name": "yaml = new Yaml()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expectation", "classes": []}, "name": "convert", "params": [{"name": "source", "type": "Object"}, {"name": "context", "type": "ParameterContext"}], "body": "                                                                                                               {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "signature": "@Override\n        public Expectation convert(Object source, ParameterContext context)"}]}, {"original_string": "    static class YamlableToken {\n        public String text;\n        public Token.Type type;\n        public int start;\n        public int end;\n\n        public Token toToken() {\n            return new Token(text, type, start, end);\n        }\n    }", "definition": "    static class YamlableToken", "class_docstring": "", "name": "YamlableToken", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String text;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "text", "syntax_pass": true}, {"attribute_expression": "public Token.Type type;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "Token.Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "public int start;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "public int end;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Token toToken() {\n            return new Token(text, type, start, end);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Token", "classes": []}, "name": "toToken", "params": [], "body": "                               {\n            return new Token(text, type, start, end);\n        }", "signature": "public Token toToken()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"tokenizer\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Path>", "classes": []}, "name": "acceptance_tests_pass", "params": [], "body": "                                                                         {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"tokenizer\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "signature": "private static List<Path> acceptance_tests_pass()"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            List<Token> tokens = tokenizer.tokenize(expectation.expression);\n            List<Token> expectedTokens = expectation.expected_tokens\n                    .stream()\n                    .map(YamlableToken::toToken)\n                    .collect(Collectors.toList());\n            assertThat(tokens, is(expectedTokens));\n        } else {\n            CucumberExpressionException exception = assertThrows(\n                    CucumberExpressionException.class,\n                    () -> tokenizer.tokenize(expectation.expression));\n            assertThat(exception.getMessage(), is(expectation.exception));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource", "marker_annotations": ["@ParameterizedTest", "@MethodSource"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "acceptance_tests_pass", "params": [{"name": "expectation", "type": "Expectation"}], "body": "                                                                                      {\n        if (expectation.exception == null) {\n            List<Token> tokens = tokenizer.tokenize(expectation.expression);\n            List<Token> expectedTokens = expectation.expected_tokens\n                    .stream()\n                    .map(YamlableToken::toToken)\n                    .collect(Collectors.toList());\n            assertThat(tokens, is(expectedTokens));\n        } else {\n            CucumberExpressionException exception = assertThrows(\n                    CucumberExpressionException.class,\n                    () -> tokenizer.tokenize(expectation.expression));\n            assertThat(exception.getMessage(), is(expectation.exception));\n        }\n    }", "signature": "@ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactoryTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\npublic class CombinatorialGeneratedExpressionFactoryTest {\n\n    private static final String WORD = \"\\\\w+\";\n\n    @Test\n    public void generates_multiple_expressions() {\n        List<ParameterType<?>> first = new ArrayList<>();\n        first.add(new ParameterType<>(\"color\", WORD, Color.class, Color::new));\n        first.add(new ParameterType<>(\"csscolor\", WORD, CssColor.class, CssColor::new));\n\n        List<ParameterType<?>> second = new ArrayList<>();\n        second.add(new ParameterType<>(\"date\", WORD, Date.class, Date::new));\n        second.add(new ParameterType<>(\"datetime\", WORD, DateTime.class, DateTime::new));\n        second.add(new ParameterType<>(\"timestamp\", WORD, Timestamp.class, Timestamp::new));\n        List<List<ParameterType<?>>> parameterTypeCombinations = asList(first, second);\n\n        CombinatorialGeneratedExpressionFactory factory = new CombinatorialGeneratedExpressionFactory(\n                \"I bought a {%s} ball on {%s}\",\n                parameterTypeCombinations\n        );\n        List<GeneratedExpression> generatedExpressions = factory.generateExpressions();\n        List<String> expressions = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            expressions.add(source);\n        }\n        assertEquals(asList(\n                \"I bought a {color} ball on {date}\",\n                \"I bought a {color} ball on {datetime}\",\n                \"I bought a {color} ball on {timestamp}\",\n                \"I bought a {csscolor} ball on {date}\",\n                \"I bought a {csscolor} ball on {datetime}\",\n                \"I bought a {csscolor} ball on {timestamp}\"\n        ), expressions);\n    }\n\n    public static class Color {\n        Color(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class CssColor {\n        CssColor(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Date {\n        Date(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class DateTime {\n        DateTime(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Timestamp {\n        Timestamp(String s) {\n            assertNotNull(s);\n        }\n    }\n\n}\n", "file_hash": "8ddb2bed29ab7b1189569ecbd71fefe719f574455dd666d247f569b4d71a1ae9", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.util.ArrayList;", "import java.util.List;", "import static java.util.Arrays.asList;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNotNull;"], "methods": [], "classes": [{"original_string": "public class CombinatorialGeneratedExpressionFactoryTest {\n\n    private static final String WORD = \"\\\\w+\";\n\n    @Test\n    public void generates_multiple_expressions() {\n        List<ParameterType<?>> first = new ArrayList<>();\n        first.add(new ParameterType<>(\"color\", WORD, Color.class, Color::new));\n        first.add(new ParameterType<>(\"csscolor\", WORD, CssColor.class, CssColor::new));\n\n        List<ParameterType<?>> second = new ArrayList<>();\n        second.add(new ParameterType<>(\"date\", WORD, Date.class, Date::new));\n        second.add(new ParameterType<>(\"datetime\", WORD, DateTime.class, DateTime::new));\n        second.add(new ParameterType<>(\"timestamp\", WORD, Timestamp.class, Timestamp::new));\n        List<List<ParameterType<?>>> parameterTypeCombinations = asList(first, second);\n\n        CombinatorialGeneratedExpressionFactory factory = new CombinatorialGeneratedExpressionFactory(\n                \"I bought a {%s} ball on {%s}\",\n                parameterTypeCombinations\n        );\n        List<GeneratedExpression> generatedExpressions = factory.generateExpressions();\n        List<String> expressions = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            expressions.add(source);\n        }\n        assertEquals(asList(\n                \"I bought a {color} ball on {date}\",\n                \"I bought a {color} ball on {datetime}\",\n                \"I bought a {color} ball on {timestamp}\",\n                \"I bought a {csscolor} ball on {date}\",\n                \"I bought a {csscolor} ball on {datetime}\",\n                \"I bought a {csscolor} ball on {timestamp}\"\n        ), expressions);\n    }\n\n    public static class Color {\n        Color(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class CssColor {\n        CssColor(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Date {\n        Date(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class DateTime {\n        DateTime(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Timestamp {\n        Timestamp(String s) {\n            assertNotNull(s);\n        }\n    }\n\n}", "definition": "public class CombinatorialGeneratedExpressionFactoryTest", "class_docstring": "", "name": "CombinatorialGeneratedExpressionFactoryTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final String WORD = \"\\\\w+\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "WORD = \"\\\\w+\"", "syntax_pass": true}], "classes": [{"original_string": "    public static class Color {\n        Color(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Color", "class_docstring": "", "name": "Color", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Color(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Color", "params": [{"name": "s", "type": "String"}], "body": "                        {\n            assertNotNull(s);\n        }", "signature": "Color(String s)"}]}, {"original_string": "    public static class CssColor {\n        CssColor(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class CssColor", "class_docstring": "", "name": "CssColor", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        CssColor(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CssColor", "params": [{"name": "s", "type": "String"}], "body": "                           {\n            assertNotNull(s);\n        }", "signature": "CssColor(String s)"}]}, {"original_string": "    public static class Date {\n        Date(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Date", "class_docstring": "", "name": "Date", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Date(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Date", "params": [{"name": "s", "type": "String"}], "body": "                       {\n            assertNotNull(s);\n        }", "signature": "Date(String s)"}]}, {"original_string": "    public static class DateTime {\n        DateTime(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class DateTime", "class_docstring": "", "name": "DateTime", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        DateTime(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DateTime", "params": [{"name": "s", "type": "String"}], "body": "                           {\n            assertNotNull(s);\n        }", "signature": "DateTime(String s)"}]}, {"original_string": "    public static class Timestamp {\n        Timestamp(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Timestamp", "class_docstring": "", "name": "Timestamp", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Timestamp(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Timestamp", "params": [{"name": "s", "type": "String"}], "body": "                            {\n            assertNotNull(s);\n        }", "signature": "Timestamp(String s)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void generates_multiple_expressions() {\n        List<ParameterType<?>> first = new ArrayList<>();\n        first.add(new ParameterType<>(\"color\", WORD, Color.class, Color::new));\n        first.add(new ParameterType<>(\"csscolor\", WORD, CssColor.class, CssColor::new));\n\n        List<ParameterType<?>> second = new ArrayList<>();\n        second.add(new ParameterType<>(\"date\", WORD, Date.class, Date::new));\n        second.add(new ParameterType<>(\"datetime\", WORD, DateTime.class, DateTime::new));\n        second.add(new ParameterType<>(\"timestamp\", WORD, Timestamp.class, Timestamp::new));\n        List<List<ParameterType<?>>> parameterTypeCombinations = asList(first, second);\n\n        CombinatorialGeneratedExpressionFactory factory = new CombinatorialGeneratedExpressionFactory(\n                \"I bought a {%s} ball on {%s}\",\n                parameterTypeCombinations\n        );\n        List<GeneratedExpression> generatedExpressions = factory.generateExpressions();\n        List<String> expressions = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            expressions.add(source);\n        }\n        assertEquals(asList(\n                \"I bought a {color} ball on {date}\",\n                \"I bought a {color} ball on {datetime}\",\n                \"I bought a {color} ball on {timestamp}\",\n                \"I bought a {csscolor} ball on {date}\",\n                \"I bought a {csscolor} ball on {datetime}\",\n                \"I bought a {csscolor} ball on {timestamp}\"\n        ), expressions);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "generates_multiple_expressions", "params": [], "body": "                                                 {\n        List<ParameterType<?>> first = new ArrayList<>();\n        first.add(new ParameterType<>(\"color\", WORD, Color.class, Color::new));\n        first.add(new ParameterType<>(\"csscolor\", WORD, CssColor.class, CssColor::new));\n\n        List<ParameterType<?>> second = new ArrayList<>();\n        second.add(new ParameterType<>(\"date\", WORD, Date.class, Date::new));\n        second.add(new ParameterType<>(\"datetime\", WORD, DateTime.class, DateTime::new));\n        second.add(new ParameterType<>(\"timestamp\", WORD, Timestamp.class, Timestamp::new));\n        List<List<ParameterType<?>>> parameterTypeCombinations = asList(first, second);\n\n        CombinatorialGeneratedExpressionFactory factory = new CombinatorialGeneratedExpressionFactory(\n                \"I bought a {%s} ball on {%s}\",\n                parameterTypeCombinations\n        );\n        List<GeneratedExpression> generatedExpressions = factory.generateExpressions();\n        List<String> expressions = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            expressions.add(source);\n        }\n        assertEquals(asList(\n                \"I bought a {color} ball on {date}\",\n                \"I bought a {color} ball on {datetime}\",\n                \"I bought a {color} ball on {timestamp}\",\n                \"I bought a {csscolor} ball on {date}\",\n                \"I bought a {csscolor} ball on {datetime}\",\n                \"I bought a {csscolor} ball on {timestamp}\"\n        ), expressions);\n    }", "signature": "@Test\n    public void generates_multiple_expressions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_useForSnippetsTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ParameterType_useForSnippetsTest {\n\n    private ParameterType<?> parameterType;\n\n    @BeforeEach\n    public void setUp() {\n        parameterType = new ParameterType<>(\"name\", \"regexp\", String.class, (String arg) -> arg, true, false);\n    }\n\n    @Test\n    public void testUseForSnippetsTrue() {\n        assertTrue(parameterType.useForSnippets());\n    }\n\n    @Test\n    public void testUseForSnippetsFalse() {\n        ParameterType<?> parameterTypeFalse = new ParameterType<>(\"name\", \"regexp\", String.class, (String arg) -> arg, false, false);\n        assertFalse(parameterTypeFalse.useForSnippets());\n    }\n}\n", "file_hash": "6ffb8dee3dc860c36a8f63fcf54bf46007a545035f96eeb0c71757e2852095b6", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.*;"], "methods": [], "classes": [{"original_string": "public class ParameterType_useForSnippetsTest {\n\n    private ParameterType<?> parameterType;\n\n    @BeforeEach\n    public void setUp() {\n        parameterType = new ParameterType<>(\"name\", \"regexp\", String.class, (String arg) -> arg, true, false);\n    }\n\n    @Test\n    public void testUseForSnippetsTrue() {\n        assertTrue(parameterType.useForSnippets());\n    }\n\n    @Test\n    public void testUseForSnippetsFalse() {\n        ParameterType<?> parameterTypeFalse = new ParameterType<>(\"name\", \"regexp\", String.class, (String arg) -> arg, false, false);\n        assertFalse(parameterTypeFalse.useForSnippets());\n    }\n}", "definition": "public class ParameterType_useForSnippetsTest", "class_docstring": "", "name": "ParameterType_useForSnippetsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private ParameterType<?> parameterType;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterType<?>", "name": "parameterType", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        parameterType = new ParameterType<>(\"name\", \"regexp\", String.class, (String arg) -> arg, true, false);\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        parameterType = new ParameterType<>(\"name\", \"regexp\", String.class, (String arg) -> arg, true, false);\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUseForSnippetsTrue() {\n        assertTrue(parameterType.useForSnippets());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUseForSnippetsTrue", "params": [], "body": "                                         {\n        assertTrue(parameterType.useForSnippets());\n    }", "signature": "@Test\n    public void testUseForSnippetsTrue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testUseForSnippetsFalse() {\n        ParameterType<?> parameterTypeFalse = new ParameterType<>(\"name\", \"regexp\", String.class, (String arg) -> arg, false, false);\n        assertFalse(parameterTypeFalse.useForSnippets());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testUseForSnippetsFalse", "params": [], "body": "                                          {\n        ParameterType<?> parameterTypeFalse = new ParameterType<>(\"name\", \"regexp\", String.class, (String arg) -> arg, false, false);\n        assertFalse(parameterTypeFalse.useForSnippets());\n    }", "signature": "@Test\n    public void testUseForSnippetsFalse()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactory_createExpressionTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Locale;\n\nclass ExpressionFactory_createExpressionTest {\n\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.getDefault());\n    private final ExpressionFactory expressionFactory = new ExpressionFactory(parameterTypeRegistry);\n\n    @Test\n    void testCreateExpression_EmptyString() {\n        Expression expression = expressionFactory.createExpression(\"\");\n        assertTrue(expression instanceof CucumberExpression);\n    }\n\n    @Test\n    void testCreateExpression_RegularExpressionWithAnchors() {\n        Expression expression = expressionFactory.createExpression(\"^start$\");\n        assertTrue(expression instanceof RegularExpression);\n    }\n\n    @Test\n    void testCreateExpression_RegularExpressionWithSlashes() {\n        Expression expression = expressionFactory.createExpression(\"/regex/\");\n        assertTrue(expression instanceof RegularExpression);\n    }\n\n    @Test\n    void testCreateExpression_CucumberExpression() {\n        Expression expression = expressionFactory.createExpression(\"some text\");\n        assertTrue(expression instanceof CucumberExpression);\n    }\n}\n", "file_hash": "f7d731b60a3b550fc87782a5512cb2ab5d726532a539e479ba54c8628a63c4bf", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.*;", "import java.util.Locale;"], "methods": [], "classes": [{"original_string": "class ExpressionFactory_createExpressionTest {\n\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.getDefault());\n    private final ExpressionFactory expressionFactory = new ExpressionFactory(parameterTypeRegistry);\n\n    @Test\n    void testCreateExpression_EmptyString() {\n        Expression expression = expressionFactory.createExpression(\"\");\n        assertTrue(expression instanceof CucumberExpression);\n    }\n\n    @Test\n    void testCreateExpression_RegularExpressionWithAnchors() {\n        Expression expression = expressionFactory.createExpression(\"^start$\");\n        assertTrue(expression instanceof RegularExpression);\n    }\n\n    @Test\n    void testCreateExpression_RegularExpressionWithSlashes() {\n        Expression expression = expressionFactory.createExpression(\"/regex/\");\n        assertTrue(expression instanceof RegularExpression);\n    }\n\n    @Test\n    void testCreateExpression_CucumberExpression() {\n        Expression expression = expressionFactory.createExpression(\"some text\");\n        assertTrue(expression instanceof CucumberExpression);\n    }\n}", "definition": "class ExpressionFactory_createExpressionTest", "class_docstring": "", "name": "ExpressionFactory_createExpressionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.getDefault());", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.getDefault())", "syntax_pass": true}, {"attribute_expression": "private final ExpressionFactory expressionFactory = new ExpressionFactory(parameterTypeRegistry);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ExpressionFactory", "name": "expressionFactory = new ExpressionFactory(parameterTypeRegistry)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    void testCreateExpression_EmptyString() {\n        Expression expression = expressionFactory.createExpression(\"\");\n        assertTrue(expression instanceof CucumberExpression);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateExpression_EmptyString", "params": [], "body": "                                            {\n        Expression expression = expressionFactory.createExpression(\"\");\n        assertTrue(expression instanceof CucumberExpression);\n    }", "signature": "@Test\n    void testCreateExpression_EmptyString()"}, {"syntax_pass": true, "original_string": "    @Test\n    void testCreateExpression_RegularExpressionWithAnchors() {\n        Expression expression = expressionFactory.createExpression(\"^start$\");\n        assertTrue(expression instanceof RegularExpression);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateExpression_RegularExpressionWithAnchors", "params": [], "body": "                                                             {\n        Expression expression = expressionFactory.createExpression(\"^start$\");\n        assertTrue(expression instanceof RegularExpression);\n    }", "signature": "@Test\n    void testCreateExpression_RegularExpressionWithAnchors()"}, {"syntax_pass": true, "original_string": "    @Test\n    void testCreateExpression_RegularExpressionWithSlashes() {\n        Expression expression = expressionFactory.createExpression(\"/regex/\");\n        assertTrue(expression instanceof RegularExpression);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateExpression_RegularExpressionWithSlashes", "params": [], "body": "                                                             {\n        Expression expression = expressionFactory.createExpression(\"/regex/\");\n        assertTrue(expression instanceof RegularExpression);\n    }", "signature": "@Test\n    void testCreateExpression_RegularExpressionWithSlashes()"}, {"syntax_pass": true, "original_string": "    @Test\n    void testCreateExpression_CucumberExpression() {\n        Expression expression = expressionFactory.createExpression(\"some text\");\n        assertTrue(expression instanceof CucumberExpression);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateExpression_CucumberExpression", "params": [], "body": "                                                   {\n        Expression expression = expressionFactory.createExpression(\"some text\");\n        assertTrue(expression instanceof CucumberExpression);\n    }", "signature": "@Test\n    void testCreateExpression_CucumberExpression()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeComparatorTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport static java.util.Arrays.asList;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\npublic class ParameterTypeComparatorTest {\n\n    public static class A {\n        A(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class B {\n        B(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class C {\n        C(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class D {\n        D(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    @Test\n    public void sorts_parameter_types_by_preferential_then_name() {\n        SortedSet<ParameterType<?>> set = new TreeSet<>();\n        set.add(new ParameterType<>(\"c\", \"c\", C.class, C::new, false, true));\n        set.add(new ParameterType<>(\"a\", \"a\", A.class, A::new, false, false));\n        set.add(new ParameterType<>(\"d\", \"d\", D.class, D::new, false, false));\n        set.add(new ParameterType<>(\"b\", \"b\", B.class, B::new, false, true));\n\n        List<String> names = new ArrayList<>();\n        for (ParameterType parameterType : set) {\n            names.add(parameterType.getName());\n        }\n        assertEquals(asList(\"b\", \"c\", \"a\", \"d\"), names);\n    }\n\n}\n", "file_hash": "8ce5e4c1224320a3b7e97ab02becb610e6fcccf3e31f4b5528150f4986540148", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.SortedSet;", "import java.util.TreeSet;", "import static java.util.Arrays.asList;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNotNull;"], "methods": [], "classes": [{"original_string": "public class ParameterTypeComparatorTest {\n\n    public static class A {\n        A(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class B {\n        B(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class C {\n        C(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class D {\n        D(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    @Test\n    public void sorts_parameter_types_by_preferential_then_name() {\n        SortedSet<ParameterType<?>> set = new TreeSet<>();\n        set.add(new ParameterType<>(\"c\", \"c\", C.class, C::new, false, true));\n        set.add(new ParameterType<>(\"a\", \"a\", A.class, A::new, false, false));\n        set.add(new ParameterType<>(\"d\", \"d\", D.class, D::new, false, false));\n        set.add(new ParameterType<>(\"b\", \"b\", B.class, B::new, false, true));\n\n        List<String> names = new ArrayList<>();\n        for (ParameterType parameterType : set) {\n            names.add(parameterType.getName());\n        }\n        assertEquals(asList(\"b\", \"c\", \"a\", \"d\"), names);\n    }\n\n}", "definition": "public class ParameterTypeComparatorTest", "class_docstring": "", "name": "ParameterTypeComparatorTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": [{"original_string": "    public static class A {\n        A(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class A", "class_docstring": "", "name": "A", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        A(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "A", "params": [{"name": "s", "type": "String"}], "body": "                    {\n            assertNotNull(s);\n        }", "signature": "A(String s)"}]}, {"original_string": "    public static class B {\n        B(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class B", "class_docstring": "", "name": "B", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        B(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "B", "params": [{"name": "s", "type": "String"}], "body": "                    {\n            assertNotNull(s);\n        }", "signature": "B(String s)"}]}, {"original_string": "    public static class C {\n        C(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class C", "class_docstring": "", "name": "C", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        C(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "C", "params": [{"name": "s", "type": "String"}], "body": "                    {\n            assertNotNull(s);\n        }", "signature": "C(String s)"}]}, {"original_string": "    public static class D {\n        D(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class D", "class_docstring": "", "name": "D", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        D(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "D", "params": [{"name": "s", "type": "String"}], "body": "                    {\n            assertNotNull(s);\n        }", "signature": "D(String s)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void sorts_parameter_types_by_preferential_then_name() {\n        SortedSet<ParameterType<?>> set = new TreeSet<>();\n        set.add(new ParameterType<>(\"c\", \"c\", C.class, C::new, false, true));\n        set.add(new ParameterType<>(\"a\", \"a\", A.class, A::new, false, false));\n        set.add(new ParameterType<>(\"d\", \"d\", D.class, D::new, false, false));\n        set.add(new ParameterType<>(\"b\", \"b\", B.class, B::new, false, true));\n\n        List<String> names = new ArrayList<>();\n        for (ParameterType parameterType : set) {\n            names.add(parameterType.getName());\n        }\n        assertEquals(asList(\"b\", \"c\", \"a\", \"d\"), names);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "sorts_parameter_types_by_preferential_then_name", "params": [], "body": "                                                                  {\n        SortedSet<ParameterType<?>> set = new TreeSet<>();\n        set.add(new ParameterType<>(\"c\", \"c\", C.class, C::new, false, true));\n        set.add(new ParameterType<>(\"a\", \"a\", A.class, A::new, false, false));\n        set.add(new ParameterType<>(\"d\", \"d\", D.class, D::new, false, false));\n        set.add(new ParameterType<>(\"b\", \"b\", B.class, B::new, false, true));\n\n        List<String> names = new ArrayList<>();\n        for (ParameterType parameterType : set) {\n            names.add(parameterType.getName());\n        }\n        assertEquals(asList(\"b\", \"c\", \"a\", \"d\"), names);\n    }", "signature": "@Test\n    public void sorts_parameter_types_by_preferential_then_name()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformerTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.function.Executable;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Optional;\nimport java.util.function.Supplier;\n\nimport static java.util.Locale.ENGLISH;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.Is.is;\nimport static org.hamcrest.core.IsEqual.equalTo;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class BuiltInParameterTransformerTest {\n\n    private final BuiltInParameterTransformer objectMapper = new BuiltInParameterTransformer(ENGLISH);\n\n    @Test\n    public void simple_object_mapper_only_supports_class_types() {\n\n        Type abstractListOfE = ArrayList.class.getGenericSuperclass();\n        final Executable testMethod = () -> objectMapper.transform(\"something\", abstractListOfE);\n\n        String expected = \"\" +\n                \"Can't transform 'something' to java.util.AbstractList<E>\\n\" +\n                \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                \"Consider using a different object mapper or register a parameter type for java.util.AbstractList<E>\";\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(expected)));\n    }\n\n    @Test\n    public void simple_object_mapper_only_supports_some_class_types() {\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", Date.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to class java.util.Date\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.util.Date\"\n        )));\n    }\n\n    @Test\n    public void simple_object_mapper_only_supports_some_optional_types() {\n        Type optionalDate = new TypeReference<Optional<Date>>() {}.getType();\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", optionalDate);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to java.util.Optional<java.util.Date>\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for java.util.Optional<java.util.Date>\"\n        )));\n    }\n\n    @Test\n    public void simple_object_mapper_only_supports_some_generic_types() {\n        Type optionalDate = new TypeReference<Supplier<String>>() {}.getType();\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", optionalDate);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to java.util.function.Supplier<java.lang.String>\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for java.util.function.Supplier<java.lang.String>\"\n        )));\n    }\n\n    @Test\n    public void should_throw_exception_for_unknown_enum_values() {\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", TestEnum.class);\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to class io.cucumber.cucumberexpressions.BuiltInParameterTransformerTest$TestEnum. \" +\n                        \"Not an enum constant\"\n        )));\n    }\n\n    @Test\n    public void should_transform_boolean() {\n        for (String value : Arrays.asList(\"true\", \"True\", \"false\", \"False\")) {\n            objectMapper.transform(value, Boolean.class);\n        }\n    }\n\n    @Test\n    public void should_transform_char() {\n        assertThat(objectMapper.transform(\"A\", char.class), is(equalTo('A')));\n        assertThat(objectMapper.transform(\"b\", Character.class), is(equalTo('b')));\n    }\n\n    @Test\n    public void should_throw_exception_for_empty_string_with_type_char() {\n        final Executable testMethod = () -> objectMapper.transform(\"\", Character.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform '' to class java.lang.Character\\nBuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.lang.Character\"\n        )));\n    }\n\n    @Test\n    public void should_throw_exception_for_nonsingelchar_string_with_type_char() {\n        Executable testMethod = () -> objectMapper.transform(\"ab\", Character.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'ab' to class java.lang.Character\\nBuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.lang.Character\"\n        )));\n    }\n\n    @Test\n    public void should_transform_optional() {\n        assertThat(objectMapper.transform(\"abc\", Optional.class), is(equalTo(Optional.of(\"abc\"))));\n        assertThat(objectMapper.transform(\"\", Optional.class), is(equalTo(Optional.of(\"\"))));\n        assertThat(objectMapper.transform(null, Optional.class), is(equalTo(Optional.empty())));\n    }\n\n    @Test\n    public void should_transform_optional_generic_string() {\n        Type optionalStringType = new TypeReference<Optional<String>>() {}.getType();\n\n        assertThat(objectMapper.transform(\"abc\", optionalStringType), is(equalTo(Optional.<String>of(\"abc\"))));\n        assertThat(objectMapper.transform(\"\", optionalStringType), is(equalTo(Optional.<String>of(\"\"))));\n        assertThat(objectMapper.transform(null, optionalStringType), is(equalTo(Optional.<String>empty())));\n    }\n\n    @Test\n    public void should_transform_optional_generic_integer() {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {}.getType();\n\n        assertThat(objectMapper.transform(\"42\", optionalIntType), is(equalTo(Optional.<Integer>of(42))));\n        assertThat(objectMapper.transform(null, optionalIntType), is(equalTo(Optional.<Integer>empty())));\n    }\n\n    private enum TestEnum {\n        TEST\n    }\n\n}\n", "file_hash": "1154f6f1e08e6e2cb328bc99f006b9fde9686897b9fc0460aa76ae647cea9292", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.function.Executable;", "import java.lang.reflect.Type;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.Date;", "import java.util.Optional;", "import java.util.function.Supplier;", "import static java.util.Locale.ENGLISH;", "import static org.hamcrest.MatcherAssert.assertThat;", "import static org.hamcrest.core.Is.is;", "import static org.hamcrest.core.IsEqual.equalTo;", "import static org.junit.jupiter.api.Assertions.assertThrows;"], "methods": [], "classes": [{"original_string": "public class BuiltInParameterTransformerTest {\n\n    private final BuiltInParameterTransformer objectMapper = new BuiltInParameterTransformer(ENGLISH);\n\n    @Test\n    public void simple_object_mapper_only_supports_class_types() {\n\n        Type abstractListOfE = ArrayList.class.getGenericSuperclass();\n        final Executable testMethod = () -> objectMapper.transform(\"something\", abstractListOfE);\n\n        String expected = \"\" +\n                \"Can't transform 'something' to java.util.AbstractList<E>\\n\" +\n                \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                \"Consider using a different object mapper or register a parameter type for java.util.AbstractList<E>\";\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(expected)));\n    }\n\n    @Test\n    public void simple_object_mapper_only_supports_some_class_types() {\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", Date.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to class java.util.Date\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.util.Date\"\n        )));\n    }\n\n    @Test\n    public void simple_object_mapper_only_supports_some_optional_types() {\n        Type optionalDate = new TypeReference<Optional<Date>>() {}.getType();\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", optionalDate);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to java.util.Optional<java.util.Date>\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for java.util.Optional<java.util.Date>\"\n        )));\n    }\n\n    @Test\n    public void simple_object_mapper_only_supports_some_generic_types() {\n        Type optionalDate = new TypeReference<Supplier<String>>() {}.getType();\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", optionalDate);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to java.util.function.Supplier<java.lang.String>\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for java.util.function.Supplier<java.lang.String>\"\n        )));\n    }\n\n    @Test\n    public void should_throw_exception_for_unknown_enum_values() {\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", TestEnum.class);\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to class io.cucumber.cucumberexpressions.BuiltInParameterTransformerTest$TestEnum. \" +\n                        \"Not an enum constant\"\n        )));\n    }\n\n    @Test\n    public void should_transform_boolean() {\n        for (String value : Arrays.asList(\"true\", \"True\", \"false\", \"False\")) {\n            objectMapper.transform(value, Boolean.class);\n        }\n    }\n\n    @Test\n    public void should_transform_char() {\n        assertThat(objectMapper.transform(\"A\", char.class), is(equalTo('A')));\n        assertThat(objectMapper.transform(\"b\", Character.class), is(equalTo('b')));\n    }\n\n    @Test\n    public void should_throw_exception_for_empty_string_with_type_char() {\n        final Executable testMethod = () -> objectMapper.transform(\"\", Character.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform '' to class java.lang.Character\\nBuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.lang.Character\"\n        )));\n    }\n\n    @Test\n    public void should_throw_exception_for_nonsingelchar_string_with_type_char() {\n        Executable testMethod = () -> objectMapper.transform(\"ab\", Character.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'ab' to class java.lang.Character\\nBuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.lang.Character\"\n        )));\n    }\n\n    @Test\n    public void should_transform_optional() {\n        assertThat(objectMapper.transform(\"abc\", Optional.class), is(equalTo(Optional.of(\"abc\"))));\n        assertThat(objectMapper.transform(\"\", Optional.class), is(equalTo(Optional.of(\"\"))));\n        assertThat(objectMapper.transform(null, Optional.class), is(equalTo(Optional.empty())));\n    }\n\n    @Test\n    public void should_transform_optional_generic_string() {\n        Type optionalStringType = new TypeReference<Optional<String>>() {}.getType();\n\n        assertThat(objectMapper.transform(\"abc\", optionalStringType), is(equalTo(Optional.<String>of(\"abc\"))));\n        assertThat(objectMapper.transform(\"\", optionalStringType), is(equalTo(Optional.<String>of(\"\"))));\n        assertThat(objectMapper.transform(null, optionalStringType), is(equalTo(Optional.<String>empty())));\n    }\n\n    @Test\n    public void should_transform_optional_generic_integer() {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {}.getType();\n\n        assertThat(objectMapper.transform(\"42\", optionalIntType), is(equalTo(Optional.<Integer>of(42))));\n        assertThat(objectMapper.transform(null, optionalIntType), is(equalTo(Optional.<Integer>empty())));\n    }\n\n    private enum TestEnum {\n        TEST\n    }\n\n}", "definition": "public class BuiltInParameterTransformerTest", "class_docstring": "", "name": "BuiltInParameterTransformerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final BuiltInParameterTransformer objectMapper = new BuiltInParameterTransformer(ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BuiltInParameterTransformer", "name": "objectMapper = new BuiltInParameterTransformer(ENGLISH)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void simple_object_mapper_only_supports_class_types() {\n\n        Type abstractListOfE = ArrayList.class.getGenericSuperclass();\n        final Executable testMethod = () -> objectMapper.transform(\"something\", abstractListOfE);\n\n        String expected = \"\" +\n                \"Can't transform 'something' to java.util.AbstractList<E>\\n\" +\n                \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                \"Consider using a different object mapper or register a parameter type for java.util.AbstractList<E>\";\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(expected)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "simple_object_mapper_only_supports_class_types", "params": [], "body": "                                                                 {\n\n        Type abstractListOfE = ArrayList.class.getGenericSuperclass();\n        final Executable testMethod = () -> objectMapper.transform(\"something\", abstractListOfE);\n\n        String expected = \"\" +\n                \"Can't transform 'something' to java.util.AbstractList<E>\\n\" +\n                \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                \"Consider using a different object mapper or register a parameter type for java.util.AbstractList<E>\";\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(expected)));\n    }", "signature": "@Test\n    public void simple_object_mapper_only_supports_class_types()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void simple_object_mapper_only_supports_some_class_types() {\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", Date.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to class java.util.Date\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.util.Date\"\n        )));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "simple_object_mapper_only_supports_some_class_types", "params": [], "body": "                                                                      {\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", Date.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to class java.util.Date\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.util.Date\"\n        )));\n    }", "signature": "@Test\n    public void simple_object_mapper_only_supports_some_class_types()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void simple_object_mapper_only_supports_some_optional_types() {\n        Type optionalDate = new TypeReference<Optional<Date>>() {}.getType();\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", optionalDate);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to java.util.Optional<java.util.Date>\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for java.util.Optional<java.util.Date>\"\n        )));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "simple_object_mapper_only_supports_some_optional_types", "params": [], "body": "                                                                         {\n        Type optionalDate = new TypeReference<Optional<Date>>() {}.getType();\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", optionalDate);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to java.util.Optional<java.util.Date>\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for java.util.Optional<java.util.Date>\"\n        )));\n    }", "signature": "@Test\n    public void simple_object_mapper_only_supports_some_optional_types()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void simple_object_mapper_only_supports_some_generic_types() {\n        Type optionalDate = new TypeReference<Supplier<String>>() {}.getType();\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", optionalDate);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to java.util.function.Supplier<java.lang.String>\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for java.util.function.Supplier<java.lang.String>\"\n        )));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "simple_object_mapper_only_supports_some_generic_types", "params": [], "body": "                                                                        {\n        Type optionalDate = new TypeReference<Supplier<String>>() {}.getType();\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", optionalDate);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to java.util.function.Supplier<java.lang.String>\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for java.util.function.Supplier<java.lang.String>\"\n        )));\n    }", "signature": "@Test\n    public void simple_object_mapper_only_supports_some_generic_types()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void should_throw_exception_for_unknown_enum_values() {\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", TestEnum.class);\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to class io.cucumber.cucumberexpressions.BuiltInParameterTransformerTest$TestEnum. \" +\n                        \"Not an enum constant\"\n        )));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_throw_exception_for_unknown_enum_values", "params": [], "body": "                                                                 {\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", TestEnum.class);\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to class io.cucumber.cucumberexpressions.BuiltInParameterTransformerTest$TestEnum. \" +\n                        \"Not an enum constant\"\n        )));\n    }", "signature": "@Test\n    public void should_throw_exception_for_unknown_enum_values()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void should_transform_boolean() {\n        for (String value : Arrays.asList(\"true\", \"True\", \"false\", \"False\")) {\n            objectMapper.transform(value, Boolean.class);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_transform_boolean", "params": [], "body": "                                           {\n        for (String value : Arrays.asList(\"true\", \"True\", \"false\", \"False\")) {\n            objectMapper.transform(value, Boolean.class);\n        }\n    }", "signature": "@Test\n    public void should_transform_boolean()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void should_transform_char() {\n        assertThat(objectMapper.transform(\"A\", char.class), is(equalTo('A')));\n        assertThat(objectMapper.transform(\"b\", Character.class), is(equalTo('b')));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_transform_char", "params": [], "body": "                                        {\n        assertThat(objectMapper.transform(\"A\", char.class), is(equalTo('A')));\n        assertThat(objectMapper.transform(\"b\", Character.class), is(equalTo('b')));\n    }", "signature": "@Test\n    public void should_transform_char()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void should_throw_exception_for_empty_string_with_type_char() {\n        final Executable testMethod = () -> objectMapper.transform(\"\", Character.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform '' to class java.lang.Character\\nBuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.lang.Character\"\n        )));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_throw_exception_for_empty_string_with_type_char", "params": [], "body": "                                                                         {\n        final Executable testMethod = () -> objectMapper.transform(\"\", Character.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform '' to class java.lang.Character\\nBuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.lang.Character\"\n        )));\n    }", "signature": "@Test\n    public void should_throw_exception_for_empty_string_with_type_char()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void should_throw_exception_for_nonsingelchar_string_with_type_char() {\n        Executable testMethod = () -> objectMapper.transform(\"ab\", Character.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'ab' to class java.lang.Character\\nBuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.lang.Character\"\n        )));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_throw_exception_for_nonsingelchar_string_with_type_char", "params": [], "body": "                                                                                 {\n        Executable testMethod = () -> objectMapper.transform(\"ab\", Character.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'ab' to class java.lang.Character\\nBuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.lang.Character\"\n        )));\n    }", "signature": "@Test\n    public void should_throw_exception_for_nonsingelchar_string_with_type_char()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void should_transform_optional() {\n        assertThat(objectMapper.transform(\"abc\", Optional.class), is(equalTo(Optional.of(\"abc\"))));\n        assertThat(objectMapper.transform(\"\", Optional.class), is(equalTo(Optional.of(\"\"))));\n        assertThat(objectMapper.transform(null, Optional.class), is(equalTo(Optional.empty())));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_transform_optional", "params": [], "body": "                                            {\n        assertThat(objectMapper.transform(\"abc\", Optional.class), is(equalTo(Optional.of(\"abc\"))));\n        assertThat(objectMapper.transform(\"\", Optional.class), is(equalTo(Optional.of(\"\"))));\n        assertThat(objectMapper.transform(null, Optional.class), is(equalTo(Optional.empty())));\n    }", "signature": "@Test\n    public void should_transform_optional()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void should_transform_optional_generic_string() {\n        Type optionalStringType = new TypeReference<Optional<String>>() {}.getType();\n\n        assertThat(objectMapper.transform(\"abc\", optionalStringType), is(equalTo(Optional.<String>of(\"abc\"))));\n        assertThat(objectMapper.transform(\"\", optionalStringType), is(equalTo(Optional.<String>of(\"\"))));\n        assertThat(objectMapper.transform(null, optionalStringType), is(equalTo(Optional.<String>empty())));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_transform_optional_generic_string", "params": [], "body": "                                                           {\n        Type optionalStringType = new TypeReference<Optional<String>>() {}.getType();\n\n        assertThat(objectMapper.transform(\"abc\", optionalStringType), is(equalTo(Optional.<String>of(\"abc\"))));\n        assertThat(objectMapper.transform(\"\", optionalStringType), is(equalTo(Optional.<String>of(\"\"))));\n        assertThat(objectMapper.transform(null, optionalStringType), is(equalTo(Optional.<String>empty())));\n    }", "signature": "@Test\n    public void should_transform_optional_generic_string()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void should_transform_optional_generic_integer() {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {}.getType();\n\n        assertThat(objectMapper.transform(\"42\", optionalIntType), is(equalTo(Optional.<Integer>of(42))));\n        assertThat(objectMapper.transform(null, optionalIntType), is(equalTo(Optional.<Integer>empty())));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_transform_optional_generic_integer", "params": [], "body": "                                                            {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {}.getType();\n\n        assertThat(objectMapper.transform(\"42\", optionalIntType), is(equalTo(Optional.<Integer>of(42))));\n        assertThat(objectMapper.transform(null, optionalIntType), is(equalTo(Optional.<Integer>empty())));\n    }", "signature": "@Test\n    public void should_transform_optional_generic_integer()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getSourceTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Locale;\n\npublic class CucumberExpression_getSourceTest {\n    private ParameterTypeRegistry parameterTypeRegistry;\n\n    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }\n\n    @Test\n    public void testGetSource() {\n        String expressionString = \"some expression\";\n        CucumberExpression cucumberExpression = new CucumberExpression(expressionString, parameterTypeRegistry);\n        assertEquals(expressionString, cucumberExpression.getSource());\n    }\n}\n", "file_hash": "920fe26008becf6a49691cd5e0d58043851d507f9e811a5263d22fd49187008c", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import java.util.Locale;"], "methods": [], "classes": [{"original_string": "public class CucumberExpression_getSourceTest {\n    private ParameterTypeRegistry parameterTypeRegistry;\n\n    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }\n\n    @Test\n    public void testGetSource() {\n        String expressionString = \"some expression\";\n        CucumberExpression cucumberExpression = new CucumberExpression(expressionString, parameterTypeRegistry);\n        assertEquals(expressionString, cucumberExpression.getSource());\n    }\n}", "definition": "public class CucumberExpression_getSourceTest", "class_docstring": "", "name": "CucumberExpression_getSourceTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGetSource() {\n        String expressionString = \"some expression\";\n        CucumberExpression cucumberExpression = new CucumberExpression(expressionString, parameterTypeRegistry);\n        assertEquals(expressionString, cucumberExpression.getSource());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetSource", "params": [], "body": "                                {\n        String expressionString = \"some expression\";\n        CucumberExpression cucumberExpression = new CucumberExpression(expressionString, parameterTypeRegistry);\n        assertEquals(expressionString, cucumberExpression.getSource());\n    }", "signature": "@Test\n    public void testGetSource()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/RegularExpressionTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ParameterContext;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.converter.ArgumentConversionException;\nimport org.junit.jupiter.params.converter.ArgumentConverter;\nimport org.junit.jupiter.params.converter.ConvertWith;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.yaml.snakeyaml.Yaml;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Type;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport static java.nio.file.Files.newDirectoryStream;\nimport static java.nio.file.Files.newInputStream;\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.singletonList;\nimport static java.util.regex.Pattern.compile;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class RegularExpressionTest {\n\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"regular-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        RegularExpression expression = new RegularExpression(Pattern.compile(expectation.expression), parameterTypeRegistry);\n        List<Argument<?>> match = expression.match(expectation.text);\n        List<?> values = match == null ? null : match.stream()\n                .map(Argument::getValue)\n                .collect(Collectors.toList());\n\n        assertThat(values, CustomMatchers.equalOrCloseTo(expectation.expected_args));\n    }\n\n    static class Expectation {\n        public String expression;\n        public String text;\n        public List<?> expected_args;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    @Test\n    public void documentation_match_arguments() {\n        Pattern expr = Pattern.compile(\"I have (\\\\d+) cukes? in my (\\\\w+) now\");\n        Expression expression = new RegularExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> match = expression.match(\"I have 7 cukes in my belly now\");\n        assertEquals(7, match.get(0).getValue());\n        assertEquals(\"belly\", match.get(1).getValue());\n    }\n\n    @Test\n    public void matches_positive_int() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\");\n        assertEquals(singletonList(22), match);\n    }\n\n    @Test\n    public void matches_positive_int_with_hint() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\", Integer.class);\n        assertEquals(singletonList(22), match);\n    }\n\n    @Test\n    public void matches_positive_int_with_conflicting_type_hint() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\", String.class);\n        assertEquals(singletonList(\"22\"), match);\n    }\n\n    @Test\n    public void matches_nested_capture_group_without_match() {\n        List<?> match = match(compile(\"^a user( named \\\"([^\\\"]*)\\\")?$\"), \"a user\");\n        assertEquals(singletonList(null), match);\n    }\n\n    @Test\n    public void matches_nested_capture_group_with_match() {\n        List<?> match = match(compile(\"^a user( named \\\"([^\\\"]*)\\\")?$\"), \"a user named \\\"Charlie\\\"\");\n        assertEquals(singletonList(\"Charlie\"), match);\n    }\n\n    @Test\n    public void ignores_non_capturing_groups() {\n        String expr = \"(\\\\S+) ?(can|cannot)? (?:delete|cancel) the (\\\\d+)(?:st|nd|rd|th) (attachment|slide) ?(?:upload)?\";\n        String step = \"I can cancel the 1st slide upload\";\n        List<?> match = match(compile(expr), step);\n        assertEquals(asList(\"I\", \"can\", 1, \"slide\"), match);\n    }\n\n    @Test\n    public void matches_capture_group_nested_in_optional_one() {\n        String regex = \"^a (pre-commercial transaction |pre buyer fee model )?purchase(?: for \\\\$(\\\\d+))?$\";\n        assertEquals(asList(null, null), match(compile(regex), \"a purchase\"));\n        assertEquals(asList(null, 33), match(compile(regex), \"a purchase for $33\"));\n        assertEquals(asList(\"pre buyer fee model \", null), match(compile(regex), \"a pre buyer fee model purchase\"));\n    }\n\n    @Test\n    public void works_with_escaped_parenthesis() {\n        String expr = \"Across the line\\\\(s\\\\)\";\n        String step = \"Across the line(s)\";\n        List<?> match = match(compile(expr), step);\n        assertEquals(emptyList(), match);\n    }\n\n    @Test\n    public void exposes_source_and_regexp() {\n        String regexp = \"I have (\\\\d+) cukes? in my (.+) now\";\n        RegularExpression expression = new RegularExpression(Pattern.compile(regexp),\n                new ParameterTypeRegistry(Locale.ENGLISH));\n        assertEquals(regexp, expression.getSource());\n        assertEquals(regexp, expression.getRegexp().pattern());\n    }\n\n    @Test\n    public void uses_float_type_hint_when_group_doesnt_match_known_param_type() {\n        List<?> match = match(compile(\"a (.*)\"), \"a 22\", Float.class);\n        assertEquals(Float.class, match.get(0).getClass());\n        assertEquals(22f, (Float) match.get(0), 0.00001);\n    }\n\n    @Test\n    public void uses_double_type_hint_when_group_doesnt_match_known_param_type() {\n        List<?> match = match(compile(\"a (\\\\d\\\\d.\\\\d)\"), \"a 33.5\", Double.class);\n        assertEquals(Double.class, match.get(0).getClass());\n        assertEquals(33.5d, (Double) match.get(0), 0.00001);\n    }\n\n    @Test\n    public void matches_empty_string() {\n        List<?> match = match(compile(\"^The value equals \\\"([^\\\"]*)\\\"$\"), \"The value equals \\\"\\\"\", String.class);\n        assertEquals(String.class, match.get(0).getClass());\n        assertEquals(\"\", match.get(0));\n    }\n\n    @Test\n    public void uses_two_type_hints_to_resolve_anonymous_parameter_type() {\n        List<?> match = match(compile(\"a (.*) and a (.*)\"), \"a 22 and a 33.5\", Float.class, Double.class);\n\n        assertEquals(Float.class, match.get(0).getClass());\n        assertEquals(22f, (Float) match.get(0), 0.00001);\n\n        assertEquals(Double.class, match.get(1).getClass());\n        assertEquals(33.5d, (Double) match.get(1), 0.00001);\n    }\n\n    @Test\n    public void retains_all_content_captured_by_the_capture_group() {\n        List<?> match = match(compile(\"a quote ([\\\"a-z ]+)\"), \"a quote \\\" and quote \\\"\", String.class);\n        assertEquals(singletonList(\"\\\" and quote \\\"\"), match);\n    }\n\n    @Test\n    public void uses_parameter_type_registry_when_parameter_type_is_defined() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"[\\\"a-z ]+\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String s) {\n                        return s.toUpperCase();\n                    }\n                }\n        ));\n        List<?> match = match(compile(\"a quote ([\\\"a-z ]+)\"), \"a quote \\\" and quote \\\"\", String.class);\n        assertEquals(singletonList(\"\\\" AND QUOTE \\\"\"), match);\n    }\n\n    @Test\n    public void ignores_type_hint_when_parameter_type_has_strong_type_hint() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"one|two|three\",\n                Integer.class,\n                new Transformer<Integer>() {\n                    @Override\n                    public Integer transform(String s) {\n                        return 42;\n                    }\n                }, false, false, true\n        ));\n        assertEquals(asList(42), match(compile(\"(one|two|three)\"), \"one\", String.class));\n    }\n\n    @Test\n    public void follows_type_hint_when_parameter_type_does_not_have_strong_type_hint() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"one|two|three\",\n                Integer.class,\n                new Transformer<Integer>() {\n                    @Override\n                    public Integer transform(String s) {\n                        return 42;\n                    }\n                }, false, false, false\n        ));\n        assertEquals(asList(\"one\"), match(compile(\"(one|two|three)\"), \"one\", String.class));\n    }\n\n    @Test\n    public void matches_anonymous_parameter_type_with_hint() {\n        assertEquals(singletonList(0.22f), match(compile(\"(.*)\"), \"0.22\", Float.class));\n    }\n\n    @Test\n    public void matches_anonymous_parameter_type() {\n        assertEquals(singletonList(\"0.22\"), match(compile(\"(.*)\"), \"0.22\"));\n    }\n\n    @Test\n    public void matches_optional_boolean_capture_group() {\n        Pattern pattern = compile(\"^(true|false)?$\");\n        assertEquals(singletonList(true), match(pattern, \"true\", Boolean.class));\n        assertEquals(singletonList(false), match(pattern, \"false\", Boolean.class));\n        assertEquals(singletonList(null), match(pattern, \"\", Boolean.class));\n    }\n\n    @Test\n    public void parameter_types_can_be_optional_when_used_in_regex() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \".+\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String s) {\n                        return s;\n                    }\n                }\n        ));\n        List<?> match = match(compile(\"^text(?: (.+))? text2$\"), \"text text2\", String.class);\n        assertEquals(singletonList(null), match);\n    }\n\n    private List<?> match(Pattern pattern, String text, Type... types) {\n        RegularExpression regularExpression = new RegularExpression(pattern, parameterTypeRegistry);\n        List<Argument<?>> arguments = regularExpression.match(text, types);\n        List<Object> values = new ArrayList<>();\n        for (Argument<?> argument : arguments) {\n            values.add(argument.getValue());\n        }\n        return values;\n    }\n\n}\n", "file_hash": "78380bd11e3d5e5b7512f1b6458896164c388e1f59b5553984a25de393cfb2e5", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.extension.ParameterContext;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.converter.ArgumentConversionException;", "import org.junit.jupiter.params.converter.ArgumentConverter;", "import org.junit.jupiter.params.converter.ConvertWith;", "import org.junit.jupiter.params.provider.MethodSource;", "import org.yaml.snakeyaml.Yaml;", "import java.io.IOException;", "import java.io.InputStream;", "import java.lang.reflect.Type;", "import java.nio.file.Path;", "import java.nio.file.Paths;", "import java.util.ArrayList;", "import java.util.Comparator;", "import java.util.List;", "import java.util.Locale;", "import java.util.regex.Pattern;", "import java.util.stream.Collectors;", "import static java.nio.file.Files.newDirectoryStream;", "import static java.nio.file.Files.newInputStream;", "import static java.util.Arrays.asList;", "import static java.util.Collections.emptyList;", "import static java.util.Collections.singletonList;", "import static java.util.regex.Pattern.compile;", "import static org.hamcrest.MatcherAssert.assertThat;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class RegularExpressionTest {\n\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"regular-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        RegularExpression expression = new RegularExpression(Pattern.compile(expectation.expression), parameterTypeRegistry);\n        List<Argument<?>> match = expression.match(expectation.text);\n        List<?> values = match == null ? null : match.stream()\n                .map(Argument::getValue)\n                .collect(Collectors.toList());\n\n        assertThat(values, CustomMatchers.equalOrCloseTo(expectation.expected_args));\n    }\n\n    static class Expectation {\n        public String expression;\n        public String text;\n        public List<?> expected_args;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    @Test\n    public void documentation_match_arguments() {\n        Pattern expr = Pattern.compile(\"I have (\\\\d+) cukes? in my (\\\\w+) now\");\n        Expression expression = new RegularExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> match = expression.match(\"I have 7 cukes in my belly now\");\n        assertEquals(7, match.get(0).getValue());\n        assertEquals(\"belly\", match.get(1).getValue());\n    }\n\n    @Test\n    public void matches_positive_int() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\");\n        assertEquals(singletonList(22), match);\n    }\n\n    @Test\n    public void matches_positive_int_with_hint() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\", Integer.class);\n        assertEquals(singletonList(22), match);\n    }\n\n    @Test\n    public void matches_positive_int_with_conflicting_type_hint() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\", String.class);\n        assertEquals(singletonList(\"22\"), match);\n    }\n\n    @Test\n    public void matches_nested_capture_group_without_match() {\n        List<?> match = match(compile(\"^a user( named \\\"([^\\\"]*)\\\")?$\"), \"a user\");\n        assertEquals(singletonList(null), match);\n    }\n\n    @Test\n    public void matches_nested_capture_group_with_match() {\n        List<?> match = match(compile(\"^a user( named \\\"([^\\\"]*)\\\")?$\"), \"a user named \\\"Charlie\\\"\");\n        assertEquals(singletonList(\"Charlie\"), match);\n    }\n\n    @Test\n    public void ignores_non_capturing_groups() {\n        String expr = \"(\\\\S+) ?(can|cannot)? (?:delete|cancel) the (\\\\d+)(?:st|nd|rd|th) (attachment|slide) ?(?:upload)?\";\n        String step = \"I can cancel the 1st slide upload\";\n        List<?> match = match(compile(expr), step);\n        assertEquals(asList(\"I\", \"can\", 1, \"slide\"), match);\n    }\n\n    @Test\n    public void matches_capture_group_nested_in_optional_one() {\n        String regex = \"^a (pre-commercial transaction |pre buyer fee model )?purchase(?: for \\\\$(\\\\d+))?$\";\n        assertEquals(asList(null, null), match(compile(regex), \"a purchase\"));\n        assertEquals(asList(null, 33), match(compile(regex), \"a purchase for $33\"));\n        assertEquals(asList(\"pre buyer fee model \", null), match(compile(regex), \"a pre buyer fee model purchase\"));\n    }\n\n    @Test\n    public void works_with_escaped_parenthesis() {\n        String expr = \"Across the line\\\\(s\\\\)\";\n        String step = \"Across the line(s)\";\n        List<?> match = match(compile(expr), step);\n        assertEquals(emptyList(), match);\n    }\n\n    @Test\n    public void exposes_source_and_regexp() {\n        String regexp = \"I have (\\\\d+) cukes? in my (.+) now\";\n        RegularExpression expression = new RegularExpression(Pattern.compile(regexp),\n                new ParameterTypeRegistry(Locale.ENGLISH));\n        assertEquals(regexp, expression.getSource());\n        assertEquals(regexp, expression.getRegexp().pattern());\n    }\n\n    @Test\n    public void uses_float_type_hint_when_group_doesnt_match_known_param_type() {\n        List<?> match = match(compile(\"a (.*)\"), \"a 22\", Float.class);\n        assertEquals(Float.class, match.get(0).getClass());\n        assertEquals(22f, (Float) match.get(0), 0.00001);\n    }\n\n    @Test\n    public void uses_double_type_hint_when_group_doesnt_match_known_param_type() {\n        List<?> match = match(compile(\"a (\\\\d\\\\d.\\\\d)\"), \"a 33.5\", Double.class);\n        assertEquals(Double.class, match.get(0).getClass());\n        assertEquals(33.5d, (Double) match.get(0), 0.00001);\n    }\n\n    @Test\n    public void matches_empty_string() {\n        List<?> match = match(compile(\"^The value equals \\\"([^\\\"]*)\\\"$\"), \"The value equals \\\"\\\"\", String.class);\n        assertEquals(String.class, match.get(0).getClass());\n        assertEquals(\"\", match.get(0));\n    }\n\n    @Test\n    public void uses_two_type_hints_to_resolve_anonymous_parameter_type() {\n        List<?> match = match(compile(\"a (.*) and a (.*)\"), \"a 22 and a 33.5\", Float.class, Double.class);\n\n        assertEquals(Float.class, match.get(0).getClass());\n        assertEquals(22f, (Float) match.get(0), 0.00001);\n\n        assertEquals(Double.class, match.get(1).getClass());\n        assertEquals(33.5d, (Double) match.get(1), 0.00001);\n    }\n\n    @Test\n    public void retains_all_content_captured_by_the_capture_group() {\n        List<?> match = match(compile(\"a quote ([\\\"a-z ]+)\"), \"a quote \\\" and quote \\\"\", String.class);\n        assertEquals(singletonList(\"\\\" and quote \\\"\"), match);\n    }\n\n    @Test\n    public void uses_parameter_type_registry_when_parameter_type_is_defined() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"[\\\"a-z ]+\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String s) {\n                        return s.toUpperCase();\n                    }\n                }\n        ));\n        List<?> match = match(compile(\"a quote ([\\\"a-z ]+)\"), \"a quote \\\" and quote \\\"\", String.class);\n        assertEquals(singletonList(\"\\\" AND QUOTE \\\"\"), match);\n    }\n\n    @Test\n    public void ignores_type_hint_when_parameter_type_has_strong_type_hint() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"one|two|three\",\n                Integer.class,\n                new Transformer<Integer>() {\n                    @Override\n                    public Integer transform(String s) {\n                        return 42;\n                    }\n                }, false, false, true\n        ));\n        assertEquals(asList(42), match(compile(\"(one|two|three)\"), \"one\", String.class));\n    }\n\n    @Test\n    public void follows_type_hint_when_parameter_type_does_not_have_strong_type_hint() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"one|two|three\",\n                Integer.class,\n                new Transformer<Integer>() {\n                    @Override\n                    public Integer transform(String s) {\n                        return 42;\n                    }\n                }, false, false, false\n        ));\n        assertEquals(asList(\"one\"), match(compile(\"(one|two|three)\"), \"one\", String.class));\n    }\n\n    @Test\n    public void matches_anonymous_parameter_type_with_hint() {\n        assertEquals(singletonList(0.22f), match(compile(\"(.*)\"), \"0.22\", Float.class));\n    }\n\n    @Test\n    public void matches_anonymous_parameter_type() {\n        assertEquals(singletonList(\"0.22\"), match(compile(\"(.*)\"), \"0.22\"));\n    }\n\n    @Test\n    public void matches_optional_boolean_capture_group() {\n        Pattern pattern = compile(\"^(true|false)?$\");\n        assertEquals(singletonList(true), match(pattern, \"true\", Boolean.class));\n        assertEquals(singletonList(false), match(pattern, \"false\", Boolean.class));\n        assertEquals(singletonList(null), match(pattern, \"\", Boolean.class));\n    }\n\n    @Test\n    public void parameter_types_can_be_optional_when_used_in_regex() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \".+\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String s) {\n                        return s;\n                    }\n                }\n        ));\n        List<?> match = match(compile(\"^text(?: (.+))? text2$\"), \"text text2\", String.class);\n        assertEquals(singletonList(null), match);\n    }\n\n    private List<?> match(Pattern pattern, String text, Type... types) {\n        RegularExpression regularExpression = new RegularExpression(pattern, parameterTypeRegistry);\n        List<Argument<?>> arguments = regularExpression.match(text, types);\n        List<Object> values = new ArrayList<>();\n        for (Argument<?> argument : arguments) {\n            values.add(argument.getValue());\n        }\n        return values;\n    }\n\n}", "definition": "public class RegularExpressionTest", "class_docstring": "", "name": "RegularExpressionTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}], "classes": [{"original_string": "    static class Expectation {\n        public String expression;\n        public String text;\n        public List<?> expected_args;\n    }", "definition": "    static class Expectation", "class_docstring": "", "name": "Expectation", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String expression;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "public String text;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "text", "syntax_pass": true}, {"attribute_expression": "public List<?> expected_args;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "List<?>", "name": "expected_args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }", "definition": "    static class Converter implements ArgumentConverter", "class_docstring": "", "name": "Converter", "super_interfaces": ["ArgumentConverter"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Yaml yaml = new Yaml();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Yaml", "name": "yaml = new Yaml()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expectation", "classes": []}, "name": "convert", "params": [{"name": "source", "type": "Object"}, {"name": "context", "type": "ParameterContext"}], "body": "                                                                                                               {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "signature": "@Override\n        public Expectation convert(Object source, ParameterContext context)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"regular-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Path>", "classes": []}, "name": "acceptance_tests_pass", "params": [], "body": "                                                                         {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"regular-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }", "signature": "private static List<Path> acceptance_tests_pass()"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        RegularExpression expression = new RegularExpression(Pattern.compile(expectation.expression), parameterTypeRegistry);\n        List<Argument<?>> match = expression.match(expectation.text);\n        List<?> values = match == null ? null : match.stream()\n                .map(Argument::getValue)\n                .collect(Collectors.toList());\n\n        assertThat(values, CustomMatchers.equalOrCloseTo(expectation.expected_args));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource", "marker_annotations": ["@ParameterizedTest", "@MethodSource"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "acceptance_tests_pass", "params": [{"name": "expectation", "type": "Expectation"}], "body": "                                                                                      {\n        RegularExpression expression = new RegularExpression(Pattern.compile(expectation.expression), parameterTypeRegistry);\n        List<Argument<?>> match = expression.match(expectation.text);\n        List<?> values = match == null ? null : match.stream()\n                .map(Argument::getValue)\n                .collect(Collectors.toList());\n\n        assertThat(values, CustomMatchers.equalOrCloseTo(expectation.expected_args));\n    }", "signature": "@ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation)"}, {"syntax_pass": true, "original_string": "    @Test\n    public void documentation_match_arguments() {\n        Pattern expr = Pattern.compile(\"I have (\\\\d+) cukes? in my (\\\\w+) now\");\n        Expression expression = new RegularExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> match = expression.match(\"I have 7 cukes in my belly now\");\n        assertEquals(7, match.get(0).getValue());\n        assertEquals(\"belly\", match.get(1).getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "documentation_match_arguments", "params": [], "body": "                                                {\n        Pattern expr = Pattern.compile(\"I have (\\\\d+) cukes? in my (\\\\w+) now\");\n        Expression expression = new RegularExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> match = expression.match(\"I have 7 cukes in my belly now\");\n        assertEquals(7, match.get(0).getValue());\n        assertEquals(\"belly\", match.get(1).getValue());\n    }", "signature": "@Test\n    public void documentation_match_arguments()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_positive_int() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\");\n        assertEquals(singletonList(22), match);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_positive_int", "params": [], "body": "                                       {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\");\n        assertEquals(singletonList(22), match);\n    }", "signature": "@Test\n    public void matches_positive_int()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_positive_int_with_hint() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\", Integer.class);\n        assertEquals(singletonList(22), match);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_positive_int_with_hint", "params": [], "body": "                                                 {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\", Integer.class);\n        assertEquals(singletonList(22), match);\n    }", "signature": "@Test\n    public void matches_positive_int_with_hint()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_positive_int_with_conflicting_type_hint() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\", String.class);\n        assertEquals(singletonList(\"22\"), match);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_positive_int_with_conflicting_type_hint", "params": [], "body": "                                                                  {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\", String.class);\n        assertEquals(singletonList(\"22\"), match);\n    }", "signature": "@Test\n    public void matches_positive_int_with_conflicting_type_hint()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_nested_capture_group_without_match() {\n        List<?> match = match(compile(\"^a user( named \\\"([^\\\"]*)\\\")?$\"), \"a user\");\n        assertEquals(singletonList(null), match);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_nested_capture_group_without_match", "params": [], "body": "                                                             {\n        List<?> match = match(compile(\"^a user( named \\\"([^\\\"]*)\\\")?$\"), \"a user\");\n        assertEquals(singletonList(null), match);\n    }", "signature": "@Test\n    public void matches_nested_capture_group_without_match()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_nested_capture_group_with_match() {\n        List<?> match = match(compile(\"^a user( named \\\"([^\\\"]*)\\\")?$\"), \"a user named \\\"Charlie\\\"\");\n        assertEquals(singletonList(\"Charlie\"), match);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_nested_capture_group_with_match", "params": [], "body": "                                                          {\n        List<?> match = match(compile(\"^a user( named \\\"([^\\\"]*)\\\")?$\"), \"a user named \\\"Charlie\\\"\");\n        assertEquals(singletonList(\"Charlie\"), match);\n    }", "signature": "@Test\n    public void matches_nested_capture_group_with_match()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void ignores_non_capturing_groups() {\n        String expr = \"(\\\\S+) ?(can|cannot)? (?:delete|cancel) the (\\\\d+)(?:st|nd|rd|th) (attachment|slide) ?(?:upload)?\";\n        String step = \"I can cancel the 1st slide upload\";\n        List<?> match = match(compile(expr), step);\n        assertEquals(asList(\"I\", \"can\", 1, \"slide\"), match);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "ignores_non_capturing_groups", "params": [], "body": "                                               {\n        String expr = \"(\\\\S+) ?(can|cannot)? (?:delete|cancel) the (\\\\d+)(?:st|nd|rd|th) (attachment|slide) ?(?:upload)?\";\n        String step = \"I can cancel the 1st slide upload\";\n        List<?> match = match(compile(expr), step);\n        assertEquals(asList(\"I\", \"can\", 1, \"slide\"), match);\n    }", "signature": "@Test\n    public void ignores_non_capturing_groups()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_capture_group_nested_in_optional_one() {\n        String regex = \"^a (pre-commercial transaction |pre buyer fee model )?purchase(?: for \\\\$(\\\\d+))?$\";\n        assertEquals(asList(null, null), match(compile(regex), \"a purchase\"));\n        assertEquals(asList(null, 33), match(compile(regex), \"a purchase for $33\"));\n        assertEquals(asList(\"pre buyer fee model \", null), match(compile(regex), \"a pre buyer fee model purchase\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_capture_group_nested_in_optional_one", "params": [], "body": "                                                               {\n        String regex = \"^a (pre-commercial transaction |pre buyer fee model )?purchase(?: for \\\\$(\\\\d+))?$\";\n        assertEquals(asList(null, null), match(compile(regex), \"a purchase\"));\n        assertEquals(asList(null, 33), match(compile(regex), \"a purchase for $33\"));\n        assertEquals(asList(\"pre buyer fee model \", null), match(compile(regex), \"a pre buyer fee model purchase\"));\n    }", "signature": "@Test\n    public void matches_capture_group_nested_in_optional_one()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void works_with_escaped_parenthesis() {\n        String expr = \"Across the line\\\\(s\\\\)\";\n        String step = \"Across the line(s)\";\n        List<?> match = match(compile(expr), step);\n        assertEquals(emptyList(), match);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "works_with_escaped_parenthesis", "params": [], "body": "                                                 {\n        String expr = \"Across the line\\\\(s\\\\)\";\n        String step = \"Across the line(s)\";\n        List<?> match = match(compile(expr), step);\n        assertEquals(emptyList(), match);\n    }", "signature": "@Test\n    public void works_with_escaped_parenthesis()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void exposes_source_and_regexp() {\n        String regexp = \"I have (\\\\d+) cukes? in my (.+) now\";\n        RegularExpression expression = new RegularExpression(Pattern.compile(regexp),\n                new ParameterTypeRegistry(Locale.ENGLISH));\n        assertEquals(regexp, expression.getSource());\n        assertEquals(regexp, expression.getRegexp().pattern());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "exposes_source_and_regexp", "params": [], "body": "                                            {\n        String regexp = \"I have (\\\\d+) cukes? in my (.+) now\";\n        RegularExpression expression = new RegularExpression(Pattern.compile(regexp),\n                new ParameterTypeRegistry(Locale.ENGLISH));\n        assertEquals(regexp, expression.getSource());\n        assertEquals(regexp, expression.getRegexp().pattern());\n    }", "signature": "@Test\n    public void exposes_source_and_regexp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void uses_float_type_hint_when_group_doesnt_match_known_param_type() {\n        List<?> match = match(compile(\"a (.*)\"), \"a 22\", Float.class);\n        assertEquals(Float.class, match.get(0).getClass());\n        assertEquals(22f, (Float) match.get(0), 0.00001);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "uses_float_type_hint_when_group_doesnt_match_known_param_type", "params": [], "body": "                                                                                {\n        List<?> match = match(compile(\"a (.*)\"), \"a 22\", Float.class);\n        assertEquals(Float.class, match.get(0).getClass());\n        assertEquals(22f, (Float) match.get(0), 0.00001);\n    }", "signature": "@Test\n    public void uses_float_type_hint_when_group_doesnt_match_known_param_type()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void uses_double_type_hint_when_group_doesnt_match_known_param_type() {\n        List<?> match = match(compile(\"a (\\\\d\\\\d.\\\\d)\"), \"a 33.5\", Double.class);\n        assertEquals(Double.class, match.get(0).getClass());\n        assertEquals(33.5d, (Double) match.get(0), 0.00001);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "uses_double_type_hint_when_group_doesnt_match_known_param_type", "params": [], "body": "                                                                                 {\n        List<?> match = match(compile(\"a (\\\\d\\\\d.\\\\d)\"), \"a 33.5\", Double.class);\n        assertEquals(Double.class, match.get(0).getClass());\n        assertEquals(33.5d, (Double) match.get(0), 0.00001);\n    }", "signature": "@Test\n    public void uses_double_type_hint_when_group_doesnt_match_known_param_type()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_empty_string() {\n        List<?> match = match(compile(\"^The value equals \\\"([^\\\"]*)\\\"$\"), \"The value equals \\\"\\\"\", String.class);\n        assertEquals(String.class, match.get(0).getClass());\n        assertEquals(\"\", match.get(0));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_empty_string", "params": [], "body": "                                       {\n        List<?> match = match(compile(\"^The value equals \\\"([^\\\"]*)\\\"$\"), \"The value equals \\\"\\\"\", String.class);\n        assertEquals(String.class, match.get(0).getClass());\n        assertEquals(\"\", match.get(0));\n    }", "signature": "@Test\n    public void matches_empty_string()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void uses_two_type_hints_to_resolve_anonymous_parameter_type() {\n        List<?> match = match(compile(\"a (.*) and a (.*)\"), \"a 22 and a 33.5\", Float.class, Double.class);\n\n        assertEquals(Float.class, match.get(0).getClass());\n        assertEquals(22f, (Float) match.get(0), 0.00001);\n\n        assertEquals(Double.class, match.get(1).getClass());\n        assertEquals(33.5d, (Double) match.get(1), 0.00001);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "uses_two_type_hints_to_resolve_anonymous_parameter_type", "params": [], "body": "                                                                          {\n        List<?> match = match(compile(\"a (.*) and a (.*)\"), \"a 22 and a 33.5\", Float.class, Double.class);\n\n        assertEquals(Float.class, match.get(0).getClass());\n        assertEquals(22f, (Float) match.get(0), 0.00001);\n\n        assertEquals(Double.class, match.get(1).getClass());\n        assertEquals(33.5d, (Double) match.get(1), 0.00001);\n    }", "signature": "@Test\n    public void uses_two_type_hints_to_resolve_anonymous_parameter_type()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void retains_all_content_captured_by_the_capture_group() {\n        List<?> match = match(compile(\"a quote ([\\\"a-z ]+)\"), \"a quote \\\" and quote \\\"\", String.class);\n        assertEquals(singletonList(\"\\\" and quote \\\"\"), match);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "retains_all_content_captured_by_the_capture_group", "params": [], "body": "                                                                    {\n        List<?> match = match(compile(\"a quote ([\\\"a-z ]+)\"), \"a quote \\\" and quote \\\"\", String.class);\n        assertEquals(singletonList(\"\\\" and quote \\\"\"), match);\n    }", "signature": "@Test\n    public void retains_all_content_captured_by_the_capture_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void uses_parameter_type_registry_when_parameter_type_is_defined() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"[\\\"a-z ]+\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String s) {\n                        return s.toUpperCase();\n                    }\n                }\n        ));\n        List<?> match = match(compile(\"a quote ([\\\"a-z ]+)\"), \"a quote \\\" and quote \\\"\", String.class);\n        assertEquals(singletonList(\"\\\" AND QUOTE \\\"\"), match);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "uses_parameter_type_registry_when_parameter_type_is_defined", "params": [], "body": "                                                                              {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"[\\\"a-z ]+\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String s) {\n                        return s.toUpperCase();\n                    }\n                }\n        ));\n        List<?> match = match(compile(\"a quote ([\\\"a-z ]+)\"), \"a quote \\\" and quote \\\"\", String.class);\n        assertEquals(singletonList(\"\\\" AND QUOTE \\\"\"), match);\n    }", "signature": "@Test\n    public void uses_parameter_type_registry_when_parameter_type_is_defined()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void ignores_type_hint_when_parameter_type_has_strong_type_hint() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"one|two|three\",\n                Integer.class,\n                new Transformer<Integer>() {\n                    @Override\n                    public Integer transform(String s) {\n                        return 42;\n                    }\n                }, false, false, true\n        ));\n        assertEquals(asList(42), match(compile(\"(one|two|three)\"), \"one\", String.class));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "ignores_type_hint_when_parameter_type_has_strong_type_hint", "params": [], "body": "                                                                             {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"one|two|three\",\n                Integer.class,\n                new Transformer<Integer>() {\n                    @Override\n                    public Integer transform(String s) {\n                        return 42;\n                    }\n                }, false, false, true\n        ));\n        assertEquals(asList(42), match(compile(\"(one|two|three)\"), \"one\", String.class));\n    }", "signature": "@Test\n    public void ignores_type_hint_when_parameter_type_has_strong_type_hint()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void follows_type_hint_when_parameter_type_does_not_have_strong_type_hint() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"one|two|three\",\n                Integer.class,\n                new Transformer<Integer>() {\n                    @Override\n                    public Integer transform(String s) {\n                        return 42;\n                    }\n                }, false, false, false\n        ));\n        assertEquals(asList(\"one\"), match(compile(\"(one|two|three)\"), \"one\", String.class));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "follows_type_hint_when_parameter_type_does_not_have_strong_type_hint", "params": [], "body": "                                                                                       {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"one|two|three\",\n                Integer.class,\n                new Transformer<Integer>() {\n                    @Override\n                    public Integer transform(String s) {\n                        return 42;\n                    }\n                }, false, false, false\n        ));\n        assertEquals(asList(\"one\"), match(compile(\"(one|two|three)\"), \"one\", String.class));\n    }", "signature": "@Test\n    public void follows_type_hint_when_parameter_type_does_not_have_strong_type_hint()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_anonymous_parameter_type_with_hint() {\n        assertEquals(singletonList(0.22f), match(compile(\"(.*)\"), \"0.22\", Float.class));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_anonymous_parameter_type_with_hint", "params": [], "body": "                                                             {\n        assertEquals(singletonList(0.22f), match(compile(\"(.*)\"), \"0.22\", Float.class));\n    }", "signature": "@Test\n    public void matches_anonymous_parameter_type_with_hint()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_anonymous_parameter_type() {\n        assertEquals(singletonList(\"0.22\"), match(compile(\"(.*)\"), \"0.22\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_anonymous_parameter_type", "params": [], "body": "                                                   {\n        assertEquals(singletonList(\"0.22\"), match(compile(\"(.*)\"), \"0.22\"));\n    }", "signature": "@Test\n    public void matches_anonymous_parameter_type()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void matches_optional_boolean_capture_group() {\n        Pattern pattern = compile(\"^(true|false)?$\");\n        assertEquals(singletonList(true), match(pattern, \"true\", Boolean.class));\n        assertEquals(singletonList(false), match(pattern, \"false\", Boolean.class));\n        assertEquals(singletonList(null), match(pattern, \"\", Boolean.class));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "matches_optional_boolean_capture_group", "params": [], "body": "                                                         {\n        Pattern pattern = compile(\"^(true|false)?$\");\n        assertEquals(singletonList(true), match(pattern, \"true\", Boolean.class));\n        assertEquals(singletonList(false), match(pattern, \"false\", Boolean.class));\n        assertEquals(singletonList(null), match(pattern, \"\", Boolean.class));\n    }", "signature": "@Test\n    public void matches_optional_boolean_capture_group()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void parameter_types_can_be_optional_when_used_in_regex() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \".+\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String s) {\n                        return s;\n                    }\n                }\n        ));\n        List<?> match = match(compile(\"^text(?: (.+))? text2$\"), \"text text2\", String.class);\n        assertEquals(singletonList(null), match);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "parameter_types_can_be_optional_when_used_in_regex", "params": [], "body": "                                                                     {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \".+\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String s) {\n                        return s;\n                    }\n                }\n        ));\n        List<?> match = match(compile(\"^text(?: (.+))? text2$\"), \"text text2\", String.class);\n        assertEquals(singletonList(null), match);\n    }", "signature": "@Test\n    public void parameter_types_can_be_optional_when_used_in_regex()"}, {"syntax_pass": true, "original_string": "    private List<?> match(Pattern pattern, String text, Type... types) {\n        RegularExpression regularExpression = new RegularExpression(pattern, parameterTypeRegistry);\n        List<Argument<?>> arguments = regularExpression.match(text, types);\n        List<Object> values = new ArrayList<>();\n        for (Argument<?> argument : arguments) {\n            values.add(argument.getValue());\n        }\n        return values;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<?>", "classes": []}, "name": "match", "params": [{"name": "pattern", "type": "Pattern"}, {"name": "text", "type": "String"}], "body": "                                                                       {\n        RegularExpression regularExpression = new RegularExpression(pattern, parameterTypeRegistry);\n        List<Argument<?>> arguments = regularExpression.match(text, types);\n        List<Object> values = new ArrayList<>();\n        for (Argument<?> argument : arguments) {\n            values.add(argument.getValue());\n        }\n        return values;\n    }", "signature": "private List<?> match(Pattern pattern, String text, Type... types)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeRegistryTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.function.Executable;\n\nimport java.math.BigDecimal;\nimport java.util.Locale;\nimport java.util.regex.Pattern;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.IsEqual.equalTo;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class ParameterTypeRegistryTest {\n\n    private static final String CAPITALISED_WORD = \"[A-Z]+\\\\w+\";\n\n    public static class Name {\n        Name(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Person {\n        Person(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Place {\n        Place(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    private final ParameterTypeRegistry registry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    @Test\n    public void does_not_allow_more_than_one_preferential_parameter_type_for_each_regexp() {\n\n        registry.defineParameterType(new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, false, true));\n        registry.defineParameterType(new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, false, false));\n\n        final Executable testMethod = () -> registry.defineParameterType(new ParameterType<>(\n                \"place\",\n                CAPITALISED_WORD,\n                Place.class,\n                Place::new,\n                false,\n                true\n        ));\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"There can only be one preferential parameter type per regexp. The regexp /[A-Z]+\\\\w+/ is used for two preferential parameter types, {name} and {place}\")));\n    }\n\n    @Test\n    public void looks_up_preferential_parameter_type_by_regexp() {\n        ParameterType<Name> name = new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, false, false);\n        ParameterType<Person> person = new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, false, true);\n        ParameterType<Place> place = new ParameterType<>(\"place\", CAPITALISED_WORD, Place.class, Place::new, false, false);\n        registry.defineParameterType(name);\n        registry.defineParameterType(person);\n        registry.defineParameterType(place);\n        assertSame(person, registry.lookupByRegexp(CAPITALISED_WORD, Pattern.compile(\"([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)\"), \"Lisa and Bob\"));\n    }\n\n    @Test\n    public void throws_ambiguous_exception_on_lookup_when_no_parameter_types_are_preferential() {\n        ParameterType<Name> name = new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, true, false);\n        ParameterType<Person> person = new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, true, false);\n        ParameterType<Place> place = new ParameterType<>(\"place\", CAPITALISED_WORD, Place.class, Place::new, true, false);\n        registry.defineParameterType(name);\n        registry.defineParameterType(person);\n        registry.defineParameterType(place);\n\n        String expected = \"\" +\n                \"Your Regular Expression /([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)/\\n\" +\n                \"matches multiple parameter types with regexp /[A-Z]+\\\\w+/:\\n\" +\n                \"   {name}\\n\" +\n                \"   {person}\\n\" +\n                \"   {place}\\n\" +\n                \"\\n\" +\n                \"I couldn't decide which one to use. You have two options:\\n\" +\n                \"\\n\" +\n                \"1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\\n\" +\n                \"   {name} and {name}\\n\" +\n                \"   {name} and {person}\\n\" +\n                \"   {name} and {place}\\n\" +\n                \"   {person} and {name}\\n\" +\n                \"   {person} and {person}\\n\" +\n                \"   {person} and {place}\\n\" +\n                \"   {place} and {name}\\n\" +\n                \"   {place} and {person}\\n\" +\n                \"   {place} and {place}\\n\" +\n                \"\\n\" +\n                \"2) Make one of the parameter types preferential and continue to use a Regular Expression.\\n\" +\n                \"\\n\";\n\n        final Executable testMethod = () -> registry.lookupByRegexp(CAPITALISED_WORD, Pattern.compile(\"([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)\"), \"Lisa and Bob\");\n\n        final AmbiguousParameterTypeException thrownException = assertThrows(AmbiguousParameterTypeException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(expected)));\n    }\n\n    @Test\n    public void does_not_allow_anonymous_parameter_type_to_be_registered() {\n\n        final Executable testMethod = () -> registry.defineParameterType(new ParameterType<>(\"\", \".*\", Object.class, (Transformer<Object>) arg -> arg));\n\n        final DuplicateTypeNameException thrownException = assertThrows(DuplicateTypeNameException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"The anonymous parameter type has already been defined\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_english() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.ENGLISH));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"\"), nullValue());\n        assertThat(expression.match(\".\"), nullValue());\n        assertThat(expression.match(\",\"), nullValue());\n        assertThat(expression.match(\"-\"), nullValue());\n        assertThat(expression.match(\"E\"), nullValue());\n        assertThat(expression.match(\"1,\"), nullValue());\n        assertThat(expression.match(\",1\"), nullValue());\n        assertThat(expression.match(\"1.\"), nullValue());\n\n        assertThat(expression.match(\"1\").get(0).getValue(), is(BigDecimal.ONE));\n        assertThat(expression.match(\"-1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n        assertThat(expression.match(\"1.1\").get(0).getValue(), is(new BigDecimal(\"1.1\")));\n        assertThat(expression.match(\"1,000\").get(0).getValue(), is(new BigDecimal(\"1000\")));\n        assertThat(expression.match(\"1,000,0\").get(0).getValue(), is(new BigDecimal(\"10000\")));\n        assertThat(expression.match(\"1,000.1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1,000,10\").get(0).getValue(), is(new BigDecimal(\"100010\")));\n        assertThat(expression.match(\"1,0.1\").get(0).getValue(), is(new BigDecimal(\"10.1\")));\n        assertThat(expression.match(\"1,000,000.1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1.1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n\n        assertThat(expression.match(\".1\").get(0).getValue(), is(new BigDecimal(\"0.1\")));\n        assertThat(expression.match(\"-.1\").get(0).getValue(), is(new BigDecimal(\"-0.1\")));\n        assertThat(expression.match(\"-.10000001\").get(0).getValue(), is(new BigDecimal(\"-0.10000001\")));\n        assertThat(expression.match(\"1E1\").get(0).getValue(), is(new BigDecimal(\"1E1\"))); // precision 1 with scale -1, can not be expressed as a decimal\n        assertThat(expression.match(\".1E1\").get(0).getValue(), is(new BigDecimal(\"1\")));\n        assertThat(expression.match(\"E1\"), nullValue());\n        assertThat(expression.match(\"-.1E-1\").get(0).getValue(), is(new BigDecimal(\"-0.01\")));\n        assertThat(expression.match(\"-.1E-2\").get(0).getValue(), is(new BigDecimal(\"-0.001\")));\n        assertThat(expression.match(\"-.1E+1\"), nullValue());\n        assertThat(expression.match(\"-.1E+2\"), nullValue());\n        assertThat(expression.match(\"-.1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n        assertThat(expression.match(\"-.10E2\").get(0).getValue(), is(new BigDecimal(\"-10\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_german() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.GERMAN));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_canadian_french() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.CANADA_FRENCH));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_norwegian() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.forLanguageTag(\"no\")));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }\n\n}\n", "file_hash": "ce2b49e57f3f677251f1a0c35e412dbb9162a5c4ef68a249b75b8a6d6ec424de", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.function.Executable;", "import java.math.BigDecimal;", "import java.util.Locale;", "import java.util.regex.Pattern;", "import static org.hamcrest.CoreMatchers.is;", "import static org.hamcrest.CoreMatchers.nullValue;", "import static org.hamcrest.MatcherAssert.assertThat;", "import static org.hamcrest.core.IsEqual.equalTo;", "import static org.junit.jupiter.api.Assertions.assertNotNull;", "import static org.junit.jupiter.api.Assertions.assertSame;", "import static org.junit.jupiter.api.Assertions.assertThrows;"], "methods": [], "classes": [{"original_string": "public class ParameterTypeRegistryTest {\n\n    private static final String CAPITALISED_WORD = \"[A-Z]+\\\\w+\";\n\n    public static class Name {\n        Name(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Person {\n        Person(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Place {\n        Place(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    private final ParameterTypeRegistry registry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    @Test\n    public void does_not_allow_more_than_one_preferential_parameter_type_for_each_regexp() {\n\n        registry.defineParameterType(new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, false, true));\n        registry.defineParameterType(new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, false, false));\n\n        final Executable testMethod = () -> registry.defineParameterType(new ParameterType<>(\n                \"place\",\n                CAPITALISED_WORD,\n                Place.class,\n                Place::new,\n                false,\n                true\n        ));\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"There can only be one preferential parameter type per regexp. The regexp /[A-Z]+\\\\w+/ is used for two preferential parameter types, {name} and {place}\")));\n    }\n\n    @Test\n    public void looks_up_preferential_parameter_type_by_regexp() {\n        ParameterType<Name> name = new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, false, false);\n        ParameterType<Person> person = new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, false, true);\n        ParameterType<Place> place = new ParameterType<>(\"place\", CAPITALISED_WORD, Place.class, Place::new, false, false);\n        registry.defineParameterType(name);\n        registry.defineParameterType(person);\n        registry.defineParameterType(place);\n        assertSame(person, registry.lookupByRegexp(CAPITALISED_WORD, Pattern.compile(\"([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)\"), \"Lisa and Bob\"));\n    }\n\n    @Test\n    public void throws_ambiguous_exception_on_lookup_when_no_parameter_types_are_preferential() {\n        ParameterType<Name> name = new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, true, false);\n        ParameterType<Person> person = new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, true, false);\n        ParameterType<Place> place = new ParameterType<>(\"place\", CAPITALISED_WORD, Place.class, Place::new, true, false);\n        registry.defineParameterType(name);\n        registry.defineParameterType(person);\n        registry.defineParameterType(place);\n\n        String expected = \"\" +\n                \"Your Regular Expression /([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)/\\n\" +\n                \"matches multiple parameter types with regexp /[A-Z]+\\\\w+/:\\n\" +\n                \"   {name}\\n\" +\n                \"   {person}\\n\" +\n                \"   {place}\\n\" +\n                \"\\n\" +\n                \"I couldn't decide which one to use. You have two options:\\n\" +\n                \"\\n\" +\n                \"1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\\n\" +\n                \"   {name} and {name}\\n\" +\n                \"   {name} and {person}\\n\" +\n                \"   {name} and {place}\\n\" +\n                \"   {person} and {name}\\n\" +\n                \"   {person} and {person}\\n\" +\n                \"   {person} and {place}\\n\" +\n                \"   {place} and {name}\\n\" +\n                \"   {place} and {person}\\n\" +\n                \"   {place} and {place}\\n\" +\n                \"\\n\" +\n                \"2) Make one of the parameter types preferential and continue to use a Regular Expression.\\n\" +\n                \"\\n\";\n\n        final Executable testMethod = () -> registry.lookupByRegexp(CAPITALISED_WORD, Pattern.compile(\"([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)\"), \"Lisa and Bob\");\n\n        final AmbiguousParameterTypeException thrownException = assertThrows(AmbiguousParameterTypeException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(expected)));\n    }\n\n    @Test\n    public void does_not_allow_anonymous_parameter_type_to_be_registered() {\n\n        final Executable testMethod = () -> registry.defineParameterType(new ParameterType<>(\"\", \".*\", Object.class, (Transformer<Object>) arg -> arg));\n\n        final DuplicateTypeNameException thrownException = assertThrows(DuplicateTypeNameException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"The anonymous parameter type has already been defined\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_english() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.ENGLISH));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"\"), nullValue());\n        assertThat(expression.match(\".\"), nullValue());\n        assertThat(expression.match(\",\"), nullValue());\n        assertThat(expression.match(\"-\"), nullValue());\n        assertThat(expression.match(\"E\"), nullValue());\n        assertThat(expression.match(\"1,\"), nullValue());\n        assertThat(expression.match(\",1\"), nullValue());\n        assertThat(expression.match(\"1.\"), nullValue());\n\n        assertThat(expression.match(\"1\").get(0).getValue(), is(BigDecimal.ONE));\n        assertThat(expression.match(\"-1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n        assertThat(expression.match(\"1.1\").get(0).getValue(), is(new BigDecimal(\"1.1\")));\n        assertThat(expression.match(\"1,000\").get(0).getValue(), is(new BigDecimal(\"1000\")));\n        assertThat(expression.match(\"1,000,0\").get(0).getValue(), is(new BigDecimal(\"10000\")));\n        assertThat(expression.match(\"1,000.1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1,000,10\").get(0).getValue(), is(new BigDecimal(\"100010\")));\n        assertThat(expression.match(\"1,0.1\").get(0).getValue(), is(new BigDecimal(\"10.1\")));\n        assertThat(expression.match(\"1,000,000.1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1.1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n\n        assertThat(expression.match(\".1\").get(0).getValue(), is(new BigDecimal(\"0.1\")));\n        assertThat(expression.match(\"-.1\").get(0).getValue(), is(new BigDecimal(\"-0.1\")));\n        assertThat(expression.match(\"-.10000001\").get(0).getValue(), is(new BigDecimal(\"-0.10000001\")));\n        assertThat(expression.match(\"1E1\").get(0).getValue(), is(new BigDecimal(\"1E1\"))); // precision 1 with scale -1, can not be expressed as a decimal\n        assertThat(expression.match(\".1E1\").get(0).getValue(), is(new BigDecimal(\"1\")));\n        assertThat(expression.match(\"E1\"), nullValue());\n        assertThat(expression.match(\"-.1E-1\").get(0).getValue(), is(new BigDecimal(\"-0.01\")));\n        assertThat(expression.match(\"-.1E-2\").get(0).getValue(), is(new BigDecimal(\"-0.001\")));\n        assertThat(expression.match(\"-.1E+1\"), nullValue());\n        assertThat(expression.match(\"-.1E+2\"), nullValue());\n        assertThat(expression.match(\"-.1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n        assertThat(expression.match(\"-.10E2\").get(0).getValue(), is(new BigDecimal(\"-10\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_german() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.GERMAN));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_canadian_french() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.CANADA_FRENCH));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_norwegian() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.forLanguageTag(\"no\")));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }\n\n}", "definition": "public class ParameterTypeRegistryTest", "class_docstring": "", "name": "ParameterTypeRegistryTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final String CAPITALISED_WORD = \"[A-Z]+\\\\w+\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "CAPITALISED_WORD = \"[A-Z]+\\\\w+\"", "syntax_pass": true}, {"attribute_expression": "private final ParameterTypeRegistry registry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "registry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}], "classes": [{"original_string": "    public static class Name {\n        Name(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Name", "class_docstring": "", "name": "Name", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Name(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Name", "params": [{"name": "s", "type": "String"}], "body": "                       {\n            assertNotNull(s);\n        }", "signature": "Name(String s)"}]}, {"original_string": "    public static class Person {\n        Person(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Person", "class_docstring": "", "name": "Person", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Person(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Person", "params": [{"name": "s", "type": "String"}], "body": "                         {\n            assertNotNull(s);\n        }", "signature": "Person(String s)"}]}, {"original_string": "    public static class Place {\n        Place(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Place", "class_docstring": "", "name": "Place", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Place(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Place", "params": [{"name": "s", "type": "String"}], "body": "                        {\n            assertNotNull(s);\n        }", "signature": "Place(String s)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void does_not_allow_more_than_one_preferential_parameter_type_for_each_regexp() {\n\n        registry.defineParameterType(new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, false, true));\n        registry.defineParameterType(new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, false, false));\n\n        final Executable testMethod = () -> registry.defineParameterType(new ParameterType<>(\n                \"place\",\n                CAPITALISED_WORD,\n                Place.class,\n                Place::new,\n                false,\n                true\n        ));\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"There can only be one preferential parameter type per regexp. The regexp /[A-Z]+\\\\w+/ is used for two preferential parameter types, {name} and {place}\")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "does_not_allow_more_than_one_preferential_parameter_type_for_each_regexp", "params": [], "body": "                                                                                           {\n\n        registry.defineParameterType(new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, false, true));\n        registry.defineParameterType(new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, false, false));\n\n        final Executable testMethod = () -> registry.defineParameterType(new ParameterType<>(\n                \"place\",\n                CAPITALISED_WORD,\n                Place.class,\n                Place::new,\n                false,\n                true\n        ));\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"There can only be one preferential parameter type per regexp. The regexp /[A-Z]+\\\\w+/ is used for two preferential parameter types, {name} and {place}\")));\n    }", "signature": "@Test\n    public void does_not_allow_more_than_one_preferential_parameter_type_for_each_regexp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void looks_up_preferential_parameter_type_by_regexp() {\n        ParameterType<Name> name = new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, false, false);\n        ParameterType<Person> person = new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, false, true);\n        ParameterType<Place> place = new ParameterType<>(\"place\", CAPITALISED_WORD, Place.class, Place::new, false, false);\n        registry.defineParameterType(name);\n        registry.defineParameterType(person);\n        registry.defineParameterType(place);\n        assertSame(person, registry.lookupByRegexp(CAPITALISED_WORD, Pattern.compile(\"([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)\"), \"Lisa and Bob\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "looks_up_preferential_parameter_type_by_regexp", "params": [], "body": "                                                                 {\n        ParameterType<Name> name = new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, false, false);\n        ParameterType<Person> person = new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, false, true);\n        ParameterType<Place> place = new ParameterType<>(\"place\", CAPITALISED_WORD, Place.class, Place::new, false, false);\n        registry.defineParameterType(name);\n        registry.defineParameterType(person);\n        registry.defineParameterType(place);\n        assertSame(person, registry.lookupByRegexp(CAPITALISED_WORD, Pattern.compile(\"([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)\"), \"Lisa and Bob\"));\n    }", "signature": "@Test\n    public void looks_up_preferential_parameter_type_by_regexp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void throws_ambiguous_exception_on_lookup_when_no_parameter_types_are_preferential() {\n        ParameterType<Name> name = new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, true, false);\n        ParameterType<Person> person = new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, true, false);\n        ParameterType<Place> place = new ParameterType<>(\"place\", CAPITALISED_WORD, Place.class, Place::new, true, false);\n        registry.defineParameterType(name);\n        registry.defineParameterType(person);\n        registry.defineParameterType(place);\n\n        String expected = \"\" +\n                \"Your Regular Expression /([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)/\\n\" +\n                \"matches multiple parameter types with regexp /[A-Z]+\\\\w+/:\\n\" +\n                \"   {name}\\n\" +\n                \"   {person}\\n\" +\n                \"   {place}\\n\" +\n                \"\\n\" +\n                \"I couldn't decide which one to use. You have two options:\\n\" +\n                \"\\n\" +\n                \"1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\\n\" +\n                \"   {name} and {name}\\n\" +\n                \"   {name} and {person}\\n\" +\n                \"   {name} and {place}\\n\" +\n                \"   {person} and {name}\\n\" +\n                \"   {person} and {person}\\n\" +\n                \"   {person} and {place}\\n\" +\n                \"   {place} and {name}\\n\" +\n                \"   {place} and {person}\\n\" +\n                \"   {place} and {place}\\n\" +\n                \"\\n\" +\n                \"2) Make one of the parameter types preferential and continue to use a Regular Expression.\\n\" +\n                \"\\n\";\n\n        final Executable testMethod = () -> registry.lookupByRegexp(CAPITALISED_WORD, Pattern.compile(\"([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)\"), \"Lisa and Bob\");\n\n        final AmbiguousParameterTypeException thrownException = assertThrows(AmbiguousParameterTypeException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(expected)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "throws_ambiguous_exception_on_lookup_when_no_parameter_types_are_preferential", "params": [], "body": "                                                                                                {\n        ParameterType<Name> name = new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, true, false);\n        ParameterType<Person> person = new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, true, false);\n        ParameterType<Place> place = new ParameterType<>(\"place\", CAPITALISED_WORD, Place.class, Place::new, true, false);\n        registry.defineParameterType(name);\n        registry.defineParameterType(person);\n        registry.defineParameterType(place);\n\n        String expected = \"\" +\n                \"Your Regular Expression /([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)/\\n\" +\n                \"matches multiple parameter types with regexp /[A-Z]+\\\\w+/:\\n\" +\n                \"   {name}\\n\" +\n                \"   {person}\\n\" +\n                \"   {place}\\n\" +\n                \"\\n\" +\n                \"I couldn't decide which one to use. You have two options:\\n\" +\n                \"\\n\" +\n                \"1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\\n\" +\n                \"   {name} and {name}\\n\" +\n                \"   {name} and {person}\\n\" +\n                \"   {name} and {place}\\n\" +\n                \"   {person} and {name}\\n\" +\n                \"   {person} and {person}\\n\" +\n                \"   {person} and {place}\\n\" +\n                \"   {place} and {name}\\n\" +\n                \"   {place} and {person}\\n\" +\n                \"   {place} and {place}\\n\" +\n                \"\\n\" +\n                \"2) Make one of the parameter types preferential and continue to use a Regular Expression.\\n\" +\n                \"\\n\";\n\n        final Executable testMethod = () -> registry.lookupByRegexp(CAPITALISED_WORD, Pattern.compile(\"([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)\"), \"Lisa and Bob\");\n\n        final AmbiguousParameterTypeException thrownException = assertThrows(AmbiguousParameterTypeException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(expected)));\n    }", "signature": "@Test\n    public void throws_ambiguous_exception_on_lookup_when_no_parameter_types_are_preferential()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void does_not_allow_anonymous_parameter_type_to_be_registered() {\n\n        final Executable testMethod = () -> registry.defineParameterType(new ParameterType<>(\"\", \".*\", Object.class, (Transformer<Object>) arg -> arg));\n\n        final DuplicateTypeNameException thrownException = assertThrows(DuplicateTypeNameException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"The anonymous parameter type has already been defined\")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "does_not_allow_anonymous_parameter_type_to_be_registered", "params": [], "body": "                                                                           {\n\n        final Executable testMethod = () -> registry.defineParameterType(new ParameterType<>(\"\", \".*\", Object.class, (Transformer<Object>) arg -> arg));\n\n        final DuplicateTypeNameException thrownException = assertThrows(DuplicateTypeNameException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"The anonymous parameter type has already been defined\")));\n    }", "signature": "@Test\n    public void does_not_allow_anonymous_parameter_type_to_be_registered()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void parse_decimal_numbers_in_english() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.ENGLISH));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"\"), nullValue());\n        assertThat(expression.match(\".\"), nullValue());\n        assertThat(expression.match(\",\"), nullValue());\n        assertThat(expression.match(\"-\"), nullValue());\n        assertThat(expression.match(\"E\"), nullValue());\n        assertThat(expression.match(\"1,\"), nullValue());\n        assertThat(expression.match(\",1\"), nullValue());\n        assertThat(expression.match(\"1.\"), nullValue());\n\n        assertThat(expression.match(\"1\").get(0).getValue(), is(BigDecimal.ONE));\n        assertThat(expression.match(\"-1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n        assertThat(expression.match(\"1.1\").get(0).getValue(), is(new BigDecimal(\"1.1\")));\n        assertThat(expression.match(\"1,000\").get(0).getValue(), is(new BigDecimal(\"1000\")));\n        assertThat(expression.match(\"1,000,0\").get(0).getValue(), is(new BigDecimal(\"10000\")));\n        assertThat(expression.match(\"1,000.1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1,000,10\").get(0).getValue(), is(new BigDecimal(\"100010\")));\n        assertThat(expression.match(\"1,0.1\").get(0).getValue(), is(new BigDecimal(\"10.1\")));\n        assertThat(expression.match(\"1,000,000.1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1.1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n\n        assertThat(expression.match(\".1\").get(0).getValue(), is(new BigDecimal(\"0.1\")));\n        assertThat(expression.match(\"-.1\").get(0).getValue(), is(new BigDecimal(\"-0.1\")));\n        assertThat(expression.match(\"-.10000001\").get(0).getValue(), is(new BigDecimal(\"-0.10000001\")));\n        assertThat(expression.match(\"1E1\").get(0).getValue(), is(new BigDecimal(\"1E1\"))); // precision 1 with scale -1, can not be expressed as a decimal\n        assertThat(expression.match(\".1E1\").get(0).getValue(), is(new BigDecimal(\"1\")));\n        assertThat(expression.match(\"E1\"), nullValue());\n        assertThat(expression.match(\"-.1E-1\").get(0).getValue(), is(new BigDecimal(\"-0.01\")));\n        assertThat(expression.match(\"-.1E-2\").get(0).getValue(), is(new BigDecimal(\"-0.001\")));\n        assertThat(expression.match(\"-.1E+1\"), nullValue());\n        assertThat(expression.match(\"-.1E+2\"), nullValue());\n        assertThat(expression.match(\"-.1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n        assertThat(expression.match(\"-.10E2\").get(0).getValue(), is(new BigDecimal(\"-10\")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "parse_decimal_numbers_in_english", "params": [], "body": "                                                   {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.ENGLISH));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"\"), nullValue());\n        assertThat(expression.match(\".\"), nullValue());\n        assertThat(expression.match(\",\"), nullValue());\n        assertThat(expression.match(\"-\"), nullValue());\n        assertThat(expression.match(\"E\"), nullValue());\n        assertThat(expression.match(\"1,\"), nullValue());\n        assertThat(expression.match(\",1\"), nullValue());\n        assertThat(expression.match(\"1.\"), nullValue());\n\n        assertThat(expression.match(\"1\").get(0).getValue(), is(BigDecimal.ONE));\n        assertThat(expression.match(\"-1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n        assertThat(expression.match(\"1.1\").get(0).getValue(), is(new BigDecimal(\"1.1\")));\n        assertThat(expression.match(\"1,000\").get(0).getValue(), is(new BigDecimal(\"1000\")));\n        assertThat(expression.match(\"1,000,0\").get(0).getValue(), is(new BigDecimal(\"10000\")));\n        assertThat(expression.match(\"1,000.1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1,000,10\").get(0).getValue(), is(new BigDecimal(\"100010\")));\n        assertThat(expression.match(\"1,0.1\").get(0).getValue(), is(new BigDecimal(\"10.1\")));\n        assertThat(expression.match(\"1,000,000.1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1.1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n\n        assertThat(expression.match(\".1\").get(0).getValue(), is(new BigDecimal(\"0.1\")));\n        assertThat(expression.match(\"-.1\").get(0).getValue(), is(new BigDecimal(\"-0.1\")));\n        assertThat(expression.match(\"-.10000001\").get(0).getValue(), is(new BigDecimal(\"-0.10000001\")));\n        assertThat(expression.match(\"1E1\").get(0).getValue(), is(new BigDecimal(\"1E1\"))); // precision 1 with scale -1, can not be expressed as a decimal\n        assertThat(expression.match(\".1E1\").get(0).getValue(), is(new BigDecimal(\"1\")));\n        assertThat(expression.match(\"E1\"), nullValue());\n        assertThat(expression.match(\"-.1E-1\").get(0).getValue(), is(new BigDecimal(\"-0.01\")));\n        assertThat(expression.match(\"-.1E-2\").get(0).getValue(), is(new BigDecimal(\"-0.001\")));\n        assertThat(expression.match(\"-.1E+1\"), nullValue());\n        assertThat(expression.match(\"-.1E+2\"), nullValue());\n        assertThat(expression.match(\"-.1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n        assertThat(expression.match(\"-.10E2\").get(0).getValue(), is(new BigDecimal(\"-10\")));\n    }", "signature": "@Test\n    public void parse_decimal_numbers_in_english()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void parse_decimal_numbers_in_german() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.GERMAN));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "parse_decimal_numbers_in_german", "params": [], "body": "                                                  {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.GERMAN));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }", "signature": "@Test\n    public void parse_decimal_numbers_in_german()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void parse_decimal_numbers_in_canadian_french() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.CANADA_FRENCH));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "parse_decimal_numbers_in_canadian_french", "params": [], "body": "                                                           {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.CANADA_FRENCH));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }", "signature": "@Test\n    public void parse_decimal_numbers_in_canadian_french()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void parse_decimal_numbers_in_norwegian() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.forLanguageTag(\"no\")));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "parse_decimal_numbers_in_norwegian", "params": [], "body": "                                                     {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.forLanguageTag(\"no\")));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }", "signature": "@Test\n    public void parse_decimal_numbers_in_norwegian()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/RegexpUtilsTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\n\nimport static io.cucumber.cucumberexpressions.RegexpUtils.escapeRegex;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass RegexpUtilsTest {\n\n    @Test\n    void escape_regex_characters(){\n        assertEquals(\"hello \\\\$world\", escapeRegex(\"hello $world\"));\n    }\n\n    @Test\n    void escape_all_regexp_characters() {\n        assertEquals(\"\\\\^\\\\$\\\\[\\\\]\\\\(\\\\)\\\\{\\\\}\\\\.\\\\|\\\\?\\\\*\\\\+\\\\\\\\\", escapeRegex(\"^$[](){}.|?*+\\\\\"));\n    }\n\n    @Test\n    void escape_escaped_regexp_characters() {\n        assertEquals(\"\\\\^\\\\$\\\\[\\\\]\\\\\\\\\\\\(\\\\\\\\\\\\)\\\\{\\\\}\\\\\\\\\\\\\\\\\\\\.\\\\|\\\\?\\\\*\\\\+\", escapeRegex(\"^$[]\\\\(\\\\){}\\\\\\\\.|?*+\"));\n    }\n\n\n    @Test\n    void do_not_escape_when_there_is_nothing_to_escape() {\n        assertEquals(\"hello world\", escapeRegex(\"hello world\"));\n    }\n\n    @Test\n    void gives_no_error_for_unicode_characters() {\n        assertEquals(\"\ud83e\udd52\", escapeRegex(\"\ud83e\udd52\"));\n    }\n\n}\n", "file_hash": "41525dba69bc64cb3a234b0d545fe16a07f1a3838060f6c3e9265d62e50f1236", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import static io.cucumber.cucumberexpressions.RegexpUtils.escapeRegex;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "class RegexpUtilsTest {\n\n    @Test\n    void escape_regex_characters(){\n        assertEquals(\"hello \\\\$world\", escapeRegex(\"hello $world\"));\n    }\n\n    @Test\n    void escape_all_regexp_characters() {\n        assertEquals(\"\\\\^\\\\$\\\\[\\\\]\\\\(\\\\)\\\\{\\\\}\\\\.\\\\|\\\\?\\\\*\\\\+\\\\\\\\\", escapeRegex(\"^$[](){}.|?*+\\\\\"));\n    }\n\n    @Test\n    void escape_escaped_regexp_characters() {\n        assertEquals(\"\\\\^\\\\$\\\\[\\\\]\\\\\\\\\\\\(\\\\\\\\\\\\)\\\\{\\\\}\\\\\\\\\\\\\\\\\\\\.\\\\|\\\\?\\\\*\\\\+\", escapeRegex(\"^$[]\\\\(\\\\){}\\\\\\\\.|?*+\"));\n    }\n\n\n    @Test\n    void do_not_escape_when_there_is_nothing_to_escape() {\n        assertEquals(\"hello world\", escapeRegex(\"hello world\"));\n    }\n\n    @Test\n    void gives_no_error_for_unicode_characters() {\n        assertEquals(\"\ud83e\udd52\", escapeRegex(\"\ud83e\udd52\"));\n    }\n\n}", "definition": "class RegexpUtilsTest", "class_docstring": "", "name": "RegexpUtilsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    void escape_regex_characters(){\n        assertEquals(\"hello \\\\$world\", escapeRegex(\"hello $world\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "escape_regex_characters", "params": [], "body": "                                  {\n        assertEquals(\"hello \\\\$world\", escapeRegex(\"hello $world\"));\n    }", "signature": "@Test\n    void escape_regex_characters()"}, {"syntax_pass": true, "original_string": "    @Test\n    void escape_all_regexp_characters() {\n        assertEquals(\"\\\\^\\\\$\\\\[\\\\]\\\\(\\\\)\\\\{\\\\}\\\\.\\\\|\\\\?\\\\*\\\\+\\\\\\\\\", escapeRegex(\"^$[](){}.|?*+\\\\\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "escape_all_regexp_characters", "params": [], "body": "                                        {\n        assertEquals(\"\\\\^\\\\$\\\\[\\\\]\\\\(\\\\)\\\\{\\\\}\\\\.\\\\|\\\\?\\\\*\\\\+\\\\\\\\\", escapeRegex(\"^$[](){}.|?*+\\\\\"));\n    }", "signature": "@Test\n    void escape_all_regexp_characters()"}, {"syntax_pass": true, "original_string": "    @Test\n    void escape_escaped_regexp_characters() {\n        assertEquals(\"\\\\^\\\\$\\\\[\\\\]\\\\\\\\\\\\(\\\\\\\\\\\\)\\\\{\\\\}\\\\\\\\\\\\\\\\\\\\.\\\\|\\\\?\\\\*\\\\+\", escapeRegex(\"^$[]\\\\(\\\\){}\\\\\\\\.|?*+\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "escape_escaped_regexp_characters", "params": [], "body": "                                            {\n        assertEquals(\"\\\\^\\\\$\\\\[\\\\]\\\\\\\\\\\\(\\\\\\\\\\\\)\\\\{\\\\}\\\\\\\\\\\\\\\\\\\\.\\\\|\\\\?\\\\*\\\\+\", escapeRegex(\"^$[]\\\\(\\\\){}\\\\\\\\.|?*+\"));\n    }", "signature": "@Test\n    void escape_escaped_regexp_characters()"}, {"syntax_pass": true, "original_string": "    @Test\n    void do_not_escape_when_there_is_nothing_to_escape() {\n        assertEquals(\"hello world\", escapeRegex(\"hello world\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "do_not_escape_when_there_is_nothing_to_escape", "params": [], "body": "                                                         {\n        assertEquals(\"hello world\", escapeRegex(\"hello world\"));\n    }", "signature": "@Test\n    void do_not_escape_when_there_is_nothing_to_escape()"}, {"syntax_pass": true, "original_string": "    @Test\n    void gives_no_error_for_unicode_characters() {\n        assertEquals(\"\ud83e\udd52\", escapeRegex(\"\ud83e\udd52\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "gives_no_error_for_unicode_characters", "params": [], "body": "                                                 {\n        assertEquals(\"\ud83e\udd52\", escapeRegex(\"\ud83e\udd52\"));\n    }", "signature": "@Test\n    void gives_no_error_for_unicode_characters()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getRegexpsTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ParameterType_getRegexpsTest {\n\n    @Test\n    public void testGetRegexps() {\n        List<String> expectedRegexps = Arrays.asList(\"\\\\d+\", \"\\\\w+\");\n        ParameterType<String> parameterType = new ParameterType<>(\"testName\", expectedRegexps, String.class, (String arg) -> arg, true, false);\n        List<String> actualRegexps = parameterType.getRegexps();\n        assertEquals(expectedRegexps, actualRegexps);\n    }\n}\n", "file_hash": "3a7ce987c10a50ff8af29317489f6ab2b5b30a021d85f416e46122b57ef4abf0", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.util.Arrays;", "import java.util.List;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class ParameterType_getRegexpsTest {\n\n    @Test\n    public void testGetRegexps() {\n        List<String> expectedRegexps = Arrays.asList(\"\\\\d+\", \"\\\\w+\");\n        ParameterType<String> parameterType = new ParameterType<>(\"testName\", expectedRegexps, String.class, (String arg) -> arg, true, false);\n        List<String> actualRegexps = parameterType.getRegexps();\n        assertEquals(expectedRegexps, actualRegexps);\n    }\n}", "definition": "public class ParameterType_getRegexpsTest", "class_docstring": "", "name": "ParameterType_getRegexpsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testGetRegexps() {\n        List<String> expectedRegexps = Arrays.asList(\"\\\\d+\", \"\\\\w+\");\n        ParameterType<String> parameterType = new ParameterType<>(\"testName\", expectedRegexps, String.class, (String arg) -> arg, true, false);\n        List<String> actualRegexps = parameterType.getRegexps();\n        assertEquals(expectedRegexps, actualRegexps);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetRegexps", "params": [], "body": "                                 {\n        List<String> expectedRegexps = Arrays.asList(\"\\\\d+\", \"\\\\w+\");\n        ParameterType<String> parameterType = new ParameterType<>(\"testName\", expectedRegexps, String.class, (String arg) -> arg, true, false);\n        List<String> actualRegexps = parameterType.getRegexps();\n        assertEquals(expectedRegexps, actualRegexps);\n    }", "signature": "@Test\n    public void testGetRegexps()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer_transformTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Locale;\nimport java.util.Optional;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass BuiltInParameterTransformer_transformTest {\n\n    private BuiltInParameterTransformer transformer;\n\n    @BeforeEach\n    void setUp() {\n        transformer = new BuiltInParameterTransformer(Locale.ENGLISH);\n    }\n\n    @Test\n    void testTransformStringToBigDecimal() {\n        String fromValue = \"123.45\";\n        Type toValueType = BigDecimal.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(new BigDecimal(\"123.45\"), result);\n    }\n\n    @Test\n    void testTransformStringToOptionalBigDecimal() {\n        String fromValue = \"123.45\";\n        Type toValueType = new ParameterizedTypeImpl(Optional.class, new Type[]{BigDecimal.class});\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(Optional.of(new BigDecimal(\"123.45\")), result);\n    }\n\n    @Test\n    void testTransformStringToUnsupportedType() {\n        String fromValue = \"test\";\n        Type toValueType = this.getClass();\n        assertThrows(IllegalArgumentException.class, () -> {\n            transformer.transform(fromValue, toValueType);\n        });\n    }\n\n    @Test\n    void testTransformNullValue() {\n        String fromValue = null;\n        Type toValueType = BigDecimal.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertNull(result);\n    }\n\n    @Test\n    void testTransformStringToEnum() {\n        String fromValue = \"VALUE1\";\n        Type toValueType = TestEnum.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(TestEnum.VALUE1, result);\n    }\n\n    private enum TestEnum {\n        VALUE1, VALUE2\n    }\n\n    private static class ParameterizedTypeImpl implements java.lang.reflect.ParameterizedType {\n        private final Type rawType;\n        private final Type[] typeArguments;\n\n        public ParameterizedTypeImpl(Type rawType, Type[] typeArguments) {\n            this.rawType = rawType;\n            this.typeArguments = typeArguments;\n        }\n\n        @Override\n        public Type[] getActualTypeArguments() {\n            return typeArguments;\n        }\n\n        @Override\n        public Type getRawType() {\n            return rawType;\n        }\n\n        @Override\n        public Type getOwnerType() {\n            return null;\n        }\n    }\n}\n", "file_hash": "a8daeeac39be4a697c9f33da23b3dafd2d21074482d77651f3407576a6da1a00", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import java.lang.reflect.Type;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import java.util.Locale;", "import java.util.Optional;", "import static org.junit.jupiter.api.Assertions.*;"], "methods": [], "classes": [{"original_string": "class BuiltInParameterTransformer_transformTest {\n\n    private BuiltInParameterTransformer transformer;\n\n    @BeforeEach\n    void setUp() {\n        transformer = new BuiltInParameterTransformer(Locale.ENGLISH);\n    }\n\n    @Test\n    void testTransformStringToBigDecimal() {\n        String fromValue = \"123.45\";\n        Type toValueType = BigDecimal.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(new BigDecimal(\"123.45\"), result);\n    }\n\n    @Test\n    void testTransformStringToOptionalBigDecimal() {\n        String fromValue = \"123.45\";\n        Type toValueType = new ParameterizedTypeImpl(Optional.class, new Type[]{BigDecimal.class});\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(Optional.of(new BigDecimal(\"123.45\")), result);\n    }\n\n    @Test\n    void testTransformStringToUnsupportedType() {\n        String fromValue = \"test\";\n        Type toValueType = this.getClass();\n        assertThrows(IllegalArgumentException.class, () -> {\n            transformer.transform(fromValue, toValueType);\n        });\n    }\n\n    @Test\n    void testTransformNullValue() {\n        String fromValue = null;\n        Type toValueType = BigDecimal.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertNull(result);\n    }\n\n    @Test\n    void testTransformStringToEnum() {\n        String fromValue = \"VALUE1\";\n        Type toValueType = TestEnum.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(TestEnum.VALUE1, result);\n    }\n\n    private enum TestEnum {\n        VALUE1, VALUE2\n    }\n\n    private static class ParameterizedTypeImpl implements java.lang.reflect.ParameterizedType {\n        private final Type rawType;\n        private final Type[] typeArguments;\n\n        public ParameterizedTypeImpl(Type rawType, Type[] typeArguments) {\n            this.rawType = rawType;\n            this.typeArguments = typeArguments;\n        }\n\n        @Override\n        public Type[] getActualTypeArguments() {\n            return typeArguments;\n        }\n\n        @Override\n        public Type getRawType() {\n            return rawType;\n        }\n\n        @Override\n        public Type getOwnerType() {\n            return null;\n        }\n    }\n}", "definition": "class BuiltInParameterTransformer_transformTest", "class_docstring": "", "name": "BuiltInParameterTransformer_transformTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "private BuiltInParameterTransformer transformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BuiltInParameterTransformer", "name": "transformer", "syntax_pass": true}], "classes": [{"original_string": "    private static class ParameterizedTypeImpl implements java.lang.reflect.ParameterizedType {\n        private final Type rawType;\n        private final Type[] typeArguments;\n\n        public ParameterizedTypeImpl(Type rawType, Type[] typeArguments) {\n            this.rawType = rawType;\n            this.typeArguments = typeArguments;\n        }\n\n        @Override\n        public Type[] getActualTypeArguments() {\n            return typeArguments;\n        }\n\n        @Override\n        public Type getRawType() {\n            return rawType;\n        }\n\n        @Override\n        public Type getOwnerType() {\n            return null;\n        }\n    }", "definition": "    private static class ParameterizedTypeImpl implements java.lang.reflect.ParameterizedType", "class_docstring": "", "name": "ParameterizedTypeImpl", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Type rawType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Type", "name": "rawType", "syntax_pass": true}, {"attribute_expression": "private final Type[] typeArguments;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Type[]", "name": "typeArguments", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ParameterizedTypeImpl(Type rawType, Type[] typeArguments) {\n            this.rawType = rawType;\n            this.typeArguments = typeArguments;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterizedTypeImpl", "params": [{"name": "rawType", "type": "Type"}, {"name": "typeArguments", "type": "Type[]"}], "body": "                                                                         {\n            this.rawType = rawType;\n            this.typeArguments = typeArguments;\n        }", "signature": "public ParameterizedTypeImpl(Type rawType, Type[] typeArguments)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Type[] getActualTypeArguments() {\n            return typeArguments;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type[]", "classes": []}, "name": "getActualTypeArguments", "params": [], "body": "                                               {\n            return typeArguments;\n        }", "signature": "@Override\n        public Type[] getActualTypeArguments()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Type getRawType() {\n            return rawType;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "getRawType", "params": [], "body": "                                 {\n            return rawType;\n        }", "signature": "@Override\n        public Type getRawType()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Type getOwnerType() {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "getOwnerType", "params": [], "body": "                                   {\n            return null;\n        }", "signature": "@Override\n        public Type getOwnerType()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    void setUp() {\n        transformer = new BuiltInParameterTransformer(Locale.ENGLISH);\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                 {\n        transformer = new BuiltInParameterTransformer(Locale.ENGLISH);\n    }", "signature": "@BeforeEach\n    void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    void testTransformStringToBigDecimal() {\n        String fromValue = \"123.45\";\n        Type toValueType = BigDecimal.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(new BigDecimal(\"123.45\"), result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testTransformStringToBigDecimal", "params": [], "body": "                                           {\n        String fromValue = \"123.45\";\n        Type toValueType = BigDecimal.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(new BigDecimal(\"123.45\"), result);\n    }", "signature": "@Test\n    void testTransformStringToBigDecimal()"}, {"syntax_pass": true, "original_string": "    @Test\n    void testTransformStringToOptionalBigDecimal() {\n        String fromValue = \"123.45\";\n        Type toValueType = new ParameterizedTypeImpl(Optional.class, new Type[]{BigDecimal.class});\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(Optional.of(new BigDecimal(\"123.45\")), result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testTransformStringToOptionalBigDecimal", "params": [], "body": "                                                   {\n        String fromValue = \"123.45\";\n        Type toValueType = new ParameterizedTypeImpl(Optional.class, new Type[]{BigDecimal.class});\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(Optional.of(new BigDecimal(\"123.45\")), result);\n    }", "signature": "@Test\n    void testTransformStringToOptionalBigDecimal()"}, {"syntax_pass": true, "original_string": "    @Test\n    void testTransformStringToUnsupportedType() {\n        String fromValue = \"test\";\n        Type toValueType = this.getClass();\n        assertThrows(IllegalArgumentException.class, () -> {\n            transformer.transform(fromValue, toValueType);\n        });\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testTransformStringToUnsupportedType", "params": [], "body": "                                                {\n        String fromValue = \"test\";\n        Type toValueType = this.getClass();\n        assertThrows(IllegalArgumentException.class, () -> {\n            transformer.transform(fromValue, toValueType);\n        });\n    }", "signature": "@Test\n    void testTransformStringToUnsupportedType()"}, {"syntax_pass": true, "original_string": "    @Test\n    void testTransformNullValue() {\n        String fromValue = null;\n        Type toValueType = BigDecimal.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertNull(result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testTransformNullValue", "params": [], "body": "                                  {\n        String fromValue = null;\n        Type toValueType = BigDecimal.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertNull(result);\n    }", "signature": "@Test\n    void testTransformNullValue()"}, {"syntax_pass": true, "original_string": "    @Test\n    void testTransformStringToEnum() {\n        String fromValue = \"VALUE1\";\n        Type toValueType = TestEnum.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(TestEnum.VALUE1, result);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testTransformStringToEnum", "params": [], "body": "                                     {\n        String fromValue = \"VALUE1\";\n        Type toValueType = TestEnum.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(TestEnum.VALUE1, result);\n    }", "signature": "@Test\n    void testTransformStringToEnum()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getNameTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ParameterType_getNameTest {\n\n    @Test\n    public void testGetName() {\n        ParameterType<String> parameterType = new ParameterType<>(\"testName\", \"testRegexp\", String.class, (String arg) -> arg);\n        assertEquals(\"testName\", parameterType.getName());\n    }\n}\n", "file_hash": "f2b7d2ad92afd3060562e056af26a7657f3e690f6c5cb559a7f9ccecbe882a76", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class ParameterType_getNameTest {\n\n    @Test\n    public void testGetName() {\n        ParameterType<String> parameterType = new ParameterType<>(\"testName\", \"testRegexp\", String.class, (String arg) -> arg);\n        assertEquals(\"testName\", parameterType.getName());\n    }\n}", "definition": "public class ParameterType_getNameTest", "class_docstring": "", "name": "ParameterType_getNameTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testGetName() {\n        ParameterType<String> parameterType = new ParameterType<>(\"testName\", \"testRegexp\", String.class, (String arg) -> arg);\n        assertEquals(\"testName\", parameterType.getName());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetName", "params": [], "body": "                              {\n        ParameterType<String> parameterType = new ParameterType<>(\"testName\", \"testRegexp\", String.class, (String arg) -> arg);\n        assertEquals(\"testName\", parameterType.getName());\n    }", "signature": "@Test\n    public void testGetName()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getTypeTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport java.lang.reflect.Type;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ParameterType_getTypeTest {\n\n    private ParameterType<String> parameterType;\n\n    @BeforeEach\n    public void setUp() {\n        parameterType = new ParameterType<>(\"testName\", \"testRegexp\", String.class, (Transformer<String>) s -> s, true, false);\n    }\n\n    @Test\n    public void getType_returnsCorrectType() {\n        Type expectedType = String.class;\n        Type actualType = parameterType.getType();\n        assertEquals(expectedType, actualType);\n    }\n}\n", "file_hash": "494edc4db7538bf23a9117e58464a07b4814380b46170aa839ad9340f3e97bc9", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import java.lang.reflect.Type;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class ParameterType_getTypeTest {\n\n    private ParameterType<String> parameterType;\n\n    @BeforeEach\n    public void setUp() {\n        parameterType = new ParameterType<>(\"testName\", \"testRegexp\", String.class, (Transformer<String>) s -> s, true, false);\n    }\n\n    @Test\n    public void getType_returnsCorrectType() {\n        Type expectedType = String.class;\n        Type actualType = parameterType.getType();\n        assertEquals(expectedType, actualType);\n    }\n}", "definition": "public class ParameterType_getTypeTest", "class_docstring": "", "name": "ParameterType_getTypeTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private ParameterType<String> parameterType;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterType<String>", "name": "parameterType", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @BeforeEach\n    public void setUp() {\n        parameterType = new ParameterType<>(\"testName\", \"testRegexp\", String.class, (Transformer<String>) s -> s, true, false);\n    }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        parameterType = new ParameterType<>(\"testName\", \"testRegexp\", String.class, (Transformer<String>) s -> s, true, false);\n    }", "signature": "@BeforeEach\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void getType_returnsCorrectType() {\n        Type expectedType = String.class;\n        Type actualType = parameterType.getType();\n        assertEquals(expectedType, actualType);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "getType_returnsCorrectType", "params": [], "body": "                                             {\n        Type expectedType = String.class;\n        Type actualType = parameterType.getType();\n        assertEquals(expectedType, actualType);\n    }", "signature": "@Test\n    public void getType_returnsCorrectType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/NumberParserTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.math.BigDecimal;\nimport java.util.Locale;\n\nimport static java.util.Locale.forLanguageTag;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass NumberParserTest {\n\n    private final NumberParser english = new NumberParser(Locale.ENGLISH);\n    private final NumberParser german = new NumberParser(Locale.GERMAN);\n    private final NumberParser canadianFrench = new NumberParser(Locale.CANADA_FRENCH);\n    private final NumberParser norwegian = new NumberParser(forLanguageTag(\"no\"));\n    private final NumberParser canadian = new NumberParser(Locale.CANADA);\n\n    @Test\n    void can_parse_float() {\n        assertEquals(1042.2f, english.parseFloat(\"1,042.2\"), 0);\n        assertEquals(1042.2f, canadian.parseFloat(\"1,042.2\"), 0);\n\n        assertEquals(1042.2f, german.parseFloat(\"1.042,2\"), 0);\n        assertEquals(1042.2f, canadianFrench.parseFloat(\"1.042,2\"), 0);\n        assertEquals(1042.2f, norwegian.parseFloat(\"1.042,2\"), 0);\n    }\n\n    @Test\n    void can_parse_double() {\n        assertEquals(1042.000000000000002, english.parseDouble(\"1,042.000000000000002\"), 0);\n        assertEquals(1042.000000000000002, canadian.parseDouble(\"1,042.000000000000002\"), 0);\n\n        assertEquals(1042.000000000000002, german.parseDouble(\"1.042,000000000000002\"), 0);\n        assertEquals(1042.000000000000002, canadianFrench.parseDouble(\"1.042,000000000000002\"), 0);\n        assertEquals(1042.000000000000002, norwegian.parseDouble(\"1.042,000000000000002\"), 0);\n    }\n\n    @Test\n    void can_parse_big_decimals() {\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), english.parseBigDecimal(\"1,042.0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), canadian.parseBigDecimal(\"1,042.0000000000000000000002\"));\n\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), german.parseBigDecimal(\"1.042,0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), canadianFrench.parseBigDecimal(\"1.042,0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), norwegian.parseBigDecimal(\"1.042,0000000000000000000002\"));\n    }\n\n    @Test\n    void can_parse_negative() {\n        assertEquals(-1042.2f, english.parseFloat(\"-1,042.2\"), 0);\n        assertEquals(-1042.2f, canadian.parseFloat(\"-1,042.2\"), 0);\n\n        assertEquals(-1042.2f, german.parseFloat(\"-1.042,2\"), 0);\n        assertEquals(-1042.2f, canadianFrench.parseFloat(\"-1.042,2\"), 0);\n        assertEquals(-1042.2f, norwegian.parseFloat(\"-1.042,2\"), 0);\n    }\n\n    // @Test\n    // void can_parse_exponents() {\n    //     assertEquals(new BigDecimal(\"100\"), english.parseBigDecimal(\"1.00E2\"));\n    //     assertEquals(new BigDecimal(\"100\"), canadian.parseBigDecimal(\"1.00e2\"));\n    //     assertEquals(new BigDecimal(\"100\"), german.parseBigDecimal(\"1,00E2\"));\n    //     assertEquals(new BigDecimal(\"100\"), canadianFrench.parseBigDecimal(\"1,00E2\"));\n    //     assertEquals(new BigDecimal(\"100\"), norwegian.parseBigDecimal(\"1,00E2\"));\n\n    //     assertEquals(new BigDecimal(\"0.01\"), english.parseBigDecimal(\"1E-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), canadian.parseBigDecimal(\"1e-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), german.parseBigDecimal(\"1E-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), canadianFrench.parseBigDecimal(\"1E-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), norwegian.parseBigDecimal(\"1E-2\"));\n    // }\n\n}\n", "file_hash": "4feec51dc5d5a98088643bfefe48c84c307359af558e49ca15e45669c8d7513e", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.math.BigDecimal;", "import java.util.Locale;", "import static java.util.Locale.forLanguageTag;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "class NumberParserTest {\n\n    private final NumberParser english = new NumberParser(Locale.ENGLISH);\n    private final NumberParser german = new NumberParser(Locale.GERMAN);\n    private final NumberParser canadianFrench = new NumberParser(Locale.CANADA_FRENCH);\n    private final NumberParser norwegian = new NumberParser(forLanguageTag(\"no\"));\n    private final NumberParser canadian = new NumberParser(Locale.CANADA);\n\n    @Test\n    void can_parse_float() {\n        assertEquals(1042.2f, english.parseFloat(\"1,042.2\"), 0);\n        assertEquals(1042.2f, canadian.parseFloat(\"1,042.2\"), 0);\n\n        assertEquals(1042.2f, german.parseFloat(\"1.042,2\"), 0);\n        assertEquals(1042.2f, canadianFrench.parseFloat(\"1.042,2\"), 0);\n        assertEquals(1042.2f, norwegian.parseFloat(\"1.042,2\"), 0);\n    }\n\n    @Test\n    void can_parse_double() {\n        assertEquals(1042.000000000000002, english.parseDouble(\"1,042.000000000000002\"), 0);\n        assertEquals(1042.000000000000002, canadian.parseDouble(\"1,042.000000000000002\"), 0);\n\n        assertEquals(1042.000000000000002, german.parseDouble(\"1.042,000000000000002\"), 0);\n        assertEquals(1042.000000000000002, canadianFrench.parseDouble(\"1.042,000000000000002\"), 0);\n        assertEquals(1042.000000000000002, norwegian.parseDouble(\"1.042,000000000000002\"), 0);\n    }\n\n    @Test\n    void can_parse_big_decimals() {\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), english.parseBigDecimal(\"1,042.0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), canadian.parseBigDecimal(\"1,042.0000000000000000000002\"));\n\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), german.parseBigDecimal(\"1.042,0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), canadianFrench.parseBigDecimal(\"1.042,0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), norwegian.parseBigDecimal(\"1.042,0000000000000000000002\"));\n    }\n\n    @Test\n    void can_parse_negative() {\n        assertEquals(-1042.2f, english.parseFloat(\"-1,042.2\"), 0);\n        assertEquals(-1042.2f, canadian.parseFloat(\"-1,042.2\"), 0);\n\n        assertEquals(-1042.2f, german.parseFloat(\"-1.042,2\"), 0);\n        assertEquals(-1042.2f, canadianFrench.parseFloat(\"-1.042,2\"), 0);\n        assertEquals(-1042.2f, norwegian.parseFloat(\"-1.042,2\"), 0);\n    }\n\n    // @Test\n    // void can_parse_exponents() {\n    //     assertEquals(new BigDecimal(\"100\"), english.parseBigDecimal(\"1.00E2\"));\n    //     assertEquals(new BigDecimal(\"100\"), canadian.parseBigDecimal(\"1.00e2\"));\n    //     assertEquals(new BigDecimal(\"100\"), german.parseBigDecimal(\"1,00E2\"));\n    //     assertEquals(new BigDecimal(\"100\"), canadianFrench.parseBigDecimal(\"1,00E2\"));\n    //     assertEquals(new BigDecimal(\"100\"), norwegian.parseBigDecimal(\"1,00E2\"));\n\n    //     assertEquals(new BigDecimal(\"0.01\"), english.parseBigDecimal(\"1E-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), canadian.parseBigDecimal(\"1e-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), german.parseBigDecimal(\"1E-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), canadianFrench.parseBigDecimal(\"1E-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), norwegian.parseBigDecimal(\"1E-2\"));\n    // }\n\n}", "definition": "class NumberParserTest", "class_docstring": "", "name": "NumberParserTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "private final NumberParser english = new NumberParser(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "english = new NumberParser(Locale.ENGLISH)", "syntax_pass": true}, {"attribute_expression": "private final NumberParser german = new NumberParser(Locale.GERMAN);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "german = new NumberParser(Locale.GERMAN)", "syntax_pass": true}, {"attribute_expression": "private final NumberParser canadianFrench = new NumberParser(Locale.CANADA_FRENCH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "canadianFrench = new NumberParser(Locale.CANADA_FRENCH)", "syntax_pass": true}, {"attribute_expression": "private final NumberParser norwegian = new NumberParser(forLanguageTag(\"no\"));", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "norwegian = new NumberParser(forLanguageTag(\"no\"))", "syntax_pass": true}, {"attribute_expression": "private final NumberParser canadian = new NumberParser(Locale.CANADA);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "canadian = new NumberParser(Locale.CANADA)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    void can_parse_float() {\n        assertEquals(1042.2f, english.parseFloat(\"1,042.2\"), 0);\n        assertEquals(1042.2f, canadian.parseFloat(\"1,042.2\"), 0);\n\n        assertEquals(1042.2f, german.parseFloat(\"1.042,2\"), 0);\n        assertEquals(1042.2f, canadianFrench.parseFloat(\"1.042,2\"), 0);\n        assertEquals(1042.2f, norwegian.parseFloat(\"1.042,2\"), 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "can_parse_float", "params": [], "body": "                           {\n        assertEquals(1042.2f, english.parseFloat(\"1,042.2\"), 0);\n        assertEquals(1042.2f, canadian.parseFloat(\"1,042.2\"), 0);\n\n        assertEquals(1042.2f, german.parseFloat(\"1.042,2\"), 0);\n        assertEquals(1042.2f, canadianFrench.parseFloat(\"1.042,2\"), 0);\n        assertEquals(1042.2f, norwegian.parseFloat(\"1.042,2\"), 0);\n    }", "signature": "@Test\n    void can_parse_float()"}, {"syntax_pass": true, "original_string": "    @Test\n    void can_parse_double() {\n        assertEquals(1042.000000000000002, english.parseDouble(\"1,042.000000000000002\"), 0);\n        assertEquals(1042.000000000000002, canadian.parseDouble(\"1,042.000000000000002\"), 0);\n\n        assertEquals(1042.000000000000002, german.parseDouble(\"1.042,000000000000002\"), 0);\n        assertEquals(1042.000000000000002, canadianFrench.parseDouble(\"1.042,000000000000002\"), 0);\n        assertEquals(1042.000000000000002, norwegian.parseDouble(\"1.042,000000000000002\"), 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "can_parse_double", "params": [], "body": "                            {\n        assertEquals(1042.000000000000002, english.parseDouble(\"1,042.000000000000002\"), 0);\n        assertEquals(1042.000000000000002, canadian.parseDouble(\"1,042.000000000000002\"), 0);\n\n        assertEquals(1042.000000000000002, german.parseDouble(\"1.042,000000000000002\"), 0);\n        assertEquals(1042.000000000000002, canadianFrench.parseDouble(\"1.042,000000000000002\"), 0);\n        assertEquals(1042.000000000000002, norwegian.parseDouble(\"1.042,000000000000002\"), 0);\n    }", "signature": "@Test\n    void can_parse_double()"}, {"syntax_pass": true, "original_string": "    @Test\n    void can_parse_big_decimals() {\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), english.parseBigDecimal(\"1,042.0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), canadian.parseBigDecimal(\"1,042.0000000000000000000002\"));\n\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), german.parseBigDecimal(\"1.042,0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), canadianFrench.parseBigDecimal(\"1.042,0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), norwegian.parseBigDecimal(\"1.042,0000000000000000000002\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "can_parse_big_decimals", "params": [], "body": "                                  {\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), english.parseBigDecimal(\"1,042.0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), canadian.parseBigDecimal(\"1,042.0000000000000000000002\"));\n\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), german.parseBigDecimal(\"1.042,0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), canadianFrench.parseBigDecimal(\"1.042,0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), norwegian.parseBigDecimal(\"1.042,0000000000000000000002\"));\n    }", "signature": "@Test\n    void can_parse_big_decimals()"}, {"syntax_pass": true, "original_string": "    @Test\n    void can_parse_negative() {\n        assertEquals(-1042.2f, english.parseFloat(\"-1,042.2\"), 0);\n        assertEquals(-1042.2f, canadian.parseFloat(\"-1,042.2\"), 0);\n\n        assertEquals(-1042.2f, german.parseFloat(\"-1.042,2\"), 0);\n        assertEquals(-1042.2f, canadianFrench.parseFloat(\"-1.042,2\"), 0);\n        assertEquals(-1042.2f, norwegian.parseFloat(\"-1.042,2\"), 0);\n    }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "can_parse_negative", "params": [], "body": "                              {\n        assertEquals(-1042.2f, english.parseFloat(\"-1,042.2\"), 0);\n        assertEquals(-1042.2f, canadian.parseFloat(\"-1,042.2\"), 0);\n\n        assertEquals(-1042.2f, german.parseFloat(\"-1.042,2\"), 0);\n        assertEquals(-1042.2f, canadianFrench.parseFloat(\"-1.042,2\"), 0);\n        assertEquals(-1042.2f, norwegian.parseFloat(\"-1.042,2\"), 0);\n    }", "signature": "@Test\n    void can_parse_negative()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/RegularExpression_getRegexpTest.java", "original_string": "\npackage io.cucumber.cucumberexpressions;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.regex.Pattern;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class RegularExpression_getRegexpTest {\n\n    @Test\n    public void testGetRegexp() {\n        Pattern expectedPattern = Pattern.compile(\"\\\\d+\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(java.util.Locale.getDefault());\n        RegularExpression regularExpression = new RegularExpression(expectedPattern, parameterTypeRegistry);\n        assertEquals(expectedPattern, regularExpression.getRegexp());\n    }\n}\n", "file_hash": "8e946b4fdc24826b7e12ba88175c00ddf0985fdd29664b16e17d70b3b7c041e8", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.junit.jupiter.api.Test;", "import java.util.regex.Pattern;", "import static org.junit.jupiter.api.Assertions.assertEquals;"], "methods": [], "classes": [{"original_string": "public class RegularExpression_getRegexpTest {\n\n    @Test\n    public void testGetRegexp() {\n        Pattern expectedPattern = Pattern.compile(\"\\\\d+\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(java.util.Locale.getDefault());\n        RegularExpression regularExpression = new RegularExpression(expectedPattern, parameterTypeRegistry);\n        assertEquals(expectedPattern, regularExpression.getRegexp());\n    }\n}", "definition": "public class RegularExpression_getRegexpTest", "class_docstring": "", "name": "RegularExpression_getRegexpTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testGetRegexp() {\n        Pattern expectedPattern = Pattern.compile(\"\\\\d+\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(java.util.Locale.getDefault());\n        RegularExpression regularExpression = new RegularExpression(expectedPattern, parameterTypeRegistry);\n        assertEquals(expectedPattern, regularExpression.getRegexp());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetRegexp", "params": [], "body": "                                {\n        Pattern expectedPattern = Pattern.compile(\"\\\\d+\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(java.util.Locale.getDefault());\n        RegularExpression regularExpression = new RegularExpression(expectedPattern, parameterTypeRegistry);\n        assertEquals(expectedPattern, regularExpression.getRegexp());\n    }", "signature": "@Test\n    public void testGetRegexp()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterByTypeTransformerTest.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport com.fasterxml.jackson.datatype.jdk8.Jdk8Module;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Optional;\nimport java.util.stream.Stream;\n\nimport static java.util.Locale.ENGLISH;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class ParameterByTypeTransformerTest {\n\n    static Stream<ParameterByTypeTransformer> objectMapperImplementations() {\n        return Stream.of(\n                new BuiltInParameterTransformer(ENGLISH),\n                new TestJacksonDefaultTransformer()\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_null(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertNull(defaultTransformer.transform(null, Object.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_optional(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Optional.empty(), defaultTransformer.transform(null, Optional.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_optional_generic(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {\n        }.getType();\n\n        assertEquals(Optional.empty(), defaultTransformer.transform(null, optionalIntType));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_string(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(\"Barbara Liskov\",\n                defaultTransformer.transform(\"Barbara Liskov\", String.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_optional_string(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalStringType = new TypeReference<Optional<String>>() {\n        }.getType();\n\n        assertEquals(Optional.of(\"Barbara Liskov\"), defaultTransformer.transform(\"Barbara Liskov\", optionalStringType));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_object(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(\"Barbara Liskov\",\n                defaultTransformer.transform(\"Barbara Liskov\", Object.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_big_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(new BigInteger(\"10000008\"),\n                defaultTransformer.transform(\"10000008\", BigInteger.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_big_decimal(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(new BigDecimal(\"1.0000008\"),\n                defaultTransformer.transform(\"1.0000008\", BigDecimal.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_byte(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Byte.decode(\"42\"), defaultTransformer.transform(\"42\", Byte.class));\n        assertEquals(Byte.decode(\"42\"), defaultTransformer.transform(\"42\", byte.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_short(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Short.decode(\"42\"), defaultTransformer.transform(\"42\", Short.class));\n        assertEquals(Short.decode(\"42\"), defaultTransformer.transform(\"42\", short.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Integer.decode(\"42\"), defaultTransformer.transform(\"42\", Integer.class));\n        assertEquals(Integer.decode(\"42\"), defaultTransformer.transform(\"42\", int.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_optional_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {\n        }.getType();\n\n        assertEquals(Optional.of(Integer.decode(\"42\")), defaultTransformer.transform(\"42\", optionalIntType));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_long(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Long.decode(\"42\"), defaultTransformer.transform(\"42\", Long.class));\n        assertEquals(Long.decode(\"42\"), defaultTransformer.transform(\"42\", long.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_float(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(4.2f, defaultTransformer.transform(\"4.2\", Float.class));\n        assertEquals(4.2f, defaultTransformer.transform(\"4.2\", float.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_double(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(4.2, defaultTransformer.transform(\"4.2\", Double.class));\n        assertEquals(4.2, defaultTransformer.transform(\"4.2\", double.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_enum(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(TestEnum.TEST, defaultTransformer.transform(\"TEST\", TestEnum.class));\n    }\n\n    private static class TestJacksonDefaultTransformer implements ParameterByTypeTransformer {\n        ObjectMapper delegate = initMapper();\n\n        private static ObjectMapper initMapper() {\n            ObjectMapper objectMapper = new ObjectMapper();\n            objectMapper.registerModule(new Jdk8Module());\n            return objectMapper;\n        }\n\n        @Override\n        public Object transform(String fromValue, Type toValueType) {\n            TypeFactory typeFactory = delegate.getTypeFactory();\n            return delegate.convertValue(fromValue, typeFactory.constructType(toValueType));\n        }\n\n    }\n\n    private enum TestEnum {\n        TEST\n    }\n\n}\n", "file_hash": "d03b89a3c27bea1bc35ee9b6be8e48f806a06d3d67831f09654ced4b5c19e6e9", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import com.fasterxml.jackson.databind.ObjectMapper;", "import com.fasterxml.jackson.databind.type.TypeFactory;", "import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;", "import org.junit.jupiter.params.ParameterizedTest;", "import org.junit.jupiter.params.provider.MethodSource;", "import java.lang.reflect.Type;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import java.util.Optional;", "import java.util.stream.Stream;", "import static java.util.Locale.ENGLISH;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.junit.jupiter.api.Assertions.assertNull;"], "methods": [], "classes": [{"original_string": "public class ParameterByTypeTransformerTest {\n\n    static Stream<ParameterByTypeTransformer> objectMapperImplementations() {\n        return Stream.of(\n                new BuiltInParameterTransformer(ENGLISH),\n                new TestJacksonDefaultTransformer()\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_null(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertNull(defaultTransformer.transform(null, Object.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_optional(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Optional.empty(), defaultTransformer.transform(null, Optional.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_optional_generic(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {\n        }.getType();\n\n        assertEquals(Optional.empty(), defaultTransformer.transform(null, optionalIntType));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_string(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(\"Barbara Liskov\",\n                defaultTransformer.transform(\"Barbara Liskov\", String.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_optional_string(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalStringType = new TypeReference<Optional<String>>() {\n        }.getType();\n\n        assertEquals(Optional.of(\"Barbara Liskov\"), defaultTransformer.transform(\"Barbara Liskov\", optionalStringType));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_object(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(\"Barbara Liskov\",\n                defaultTransformer.transform(\"Barbara Liskov\", Object.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_big_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(new BigInteger(\"10000008\"),\n                defaultTransformer.transform(\"10000008\", BigInteger.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_big_decimal(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(new BigDecimal(\"1.0000008\"),\n                defaultTransformer.transform(\"1.0000008\", BigDecimal.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_byte(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Byte.decode(\"42\"), defaultTransformer.transform(\"42\", Byte.class));\n        assertEquals(Byte.decode(\"42\"), defaultTransformer.transform(\"42\", byte.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_short(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Short.decode(\"42\"), defaultTransformer.transform(\"42\", Short.class));\n        assertEquals(Short.decode(\"42\"), defaultTransformer.transform(\"42\", short.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Integer.decode(\"42\"), defaultTransformer.transform(\"42\", Integer.class));\n        assertEquals(Integer.decode(\"42\"), defaultTransformer.transform(\"42\", int.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_optional_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {\n        }.getType();\n\n        assertEquals(Optional.of(Integer.decode(\"42\")), defaultTransformer.transform(\"42\", optionalIntType));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_long(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Long.decode(\"42\"), defaultTransformer.transform(\"42\", Long.class));\n        assertEquals(Long.decode(\"42\"), defaultTransformer.transform(\"42\", long.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_float(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(4.2f, defaultTransformer.transform(\"4.2\", Float.class));\n        assertEquals(4.2f, defaultTransformer.transform(\"4.2\", float.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_double(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(4.2, defaultTransformer.transform(\"4.2\", Double.class));\n        assertEquals(4.2, defaultTransformer.transform(\"4.2\", double.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_enum(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(TestEnum.TEST, defaultTransformer.transform(\"TEST\", TestEnum.class));\n    }\n\n    private static class TestJacksonDefaultTransformer implements ParameterByTypeTransformer {\n        ObjectMapper delegate = initMapper();\n\n        private static ObjectMapper initMapper() {\n            ObjectMapper objectMapper = new ObjectMapper();\n            objectMapper.registerModule(new Jdk8Module());\n            return objectMapper;\n        }\n\n        @Override\n        public Object transform(String fromValue, Type toValueType) {\n            TypeFactory typeFactory = delegate.getTypeFactory();\n            return delegate.convertValue(fromValue, typeFactory.constructType(toValueType));\n        }\n\n    }\n\n    private enum TestEnum {\n        TEST\n    }\n\n}", "definition": "public class ParameterByTypeTransformerTest", "class_docstring": "", "name": "ParameterByTypeTransformerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": [{"original_string": "    private static class TestJacksonDefaultTransformer implements ParameterByTypeTransformer {\n        ObjectMapper delegate = initMapper();\n\n        private static ObjectMapper initMapper() {\n            ObjectMapper objectMapper = new ObjectMapper();\n            objectMapper.registerModule(new Jdk8Module());\n            return objectMapper;\n        }\n\n        @Override\n        public Object transform(String fromValue, Type toValueType) {\n            TypeFactory typeFactory = delegate.getTypeFactory();\n            return delegate.convertValue(fromValue, typeFactory.constructType(toValueType));\n        }\n\n    }", "definition": "    private static class TestJacksonDefaultTransformer implements ParameterByTypeTransformer", "class_docstring": "", "name": "TestJacksonDefaultTransformer", "super_interfaces": ["ParameterByTypeTransformer"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "ObjectMapper delegate = initMapper();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ObjectMapper", "name": "delegate = initMapper()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private static ObjectMapper initMapper() {\n            ObjectMapper objectMapper = new ObjectMapper();\n            objectMapper.registerModule(new Jdk8Module());\n            return objectMapper;\n        }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ObjectMapper", "classes": []}, "name": "initMapper", "params": [], "body": "                                                 {\n            ObjectMapper objectMapper = new ObjectMapper();\n            objectMapper.registerModule(new Jdk8Module());\n            return objectMapper;\n        }", "signature": "private static ObjectMapper initMapper()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object transform(String fromValue, Type toValueType) {\n            TypeFactory typeFactory = delegate.getTypeFactory();\n            return delegate.convertValue(fromValue, typeFactory.constructType(toValueType));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "transform", "params": [{"name": "fromValue", "type": "String"}, {"name": "toValueType", "type": "Type"}], "body": "                                                                    {\n            TypeFactory typeFactory = delegate.getTypeFactory();\n            return delegate.convertValue(fromValue, typeFactory.constructType(toValueType));\n        }", "signature": "@Override\n        public Object transform(String fromValue, Type toValueType)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    static Stream<ParameterByTypeTransformer> objectMapperImplementations() {\n        return Stream.of(\n                new BuiltInParameterTransformer(ENGLISH),\n                new TestJacksonDefaultTransformer()\n        );\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Stream<ParameterByTypeTransformer>", "classes": []}, "name": "objectMapperImplementations", "params": [], "body": "                                                                            {\n        return Stream.of(\n                new BuiltInParameterTransformer(ENGLISH),\n                new TestJacksonDefaultTransformer()\n        );\n    }", "signature": "static Stream<ParameterByTypeTransformer> objectMapperImplementations()"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_null(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertNull(defaultTransformer.transform(null, Object.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_null_to_null", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                                  {\n        assertNull(defaultTransformer.transform(null, Object.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_null(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_optional(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Optional.empty(), defaultTransformer.transform(null, Optional.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_null_to_optional", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                                      {\n        assertEquals(Optional.empty(), defaultTransformer.transform(null, Optional.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_optional(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_optional_generic(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {\n        }.getType();\n\n        assertEquals(Optional.empty(), defaultTransformer.transform(null, optionalIntType));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_null_to_optional_generic", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                                              {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {\n        }.getType();\n\n        assertEquals(Optional.empty(), defaultTransformer.transform(null, optionalIntType));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_optional_generic(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_string(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(\"Barbara Liskov\",\n                defaultTransformer.transform(\"Barbara Liskov\", String.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_string", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                               {\n        assertEquals(\"Barbara Liskov\",\n                defaultTransformer.transform(\"Barbara Liskov\", String.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_string(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_optional_string(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalStringType = new TypeReference<Optional<String>>() {\n        }.getType();\n\n        assertEquals(Optional.of(\"Barbara Liskov\"), defaultTransformer.transform(\"Barbara Liskov\", optionalStringType));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_optional_string", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                                        {\n        Type optionalStringType = new TypeReference<Optional<String>>() {\n        }.getType();\n\n        assertEquals(Optional.of(\"Barbara Liskov\"), defaultTransformer.transform(\"Barbara Liskov\", optionalStringType));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_optional_string(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_object(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(\"Barbara Liskov\",\n                defaultTransformer.transform(\"Barbara Liskov\", Object.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_object", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                               {\n        assertEquals(\"Barbara Liskov\",\n                defaultTransformer.transform(\"Barbara Liskov\", Object.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_object(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_big_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(new BigInteger(\"10000008\"),\n                defaultTransformer.transform(\"10000008\", BigInteger.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_big_integer", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                                    {\n        assertEquals(new BigInteger(\"10000008\"),\n                defaultTransformer.transform(\"10000008\", BigInteger.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_big_integer(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_big_decimal(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(new BigDecimal(\"1.0000008\"),\n                defaultTransformer.transform(\"1.0000008\", BigDecimal.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_big_decimal", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                                    {\n        assertEquals(new BigDecimal(\"1.0000008\"),\n                defaultTransformer.transform(\"1.0000008\", BigDecimal.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_big_decimal(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_byte(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Byte.decode(\"42\"), defaultTransformer.transform(\"42\", Byte.class));\n        assertEquals(Byte.decode(\"42\"), defaultTransformer.transform(\"42\", byte.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_byte", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                             {\n        assertEquals(Byte.decode(\"42\"), defaultTransformer.transform(\"42\", Byte.class));\n        assertEquals(Byte.decode(\"42\"), defaultTransformer.transform(\"42\", byte.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_byte(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_short(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Short.decode(\"42\"), defaultTransformer.transform(\"42\", Short.class));\n        assertEquals(Short.decode(\"42\"), defaultTransformer.transform(\"42\", short.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_short", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                              {\n        assertEquals(Short.decode(\"42\"), defaultTransformer.transform(\"42\", Short.class));\n        assertEquals(Short.decode(\"42\"), defaultTransformer.transform(\"42\", short.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_short(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Integer.decode(\"42\"), defaultTransformer.transform(\"42\", Integer.class));\n        assertEquals(Integer.decode(\"42\"), defaultTransformer.transform(\"42\", int.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_integer", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                                {\n        assertEquals(Integer.decode(\"42\"), defaultTransformer.transform(\"42\", Integer.class));\n        assertEquals(Integer.decode(\"42\"), defaultTransformer.transform(\"42\", int.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_integer(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_optional_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {\n        }.getType();\n\n        assertEquals(Optional.of(Integer.decode(\"42\")), defaultTransformer.transform(\"42\", optionalIntType));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_optional_integer", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                                         {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {\n        }.getType();\n\n        assertEquals(Optional.of(Integer.decode(\"42\")), defaultTransformer.transform(\"42\", optionalIntType));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_optional_integer(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_long(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Long.decode(\"42\"), defaultTransformer.transform(\"42\", Long.class));\n        assertEquals(Long.decode(\"42\"), defaultTransformer.transform(\"42\", long.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_long", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                             {\n        assertEquals(Long.decode(\"42\"), defaultTransformer.transform(\"42\", Long.class));\n        assertEquals(Long.decode(\"42\"), defaultTransformer.transform(\"42\", long.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_long(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_float(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(4.2f, defaultTransformer.transform(\"4.2\", Float.class));\n        assertEquals(4.2f, defaultTransformer.transform(\"4.2\", float.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_float", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                              {\n        assertEquals(4.2f, defaultTransformer.transform(\"4.2\", Float.class));\n        assertEquals(4.2f, defaultTransformer.transform(\"4.2\", float.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_float(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_double(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(4.2, defaultTransformer.transform(\"4.2\", Double.class));\n        assertEquals(4.2, defaultTransformer.transform(\"4.2\", double.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_double", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                               {\n        assertEquals(4.2, defaultTransformer.transform(\"4.2\", Double.class));\n        assertEquals(4.2, defaultTransformer.transform(\"4.2\", double.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_double(final ParameterByTypeTransformer defaultTransformer)"}, {"syntax_pass": true, "original_string": "    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_enum(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(TestEnum.TEST, defaultTransformer.transform(\"TEST\", TestEnum.class));\n    }", "docstring": "", "attributes": {"modifiers": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"objectMapperImplementations\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "should_convert_to_enum", "params": [{"name": "defaultTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                             {\n        assertEquals(TestEnum.TEST, defaultTransformer.transform(\"TEST\", TestEnum.class));\n    }", "signature": "@ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_enum(final ParameterByTypeTransformer defaultTransformer)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nfinal class ParameterTypeMatcher implements Comparable<ParameterTypeMatcher> {\n    private final ParameterType<?> parameterType;\n    private final Matcher matcher;\n    private final String text;\n\n    ParameterTypeMatcher(ParameterType<?> parameterType, Matcher matcher, String text) {\n        this.parameterType = parameterType;\n        this.matcher = matcher;\n        this.text = text;\n    }\n\n    private static boolean isWhitespaceOrPunctuationOrSymbol(char c) {\n        return Pattern.matches(\"[\\\\p{Z}\\\\p{P}\\\\p{S}]\", new String(new char[] { c }));\n    }\n\n    boolean advanceToAndFind(int newMatchPos) {\n        // Unlike js, ruby and go, the matcher is stateful\n        // so we can't use the immutable semantics.\n        matcher.region(newMatchPos, text.length());\n        while (matcher.find()) {\n            if (group().isEmpty()) {\n                continue;\n            }\n            if (groupHasWordBoundaryOnBothSides()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean groupHasWordBoundaryOnBothSides() {\n        return groupHasLeftWordBoundary() && groupHasRightWordBoundary();\n    }\n\n    private boolean groupHasLeftWordBoundary() {\n        if (matcher.start() > 0) {\n            char before = text.charAt(matcher.start() - 1);\n            return isWhitespaceOrPunctuationOrSymbol(before);\n        }\n        return true;\n    }\n\n    private boolean groupHasRightWordBoundary() {\n        if (matcher.end() < text.length()) {\n            char after = text.charAt(matcher.end());\n            return isWhitespaceOrPunctuationOrSymbol(after);\n        }\n        return true;\n    }\n\n    int start() {\n        return matcher.start();\n    }\n\n    String group() {\n        return matcher.group();\n    }\n\n    @Override\n    public int compareTo(ParameterTypeMatcher o) {\n        int posComparison = Integer.compare(start(), o.start());\n        if (posComparison != 0) return posComparison;\n        int lengthComparison = Integer.compare(o.group().length(), group().length());\n        if (lengthComparison != 0) return lengthComparison;\n        int weightComparison = Integer.compare(o.parameterType.weight(), parameterType.weight());\n        if (weightComparison != 0) return weightComparison;\n        return 0;\n    }\n\n    ParameterType<?> getParameterType() {\n        return parameterType;\n    }\n\n    public String toString() {\n        return parameterType.getType().toString();\n    }\n}\n", "file_hash": "2c2d442a7f8db45a7ce63dea259239c89a32e856593a774de1c47c369aecc457", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import java.util.regex.Matcher;", "import java.util.regex.Pattern;"], "methods": [], "classes": [{"original_string": "final class ParameterTypeMatcher implements Comparable<ParameterTypeMatcher> {\n    private final ParameterType<?> parameterType;\n    private final Matcher matcher;\n    private final String text;\n\n    ParameterTypeMatcher(ParameterType<?> parameterType, Matcher matcher, String text) {\n        this.parameterType = parameterType;\n        this.matcher = matcher;\n        this.text = text;\n    }\n\n    private static boolean isWhitespaceOrPunctuationOrSymbol(char c) {\n        return Pattern.matches(\"[\\\\p{Z}\\\\p{P}\\\\p{S}]\", new String(new char[] { c }));\n    }\n\n    boolean advanceToAndFind(int newMatchPos) {\n        // Unlike js, ruby and go, the matcher is stateful\n        // so we can't use the immutable semantics.\n        matcher.region(newMatchPos, text.length());\n        while (matcher.find()) {\n            if (group().isEmpty()) {\n                continue;\n            }\n            if (groupHasWordBoundaryOnBothSides()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean groupHasWordBoundaryOnBothSides() {\n        return groupHasLeftWordBoundary() && groupHasRightWordBoundary();\n    }\n\n    private boolean groupHasLeftWordBoundary() {\n        if (matcher.start() > 0) {\n            char before = text.charAt(matcher.start() - 1);\n            return isWhitespaceOrPunctuationOrSymbol(before);\n        }\n        return true;\n    }\n\n    private boolean groupHasRightWordBoundary() {\n        if (matcher.end() < text.length()) {\n            char after = text.charAt(matcher.end());\n            return isWhitespaceOrPunctuationOrSymbol(after);\n        }\n        return true;\n    }\n\n    int start() {\n        return matcher.start();\n    }\n\n    String group() {\n        return matcher.group();\n    }\n\n    @Override\n    public int compareTo(ParameterTypeMatcher o) {\n        int posComparison = Integer.compare(start(), o.start());\n        if (posComparison != 0) return posComparison;\n        int lengthComparison = Integer.compare(o.group().length(), group().length());\n        if (lengthComparison != 0) return lengthComparison;\n        int weightComparison = Integer.compare(o.parameterType.weight(), parameterType.weight());\n        if (weightComparison != 0) return weightComparison;\n        return 0;\n    }\n\n    ParameterType<?> getParameterType() {\n        return parameterType;\n    }\n\n    public String toString() {\n        return parameterType.getType().toString();\n    }\n}", "definition": "final class ParameterTypeMatcher implements Comparable<ParameterTypeMatcher>", "class_docstring": "", "name": "ParameterTypeMatcher", "super_interfaces": ["Comparable<ParameterTypeMatcher>"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private final ParameterType<?> parameterType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterType<?>", "name": "parameterType", "syntax_pass": true}, {"attribute_expression": "private final Matcher matcher;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Matcher", "name": "matcher", "syntax_pass": true}, {"attribute_expression": "private final String text;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "text", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    ParameterTypeMatcher(ParameterType<?> parameterType, Matcher matcher, String text) {\n        this.parameterType = parameterType;\n        this.matcher = matcher;\n        this.text = text;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ParameterTypeMatcher", "params": [{"name": "parameterType", "type": "ParameterType<?>"}, {"name": "matcher", "type": "Matcher"}, {"name": "text", "type": "String"}], "body": "                                                                                       {\n        this.parameterType = parameterType;\n        this.matcher = matcher;\n        this.text = text;\n    }", "signature": "ParameterTypeMatcher(ParameterType<?> parameterType, Matcher matcher, String text)"}, {"syntax_pass": true, "original_string": "    private static boolean isWhitespaceOrPunctuationOrSymbol(char c) {\n        return Pattern.matches(\"[\\\\p{Z}\\\\p{P}\\\\p{S}]\", new String(new char[] { c }));\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isWhitespaceOrPunctuationOrSymbol", "params": [{"name": "c", "type": "char"}], "body": "                                                                     {\n        return Pattern.matches(\"[\\\\p{Z}\\\\p{P}\\\\p{S}]\", new String(new char[] { c }));\n    }", "signature": "private static boolean isWhitespaceOrPunctuationOrSymbol(char c)"}, {"syntax_pass": true, "original_string": "    boolean advanceToAndFind(int newMatchPos) {\n        // Unlike js, ruby and go, the matcher is stateful\n        // so we can't use the immutable semantics.\n        matcher.region(newMatchPos, text.length());\n        while (matcher.find()) {\n            if (group().isEmpty()) {\n                continue;\n            }\n            if (groupHasWordBoundaryOnBothSides()) {\n                return true;\n            }\n        }\n        return false;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "advanceToAndFind", "params": [{"name": "newMatchPos", "type": "int"}], "body": "                                              {\n        // Unlike js, ruby and go, the matcher is stateful\n        // so we can't use the immutable semantics.\n        matcher.region(newMatchPos, text.length());\n        while (matcher.find()) {\n            if (group().isEmpty()) {\n                continue;\n            }\n            if (groupHasWordBoundaryOnBothSides()) {\n                return true;\n            }\n        }\n        return false;\n    }", "signature": "boolean advanceToAndFind(int newMatchPos)"}, {"syntax_pass": true, "original_string": "    private boolean groupHasWordBoundaryOnBothSides() {\n        return groupHasLeftWordBoundary() && groupHasRightWordBoundary();\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "groupHasWordBoundaryOnBothSides", "params": [], "body": "                                                      {\n        return groupHasLeftWordBoundary() && groupHasRightWordBoundary();\n    }", "signature": "private boolean groupHasWordBoundaryOnBothSides()"}, {"syntax_pass": true, "original_string": "    private boolean groupHasLeftWordBoundary() {\n        if (matcher.start() > 0) {\n            char before = text.charAt(matcher.start() - 1);\n            return isWhitespaceOrPunctuationOrSymbol(before);\n        }\n        return true;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "groupHasLeftWordBoundary", "params": [], "body": "                                               {\n        if (matcher.start() > 0) {\n            char before = text.charAt(matcher.start() - 1);\n            return isWhitespaceOrPunctuationOrSymbol(before);\n        }\n        return true;\n    }", "signature": "private boolean groupHasLeftWordBoundary()"}, {"syntax_pass": true, "original_string": "    private boolean groupHasRightWordBoundary() {\n        if (matcher.end() < text.length()) {\n            char after = text.charAt(matcher.end());\n            return isWhitespaceOrPunctuationOrSymbol(after);\n        }\n        return true;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "groupHasRightWordBoundary", "params": [], "body": "                                                {\n        if (matcher.end() < text.length()) {\n            char after = text.charAt(matcher.end());\n            return isWhitespaceOrPunctuationOrSymbol(after);\n        }\n        return true;\n    }", "signature": "private boolean groupHasRightWordBoundary()"}, {"syntax_pass": true, "original_string": "    int start() {\n        return matcher.start();\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "name": "start", "params": [], "body": "                {\n        return matcher.start();\n    }", "signature": "int start()"}, {"syntax_pass": true, "original_string": "    String group() {\n        return matcher.group();\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "group", "params": [], "body": "                   {\n        return matcher.group();\n    }", "signature": "String group()"}, {"syntax_pass": true, "original_string": "    @Override\n    public int compareTo(ParameterTypeMatcher o) {\n        int posComparison = Integer.compare(start(), o.start());\n        if (posComparison != 0) return posComparison;\n        int lengthComparison = Integer.compare(o.group().length(), group().length());\n        if (lengthComparison != 0) return lengthComparison;\n        int weightComparison = Integer.compare(o.parameterType.weight(), parameterType.weight());\n        if (weightComparison != 0) return weightComparison;\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compareTo", "params": [{"name": "o", "type": "ParameterTypeMatcher"}], "body": "                                                 {\n        int posComparison = Integer.compare(start(), o.start());\n        if (posComparison != 0) return posComparison;\n        int lengthComparison = Integer.compare(o.group().length(), group().length());\n        if (lengthComparison != 0) return lengthComparison;\n        int weightComparison = Integer.compare(o.parameterType.weight(), parameterType.weight());\n        if (weightComparison != 0) return weightComparison;\n        return 0;\n    }", "signature": "@Override\n    public int compareTo(ParameterTypeMatcher o)"}, {"syntax_pass": true, "original_string": "    ParameterType<?> getParameterType() {\n        return parameterType;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ParameterType<?>", "classes": []}, "name": "getParameterType", "params": [], "body": "                                        {\n        return parameterType;\n    }", "signature": "ParameterType<?> getParameterType()"}, {"syntax_pass": true, "original_string": "    public String toString() {\n        return parameterType.getType().toString();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        return parameterType.getType().toString();\n    }", "signature": "public String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport io.cucumber.cucumberexpressions.Ast.Node;\nimport org.apiguardian.api.API;\n\n@API(status = API.Status.STABLE)\npublic final class UndefinedParameterTypeException extends CucumberExpressionException {\n    private final String undefinedParameterTypeName;\n\n    UndefinedParameterTypeException(String message, String undefinedParameterTypeName) {\n        super(message);\n        this.undefinedParameterTypeName = undefinedParameterTypeName;\n    }\n\n    public String getUndefinedParameterTypeName() {\n        return undefinedParameterTypeName;\n    }\n\n    static CucumberExpressionException createUndefinedParameterType(Node node, String expression, String undefinedParameterTypeName) {\n        return new UndefinedParameterTypeException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Undefined parameter type '\" +undefinedParameterTypeName+ \"'\",\n                \"Please register a ParameterType for '\"+undefinedParameterTypeName+\"'\"), undefinedParameterTypeName);\n    }\n}\n", "file_hash": "2c7b2d581833ea574b404e0de836bcbb993cd3c88fd9c6c7c77fe93c9ffb1e54", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import io.cucumber.cucumberexpressions.Ast.Node;", "import org.apiguardian.api.API;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic final class UndefinedParameterTypeException extends CucumberExpressionException {\n    private final String undefinedParameterTypeName;\n\n    UndefinedParameterTypeException(String message, String undefinedParameterTypeName) {\n        super(message);\n        this.undefinedParameterTypeName = undefinedParameterTypeName;\n    }\n\n    public String getUndefinedParameterTypeName() {\n        return undefinedParameterTypeName;\n    }\n\n    static CucumberExpressionException createUndefinedParameterType(Node node, String expression, String undefinedParameterTypeName) {\n        return new UndefinedParameterTypeException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Undefined parameter type '\" +undefinedParameterTypeName+ \"'\",\n                \"Please register a ParameterType for '\"+undefinedParameterTypeName+\"'\"), undefinedParameterTypeName);\n    }\n}", "definition": "@API(status = API.Status.STABLE)\npublic final class UndefinedParameterTypeException extends CucumberExpressionException", "class_docstring": "", "name": "UndefinedParameterTypeException", "super_interfaces": [], "superclasses": "CucumberExpressionException", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic final", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public", "final"], "comments": [], "fields": [{"attribute_expression": "private final String undefinedParameterTypeName;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "undefinedParameterTypeName", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    UndefinedParameterTypeException(String message, String undefinedParameterTypeName) {\n        super(message);\n        this.undefinedParameterTypeName = undefinedParameterTypeName;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "UndefinedParameterTypeException", "params": [{"name": "message", "type": "String"}, {"name": "undefinedParameterTypeName", "type": "String"}], "body": "                                                                                       {\n        super(message);\n        this.undefinedParameterTypeName = undefinedParameterTypeName;\n    }", "signature": "UndefinedParameterTypeException(String message, String undefinedParameterTypeName)"}, {"syntax_pass": true, "original_string": "    public String getUndefinedParameterTypeName() {\n        return undefinedParameterTypeName;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getUndefinedParameterTypeName", "params": [], "body": "                                                  {\n        return undefinedParameterTypeName;\n    }", "signature": "public String getUndefinedParameterTypeName()"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createUndefinedParameterType(Node node, String expression, String undefinedParameterTypeName) {\n        return new UndefinedParameterTypeException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Undefined parameter type '\" +undefinedParameterTypeName+ \"'\",\n                \"Please register a ParameterType for '\"+undefinedParameterTypeName+\"'\"), undefinedParameterTypeName);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createUndefinedParameterType", "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}, {"name": "undefinedParameterTypeName", "type": "String"}], "body": "                                                                                                                                     {\n        return new UndefinedParameterTypeException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Undefined parameter type '\" +undefinedParameterTypeName+ \"'\",\n                \"Please register a ParameterType for '\"+undefinedParameterTypeName+\"'\"), undefinedParameterTypeName);\n    }", "signature": "static CucumberExpressionException createUndefinedParameterType(Node node, String expression, String undefinedParameterTypeName)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static java.util.Collections.singletonList;\n\n@API(status = API.Status.STABLE)\npublic final class ParameterType<T> implements Comparable<ParameterType<?>> {\n    @SuppressWarnings(\"RegExpRedundantEscape\") // Android can't parse unescaped braces\n    private static final Pattern ILLEGAL_PARAMETER_NAME_PATTERN = Pattern.compile(\"([{}()\\\\\\\\/])\");\n    private static final Pattern UNESCAPE_PATTERN = Pattern.compile(\"(\\\\\\\\([\\\\[$.|?*+\\\\]]))\");\n\n    private final String name;\n    private final Type type;\n    private final List<String> regexps;\n    private final boolean preferForRegexpMatch;\n    private final boolean useForSnippets;\n    private final CaptureGroupTransformer<T> transformer;\n    private final boolean anonymous;\n    private final boolean useRegexpMatchAsStrongTypeHint;\n\n    static void checkParameterTypeName(String name) {\n        if (!isValidParameterTypeName(name)) {\n            throw CucumberExpressionException.createInvalidParameterTypeName(name);\n        }\n    }\n\n    static boolean isValidParameterTypeName(String name) {\n        String unescapedTypeName = UNESCAPE_PATTERN.matcher(name).replaceAll(\"$2\");\n        Matcher matcher = ILLEGAL_PARAMETER_NAME_PATTERN.matcher(unescapedTypeName);\n        return !matcher.find();\n    }\n\n    static ParameterType<Object> createAnonymousParameterType(String regexp) {\n        return new ParameterType<>(\"\", singletonList(regexp), Object.class, new CaptureGroupTransformer<Object>() {\n\n            public Object transform(String[] arg) {\n                throw new UnsupportedOperationException(\"Anonymous transform must be deanonymized before use\");\n            }\n        }, false, true, false, true);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <E extends Enum> ParameterType<E> fromEnum(final Class<E> enumClass) {\n        Enum[] enumConstants = enumClass.getEnumConstants();\n        StringBuilder regexpBuilder = new StringBuilder();\n        for (int i = 0; i < enumConstants.length; i++) {\n            if (i > 0)\n                regexpBuilder.append(\"|\");\n            regexpBuilder.append(enumConstants[i].name());\n        }\n        return new ParameterType<>(\n                enumClass.getSimpleName(),\n                regexpBuilder.toString(),\n                enumClass,\n                (String arg) -> (E) Enum.valueOf(enumClass, arg)\n        );\n    }\n\n    private ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint,\n            boolean anonymous) {\n        if (regexps == null)\n            throw new NullPointerException(\"regexps cannot be null\");\n        if (type == null)\n            throw new NullPointerException(\"type cannot be null\");\n        if (transformer == null)\n            throw new NullPointerException(\"transformer cannot be null\");\n        if (name != null)\n            checkParameterTypeName(name);\n        this.name = name;\n        this.regexps = regexps;\n        this.type = type;\n        this.transformer = transformer;\n        this.useForSnippets = useForSnippets;\n        this.preferForRegexpMatch = preferForRegexpMatch;\n        this.anonymous = anonymous;\n        this.useRegexpMatchAsStrongTypeHint = useRegexpMatchAsStrongTypeHint;\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, useRegexpMatchAsStrongTypeHint,\n                false);\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        // Unless explicitly set useRegexpMatchAsStrongTypeHint is true.\n        //\n        // Reasoning:\n        // 1. Pure cucumber expression users will not notice this in either scenario.\n        // 2. Pure regular expression users will benefit because BuiltInParameterTransformer can now seamlessly\n        //    transform any captured values. (For all built in types useRegexpMatchAsStrongTypeHint is explicitly set to\n        //    false.)\n        // 2. Regular expression users that define a default transformer have little need to define parameter types. The\n        //    default transformer should be sufficiently powerful to meet their needs and will often allow users to add\n        //    custom creation methods e.g. Jacksons @JsonFactory.\n        // 3. Users who mix regular and cucumber expressions may run into conflicts when a registered cucumber expression\n        //    and unregistered happens to collide. However this was the situation before this flag was added.\n        // 4. Regular expression users who define custom parameter types do so with the expectation that the parameter\n        //    will be matched. Subverting this expectation when the method signature does not match may result in a\n        //    parameter transformer that is unable to convert to the desired type. Leaving the user puzzled as to why\n        //    his transform was ignored.\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, true);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer) {\n        this(name, regexps, type, transformer, true, false);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer) {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer) {\n        this(name, regexps, type, transformer, true, false);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer) {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }\n\n    /**\n     * This is used in the type name in typed expressions\n     *\n     * @return human readable type name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the type of the parameter type - typically the type\n     * the transform transforms to. This can be used in conjunction with\n     * GeneratedExpression (snippets) to generate snippets for statically typed\n     * languages. Not used for anything else.\n     *\n     * @return the type of the parameter type\n     */\n    public Type getType() {\n        return type;\n    }\n\n    public List<String> getRegexps() {\n        return regexps;\n    }\n\n    /**\n     * Indicates whether or not this is a preferential parameter type when matching text\n     * against a {@link RegularExpression}. In case there are multiple parameter types\n     * with a regexp identical to the capture group's regexp, a preferential parameter type will\n     * win. If there are more than 1 preferential ones, an error will be thrown.\n     *\n     * @return true if this is a preferential type\n     */\n    public boolean preferForRegexpMatch() {\n        return preferForRegexpMatch;\n    }\n\n    /**\n     * Indicates whether or not this is a parameter type should be used for generating\n     * {@link GeneratedExpression}s from text. Typically, parameter types with greedy regexps\n     * should return false.\n     *\n     * @return true is this parameter type is used for expression generation\n     */\n    public boolean useForSnippets() {\n        return useForSnippets;\n    }\n\n    boolean isAnonymous() {\n        return anonymous;\n    }\n\n    /**\n     * Indicates whether or not this parameter provides a strong type hint when considering a\n     * regular expression match. If so, the type hint provided by the method arguments  will be\n     * ignored. If not, when both type hints are in agreement, this parameter types transformer\n     * will be used. Otherwise parameter transformation for a regular expression match will be\n     * handled by {@link ParameterTypeRegistry#getDefaultParameterTransformer()}.\n     *\n     * @return true if this parameter type provides a type hint when considering a regular\n     * expression match\n     */\n    public boolean useRegexpMatchAsStrongTypeHint() {\n        return useRegexpMatchAsStrongTypeHint;\n    }\n\n    ParameterType<Object> deAnonymize(Type type, Transformer<Object> transformer) {\n        return new ParameterType<>(\"anonymous\", regexps, type, new TransformerAdaptor<>(transformer), useForSnippets,\n                preferForRegexpMatch, useRegexpMatchAsStrongTypeHint, anonymous);\n    }\n\n    T transform(List<String> groupValues) {\n        if (transformer instanceof TransformerAdaptor) {\n            if (groupValues.size() > 1) {\n                if (isAnonymous()) {\n                    throw new CucumberExpressionException(String.format(\"\" +\n                            \"Anonymous ParameterType has multiple capture groups %s. \" +\n                            \"You can only use a single capture group in an anonymous ParameterType.\", regexps));\n                }\n                throw new CucumberExpressionException(String.format(\"\" +\n                        \"ParameterType {%s} was registered with a Transformer but has multiple capture groups %s. \" +\n                        \"Did you mean to use a CaptureGroupTransformer?\", name, regexps));\n            }\n        }\n\n        try {\n            String[] groupValueArray = groupValues.toArray(new String[0]);\n            return transformer.transform(groupValueArray);\n        } catch (CucumberExpressionException e) {\n            throw e;\n        } catch (Throwable throwable) {\n            throw new CucumberExpressionException(\n                    String.format(\"ParameterType {%s} failed to transform %s to %s\", name, groupValues, type),\n                    throwable);\n        }\n    }\n\n    @Override\n    public int compareTo(ParameterType<?> o) {\n        if (preferForRegexpMatch() && !o.preferForRegexpMatch())\n            return -1;\n        if (o.preferForRegexpMatch() && !preferForRegexpMatch())\n            return 1;\n        String name = getName() != null ? getName() : \"\";\n        String otherName = o.getName() != null ? o.getName() : \"\";\n        return name.compareTo(otherName);\n    }\n\n    public int weight() {\n        if (this.type.equals(Integer.class) || this.type.equals(Integer.TYPE)) {\n            return 1000;\n        }\n        return 0;\n    }\n\n    private static final class TransformerAdaptor<T> implements CaptureGroupTransformer<T> {\n\n        private final Transformer<T> transformer;\n\n        private TransformerAdaptor(Transformer<T> transformer) {\n            if (transformer == null)\n                throw new NullPointerException(\"transformer cannot be null\");\n            this.transformer = transformer;\n        }\n\n        @Override\n        public T transform(String[] args) throws Throwable {\n            return transformer.transform(args[0]);\n        }\n\n    }\n\n}\n", "file_hash": "953185f8350fe7083ca4d11237a4017f95a100c93536463c9e83e990031d19b3", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.lang.reflect.Type;", "import java.util.List;", "import java.util.regex.Matcher;", "import java.util.regex.Pattern;", "import static java.util.Collections.singletonList;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic final class ParameterType<T> implements Comparable<ParameterType<?>> {\n    @SuppressWarnings(\"RegExpRedundantEscape\") // Android can't parse unescaped braces\n    private static final Pattern ILLEGAL_PARAMETER_NAME_PATTERN = Pattern.compile(\"([{}()\\\\\\\\/])\");\n    private static final Pattern UNESCAPE_PATTERN = Pattern.compile(\"(\\\\\\\\([\\\\[$.|?*+\\\\]]))\");\n\n    private final String name;\n    private final Type type;\n    private final List<String> regexps;\n    private final boolean preferForRegexpMatch;\n    private final boolean useForSnippets;\n    private final CaptureGroupTransformer<T> transformer;\n    private final boolean anonymous;\n    private final boolean useRegexpMatchAsStrongTypeHint;\n\n    static void checkParameterTypeName(String name) {\n        if (!isValidParameterTypeName(name)) {\n            throw CucumberExpressionException.createInvalidParameterTypeName(name);\n        }\n    }\n\n    static boolean isValidParameterTypeName(String name) {\n        String unescapedTypeName = UNESCAPE_PATTERN.matcher(name).replaceAll(\"$2\");\n        Matcher matcher = ILLEGAL_PARAMETER_NAME_PATTERN.matcher(unescapedTypeName);\n        return !matcher.find();\n    }\n\n    static ParameterType<Object> createAnonymousParameterType(String regexp) {\n        return new ParameterType<>(\"\", singletonList(regexp), Object.class, new CaptureGroupTransformer<Object>() {\n\n            public Object transform(String[] arg) {\n                throw new UnsupportedOperationException(\"Anonymous transform must be deanonymized before use\");\n            }\n        }, false, true, false, true);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <E extends Enum> ParameterType<E> fromEnum(final Class<E> enumClass) {\n        Enum[] enumConstants = enumClass.getEnumConstants();\n        StringBuilder regexpBuilder = new StringBuilder();\n        for (int i = 0; i < enumConstants.length; i++) {\n            if (i > 0)\n                regexpBuilder.append(\"|\");\n            regexpBuilder.append(enumConstants[i].name());\n        }\n        return new ParameterType<>(\n                enumClass.getSimpleName(),\n                regexpBuilder.toString(),\n                enumClass,\n                (String arg) -> (E) Enum.valueOf(enumClass, arg)\n        );\n    }\n\n    private ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint,\n            boolean anonymous) {\n        if (regexps == null)\n            throw new NullPointerException(\"regexps cannot be null\");\n        if (type == null)\n            throw new NullPointerException(\"type cannot be null\");\n        if (transformer == null)\n            throw new NullPointerException(\"transformer cannot be null\");\n        if (name != null)\n            checkParameterTypeName(name);\n        this.name = name;\n        this.regexps = regexps;\n        this.type = type;\n        this.transformer = transformer;\n        this.useForSnippets = useForSnippets;\n        this.preferForRegexpMatch = preferForRegexpMatch;\n        this.anonymous = anonymous;\n        this.useRegexpMatchAsStrongTypeHint = useRegexpMatchAsStrongTypeHint;\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, useRegexpMatchAsStrongTypeHint,\n                false);\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        // Unless explicitly set useRegexpMatchAsStrongTypeHint is true.\n        //\n        // Reasoning:\n        // 1. Pure cucumber expression users will not notice this in either scenario.\n        // 2. Pure regular expression users will benefit because BuiltInParameterTransformer can now seamlessly\n        //    transform any captured values. (For all built in types useRegexpMatchAsStrongTypeHint is explicitly set to\n        //    false.)\n        // 2. Regular expression users that define a default transformer have little need to define parameter types. The\n        //    default transformer should be sufficiently powerful to meet their needs and will often allow users to add\n        //    custom creation methods e.g. Jacksons @JsonFactory.\n        // 3. Users who mix regular and cucumber expressions may run into conflicts when a registered cucumber expression\n        //    and unregistered happens to collide. However this was the situation before this flag was added.\n        // 4. Regular expression users who define custom parameter types do so with the expectation that the parameter\n        //    will be matched. Subverting this expectation when the method signature does not match may result in a\n        //    parameter transformer that is unable to convert to the desired type. Leaving the user puzzled as to why\n        //    his transform was ignored.\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, true);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer) {\n        this(name, regexps, type, transformer, true, false);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer) {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer) {\n        this(name, regexps, type, transformer, true, false);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer) {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }\n\n    /**\n     * This is used in the type name in typed expressions\n     *\n     * @return human readable type name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the type of the parameter type - typically the type\n     * the transform transforms to. This can be used in conjunction with\n     * GeneratedExpression (snippets) to generate snippets for statically typed\n     * languages. Not used for anything else.\n     *\n     * @return the type of the parameter type\n     */\n    public Type getType() {\n        return type;\n    }\n\n    public List<String> getRegexps() {\n        return regexps;\n    }\n\n    /**\n     * Indicates whether or not this is a preferential parameter type when matching text\n     * against a {@link RegularExpression}. In case there are multiple parameter types\n     * with a regexp identical to the capture group's regexp, a preferential parameter type will\n     * win. If there are more than 1 preferential ones, an error will be thrown.\n     *\n     * @return true if this is a preferential type\n     */\n    public boolean preferForRegexpMatch() {\n        return preferForRegexpMatch;\n    }\n\n    /**\n     * Indicates whether or not this is a parameter type should be used for generating\n     * {@link GeneratedExpression}s from text. Typically, parameter types with greedy regexps\n     * should return false.\n     *\n     * @return true is this parameter type is used for expression generation\n     */\n    public boolean useForSnippets() {\n        return useForSnippets;\n    }\n\n    boolean isAnonymous() {\n        return anonymous;\n    }\n\n    /**\n     * Indicates whether or not this parameter provides a strong type hint when considering a\n     * regular expression match. If so, the type hint provided by the method arguments  will be\n     * ignored. If not, when both type hints are in agreement, this parameter types transformer\n     * will be used. Otherwise parameter transformation for a regular expression match will be\n     * handled by {@link ParameterTypeRegistry#getDefaultParameterTransformer()}.\n     *\n     * @return true if this parameter type provides a type hint when considering a regular\n     * expression match\n     */\n    public boolean useRegexpMatchAsStrongTypeHint() {\n        return useRegexpMatchAsStrongTypeHint;\n    }\n\n    ParameterType<Object> deAnonymize(Type type, Transformer<Object> transformer) {\n        return new ParameterType<>(\"anonymous\", regexps, type, new TransformerAdaptor<>(transformer), useForSnippets,\n                preferForRegexpMatch, useRegexpMatchAsStrongTypeHint, anonymous);\n    }\n\n    T transform(List<String> groupValues) {\n        if (transformer instanceof TransformerAdaptor) {\n            if (groupValues.size() > 1) {\n                if (isAnonymous()) {\n                    throw new CucumberExpressionException(String.format(\"\" +\n                            \"Anonymous ParameterType has multiple capture groups %s. \" +\n                            \"You can only use a single capture group in an anonymous ParameterType.\", regexps));\n                }\n                throw new CucumberExpressionException(String.format(\"\" +\n                        \"ParameterType {%s} was registered with a Transformer but has multiple capture groups %s. \" +\n                        \"Did you mean to use a CaptureGroupTransformer?\", name, regexps));\n            }\n        }\n\n        try {\n            String[] groupValueArray = groupValues.toArray(new String[0]);\n            return transformer.transform(groupValueArray);\n        } catch (CucumberExpressionException e) {\n            throw e;\n        } catch (Throwable throwable) {\n            throw new CucumberExpressionException(\n                    String.format(\"ParameterType {%s} failed to transform %s to %s\", name, groupValues, type),\n                    throwable);\n        }\n    }\n\n    @Override\n    public int compareTo(ParameterType<?> o) {\n        if (preferForRegexpMatch() && !o.preferForRegexpMatch())\n            return -1;\n        if (o.preferForRegexpMatch() && !preferForRegexpMatch())\n            return 1;\n        String name = getName() != null ? getName() : \"\";\n        String otherName = o.getName() != null ? o.getName() : \"\";\n        return name.compareTo(otherName);\n    }\n\n    public int weight() {\n        if (this.type.equals(Integer.class) || this.type.equals(Integer.TYPE)) {\n            return 1000;\n        }\n        return 0;\n    }\n\n    private static final class TransformerAdaptor<T> implements CaptureGroupTransformer<T> {\n\n        private final Transformer<T> transformer;\n\n        private TransformerAdaptor(Transformer<T> transformer) {\n            if (transformer == null)\n                throw new NullPointerException(\"transformer cannot be null\");\n            this.transformer = transformer;\n        }\n\n        @Override\n        public T transform(String[] args) throws Throwable {\n            return transformer.transform(args[0]);\n        }\n\n    }\n\n}", "definition": "@API(status = API.Status.STABLE)\npublic final class ParameterType<T> implements Comparable<ParameterType<?>>", "class_docstring": "", "name": "ParameterType", "super_interfaces": ["Comparable<ParameterType<?>>"], "superclasses": "", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic final", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public", "final"], "comments": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"RegExpRedundantEscape\") // Android can't parse unescaped braces\n    private static final Pattern ILLEGAL_PARAMETER_NAME_PATTERN = Pattern.compile(\"([{}()\\\\\\\\/])\");", "docstring": "", "modifiers": "@SuppressWarnings(\"RegExpRedundantEscape\") // Android can't parse unescaped braces\n    private static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"RegExpRedundantEscape\")", "private", "static", "final"], "comments": ["// Android can't parse unescaped braces"], "type": "Pattern", "name": "ILLEGAL_PARAMETER_NAME_PATTERN = Pattern.compile(\"([{}()\\\\\\\\/])\")", "syntax_pass": true}, {"attribute_expression": "private static final Pattern UNESCAPE_PATTERN = Pattern.compile(\"(\\\\\\\\([\\\\[$.|?*+\\\\]]))\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "UNESCAPE_PATTERN = Pattern.compile(\"(\\\\\\\\([\\\\[$.|?*+\\\\]]))\")", "syntax_pass": true}, {"attribute_expression": "private final String name;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "private final Type type;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "private final List<String> regexps;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "regexps", "syntax_pass": true}, {"attribute_expression": "private final boolean preferForRegexpMatch;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "preferForRegexpMatch", "syntax_pass": true}, {"attribute_expression": "private final boolean useForSnippets;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "useForSnippets", "syntax_pass": true}, {"attribute_expression": "private final CaptureGroupTransformer<T> transformer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CaptureGroupTransformer<T>", "name": "transformer", "syntax_pass": true}, {"attribute_expression": "private final boolean anonymous;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "anonymous", "syntax_pass": true}, {"attribute_expression": "private final boolean useRegexpMatchAsStrongTypeHint;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "useRegexpMatchAsStrongTypeHint", "syntax_pass": true}], "classes": [{"original_string": "    private static final class TransformerAdaptor<T> implements CaptureGroupTransformer<T> {\n\n        private final Transformer<T> transformer;\n\n        private TransformerAdaptor(Transformer<T> transformer) {\n            if (transformer == null)\n                throw new NullPointerException(\"transformer cannot be null\");\n            this.transformer = transformer;\n        }\n\n        @Override\n        public T transform(String[] args) throws Throwable {\n            return transformer.transform(args[0]);\n        }\n\n    }", "definition": "    private static final class TransformerAdaptor<T> implements CaptureGroupTransformer<T>", "class_docstring": "", "name": "TransformerAdaptor", "super_interfaces": ["CaptureGroupTransformer<T>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Transformer<T> transformer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<T>", "name": "transformer", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private TransformerAdaptor(Transformer<T> transformer) {\n            if (transformer == null)\n                throw new NullPointerException(\"transformer cannot be null\");\n            this.transformer = transformer;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "TransformerAdaptor", "params": [{"name": "transformer", "type": "Transformer<T>"}], "body": "                                                               {\n            if (transformer == null)\n                throw new NullPointerException(\"transformer cannot be null\");\n            this.transformer = transformer;\n        }", "signature": "private TransformerAdaptor(Transformer<T> transformer)"}, {"syntax_pass": true, "original_string": "        @Override\n        public T transform(String[] args) throws Throwable {\n            return transformer.transform(args[0]);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "transform", "params": [{"name": "args", "type": "String[]"}], "body": "                                                           {\n            return transformer.transform(args[0]);\n        }", "signature": "@Override\n        public T transform(String[] args)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    static void checkParameterTypeName(String name) {\n        if (!isValidParameterTypeName(name)) {\n            throw CucumberExpressionException.createInvalidParameterTypeName(name);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "name": "checkParameterTypeName", "params": [{"name": "name", "type": "String"}], "body": "                                                    {\n        if (!isValidParameterTypeName(name)) {\n            throw CucumberExpressionException.createInvalidParameterTypeName(name);\n        }\n    }", "signature": "static void checkParameterTypeName(String name)"}, {"syntax_pass": true, "original_string": "    static boolean isValidParameterTypeName(String name) {\n        String unescapedTypeName = UNESCAPE_PATTERN.matcher(name).replaceAll(\"$2\");\n        Matcher matcher = ILLEGAL_PARAMETER_NAME_PATTERN.matcher(unescapedTypeName);\n        return !matcher.find();\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isValidParameterTypeName", "params": [{"name": "name", "type": "String"}], "body": "                                                         {\n        String unescapedTypeName = UNESCAPE_PATTERN.matcher(name).replaceAll(\"$2\");\n        Matcher matcher = ILLEGAL_PARAMETER_NAME_PATTERN.matcher(unescapedTypeName);\n        return !matcher.find();\n    }", "signature": "static boolean isValidParameterTypeName(String name)"}, {"syntax_pass": true, "original_string": "    static ParameterType<Object> createAnonymousParameterType(String regexp) {\n        return new ParameterType<>(\"\", singletonList(regexp), Object.class, new CaptureGroupTransformer<Object>() {\n\n            public Object transform(String[] arg) {\n                throw new UnsupportedOperationException(\"Anonymous transform must be deanonymized before use\");\n            }\n        }, false, true, false, true);\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "ParameterType<Object>", "classes": []}, "name": "createAnonymousParameterType", "params": [{"name": "regexp", "type": "String"}], "body": "                                                                             {\n        return new ParameterType<>(\"\", singletonList(regexp), Object.class, new CaptureGroupTransformer<Object>() {\n\n            public Object transform(String[] arg) {\n                throw new UnsupportedOperationException(\"Anonymous transform must be deanonymized before use\");\n            }\n        }, false, true, false, true);\n    }", "signature": "static ParameterType<Object> createAnonymousParameterType(String regexp)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    static <E extends Enum> ParameterType<E> fromEnum(final Class<E> enumClass) {\n        Enum[] enumConstants = enumClass.getEnumConstants();\n        StringBuilder regexpBuilder = new StringBuilder();\n        for (int i = 0; i < enumConstants.length; i++) {\n            if (i > 0)\n                regexpBuilder.append(\"|\");\n            regexpBuilder.append(enumConstants[i].name());\n        }\n        return new ParameterType<>(\n                enumClass.getSimpleName(),\n                regexpBuilder.toString(),\n                enumClass,\n                (String arg) -> (E) Enum.valueOf(enumClass, arg)\n        );\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "static"], "comments": [], "return_type": "ParameterType<E>", "classes": []}, "name": "fromEnum", "params": [{"name": "enumClass", "type": "Class<E>"}], "body": "                                                                                {\n        Enum[] enumConstants = enumClass.getEnumConstants();\n        StringBuilder regexpBuilder = new StringBuilder();\n        for (int i = 0; i < enumConstants.length; i++) {\n            if (i > 0)\n                regexpBuilder.append(\"|\");\n            regexpBuilder.append(enumConstants[i].name());\n        }\n        return new ParameterType<>(\n                enumClass.getSimpleName(),\n                regexpBuilder.toString(),\n                enumClass,\n                (String arg) -> (E) Enum.valueOf(enumClass, arg)\n        );\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    static <E extends Enum> ParameterType<E> fromEnum(final Class<E> enumClass)"}, {"syntax_pass": true, "original_string": "    private ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint,\n            boolean anonymous) {\n        if (regexps == null)\n            throw new NullPointerException(\"regexps cannot be null\");\n        if (type == null)\n            throw new NullPointerException(\"type cannot be null\");\n        if (transformer == null)\n            throw new NullPointerException(\"transformer cannot be null\");\n        if (name != null)\n            checkParameterTypeName(name);\n        this.name = name;\n        this.regexps = regexps;\n        this.type = type;\n        this.transformer = transformer;\n        this.useForSnippets = useForSnippets;\n        this.preferForRegexpMatch = preferForRegexpMatch;\n        this.anonymous = anonymous;\n        this.useRegexpMatchAsStrongTypeHint = useRegexpMatchAsStrongTypeHint;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Type"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}, {"name": "useRegexpMatchAsStrongTypeHint", "type": "boolean"}, {"name": "anonymous", "type": "boolean"}], "body": "                               {\n        if (regexps == null)\n            throw new NullPointerException(\"regexps cannot be null\");\n        if (type == null)\n            throw new NullPointerException(\"type cannot be null\");\n        if (transformer == null)\n            throw new NullPointerException(\"transformer cannot be null\");\n        if (name != null)\n            checkParameterTypeName(name);\n        this.name = name;\n        this.regexps = regexps;\n        this.type = type;\n        this.transformer = transformer;\n        this.useForSnippets = useForSnippets;\n        this.preferForRegexpMatch = preferForRegexpMatch;\n        this.anonymous = anonymous;\n        this.useRegexpMatchAsStrongTypeHint = useRegexpMatchAsStrongTypeHint;\n    }", "signature": "private ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint,\n            boolean anonymous)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, useRegexpMatchAsStrongTypeHint,\n                false);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Type"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}, {"name": "useRegexpMatchAsStrongTypeHint", "type": "boolean"}], "body": "                                                                                                          {\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, useRegexpMatchAsStrongTypeHint,\n                false);\n    }", "signature": "public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        // Unless explicitly set useRegexpMatchAsStrongTypeHint is true.\n        //\n        // Reasoning:\n        // 1. Pure cucumber expression users will not notice this in either scenario.\n        // 2. Pure regular expression users will benefit because BuiltInParameterTransformer can now seamlessly\n        //    transform any captured values. (For all built in types useRegexpMatchAsStrongTypeHint is explicitly set to\n        //    false.)\n        // 2. Regular expression users that define a default transformer have little need to define parameter types. The\n        //    default transformer should be sufficiently powerful to meet their needs and will often allow users to add\n        //    custom creation methods e.g. Jacksons @JsonFactory.\n        // 3. Users who mix regular and cucumber expressions may run into conflicts when a registered cucumber expression\n        //    and unregistered happens to collide. However this was the situation before this flag was added.\n        // 4. Regular expression users who define custom parameter types do so with the expectation that the parameter\n        //    will be matched. Subverting this expectation when the method signature does not match may result in a\n        //    parameter transformer that is unable to convert to the desired type. Leaving the user puzzled as to why\n        //    his transform was ignored.\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, true);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Type"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "body": "                                                                  {\n        // Unless explicitly set useRegexpMatchAsStrongTypeHint is true.\n        //\n        // Reasoning:\n        // 1. Pure cucumber expression users will not notice this in either scenario.\n        // 2. Pure regular expression users will benefit because BuiltInParameterTransformer can now seamlessly\n        //    transform any captured values. (For all built in types useRegexpMatchAsStrongTypeHint is explicitly set to\n        //    false.)\n        // 2. Regular expression users that define a default transformer have little need to define parameter types. The\n        //    default transformer should be sufficiently powerful to meet their needs and will often allow users to add\n        //    custom creation methods e.g. Jacksons @JsonFactory.\n        // 3. Users who mix regular and cucumber expressions may run into conflicts when a registered cucumber expression\n        //    and unregistered happens to collide. However this was the situation before this flag was added.\n        // 4. Regular expression users who define custom parameter types do so with the expectation that the parameter\n        //    will be matched. Subverting this expectation when the method signature does not match may result in a\n        //    parameter transformer that is unable to convert to the desired type. Leaving the user puzzled as to why\n        //    his transform was ignored.\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, true);\n    }", "signature": "public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "body": "                                                                  {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "signature": "public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexp", "type": "String"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "body": "                                                                  {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "signature": "public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer) {\n        this(name, regexps, type, transformer, true, false);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}], "body": "                                                                                                                   {\n        this(name, regexps, type, transformer, true, false);\n    }", "signature": "public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer) {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexp", "type": "String"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "CaptureGroupTransformer<T>"}], "body": "                                                                                                            {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }", "signature": "public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Type"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}, {"name": "useRegexpMatchAsStrongTypeHint", "type": "boolean"}], "body": "                                                                                                          {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }", "signature": "public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Type"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "body": "                                                                  {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch);\n    }", "signature": "public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}, {"name": "useRegexpMatchAsStrongTypeHint", "type": "boolean"}], "body": "                                                                                                          {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }", "signature": "public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "body": "                                                                  {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "signature": "public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexp", "type": "String"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}, {"name": "useRegexpMatchAsStrongTypeHint", "type": "boolean"}], "body": "                                                                                  {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }", "signature": "public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexp", "type": "String"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}, {"name": "useForSnippets", "type": "boolean"}, {"name": "preferForRegexpMatch", "type": "boolean"}], "body": "                                          {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }", "signature": "public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer) {\n        this(name, regexps, type, transformer, true, false);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexps", "type": "List<String>"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}], "body": "                                                                                                       {\n        this(name, regexps, type, transformer, true, false);\n    }", "signature": "public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer)"}, {"syntax_pass": true, "original_string": "    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer) {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterType", "params": [{"name": "name", "type": "String"}, {"name": "regexp", "type": "String"}, {"name": "type", "type": "Class<T>"}, {"name": "transformer", "type": "Transformer<T>"}], "body": "                                                                                                {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }", "signature": "public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer)"}, {"syntax_pass": true, "original_string": "    public String getName() {\n        return name;\n    }", "docstring": "\nThis is used in the type name in typed expressions\n\n@return human readable type name\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getName", "params": [], "body": "                            {\n        return name;\n    }", "signature": "public String getName()"}, {"syntax_pass": true, "original_string": "    public Type getType() {\n        return type;\n    }", "docstring": "\nReturns the type of the parameter type - typically the type\nthe transform transforms to. This can be used in conjunction with\nGeneratedExpression (snippets) to generate snippets for statically typed\nlanguages. Not used for anything else.\n\n@return the type of the parameter type\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "getType", "params": [], "body": "                          {\n        return type;\n    }", "signature": "public Type getType()"}, {"syntax_pass": true, "original_string": "    public List<String> getRegexps() {\n        return regexps;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getRegexps", "params": [], "body": "                                     {\n        return regexps;\n    }", "signature": "public List<String> getRegexps()"}, {"syntax_pass": true, "original_string": "    public boolean preferForRegexpMatch() {\n        return preferForRegexpMatch;\n    }", "docstring": "\nIndicates whether or not this is a preferential parameter type when matching text\nagainst a {@link RegularExpression}. In case there are multiple parameter types\nwith a regexp identical to the capture group's regexp, a preferential parameter type will\nwin. If there are more than 1 preferential ones, an error will be thrown.\n\n@return true if this is a preferential type\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "preferForRegexpMatch", "params": [], "body": "                                          {\n        return preferForRegexpMatch;\n    }", "signature": "public boolean preferForRegexpMatch()"}, {"syntax_pass": true, "original_string": "    public boolean useForSnippets() {\n        return useForSnippets;\n    }", "docstring": "\nIndicates whether or not this is a parameter type should be used for generating\n{@link GeneratedExpression}s from text. Typically, parameter types with greedy regexps\nshould return false.\n\n@return true is this parameter type is used for expression generation\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "useForSnippets", "params": [], "body": "                                    {\n        return useForSnippets;\n    }", "signature": "public boolean useForSnippets()"}, {"syntax_pass": true, "original_string": "    boolean isAnonymous() {\n        return anonymous;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAnonymous", "params": [], "body": "                          {\n        return anonymous;\n    }", "signature": "boolean isAnonymous()"}, {"syntax_pass": true, "original_string": "    public boolean useRegexpMatchAsStrongTypeHint() {\n        return useRegexpMatchAsStrongTypeHint;\n    }", "docstring": "\nIndicates whether or not this parameter provides a strong type hint when considering a\nregular expression match. If so, the type hint provided by the method arguments  will be\nignored. If not, when both type hints are in agreement, this parameter types transformer\nwill be used. Otherwise parameter transformation for a regular expression match will be\nhandled by {@link ParameterTypeRegistry#getDefaultParameterTransformer()}.\n\n@return true if this parameter type provides a type hint when considering a regular\nexpression match\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "useRegexpMatchAsStrongTypeHint", "params": [], "body": "                                                    {\n        return useRegexpMatchAsStrongTypeHint;\n    }", "signature": "public boolean useRegexpMatchAsStrongTypeHint()"}, {"syntax_pass": true, "original_string": "    ParameterType<Object> deAnonymize(Type type, Transformer<Object> transformer) {\n        return new ParameterType<>(\"anonymous\", regexps, type, new TransformerAdaptor<>(transformer), useForSnippets,\n                preferForRegexpMatch, useRegexpMatchAsStrongTypeHint, anonymous);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ParameterType<Object>", "classes": []}, "name": "deAnonymize", "params": [{"name": "type", "type": "Type"}, {"name": "transformer", "type": "Transformer<Object>"}], "body": "                                                                                  {\n        return new ParameterType<>(\"anonymous\", regexps, type, new TransformerAdaptor<>(transformer), useForSnippets,\n                preferForRegexpMatch, useRegexpMatchAsStrongTypeHint, anonymous);\n    }", "signature": "ParameterType<Object> deAnonymize(Type type, Transformer<Object> transformer)"}, {"syntax_pass": true, "original_string": "    T transform(List<String> groupValues) {\n        if (transformer instanceof TransformerAdaptor) {\n            if (groupValues.size() > 1) {\n                if (isAnonymous()) {\n                    throw new CucumberExpressionException(String.format(\"\" +\n                            \"Anonymous ParameterType has multiple capture groups %s. \" +\n                            \"You can only use a single capture group in an anonymous ParameterType.\", regexps));\n                }\n                throw new CucumberExpressionException(String.format(\"\" +\n                        \"ParameterType {%s} was registered with a Transformer but has multiple capture groups %s. \" +\n                        \"Did you mean to use a CaptureGroupTransformer?\", name, regexps));\n            }\n        }\n\n        try {\n            String[] groupValueArray = groupValues.toArray(new String[0]);\n            return transformer.transform(groupValueArray);\n        } catch (CucumberExpressionException e) {\n            throw e;\n        } catch (Throwable throwable) {\n            throw new CucumberExpressionException(\n                    String.format(\"ParameterType {%s} failed to transform %s to %s\", name, groupValues, type),\n                    throwable);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "name": "transform", "params": [{"name": "groupValues", "type": "List<String>"}], "body": "                                          {\n        if (transformer instanceof TransformerAdaptor) {\n            if (groupValues.size() > 1) {\n                if (isAnonymous()) {\n                    throw new CucumberExpressionException(String.format(\"\" +\n                            \"Anonymous ParameterType has multiple capture groups %s. \" +\n                            \"You can only use a single capture group in an anonymous ParameterType.\", regexps));\n                }\n                throw new CucumberExpressionException(String.format(\"\" +\n                        \"ParameterType {%s} was registered with a Transformer but has multiple capture groups %s. \" +\n                        \"Did you mean to use a CaptureGroupTransformer?\", name, regexps));\n            }\n        }\n\n        try {\n            String[] groupValueArray = groupValues.toArray(new String[0]);\n            return transformer.transform(groupValueArray);\n        } catch (CucumberExpressionException e) {\n            throw e;\n        } catch (Throwable throwable) {\n            throw new CucumberExpressionException(\n                    String.format(\"ParameterType {%s} failed to transform %s to %s\", name, groupValues, type),\n                    throwable);\n        }\n    }", "signature": "T transform(List<String> groupValues)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int compareTo(ParameterType<?> o) {\n        if (preferForRegexpMatch() && !o.preferForRegexpMatch())\n            return -1;\n        if (o.preferForRegexpMatch() && !preferForRegexpMatch())\n            return 1;\n        String name = getName() != null ? getName() : \"\";\n        String otherName = o.getName() != null ? o.getName() : \"\";\n        return name.compareTo(otherName);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compareTo", "params": [{"name": "o", "type": "ParameterType<?>"}], "body": "                                             {\n        if (preferForRegexpMatch() && !o.preferForRegexpMatch())\n            return -1;\n        if (o.preferForRegexpMatch() && !preferForRegexpMatch())\n            return 1;\n        String name = getName() != null ? getName() : \"\";\n        String otherName = o.getName() != null ? o.getName() : \"\";\n        return name.compareTo(otherName);\n    }", "signature": "@Override\n    public int compareTo(ParameterType<?> o)"}, {"syntax_pass": true, "original_string": "    public int weight() {\n        if (this.type.equals(Integer.class) || this.type.equals(Integer.TYPE)) {\n            return 1000;\n        }\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "weight", "params": [], "body": "                        {\n        if (this.type.equals(Integer.class) || this.type.equals(Integer.TYPE)) {\n            return 1000;\n        }\n        return 0;\n    }", "signature": "public int weight()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/RegexpUtils.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nclass RegexpUtils {\n    /**\n     * List of characters to be escaped.\n     * The last char is '}' with index 125, so we need only 126 characters.\n     */\n    private static final boolean[] CHAR_TO_ESCAPE = new boolean[126];\n\n    static {\n        CHAR_TO_ESCAPE['^'] = true;\n        CHAR_TO_ESCAPE['$'] = true;\n        CHAR_TO_ESCAPE['['] = true;\n        CHAR_TO_ESCAPE[']'] = true;\n        CHAR_TO_ESCAPE['('] = true;\n        CHAR_TO_ESCAPE[')'] = true;\n        CHAR_TO_ESCAPE['{'] = true;\n        CHAR_TO_ESCAPE['}'] = true;\n        CHAR_TO_ESCAPE['.'] = true;\n        CHAR_TO_ESCAPE['|'] = true;\n        CHAR_TO_ESCAPE['?'] = true;\n        CHAR_TO_ESCAPE['*'] = true;\n        CHAR_TO_ESCAPE['+'] = true;\n        CHAR_TO_ESCAPE['\\\\'] = true;\n    }\n\n    /**\n     * Escapes the regexp characters (the ones from \"^$(){}[].+*?\\\")\n     * from the given text, so that they are not considered as regexp\n     * characters.\n     *\n     * @param text the non-null input text\n     * @return the input text with escaped regexp characters\n     */\n    public static String escapeRegex(String text) {\n        /*\n        Note on performance: this code has been benchmarked for\n        escaping frequencies of 100%, 50%, 20%, 10%, 1%, 0.1%.\n        Amongst 4 other variants (including Pattern matching),\n        this variant is the faster on all escaping frequencies.\n        */\n        int length = text.length();\n        StringBuilder sb = null; // lazy initialization\n        int blockStart = 0;\n        int maxChar = CHAR_TO_ESCAPE.length;\n        for (int i = 0; i < length; i++) {\n            char currentChar = text.charAt(i);\n            if (currentChar < maxChar && CHAR_TO_ESCAPE[currentChar]) {\n                if (sb == null) {\n                    sb = new StringBuilder(length * 2);\n                }\n                if (blockStart < i) {\n                    // flush previous block\n                    sb.append(text, blockStart, i);\n                }\n                sb.append('\\\\');\n                sb.append(currentChar);\n                blockStart = i + 1;\n            }\n        }\n        if (sb != null) {\n            // finalizing character escaping\n            if (blockStart < length) {\n                // flush remaining characters\n                sb.append(text, blockStart, length);\n            }\n            return sb.toString();\n        }\n        return text;\n    }\n\n}\n", "file_hash": "f5f4fe6e548b559e3c197dbb984ec5454a1e7566f0f51b1aac95040125930e0a", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;"], "methods": [], "classes": [{"original_string": "class RegexpUtils {\n    /**\n     * List of characters to be escaped.\n     * The last char is '}' with index 125, so we need only 126 characters.\n     */\n    private static final boolean[] CHAR_TO_ESCAPE = new boolean[126];\n\n    static {\n        CHAR_TO_ESCAPE['^'] = true;\n        CHAR_TO_ESCAPE['$'] = true;\n        CHAR_TO_ESCAPE['['] = true;\n        CHAR_TO_ESCAPE[']'] = true;\n        CHAR_TO_ESCAPE['('] = true;\n        CHAR_TO_ESCAPE[')'] = true;\n        CHAR_TO_ESCAPE['{'] = true;\n        CHAR_TO_ESCAPE['}'] = true;\n        CHAR_TO_ESCAPE['.'] = true;\n        CHAR_TO_ESCAPE['|'] = true;\n        CHAR_TO_ESCAPE['?'] = true;\n        CHAR_TO_ESCAPE['*'] = true;\n        CHAR_TO_ESCAPE['+'] = true;\n        CHAR_TO_ESCAPE['\\\\'] = true;\n    }\n\n    /**\n     * Escapes the regexp characters (the ones from \"^$(){}[].+*?\\\")\n     * from the given text, so that they are not considered as regexp\n     * characters.\n     *\n     * @param text the non-null input text\n     * @return the input text with escaped regexp characters\n     */\n    public static String escapeRegex(String text) {\n        /*\n        Note on performance: this code has been benchmarked for\n        escaping frequencies of 100%, 50%, 20%, 10%, 1%, 0.1%.\n        Amongst 4 other variants (including Pattern matching),\n        this variant is the faster on all escaping frequencies.\n        */\n        int length = text.length();\n        StringBuilder sb = null; // lazy initialization\n        int blockStart = 0;\n        int maxChar = CHAR_TO_ESCAPE.length;\n        for (int i = 0; i < length; i++) {\n            char currentChar = text.charAt(i);\n            if (currentChar < maxChar && CHAR_TO_ESCAPE[currentChar]) {\n                if (sb == null) {\n                    sb = new StringBuilder(length * 2);\n                }\n                if (blockStart < i) {\n                    // flush previous block\n                    sb.append(text, blockStart, i);\n                }\n                sb.append('\\\\');\n                sb.append(currentChar);\n                blockStart = i + 1;\n            }\n        }\n        if (sb != null) {\n            // finalizing character escaping\n            if (blockStart < length) {\n                // flush remaining characters\n                sb.append(text, blockStart, length);\n            }\n            return sb.toString();\n        }\n        return text;\n    }\n\n}", "definition": "class RegexpUtils", "class_docstring": "", "name": "RegexpUtils", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "private static final boolean[] CHAR_TO_ESCAPE = new boolean[126];", "docstring": "\nList of characters to be escaped.\nThe last char is '}' with index 125, so we need only 126 characters.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "boolean[]", "name": "CHAR_TO_ESCAPE = new boolean[126]", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static String escapeRegex(String text) {\n        /*\n        Note on performance: this code has been benchmarked for\n        escaping frequencies of 100%, 50%, 20%, 10%, 1%, 0.1%.\n        Amongst 4 other variants (including Pattern matching),\n        this variant is the faster on all escaping frequencies.\n        */\n        int length = text.length();\n        StringBuilder sb = null; // lazy initialization\n        int blockStart = 0;\n        int maxChar = CHAR_TO_ESCAPE.length;\n        for (int i = 0; i < length; i++) {\n            char currentChar = text.charAt(i);\n            if (currentChar < maxChar && CHAR_TO_ESCAPE[currentChar]) {\n                if (sb == null) {\n                    sb = new StringBuilder(length * 2);\n                }\n                if (blockStart < i) {\n                    // flush previous block\n                    sb.append(text, blockStart, i);\n                }\n                sb.append('\\\\');\n                sb.append(currentChar);\n                blockStart = i + 1;\n            }\n        }\n        if (sb != null) {\n            // finalizing character escaping\n            if (blockStart < length) {\n                // flush remaining characters\n                sb.append(text, blockStart, length);\n            }\n            return sb.toString();\n        }\n        return text;\n    }", "docstring": "\nEscapes the regexp characters (the ones from \"^$(){}[].+*?\\\")\nfrom the given text, so that they are not considered as regexp\ncharacters.\n\n@param text the non-null input text\n@return the input text with escaped regexp characters\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "escapeRegex", "params": [{"name": "text", "type": "String"}], "body": "                                                  {\n        /*\n        Note on performance: this code has been benchmarked for\n        escaping frequencies of 100%, 50%, 20%, 10%, 1%, 0.1%.\n        Amongst 4 other variants (including Pattern matching),\n        this variant is the faster on all escaping frequencies.\n        */\n        int length = text.length();\n        StringBuilder sb = null; // lazy initialization\n        int blockStart = 0;\n        int maxChar = CHAR_TO_ESCAPE.length;\n        for (int i = 0; i < length; i++) {\n            char currentChar = text.charAt(i);\n            if (currentChar < maxChar && CHAR_TO_ESCAPE[currentChar]) {\n                if (sb == null) {\n                    sb = new StringBuilder(length * 2);\n                }\n                if (blockStart < i) {\n                    // flush previous block\n                    sb.append(text, blockStart, i);\n                }\n                sb.append('\\\\');\n                sb.append(currentChar);\n                blockStart = i + 1;\n            }\n        }\n        if (sb != null) {\n            // finalizing character escaping\n            if (blockStart < length) {\n                // flush remaining characters\n                sb.append(text, blockStart, length);\n            }\n            return sb.toString();\n        }\n        return text;\n    }", "signature": "public static String escapeRegex(String text)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/Group.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport static java.util.Collections.singletonList;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n@API(status = API.Status.STABLE)\npublic class Group {\n    private final List<Group> children;\n    private final String value;\n    private final int start;\n    private final int end;\n\n    Group(String value, int start, int end, List<Group> children) {\n        this.value = value;\n        this.start = start;\n        this.end = end;\n        this.children = children;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public int getStart() {\n        return start;\n    }\n\n    public int getEnd() {\n        return end;\n    }\n\n    public List<Group> getChildren() {\n        return children;\n    }\n\n    public List<String> getValues() {\n        List<Group> groups = getChildren().isEmpty() ? singletonList(this) : getChildren();\n        return groups.stream()\n                .map(Group::getValue)\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Parse a {@link Pattern} into collection of {@link Group}s\n     * \n     * @param expression the expression to decompose\n     * @return A collection of {@link Group}s, possibly empty but never\n     *         <code>null</code>\n     */\n    public static Collection<Group> parse(Pattern expression) {\n        GroupBuilder builder = TreeRegexp.createGroupBuilder(expression);\n        return toGroups(builder.getChildren());\n    }\n\n    private static List<Group> toGroups(List<GroupBuilder> children) {\n        List<Group> list = new ArrayList<>();\n        if (children != null) {\n            for (GroupBuilder child : children) {\n                list.add(new Group(child.getSource(), child.getStartIndex(), child.getEndIndex(),\n                        toGroups(child.getChildren())));\n            }\n        }\n        return list;\n    }\n}\n", "file_hash": "a0cf683b6e5661ae509e6728aa201147ad14b4bc030caa235c2e45fc0312983b", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.util.List;", "import java.util.regex.Pattern;", "import java.util.stream.Collectors;", "import static java.util.Collections.singletonList;", "import java.util.ArrayList;", "import java.util.Collection;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic class Group {\n    private final List<Group> children;\n    private final String value;\n    private final int start;\n    private final int end;\n\n    Group(String value, int start, int end, List<Group> children) {\n        this.value = value;\n        this.start = start;\n        this.end = end;\n        this.children = children;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public int getStart() {\n        return start;\n    }\n\n    public int getEnd() {\n        return end;\n    }\n\n    public List<Group> getChildren() {\n        return children;\n    }\n\n    public List<String> getValues() {\n        List<Group> groups = getChildren().isEmpty() ? singletonList(this) : getChildren();\n        return groups.stream()\n                .map(Group::getValue)\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Parse a {@link Pattern} into collection of {@link Group}s\n     * \n     * @param expression the expression to decompose\n     * @return A collection of {@link Group}s, possibly empty but never\n     *         <code>null</code>\n     */\n    public static Collection<Group> parse(Pattern expression) {\n        GroupBuilder builder = TreeRegexp.createGroupBuilder(expression);\n        return toGroups(builder.getChildren());\n    }\n\n    private static List<Group> toGroups(List<GroupBuilder> children) {\n        List<Group> list = new ArrayList<>();\n        if (children != null) {\n            for (GroupBuilder child : children) {\n                list.add(new Group(child.getSource(), child.getStartIndex(), child.getEndIndex(),\n                        toGroups(child.getChildren())));\n            }\n        }\n        return list;\n    }\n}", "definition": "@API(status = API.Status.STABLE)\npublic class Group", "class_docstring": "", "name": "Group", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public"], "comments": [], "fields": [{"attribute_expression": "private final List<Group> children;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Group>", "name": "children", "syntax_pass": true}, {"attribute_expression": "private final String value;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "value", "syntax_pass": true}, {"attribute_expression": "private final int start;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "private final int end;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Group(String value, int start, int end, List<Group> children) {\n        this.value = value;\n        this.start = start;\n        this.end = end;\n        this.children = children;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Group", "params": [{"name": "value", "type": "String"}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "children", "type": "List<Group>"}], "body": "                                                                  {\n        this.value = value;\n        this.start = start;\n        this.end = end;\n        this.children = children;\n    }", "signature": "Group(String value, int start, int end, List<Group> children)"}, {"syntax_pass": true, "original_string": "    public String getValue() {\n        return value;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getValue", "params": [], "body": "                             {\n        return value;\n    }", "signature": "public String getValue()"}, {"syntax_pass": true, "original_string": "    public int getStart() {\n        return start;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getStart", "params": [], "body": "                          {\n        return start;\n    }", "signature": "public int getStart()"}, {"syntax_pass": true, "original_string": "    public int getEnd() {\n        return end;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getEnd", "params": [], "body": "                        {\n        return end;\n    }", "signature": "public int getEnd()"}, {"syntax_pass": true, "original_string": "    public List<Group> getChildren() {\n        return children;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Group>", "classes": []}, "name": "getChildren", "params": [], "body": "                                     {\n        return children;\n    }", "signature": "public List<Group> getChildren()"}, {"syntax_pass": true, "original_string": "    public List<String> getValues() {\n        List<Group> groups = getChildren().isEmpty() ? singletonList(this) : getChildren();\n        return groups.stream()\n                .map(Group::getValue)\n                .collect(Collectors.toList());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getValues", "params": [], "body": "                                    {\n        List<Group> groups = getChildren().isEmpty() ? singletonList(this) : getChildren();\n        return groups.stream()\n                .map(Group::getValue)\n                .collect(Collectors.toList());\n    }", "signature": "public List<String> getValues()"}, {"syntax_pass": true, "original_string": "    public static Collection<Group> parse(Pattern expression) {\n        GroupBuilder builder = TreeRegexp.createGroupBuilder(expression);\n        return toGroups(builder.getChildren());\n    }", "docstring": "\nParse a {@link Pattern} into collection of {@link Group}s\n\n@param expression the expression to decompose\n@return A collection of {@link Group}s, possibly empty but never\n        <code>null</code>\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Collection<Group>", "classes": []}, "name": "parse", "params": [{"name": "expression", "type": "Pattern"}], "body": "                                                              {\n        GroupBuilder builder = TreeRegexp.createGroupBuilder(expression);\n        return toGroups(builder.getChildren());\n    }", "signature": "public static Collection<Group> parse(Pattern expression)"}, {"syntax_pass": true, "original_string": "    private static List<Group> toGroups(List<GroupBuilder> children) {\n        List<Group> list = new ArrayList<>();\n        if (children != null) {\n            for (GroupBuilder child : children) {\n                list.add(new Group(child.getSource(), child.getStartIndex(), child.getEndIndex(),\n                        toGroups(child.getChildren())));\n            }\n        }\n        return list;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Group>", "classes": []}, "name": "toGroups", "params": [{"name": "children", "type": "List<GroupBuilder>"}], "body": "                                                                     {\n        List<Group> list = new ArrayList<>();\n        if (children != null) {\n            for (GroupBuilder child : children) {\n                list.add(new Group(child.getSource(), child.getStartIndex(), child.getEndIndex(),\n                        toGroups(child.getChildren())));\n            }\n        }\n        return list;\n    }", "signature": "private static List<Group> toGroups(List<GroupBuilder> children)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.IntStream;\n\nimport static java.util.Collections.singleton;\n\n/**\n * TreeRegexp represents matches as a tree of {@link Group}\n * reflecting the nested structure of capture groups in the original\n * regexp.\n */\nfinal class TreeRegexp {\n    private final Pattern pattern;\n    private final GroupBuilder groupBuilder;\n\n    TreeRegexp(String regexp) {\n        this(PatternCompilerProvider.getCompiler().compile(regexp, Pattern.UNICODE_CHARACTER_CLASS));\n    }\n\n    TreeRegexp(Pattern pattern) {\n        this.pattern = pattern;\n        this.groupBuilder = createGroupBuilder(pattern);\n    }\n\n    static GroupBuilder createGroupBuilder(Pattern pattern) {\n        String source = pattern.pattern();\n        Deque<GroupBuilder> stack = new ArrayDeque<>(singleton(new GroupBuilder(0)));\n        boolean escaping = false;\n        boolean charClass = false;\n\n        for (int i = 0; i < source.length(); i++) {\n            char c = source.charAt(i);\n            if (c == '[' && !escaping) {\n                charClass = true;\n            } else if (c == ']' && !escaping) {\n                charClass = false;\n            } else if (c == '(' && !escaping && !charClass) {\n                boolean nonCapturing = isNonCapturingGroup(source, i);\n                GroupBuilder groupBuilder = new GroupBuilder(i);\n                if (nonCapturing) {\n                    groupBuilder.setNonCapturing();\n                }\n                stack.push(groupBuilder);\n            } else if (c == ')' && !escaping && !charClass) {\n                GroupBuilder gb = stack.pop();\n                if (gb.isCapturing()) {\n                    gb.setSource(source.substring(gb.getStartIndex() + 1, i));\n                    stack.peek().add(gb);\n                } else {\n                    gb.moveChildrenTo(stack.peek());\n                }\n                gb.setEndIndex(i);\n            }\n            escaping = c == '\\\\' && !escaping;\n        }\n        return stack.pop();\n    }\n\n    private static boolean isNonCapturingGroup(String source, int i) {\n        // Regex is valid. Bounds check not required.\n        if (source.charAt(i+1) != '?') {\n            // (X)\n            return false;\n        }\n        if (source.charAt(i+2) != '<') {\n            // (?:X)\n            // (?idmsuxU-idmsuxU)\n            // (?idmsux-idmsux:X)\n            // (?=X)\n            // (?!X)\n            // (?>X)\n            return true;\n        }\n        // (?<=X) or (?<!X) else (?<name>X)\n        return source.charAt(i + 3) == '=' || source.charAt(i + 3) == '!';\n    }\n\n    Pattern pattern() {\n        return pattern;\n    }\n\n    Group match(CharSequence s) {\n        final Matcher matcher = pattern.matcher(s);\n        if (!matcher.matches())\n            return null;\n        return groupBuilder.build(matcher, IntStream.rangeClosed(0, matcher.groupCount()).iterator());\n    }\n\n    public GroupBuilder getGroupBuilder() {\n        return groupBuilder;\n    }\n\n}\n", "file_hash": "dc4c240fa9107f7e8911145b33c86cac91907d02bf617e3e546b73a7bbad0968", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import java.util.ArrayDeque;", "import java.util.Collections;", "import java.util.Deque;", "import java.util.regex.Matcher;", "import java.util.regex.Pattern;", "import java.util.stream.IntStream;", "import static java.util.Collections.singleton;"], "methods": [], "classes": [{"original_string": "final class TreeRegexp {\n    private final Pattern pattern;\n    private final GroupBuilder groupBuilder;\n\n    TreeRegexp(String regexp) {\n        this(PatternCompilerProvider.getCompiler().compile(regexp, Pattern.UNICODE_CHARACTER_CLASS));\n    }\n\n    TreeRegexp(Pattern pattern) {\n        this.pattern = pattern;\n        this.groupBuilder = createGroupBuilder(pattern);\n    }\n\n    static GroupBuilder createGroupBuilder(Pattern pattern) {\n        String source = pattern.pattern();\n        Deque<GroupBuilder> stack = new ArrayDeque<>(singleton(new GroupBuilder(0)));\n        boolean escaping = false;\n        boolean charClass = false;\n\n        for (int i = 0; i < source.length(); i++) {\n            char c = source.charAt(i);\n            if (c == '[' && !escaping) {\n                charClass = true;\n            } else if (c == ']' && !escaping) {\n                charClass = false;\n            } else if (c == '(' && !escaping && !charClass) {\n                boolean nonCapturing = isNonCapturingGroup(source, i);\n                GroupBuilder groupBuilder = new GroupBuilder(i);\n                if (nonCapturing) {\n                    groupBuilder.setNonCapturing();\n                }\n                stack.push(groupBuilder);\n            } else if (c == ')' && !escaping && !charClass) {\n                GroupBuilder gb = stack.pop();\n                if (gb.isCapturing()) {\n                    gb.setSource(source.substring(gb.getStartIndex() + 1, i));\n                    stack.peek().add(gb);\n                } else {\n                    gb.moveChildrenTo(stack.peek());\n                }\n                gb.setEndIndex(i);\n            }\n            escaping = c == '\\\\' && !escaping;\n        }\n        return stack.pop();\n    }\n\n    private static boolean isNonCapturingGroup(String source, int i) {\n        // Regex is valid. Bounds check not required.\n        if (source.charAt(i+1) != '?') {\n            // (X)\n            return false;\n        }\n        if (source.charAt(i+2) != '<') {\n            // (?:X)\n            // (?idmsuxU-idmsuxU)\n            // (?idmsux-idmsux:X)\n            // (?=X)\n            // (?!X)\n            // (?>X)\n            return true;\n        }\n        // (?<=X) or (?<!X) else (?<name>X)\n        return source.charAt(i + 3) == '=' || source.charAt(i + 3) == '!';\n    }\n\n    Pattern pattern() {\n        return pattern;\n    }\n\n    Group match(CharSequence s) {\n        final Matcher matcher = pattern.matcher(s);\n        if (!matcher.matches())\n            return null;\n        return groupBuilder.build(matcher, IntStream.rangeClosed(0, matcher.groupCount()).iterator());\n    }\n\n    public GroupBuilder getGroupBuilder() {\n        return groupBuilder;\n    }\n\n}", "definition": "final class TreeRegexp", "class_docstring": "\nTreeRegexp represents matches as a tree of {@link Group}\nreflecting the nested structure of capture groups in the original\nregexp.\n", "name": "TreeRegexp", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private final Pattern pattern;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pattern", "name": "pattern", "syntax_pass": true}, {"attribute_expression": "private final GroupBuilder groupBuilder;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "GroupBuilder", "name": "groupBuilder", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    TreeRegexp(String regexp) {\n        this(PatternCompilerProvider.getCompiler().compile(regexp, Pattern.UNICODE_CHARACTER_CLASS));\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TreeRegexp", "params": [{"name": "regexp", "type": "String"}], "body": "                              {\n        this(PatternCompilerProvider.getCompiler().compile(regexp, Pattern.UNICODE_CHARACTER_CLASS));\n    }", "signature": "TreeRegexp(String regexp)"}, {"syntax_pass": true, "original_string": "    TreeRegexp(Pattern pattern) {\n        this.pattern = pattern;\n        this.groupBuilder = createGroupBuilder(pattern);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TreeRegexp", "params": [{"name": "pattern", "type": "Pattern"}], "body": "                                {\n        this.pattern = pattern;\n        this.groupBuilder = createGroupBuilder(pattern);\n    }", "signature": "TreeRegexp(Pattern pattern)"}, {"syntax_pass": true, "original_string": "    static GroupBuilder createGroupBuilder(Pattern pattern) {\n        String source = pattern.pattern();\n        Deque<GroupBuilder> stack = new ArrayDeque<>(singleton(new GroupBuilder(0)));\n        boolean escaping = false;\n        boolean charClass = false;\n\n        for (int i = 0; i < source.length(); i++) {\n            char c = source.charAt(i);\n            if (c == '[' && !escaping) {\n                charClass = true;\n            } else if (c == ']' && !escaping) {\n                charClass = false;\n            } else if (c == '(' && !escaping && !charClass) {\n                boolean nonCapturing = isNonCapturingGroup(source, i);\n                GroupBuilder groupBuilder = new GroupBuilder(i);\n                if (nonCapturing) {\n                    groupBuilder.setNonCapturing();\n                }\n                stack.push(groupBuilder);\n            } else if (c == ')' && !escaping && !charClass) {\n                GroupBuilder gb = stack.pop();\n                if (gb.isCapturing()) {\n                    gb.setSource(source.substring(gb.getStartIndex() + 1, i));\n                    stack.peek().add(gb);\n                } else {\n                    gb.moveChildrenTo(stack.peek());\n                }\n                gb.setEndIndex(i);\n            }\n            escaping = c == '\\\\' && !escaping;\n        }\n        return stack.pop();\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "GroupBuilder", "classes": []}, "name": "createGroupBuilder", "params": [{"name": "pattern", "type": "Pattern"}], "body": "                                                            {\n        String source = pattern.pattern();\n        Deque<GroupBuilder> stack = new ArrayDeque<>(singleton(new GroupBuilder(0)));\n        boolean escaping = false;\n        boolean charClass = false;\n\n        for (int i = 0; i < source.length(); i++) {\n            char c = source.charAt(i);\n            if (c == '[' && !escaping) {\n                charClass = true;\n            } else if (c == ']' && !escaping) {\n                charClass = false;\n            } else if (c == '(' && !escaping && !charClass) {\n                boolean nonCapturing = isNonCapturingGroup(source, i);\n                GroupBuilder groupBuilder = new GroupBuilder(i);\n                if (nonCapturing) {\n                    groupBuilder.setNonCapturing();\n                }\n                stack.push(groupBuilder);\n            } else if (c == ')' && !escaping && !charClass) {\n                GroupBuilder gb = stack.pop();\n                if (gb.isCapturing()) {\n                    gb.setSource(source.substring(gb.getStartIndex() + 1, i));\n                    stack.peek().add(gb);\n                } else {\n                    gb.moveChildrenTo(stack.peek());\n                }\n                gb.setEndIndex(i);\n            }\n            escaping = c == '\\\\' && !escaping;\n        }\n        return stack.pop();\n    }", "signature": "static GroupBuilder createGroupBuilder(Pattern pattern)"}, {"syntax_pass": true, "original_string": "    private static boolean isNonCapturingGroup(String source, int i) {\n        // Regex is valid. Bounds check not required.\n        if (source.charAt(i+1) != '?') {\n            // (X)\n            return false;\n        }\n        if (source.charAt(i+2) != '<') {\n            // (?:X)\n            // (?idmsuxU-idmsuxU)\n            // (?idmsux-idmsux:X)\n            // (?=X)\n            // (?!X)\n            // (?>X)\n            return true;\n        }\n        // (?<=X) or (?<!X) else (?<name>X)\n        return source.charAt(i + 3) == '=' || source.charAt(i + 3) == '!';\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNonCapturingGroup", "params": [{"name": "source", "type": "String"}, {"name": "i", "type": "int"}], "body": "                                                                     {\n        // Regex is valid. Bounds check not required.\n        if (source.charAt(i+1) != '?') {\n            // (X)\n            return false;\n        }\n        if (source.charAt(i+2) != '<') {\n            // (?:X)\n            // (?idmsuxU-idmsuxU)\n            // (?idmsux-idmsux:X)\n            // (?=X)\n            // (?!X)\n            // (?>X)\n            return true;\n        }\n        // (?<=X) or (?<!X) else (?<name>X)\n        return source.charAt(i + 3) == '=' || source.charAt(i + 3) == '!';\n    }", "signature": "private static boolean isNonCapturingGroup(String source, int i)"}, {"syntax_pass": true, "original_string": "    Pattern pattern() {\n        return pattern;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Pattern", "classes": []}, "name": "pattern", "params": [], "body": "                      {\n        return pattern;\n    }", "signature": "Pattern pattern()"}, {"syntax_pass": true, "original_string": "    Group match(CharSequence s) {\n        final Matcher matcher = pattern.matcher(s);\n        if (!matcher.matches())\n            return null;\n        return groupBuilder.build(matcher, IntStream.rangeClosed(0, matcher.groupCount()).iterator());\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Group", "classes": []}, "name": "match", "params": [{"name": "s", "type": "CharSequence"}], "body": "                                {\n        final Matcher matcher = pattern.matcher(s);\n        if (!matcher.matches())\n            return null;\n        return groupBuilder.build(matcher, IntStream.rangeClosed(0, matcher.groupCount()).iterator());\n    }", "signature": "Group match(CharSequence s)"}, {"syntax_pass": true, "original_string": "    public GroupBuilder getGroupBuilder() {\n        return groupBuilder;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "GroupBuilder", "classes": []}, "name": "getGroupBuilder", "params": [], "body": "                                          {\n        return groupBuilder;\n    }", "signature": "public GroupBuilder getGroupBuilder()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/PatternCompiler.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.util.regex.Pattern;\n\n/**\n * Abstracts creation of new {@link Pattern}. In some platforms and Java versions some flags are not supported (e.g {@link Pattern#UNICODE_CHARACTER_CLASS} on Android) - clients for those platforms should provide resource {@code META-INF/services/io.cucumber.cucumberexpressions.PatternCompiler} pointing to implementation of this interface.\n *\n * @see DefaultPatternCompiler\n * @see java.util.ServiceLoader\n */\n@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic interface PatternCompiler {\n\n    /**\n     * @param regexp regular expression\n     * @param flags  additional flags (e.g. {@link Pattern#UNICODE_CHARACTER_CLASS})\n     * @return new {@link Pattern} instance from provided {@code regexp}\n     */\n    Pattern compile(String regexp, int flags);\n}\n", "file_hash": "8096444243f0e771715eeaea7f1e24001421dcd4d47aa8ec3c35b668e2ff8c1a", "file_docstring": "\nAbstracts creation of new {@link Pattern}. In some platforms and Java versions some flags are not supported (e.g {@link Pattern#UNICODE_CHARACTER_CLASS} on Android) - clients for those platforms should provide resource {@code META-INF/services/io.cucumber.cucumberexpressions.PatternCompiler} pointing to implementation of this interface.\n\n@see DefaultPatternCompiler\n@see java.util.ServiceLoader\n", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.util.regex.Pattern;"], "methods": [], "classes": [], "interfaces": [{"original_string": "@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic interface PatternCompiler {\n\n    /**\n     * @param regexp regular expression\n     * @param flags  additional flags (e.g. {@link Pattern#UNICODE_CHARACTER_CLASS})\n     * @return new {@link Pattern} instance from provided {@code regexp}\n     */\n    Pattern compile(String regexp, int flags);\n}", "definition": "@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic interface PatternCompiler", "interface_docstring": "\nAbstracts creation of new {@link Pattern}. In some platforms and Java versions some flags are not supported (e.g {@link Pattern#UNICODE_CHARACTER_CLASS} on Android) - clients for those platforms should provide resource {@code META-INF/services/io.cucumber.cucumberexpressions.PatternCompiler} pointing to implementation of this interface.\n\n@see DefaultPatternCompiler\n@see java.util.ServiceLoader\n", "name": "PatternCompiler", "extends_interfaces": [], "attributes": {"modifiers": "@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic", "marker_annotations": ["@FunctionalInterface"], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Pattern compile(String regexp, int flags);", "docstring": "\n@param regexp regular expression\n@param flags  additional flags (e.g. {@link Pattern#UNICODE_CHARACTER_CLASS})\n@return new {@link Pattern} instance from provided {@code regexp}\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Pattern", "classes": []}, "name": "compile", "params": [{"name": "regexp", "type": "String"}, {"name": "flags", "type": "int"}], "body": "", "signature": "Pattern compile(String regexp, int flags)"}]}], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/DuplicateTypeNameException.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\n@API(status = API.Status.STABLE)\npublic class DuplicateTypeNameException extends CucumberExpressionException {\n    DuplicateTypeNameException(String message) {\n        super(message);\n    }\n}\n", "file_hash": "c3fe5a5fc76dbc211b1e52665e6b1b938fbc4c170a96be46779c235f2f6d7ed8", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic class DuplicateTypeNameException extends CucumberExpressionException {\n    DuplicateTypeNameException(String message) {\n        super(message);\n    }\n}", "definition": "@API(status = API.Status.STABLE)\npublic class DuplicateTypeNameException extends CucumberExpressionException", "class_docstring": "", "name": "DuplicateTypeNameException", "super_interfaces": [], "superclasses": "CucumberExpressionException", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    DuplicateTypeNameException(String message) {\n        super(message);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DuplicateTypeNameException", "params": [{"name": "message", "type": "String"}], "body": "                                               {\n        super(message);\n    }", "signature": "DuplicateTypeNameException(String message)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/Expression.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n@API(status = API.Status.STABLE)\npublic interface Expression {\n    List<Argument<?>> match(String text, Type... typeHints);\n\n    Pattern getRegexp();\n\n    String getSource();\n}\n", "file_hash": "fe0f57b0e4521b4b228af4fd35e5ae7697d7050d9e3433f66924cb98771804e8", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.lang.reflect.Type;", "import java.util.List;", "import java.util.Set;", "import java.util.regex.Pattern;"], "methods": [], "classes": [], "interfaces": [{"original_string": "@API(status = API.Status.STABLE)\npublic interface Expression {\n    List<Argument<?>> match(String text, Type... typeHints);\n\n    Pattern getRegexp();\n\n    String getSource();\n}", "definition": "@API(status = API.Status.STABLE)\npublic interface Expression", "interface_docstring": "", "name": "Expression", "extends_interfaces": [], "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    List<Argument<?>> match(String text, Type... typeHints);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Argument<?>>", "classes": []}, "name": "match", "params": [{"name": "text", "type": "String"}], "body": "", "signature": "List<Argument<?>> match(String text, Type... typeHints)"}, {"syntax_pass": true, "original_string": "    Pattern getRegexp();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Pattern", "classes": []}, "name": "getRegexp", "params": [], "body": "", "signature": "Pattern getRegexp()"}, {"syntax_pass": true, "original_string": "    String getSource();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "getSource", "params": [], "body": "", "signature": "String getSource()"}]}], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/Argument.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@API(status = API.Status.STABLE)\npublic final class Argument<T> {\n    private final ParameterType<T> parameterType;\n    private final Group group;\n\n    static List<Argument<?>> build(Group group, List<ParameterType<?>> parameterTypes) {\n        List<Group> argGroups = group.getChildren();\n\n        if (argGroups.size() != parameterTypes.size()) {\n            // This requires regex injection through a Cucumber expression.\n            // Regex injection should be be possible any more.\n            throw new IllegalArgumentException(String.format(\"Group has %s capture groups, but there were %s parameter types\", argGroups.size(), parameterTypes.size()));\n        }\n        List<Argument<?>> args = new ArrayList<>(argGroups.size());\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            Group argGroup = argGroups.get(i);\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            args.add(new Argument<>(argGroup, parameterType));\n        }\n\n        return args;\n    }\n\n    private Argument(Group group, ParameterType<T> parameterType) {\n        this.group = group;\n        this.parameterType = parameterType;\n    }\n\n    public Group getGroup() {\n        return group;\n    }\n\n    public T getValue() {\n        return parameterType.transform(group.getValues());\n    }\n\n    public Type getType() {\n        return parameterType.getType();\n    }\n\n    public ParameterType<T> getParameterType() {\n        return parameterType;\n    }\n}\n", "file_hash": "0c32e9bcfebceb922c8335d0ddb97af735e642f26886d2d1d2c841091a3b7a45", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.lang.reflect.Type;", "import java.util.ArrayList;", "import java.util.List;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic final class Argument<T> {\n    private final ParameterType<T> parameterType;\n    private final Group group;\n\n    static List<Argument<?>> build(Group group, List<ParameterType<?>> parameterTypes) {\n        List<Group> argGroups = group.getChildren();\n\n        if (argGroups.size() != parameterTypes.size()) {\n            // This requires regex injection through a Cucumber expression.\n            // Regex injection should be be possible any more.\n            throw new IllegalArgumentException(String.format(\"Group has %s capture groups, but there were %s parameter types\", argGroups.size(), parameterTypes.size()));\n        }\n        List<Argument<?>> args = new ArrayList<>(argGroups.size());\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            Group argGroup = argGroups.get(i);\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            args.add(new Argument<>(argGroup, parameterType));\n        }\n\n        return args;\n    }\n\n    private Argument(Group group, ParameterType<T> parameterType) {\n        this.group = group;\n        this.parameterType = parameterType;\n    }\n\n    public Group getGroup() {\n        return group;\n    }\n\n    public T getValue() {\n        return parameterType.transform(group.getValues());\n    }\n\n    public Type getType() {\n        return parameterType.getType();\n    }\n\n    public ParameterType<T> getParameterType() {\n        return parameterType;\n    }\n}", "definition": "@API(status = API.Status.STABLE)\npublic final class Argument<T>", "class_docstring": "", "name": "Argument", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic final", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public", "final"], "comments": [], "fields": [{"attribute_expression": "private final ParameterType<T> parameterType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterType<T>", "name": "parameterType", "syntax_pass": true}, {"attribute_expression": "private final Group group;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Group", "name": "group", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    static List<Argument<?>> build(Group group, List<ParameterType<?>> parameterTypes) {\n        List<Group> argGroups = group.getChildren();\n\n        if (argGroups.size() != parameterTypes.size()) {\n            // This requires regex injection through a Cucumber expression.\n            // Regex injection should be be possible any more.\n            throw new IllegalArgumentException(String.format(\"Group has %s capture groups, but there were %s parameter types\", argGroups.size(), parameterTypes.size()));\n        }\n        List<Argument<?>> args = new ArrayList<>(argGroups.size());\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            Group argGroup = argGroups.get(i);\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            args.add(new Argument<>(argGroup, parameterType));\n        }\n\n        return args;\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "List<Argument<?>>", "classes": []}, "name": "build", "params": [{"name": "group", "type": "Group"}, {"name": "parameterTypes", "type": "List<ParameterType<?>>"}], "body": "                                                                                       {\n        List<Group> argGroups = group.getChildren();\n\n        if (argGroups.size() != parameterTypes.size()) {\n            // This requires regex injection through a Cucumber expression.\n            // Regex injection should be be possible any more.\n            throw new IllegalArgumentException(String.format(\"Group has %s capture groups, but there were %s parameter types\", argGroups.size(), parameterTypes.size()));\n        }\n        List<Argument<?>> args = new ArrayList<>(argGroups.size());\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            Group argGroup = argGroups.get(i);\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            args.add(new Argument<>(argGroup, parameterType));\n        }\n\n        return args;\n    }", "signature": "static List<Argument<?>> build(Group group, List<ParameterType<?>> parameterTypes)"}, {"syntax_pass": true, "original_string": "    private Argument(Group group, ParameterType<T> parameterType) {\n        this.group = group;\n        this.parameterType = parameterType;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Argument", "params": [{"name": "group", "type": "Group"}, {"name": "parameterType", "type": "ParameterType<T>"}], "body": "                                                                  {\n        this.group = group;\n        this.parameterType = parameterType;\n    }", "signature": "private Argument(Group group, ParameterType<T> parameterType)"}, {"syntax_pass": true, "original_string": "    public Group getGroup() {\n        return group;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Group", "classes": []}, "name": "getGroup", "params": [], "body": "                            {\n        return group;\n    }", "signature": "public Group getGroup()"}, {"syntax_pass": true, "original_string": "    public T getValue() {\n        return parameterType.transform(group.getValues());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getValue", "params": [], "body": "                        {\n        return parameterType.transform(group.getValues());\n    }", "signature": "public T getValue()"}, {"syntax_pass": true, "original_string": "    public Type getType() {\n        return parameterType.getType();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "getType", "params": [], "body": "                          {\n        return parameterType.getType();\n    }", "signature": "public Type getType()"}, {"syntax_pass": true, "original_string": "    public ParameterType<T> getParameterType() {\n        return parameterType;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ParameterType<T>", "classes": []}, "name": "getParameterType", "params": [], "body": "                                               {\n        return parameterType;\n    }", "signature": "public ParameterType<T> getParameterType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.List;\n\nfinal class CombinatorialGeneratedExpressionFactory {\n    // 256 generated expressions ought to be enough for anybody\n    private static final int MAX_EXPRESSIONS = 256;\n    private final String expressionTemplate;\n    private final List<List<ParameterType<?>>> parameterTypeCombinations;\n\n    CombinatorialGeneratedExpressionFactory(\n            String expressionTemplate,\n            List<List<ParameterType<?>>> parameterTypeCombinations) {\n\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypeCombinations = parameterTypeCombinations;\n    }\n\n    List<GeneratedExpression> generateExpressions() {\n        List<GeneratedExpression> generatedExpressions = new ArrayList<>();\n        ArrayDeque<ParameterType<?>> permutation = new ArrayDeque<>(parameterTypeCombinations.size());\n        generatePermutations(generatedExpressions, permutation);\n        return generatedExpressions;\n    }\n\n    private void generatePermutations(\n            List<GeneratedExpression> generatedExpressions,\n            Deque<ParameterType<?>> permutation\n    ) {\n        if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n            return;\n        }\n\n        if (permutation.size() == parameterTypeCombinations.size()) {\n            ArrayList<ParameterType<?>> permutationCopy = new ArrayList<>(permutation);\n            generatedExpressions.add(new GeneratedExpression(expressionTemplate, permutationCopy));\n            return;\n        }\n\n        List<ParameterType<?>> parameterTypes = parameterTypeCombinations.get(permutation.size());\n        for (ParameterType<?> parameterType : parameterTypes) {\n            // Avoid recursion if no elements can be added.\n            if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n                return;\n            }\n            permutation.addLast(parameterType);\n            generatePermutations(generatedExpressions, permutation);\n            permutation.removeLast();\n        }\n    }\n}\n", "file_hash": "3bbc4b21960fe78c1aded06d50938fa70be2262da0aa97f9f5b2911d2a7afdb5", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import java.util.ArrayDeque;", "import java.util.ArrayList;", "import java.util.Deque;", "import java.util.List;"], "methods": [], "classes": [{"original_string": "final class CombinatorialGeneratedExpressionFactory {\n    // 256 generated expressions ought to be enough for anybody\n    private static final int MAX_EXPRESSIONS = 256;\n    private final String expressionTemplate;\n    private final List<List<ParameterType<?>>> parameterTypeCombinations;\n\n    CombinatorialGeneratedExpressionFactory(\n            String expressionTemplate,\n            List<List<ParameterType<?>>> parameterTypeCombinations) {\n\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypeCombinations = parameterTypeCombinations;\n    }\n\n    List<GeneratedExpression> generateExpressions() {\n        List<GeneratedExpression> generatedExpressions = new ArrayList<>();\n        ArrayDeque<ParameterType<?>> permutation = new ArrayDeque<>(parameterTypeCombinations.size());\n        generatePermutations(generatedExpressions, permutation);\n        return generatedExpressions;\n    }\n\n    private void generatePermutations(\n            List<GeneratedExpression> generatedExpressions,\n            Deque<ParameterType<?>> permutation\n    ) {\n        if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n            return;\n        }\n\n        if (permutation.size() == parameterTypeCombinations.size()) {\n            ArrayList<ParameterType<?>> permutationCopy = new ArrayList<>(permutation);\n            generatedExpressions.add(new GeneratedExpression(expressionTemplate, permutationCopy));\n            return;\n        }\n\n        List<ParameterType<?>> parameterTypes = parameterTypeCombinations.get(permutation.size());\n        for (ParameterType<?> parameterType : parameterTypes) {\n            // Avoid recursion if no elements can be added.\n            if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n                return;\n            }\n            permutation.addLast(parameterType);\n            generatePermutations(generatedExpressions, permutation);\n            permutation.removeLast();\n        }\n    }\n}", "definition": "final class CombinatorialGeneratedExpressionFactory", "class_docstring": "", "name": "CombinatorialGeneratedExpressionFactory", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private static final int MAX_EXPRESSIONS = 256;", "docstring": " 256 generated expressions ought to be enough for anybody", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "MAX_EXPRESSIONS = 256", "syntax_pass": true}, {"attribute_expression": "private final String expressionTemplate;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "expressionTemplate", "syntax_pass": true}, {"attribute_expression": "private final List<List<ParameterType<?>>> parameterTypeCombinations;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<List<ParameterType<?>>>", "name": "parameterTypeCombinations", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    CombinatorialGeneratedExpressionFactory(\n            String expressionTemplate,\n            List<List<ParameterType<?>>> parameterTypeCombinations) {\n\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypeCombinations = parameterTypeCombinations;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CombinatorialGeneratedExpressionFactory", "params": [{"name": "expressionTemplate", "type": "String"}, {"name": "parameterTypeCombinations", "type": "List<List<ParameterType<?>>>"}], "body": "                                                                    {\n\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypeCombinations = parameterTypeCombinations;\n    }", "signature": "CombinatorialGeneratedExpressionFactory(\n            String expressionTemplate,\n            List<List<ParameterType<?>>> parameterTypeCombinations)"}, {"syntax_pass": true, "original_string": "    List<GeneratedExpression> generateExpressions() {\n        List<GeneratedExpression> generatedExpressions = new ArrayList<>();\n        ArrayDeque<ParameterType<?>> permutation = new ArrayDeque<>(parameterTypeCombinations.size());\n        generatePermutations(generatedExpressions, permutation);\n        return generatedExpressions;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<GeneratedExpression>", "classes": []}, "name": "generateExpressions", "params": [], "body": "                                                    {\n        List<GeneratedExpression> generatedExpressions = new ArrayList<>();\n        ArrayDeque<ParameterType<?>> permutation = new ArrayDeque<>(parameterTypeCombinations.size());\n        generatePermutations(generatedExpressions, permutation);\n        return generatedExpressions;\n    }", "signature": "List<GeneratedExpression> generateExpressions()"}, {"syntax_pass": true, "original_string": "    private void generatePermutations(\n            List<GeneratedExpression> generatedExpressions,\n            Deque<ParameterType<?>> permutation\n    ) {\n        if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n            return;\n        }\n\n        if (permutation.size() == parameterTypeCombinations.size()) {\n            ArrayList<ParameterType<?>> permutationCopy = new ArrayList<>(permutation);\n            generatedExpressions.add(new GeneratedExpression(expressionTemplate, permutationCopy));\n            return;\n        }\n\n        List<ParameterType<?>> parameterTypes = parameterTypeCombinations.get(permutation.size());\n        for (ParameterType<?> parameterType : parameterTypes) {\n            // Avoid recursion if no elements can be added.\n            if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n                return;\n            }\n            permutation.addLast(parameterType);\n            generatePermutations(generatedExpressions, permutation);\n            permutation.removeLast();\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "generatePermutations", "params": [{"name": "generatedExpressions", "type": "List<GeneratedExpression>"}, {"name": "permutation", "type": "Deque<ParameterType<?>>"}], "body": "      {\n        if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n            return;\n        }\n\n        if (permutation.size() == parameterTypeCombinations.size()) {\n            ArrayList<ParameterType<?>> permutationCopy = new ArrayList<>(permutation);\n            generatedExpressions.add(new GeneratedExpression(expressionTemplate, permutationCopy));\n            return;\n        }\n\n        List<ParameterType<?>> parameterTypes = parameterTypeCombinations.get(permutation.size());\n        for (ParameterType<?> parameterType : parameterTypes) {\n            // Avoid recursion if no elements can be added.\n            if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n                return;\n            }\n            permutation.addLast(parameterType);\n            generatePermutations(generatedExpressions, permutation);\n            permutation.removeLast();\n        }\n    }", "signature": "private void generatePermutations(\n            List<GeneratedExpression> generatedExpressions,\n            Deque<ParameterType<?>> permutation\n    )"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/ParameterByTypeTransformer.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.lang.reflect.Type;\n\n/**\n * The {@link ParameterTypeRegistry} uses the default transformer\n * to execute all transforms for built-in parameter types and all\n * anonymous types.\n */\n@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic interface ParameterByTypeTransformer {\n\n    Object transform(String fromValue, Type toValueType) throws Throwable;\n}\n", "file_hash": "ddaf19732097491b747bcc119c9a3c814077accd753bd0af8d3edfc512a72910", "file_docstring": "\nThe {@link ParameterTypeRegistry} uses the default transformer\nto execute all transforms for built-in parameter types and all\nanonymous types.\n", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.lang.reflect.Type;"], "methods": [], "classes": [], "interfaces": [{"original_string": "@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic interface ParameterByTypeTransformer {\n\n    Object transform(String fromValue, Type toValueType) throws Throwable;\n}", "definition": "@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic interface ParameterByTypeTransformer", "interface_docstring": "\nThe {@link ParameterTypeRegistry} uses the default transformer\nto execute all transforms for built-in parameter types and all\nanonymous types.\n", "name": "ParameterByTypeTransformer", "extends_interfaces": [], "attributes": {"modifiers": "@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic", "marker_annotations": ["@FunctionalInterface"], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Object transform(String fromValue, Type toValueType) throws Throwable;", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Object", "classes": []}, "name": "transform", "params": [{"name": "fromValue", "type": "String"}, {"name": "toValueType", "type": "Type"}], "body": "", "signature": "Object transform(String fromValue, Type toValueType)"}]}], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n@API(status = API.Status.STABLE)\npublic final class CucumberExpressionGenerator {\n    private final ParameterTypeRegistry parameterTypeRegistry;\n\n    public CucumberExpressionGenerator(ParameterTypeRegistry parameterTypeRegistry) {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }\n\n    public List<GeneratedExpression> generateExpressions(String text) {\n        List<List<ParameterType<?>>> parameterTypeCombinations = new ArrayList<>();\n        List<ParameterTypeMatcher> parameterTypeMatchers = createParameterTypeMatchers(text);\n        StringBuilder expressionTemplate = new StringBuilder();\n        int pos = 0;\n        while (true) {\n            List<ParameterTypeMatcher> matchingParameterTypeMatchers = new ArrayList<>();\n\n            for (ParameterTypeMatcher parameterTypeMatcher : parameterTypeMatchers) {\n                if (parameterTypeMatcher.advanceToAndFind(pos)) {\n                    matchingParameterTypeMatchers.add(parameterTypeMatcher);\n                }\n            }\n\n            if (!matchingParameterTypeMatchers.isEmpty()) {\n                Collections.sort(matchingParameterTypeMatchers);\n\n                // Find all the best parameter type matchers, they are all candidates.\n                ParameterTypeMatcher bestParameterTypeMatcher = matchingParameterTypeMatchers.get(0);\n                List<ParameterTypeMatcher> bestParameterTypeMatchers = new ArrayList<>();\n                for (ParameterTypeMatcher m : matchingParameterTypeMatchers) {\n                    if (m.compareTo(bestParameterTypeMatcher) == 0) {\n                        bestParameterTypeMatchers.add(m);\n                    }\n                }\n\n                // Build a list of parameter types without duplicates. The reason there\n                // might be duplicates is that some parameter types have more than one regexp,\n                // which means multiple ParameterTypeMatcher objects will have a reference to the\n                // same ParameterType.\n                // We're sorting the list so preferential parameter types are listed first.\n                // Users are most likely to want these, so they should be listed at the top.\n                Set<ParameterType<?>> set = new HashSet<>();\n                for (ParameterTypeMatcher parameterTypeMatcher : bestParameterTypeMatchers) {\n                    ParameterType<?> parameterType = parameterTypeMatcher.getParameterType();\n                    set.add(parameterType);\n                }\n                SortedSet<ParameterType<?>> parameterTypes = new TreeSet<>(set);\n\n                parameterTypeCombinations.add(new ArrayList<>(parameterTypes));\n\n                expressionTemplate\n                        .append(escape(text.substring(pos, bestParameterTypeMatcher.start())))\n                        .append(\"{%s}\");\n                pos = bestParameterTypeMatcher.start() + bestParameterTypeMatcher.group().length();\n            } else {\n                break;\n            }\n\n            if (pos >= text.length()) {\n                break;\n            }\n        }\n        expressionTemplate.append(escape(text.substring(pos)));\n        return new CombinatorialGeneratedExpressionFactory(expressionTemplate.toString(), parameterTypeCombinations).generateExpressions();\n    }\n\n    private String escape(String s) {\n        return s.replaceAll(\"%\", \"%%\") // Escape for String.format\n                .replaceAll(\"\\\\(\", \"\\\\\\\\(\")\n                .replaceAll(\"\\\\{\", \"\\\\\\\\{\")\n                .replaceAll(\"/\", \"\\\\\\\\/\");\n    }\n\n    private List<ParameterTypeMatcher> createParameterTypeMatchers(String text) {\n        Collection<ParameterType<?>> parameterTypes = parameterTypeRegistry.getParameterTypes();\n        List<ParameterTypeMatcher> parameterTypeMatchers = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            if (parameterType.useForSnippets()) {\n                parameterTypeMatchers.addAll(createParameterTypeMatchers(parameterType, text));\n            }\n        }\n        return parameterTypeMatchers;\n    }\n\n    private static List<ParameterTypeMatcher> createParameterTypeMatchers(ParameterType<?> parameterType, String text) {\n        List<ParameterTypeMatcher> result = new ArrayList<>();\n        List<String> captureGroupRegexps = parameterType.getRegexps();\n        for (String captureGroupRegexp : captureGroupRegexps) {\n            Pattern regexp = Pattern.compile(\"(\" + captureGroupRegexp + \")\");\n            Matcher matcher = regexp.matcher(text);\n            result.add(new ParameterTypeMatcher(parameterType, matcher, text));\n        }\n        return result;\n    }\n\n}\n", "file_hash": "5e43767866d6bfc7fd8b9db0ac8d16da5a0df0cf949c0de41775a5ffebe69fcb", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.HashSet;", "import java.util.List;", "import java.util.Set;", "import java.util.SortedSet;", "import java.util.TreeSet;", "import java.util.regex.Matcher;", "import java.util.regex.Pattern;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic final class CucumberExpressionGenerator {\n    private final ParameterTypeRegistry parameterTypeRegistry;\n\n    public CucumberExpressionGenerator(ParameterTypeRegistry parameterTypeRegistry) {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }\n\n    public List<GeneratedExpression> generateExpressions(String text) {\n        List<List<ParameterType<?>>> parameterTypeCombinations = new ArrayList<>();\n        List<ParameterTypeMatcher> parameterTypeMatchers = createParameterTypeMatchers(text);\n        StringBuilder expressionTemplate = new StringBuilder();\n        int pos = 0;\n        while (true) {\n            List<ParameterTypeMatcher> matchingParameterTypeMatchers = new ArrayList<>();\n\n            for (ParameterTypeMatcher parameterTypeMatcher : parameterTypeMatchers) {\n                if (parameterTypeMatcher.advanceToAndFind(pos)) {\n                    matchingParameterTypeMatchers.add(parameterTypeMatcher);\n                }\n            }\n\n            if (!matchingParameterTypeMatchers.isEmpty()) {\n                Collections.sort(matchingParameterTypeMatchers);\n\n                // Find all the best parameter type matchers, they are all candidates.\n                ParameterTypeMatcher bestParameterTypeMatcher = matchingParameterTypeMatchers.get(0);\n                List<ParameterTypeMatcher> bestParameterTypeMatchers = new ArrayList<>();\n                for (ParameterTypeMatcher m : matchingParameterTypeMatchers) {\n                    if (m.compareTo(bestParameterTypeMatcher) == 0) {\n                        bestParameterTypeMatchers.add(m);\n                    }\n                }\n\n                // Build a list of parameter types without duplicates. The reason there\n                // might be duplicates is that some parameter types have more than one regexp,\n                // which means multiple ParameterTypeMatcher objects will have a reference to the\n                // same ParameterType.\n                // We're sorting the list so preferential parameter types are listed first.\n                // Users are most likely to want these, so they should be listed at the top.\n                Set<ParameterType<?>> set = new HashSet<>();\n                for (ParameterTypeMatcher parameterTypeMatcher : bestParameterTypeMatchers) {\n                    ParameterType<?> parameterType = parameterTypeMatcher.getParameterType();\n                    set.add(parameterType);\n                }\n                SortedSet<ParameterType<?>> parameterTypes = new TreeSet<>(set);\n\n                parameterTypeCombinations.add(new ArrayList<>(parameterTypes));\n\n                expressionTemplate\n                        .append(escape(text.substring(pos, bestParameterTypeMatcher.start())))\n                        .append(\"{%s}\");\n                pos = bestParameterTypeMatcher.start() + bestParameterTypeMatcher.group().length();\n            } else {\n                break;\n            }\n\n            if (pos >= text.length()) {\n                break;\n            }\n        }\n        expressionTemplate.append(escape(text.substring(pos)));\n        return new CombinatorialGeneratedExpressionFactory(expressionTemplate.toString(), parameterTypeCombinations).generateExpressions();\n    }\n\n    private String escape(String s) {\n        return s.replaceAll(\"%\", \"%%\") // Escape for String.format\n                .replaceAll(\"\\\\(\", \"\\\\\\\\(\")\n                .replaceAll(\"\\\\{\", \"\\\\\\\\{\")\n                .replaceAll(\"/\", \"\\\\\\\\/\");\n    }\n\n    private List<ParameterTypeMatcher> createParameterTypeMatchers(String text) {\n        Collection<ParameterType<?>> parameterTypes = parameterTypeRegistry.getParameterTypes();\n        List<ParameterTypeMatcher> parameterTypeMatchers = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            if (parameterType.useForSnippets()) {\n                parameterTypeMatchers.addAll(createParameterTypeMatchers(parameterType, text));\n            }\n        }\n        return parameterTypeMatchers;\n    }\n\n    private static List<ParameterTypeMatcher> createParameterTypeMatchers(ParameterType<?> parameterType, String text) {\n        List<ParameterTypeMatcher> result = new ArrayList<>();\n        List<String> captureGroupRegexps = parameterType.getRegexps();\n        for (String captureGroupRegexp : captureGroupRegexps) {\n            Pattern regexp = Pattern.compile(\"(\" + captureGroupRegexp + \")\");\n            Matcher matcher = regexp.matcher(text);\n            result.add(new ParameterTypeMatcher(parameterType, matcher, text));\n        }\n        return result;\n    }\n\n}", "definition": "@API(status = API.Status.STABLE)\npublic final class CucumberExpressionGenerator", "class_docstring": "", "name": "CucumberExpressionGenerator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic final", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public", "final"], "comments": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public CucumberExpressionGenerator(ParameterTypeRegistry parameterTypeRegistry) {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "CucumberExpressionGenerator", "params": [{"name": "parameterTypeRegistry", "type": "ParameterTypeRegistry"}], "body": "                                                                                    {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }", "signature": "public CucumberExpressionGenerator(ParameterTypeRegistry parameterTypeRegistry)"}, {"syntax_pass": true, "original_string": "    public List<GeneratedExpression> generateExpressions(String text) {\n        List<List<ParameterType<?>>> parameterTypeCombinations = new ArrayList<>();\n        List<ParameterTypeMatcher> parameterTypeMatchers = createParameterTypeMatchers(text);\n        StringBuilder expressionTemplate = new StringBuilder();\n        int pos = 0;\n        while (true) {\n            List<ParameterTypeMatcher> matchingParameterTypeMatchers = new ArrayList<>();\n\n            for (ParameterTypeMatcher parameterTypeMatcher : parameterTypeMatchers) {\n                if (parameterTypeMatcher.advanceToAndFind(pos)) {\n                    matchingParameterTypeMatchers.add(parameterTypeMatcher);\n                }\n            }\n\n            if (!matchingParameterTypeMatchers.isEmpty()) {\n                Collections.sort(matchingParameterTypeMatchers);\n\n                // Find all the best parameter type matchers, they are all candidates.\n                ParameterTypeMatcher bestParameterTypeMatcher = matchingParameterTypeMatchers.get(0);\n                List<ParameterTypeMatcher> bestParameterTypeMatchers = new ArrayList<>();\n                for (ParameterTypeMatcher m : matchingParameterTypeMatchers) {\n                    if (m.compareTo(bestParameterTypeMatcher) == 0) {\n                        bestParameterTypeMatchers.add(m);\n                    }\n                }\n\n                // Build a list of parameter types without duplicates. The reason there\n                // might be duplicates is that some parameter types have more than one regexp,\n                // which means multiple ParameterTypeMatcher objects will have a reference to the\n                // same ParameterType.\n                // We're sorting the list so preferential parameter types are listed first.\n                // Users are most likely to want these, so they should be listed at the top.\n                Set<ParameterType<?>> set = new HashSet<>();\n                for (ParameterTypeMatcher parameterTypeMatcher : bestParameterTypeMatchers) {\n                    ParameterType<?> parameterType = parameterTypeMatcher.getParameterType();\n                    set.add(parameterType);\n                }\n                SortedSet<ParameterType<?>> parameterTypes = new TreeSet<>(set);\n\n                parameterTypeCombinations.add(new ArrayList<>(parameterTypes));\n\n                expressionTemplate\n                        .append(escape(text.substring(pos, bestParameterTypeMatcher.start())))\n                        .append(\"{%s}\");\n                pos = bestParameterTypeMatcher.start() + bestParameterTypeMatcher.group().length();\n            } else {\n                break;\n            }\n\n            if (pos >= text.length()) {\n                break;\n            }\n        }\n        expressionTemplate.append(escape(text.substring(pos)));\n        return new CombinatorialGeneratedExpressionFactory(expressionTemplate.toString(), parameterTypeCombinations).generateExpressions();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<GeneratedExpression>", "classes": []}, "name": "generateExpressions", "params": [{"name": "text", "type": "String"}], "body": "                                                                      {\n        List<List<ParameterType<?>>> parameterTypeCombinations = new ArrayList<>();\n        List<ParameterTypeMatcher> parameterTypeMatchers = createParameterTypeMatchers(text);\n        StringBuilder expressionTemplate = new StringBuilder();\n        int pos = 0;\n        while (true) {\n            List<ParameterTypeMatcher> matchingParameterTypeMatchers = new ArrayList<>();\n\n            for (ParameterTypeMatcher parameterTypeMatcher : parameterTypeMatchers) {\n                if (parameterTypeMatcher.advanceToAndFind(pos)) {\n                    matchingParameterTypeMatchers.add(parameterTypeMatcher);\n                }\n            }\n\n            if (!matchingParameterTypeMatchers.isEmpty()) {\n                Collections.sort(matchingParameterTypeMatchers);\n\n                // Find all the best parameter type matchers, they are all candidates.\n                ParameterTypeMatcher bestParameterTypeMatcher = matchingParameterTypeMatchers.get(0);\n                List<ParameterTypeMatcher> bestParameterTypeMatchers = new ArrayList<>();\n                for (ParameterTypeMatcher m : matchingParameterTypeMatchers) {\n                    if (m.compareTo(bestParameterTypeMatcher) == 0) {\n                        bestParameterTypeMatchers.add(m);\n                    }\n                }\n\n                // Build a list of parameter types without duplicates. The reason there\n                // might be duplicates is that some parameter types have more than one regexp,\n                // which means multiple ParameterTypeMatcher objects will have a reference to the\n                // same ParameterType.\n                // We're sorting the list so preferential parameter types are listed first.\n                // Users are most likely to want these, so they should be listed at the top.\n                Set<ParameterType<?>> set = new HashSet<>();\n                for (ParameterTypeMatcher parameterTypeMatcher : bestParameterTypeMatchers) {\n                    ParameterType<?> parameterType = parameterTypeMatcher.getParameterType();\n                    set.add(parameterType);\n                }\n                SortedSet<ParameterType<?>> parameterTypes = new TreeSet<>(set);\n\n                parameterTypeCombinations.add(new ArrayList<>(parameterTypes));\n\n                expressionTemplate\n                        .append(escape(text.substring(pos, bestParameterTypeMatcher.start())))\n                        .append(\"{%s}\");\n                pos = bestParameterTypeMatcher.start() + bestParameterTypeMatcher.group().length();\n            } else {\n                break;\n            }\n\n            if (pos >= text.length()) {\n                break;\n            }\n        }\n        expressionTemplate.append(escape(text.substring(pos)));\n        return new CombinatorialGeneratedExpressionFactory(expressionTemplate.toString(), parameterTypeCombinations).generateExpressions();\n    }", "signature": "public List<GeneratedExpression> generateExpressions(String text)"}, {"syntax_pass": true, "original_string": "    private String escape(String s) {\n        return s.replaceAll(\"%\", \"%%\") // Escape for String.format\n                .replaceAll(\"\\\\(\", \"\\\\\\\\(\")\n                .replaceAll(\"\\\\{\", \"\\\\\\\\{\")\n                .replaceAll(\"/\", \"\\\\\\\\/\");\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "escape", "params": [{"name": "s", "type": "String"}], "body": "                                    {\n        return s.replaceAll(\"%\", \"%%\") // Escape for String.format\n                .replaceAll(\"\\\\(\", \"\\\\\\\\(\")\n                .replaceAll(\"\\\\{\", \"\\\\\\\\{\")\n                .replaceAll(\"/\", \"\\\\\\\\/\");\n    }", "signature": "private String escape(String s)"}, {"syntax_pass": true, "original_string": "    private List<ParameterTypeMatcher> createParameterTypeMatchers(String text) {\n        Collection<ParameterType<?>> parameterTypes = parameterTypeRegistry.getParameterTypes();\n        List<ParameterTypeMatcher> parameterTypeMatchers = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            if (parameterType.useForSnippets()) {\n                parameterTypeMatchers.addAll(createParameterTypeMatchers(parameterType, text));\n            }\n        }\n        return parameterTypeMatchers;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<ParameterTypeMatcher>", "classes": []}, "name": "createParameterTypeMatchers", "params": [{"name": "text", "type": "String"}], "body": "                                                                                {\n        Collection<ParameterType<?>> parameterTypes = parameterTypeRegistry.getParameterTypes();\n        List<ParameterTypeMatcher> parameterTypeMatchers = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            if (parameterType.useForSnippets()) {\n                parameterTypeMatchers.addAll(createParameterTypeMatchers(parameterType, text));\n            }\n        }\n        return parameterTypeMatchers;\n    }", "signature": "private List<ParameterTypeMatcher> createParameterTypeMatchers(String text)"}, {"syntax_pass": true, "original_string": "    private static List<ParameterTypeMatcher> createParameterTypeMatchers(ParameterType<?> parameterType, String text) {\n        List<ParameterTypeMatcher> result = new ArrayList<>();\n        List<String> captureGroupRegexps = parameterType.getRegexps();\n        for (String captureGroupRegexp : captureGroupRegexps) {\n            Pattern regexp = Pattern.compile(\"(\" + captureGroupRegexp + \")\");\n            Matcher matcher = regexp.matcher(text);\n            result.add(new ParameterTypeMatcher(parameterType, matcher, text));\n        }\n        return result;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<ParameterTypeMatcher>", "classes": []}, "name": "createParameterTypeMatchers", "params": [{"name": "parameterType", "type": "ParameterType<?>"}, {"name": "text", "type": "String"}], "body": "                                                                                                                       {\n        List<ParameterTypeMatcher> result = new ArrayList<>();\n        List<String> captureGroupRegexps = parameterType.getRegexps();\n        for (String captureGroupRegexp : captureGroupRegexps) {\n            Pattern regexp = Pattern.compile(\"(\" + captureGroupRegexp + \")\");\n            Matcher matcher = regexp.matcher(text);\n            result.add(new ParameterTypeMatcher(parameterType, matcher, text));\n        }\n        return result;\n    }", "signature": "private static List<ParameterTypeMatcher> createParameterTypeMatchers(ParameterType<?> parameterType, String text)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.regex.Pattern;\n\n@API(status = API.Status.STABLE)\npublic final class AmbiguousParameterTypeException extends CucumberExpressionException {\n    private final Pattern regexp;\n    private final String parameterTypeRegexp;\n    private final SortedSet<ParameterType<?>> parameterTypes;\n    private final List<GeneratedExpression> generatedExpressions;\n\n    AmbiguousParameterTypeException(String parameterTypeRegexp, Pattern expressionRegexp, SortedSet<ParameterType<?>> parameterTypes, List<GeneratedExpression> generatedExpressions) {\n        super(String.format(\"Your Regular Expression /%s/\\n\" +\n                        \"matches multiple parameter types with regexp /%s/:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"I couldn't decide which one to use. You have two options:\\n\" +\n                        \"\\n\" +\n                        \"1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"2) Make one of the parameter types preferential and continue to use a Regular Expression.\\n\" +\n                        \"\\n\",\n                expressionRegexp.pattern(),\n                parameterTypeRegexp,\n                parameterTypeNames(parameterTypes),\n                expressions(generatedExpressions)\n        ));\n        this.regexp = expressionRegexp;\n        this.parameterTypeRegexp = parameterTypeRegexp;\n        this.parameterTypes = parameterTypes;\n        this.generatedExpressions = generatedExpressions;\n    }\n\n    private static String parameterTypeNames(SortedSet<ParameterType<?>> parameterTypes) {\n\n        List<String> parameterNames = new ArrayList<>();\n        for (ParameterType<?> p : parameterTypes) {\n            String s = \"{\" + p.getName() + \"}\";\n            parameterNames.add(s);\n        }\n        return join(parameterNames);\n    }\n\n    private static String expressions(List<GeneratedExpression> generatedExpressions) {\n        List<String> sources = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            sources.add(source);\n        }\n        return join(sources);\n    }\n\n    private static String join(List<String> strings) {\n        StringBuilder builder = new StringBuilder();\n        boolean first = true;\n        for (String element : strings) {\n            if (first) {\n                first = false;\n            } else {\n                builder.append(\"\\n   \");\n            }\n            builder.append(element);\n        }\n\n        return builder.toString();\n    }\n\n    public Pattern getRegexp() {\n        return regexp;\n    }\n\n    public String getParameterTypeRegexp() {\n        return parameterTypeRegexp;\n    }\n\n    public SortedSet<ParameterType<?>> getParameterTypes() {\n        return parameterTypes;\n    }\n\n    public List<GeneratedExpression> getGeneratedExpressions() {\n        return generatedExpressions;\n    }\n}\n", "file_hash": "0b8a48391f62baef8b158c3bd35a32e7eae96c017cb0bfadc3c916352a855934", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.SortedSet;", "import java.util.regex.Pattern;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic final class AmbiguousParameterTypeException extends CucumberExpressionException {\n    private final Pattern regexp;\n    private final String parameterTypeRegexp;\n    private final SortedSet<ParameterType<?>> parameterTypes;\n    private final List<GeneratedExpression> generatedExpressions;\n\n    AmbiguousParameterTypeException(String parameterTypeRegexp, Pattern expressionRegexp, SortedSet<ParameterType<?>> parameterTypes, List<GeneratedExpression> generatedExpressions) {\n        super(String.format(\"Your Regular Expression /%s/\\n\" +\n                        \"matches multiple parameter types with regexp /%s/:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"I couldn't decide which one to use. You have two options:\\n\" +\n                        \"\\n\" +\n                        \"1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"2) Make one of the parameter types preferential and continue to use a Regular Expression.\\n\" +\n                        \"\\n\",\n                expressionRegexp.pattern(),\n                parameterTypeRegexp,\n                parameterTypeNames(parameterTypes),\n                expressions(generatedExpressions)\n        ));\n        this.regexp = expressionRegexp;\n        this.parameterTypeRegexp = parameterTypeRegexp;\n        this.parameterTypes = parameterTypes;\n        this.generatedExpressions = generatedExpressions;\n    }\n\n    private static String parameterTypeNames(SortedSet<ParameterType<?>> parameterTypes) {\n\n        List<String> parameterNames = new ArrayList<>();\n        for (ParameterType<?> p : parameterTypes) {\n            String s = \"{\" + p.getName() + \"}\";\n            parameterNames.add(s);\n        }\n        return join(parameterNames);\n    }\n\n    private static String expressions(List<GeneratedExpression> generatedExpressions) {\n        List<String> sources = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            sources.add(source);\n        }\n        return join(sources);\n    }\n\n    private static String join(List<String> strings) {\n        StringBuilder builder = new StringBuilder();\n        boolean first = true;\n        for (String element : strings) {\n            if (first) {\n                first = false;\n            } else {\n                builder.append(\"\\n   \");\n            }\n            builder.append(element);\n        }\n\n        return builder.toString();\n    }\n\n    public Pattern getRegexp() {\n        return regexp;\n    }\n\n    public String getParameterTypeRegexp() {\n        return parameterTypeRegexp;\n    }\n\n    public SortedSet<ParameterType<?>> getParameterTypes() {\n        return parameterTypes;\n    }\n\n    public List<GeneratedExpression> getGeneratedExpressions() {\n        return generatedExpressions;\n    }\n}", "definition": "@API(status = API.Status.STABLE)\npublic final class AmbiguousParameterTypeException extends CucumberExpressionException", "class_docstring": "", "name": "AmbiguousParameterTypeException", "super_interfaces": [], "superclasses": "CucumberExpressionException", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic final", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public", "final"], "comments": [], "fields": [{"attribute_expression": "private final Pattern regexp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pattern", "name": "regexp", "syntax_pass": true}, {"attribute_expression": "private final String parameterTypeRegexp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "parameterTypeRegexp", "syntax_pass": true}, {"attribute_expression": "private final SortedSet<ParameterType<?>> parameterTypes;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SortedSet<ParameterType<?>>", "name": "parameterTypes", "syntax_pass": true}, {"attribute_expression": "private final List<GeneratedExpression> generatedExpressions;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<GeneratedExpression>", "name": "generatedExpressions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    AmbiguousParameterTypeException(String parameterTypeRegexp, Pattern expressionRegexp, SortedSet<ParameterType<?>> parameterTypes, List<GeneratedExpression> generatedExpressions) {\n        super(String.format(\"Your Regular Expression /%s/\\n\" +\n                        \"matches multiple parameter types with regexp /%s/:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"I couldn't decide which one to use. You have two options:\\n\" +\n                        \"\\n\" +\n                        \"1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"2) Make one of the parameter types preferential and continue to use a Regular Expression.\\n\" +\n                        \"\\n\",\n                expressionRegexp.pattern(),\n                parameterTypeRegexp,\n                parameterTypeNames(parameterTypes),\n                expressions(generatedExpressions)\n        ));\n        this.regexp = expressionRegexp;\n        this.parameterTypeRegexp = parameterTypeRegexp;\n        this.parameterTypes = parameterTypes;\n        this.generatedExpressions = generatedExpressions;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AmbiguousParameterTypeException", "params": [{"name": "parameterTypeRegexp", "type": "String"}, {"name": "expressionRegexp", "type": "Pattern"}, {"name": "parameterTypes", "type": "SortedSet<ParameterType<?>>"}, {"name": "generatedExpressions", "type": "List<GeneratedExpression>"}], "body": "                                                                                                                                                                                      {\n        super(String.format(\"Your Regular Expression /%s/\\n\" +\n                        \"matches multiple parameter types with regexp /%s/:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"I couldn't decide which one to use. You have two options:\\n\" +\n                        \"\\n\" +\n                        \"1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"2) Make one of the parameter types preferential and continue to use a Regular Expression.\\n\" +\n                        \"\\n\",\n                expressionRegexp.pattern(),\n                parameterTypeRegexp,\n                parameterTypeNames(parameterTypes),\n                expressions(generatedExpressions)\n        ));\n        this.regexp = expressionRegexp;\n        this.parameterTypeRegexp = parameterTypeRegexp;\n        this.parameterTypes = parameterTypes;\n        this.generatedExpressions = generatedExpressions;\n    }", "signature": "AmbiguousParameterTypeException(String parameterTypeRegexp, Pattern expressionRegexp, SortedSet<ParameterType<?>> parameterTypes, List<GeneratedExpression> generatedExpressions)"}, {"syntax_pass": true, "original_string": "    private static String parameterTypeNames(SortedSet<ParameterType<?>> parameterTypes) {\n\n        List<String> parameterNames = new ArrayList<>();\n        for (ParameterType<?> p : parameterTypes) {\n            String s = \"{\" + p.getName() + \"}\";\n            parameterNames.add(s);\n        }\n        return join(parameterNames);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "parameterTypeNames", "params": [{"name": "parameterTypes", "type": "SortedSet<ParameterType<?>>"}], "body": "                                                                                         {\n\n        List<String> parameterNames = new ArrayList<>();\n        for (ParameterType<?> p : parameterTypes) {\n            String s = \"{\" + p.getName() + \"}\";\n            parameterNames.add(s);\n        }\n        return join(parameterNames);\n    }", "signature": "private static String parameterTypeNames(SortedSet<ParameterType<?>> parameterTypes)"}, {"syntax_pass": true, "original_string": "    private static String expressions(List<GeneratedExpression> generatedExpressions) {\n        List<String> sources = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            sources.add(source);\n        }\n        return join(sources);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "expressions", "params": [{"name": "generatedExpressions", "type": "List<GeneratedExpression>"}], "body": "                                                                                      {\n        List<String> sources = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            sources.add(source);\n        }\n        return join(sources);\n    }", "signature": "private static String expressions(List<GeneratedExpression> generatedExpressions)"}, {"syntax_pass": true, "original_string": "    private static String join(List<String> strings) {\n        StringBuilder builder = new StringBuilder();\n        boolean first = true;\n        for (String element : strings) {\n            if (first) {\n                first = false;\n            } else {\n                builder.append(\"\\n   \");\n            }\n            builder.append(element);\n        }\n\n        return builder.toString();\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "join", "params": [{"name": "strings", "type": "List<String>"}], "body": "                                                     {\n        StringBuilder builder = new StringBuilder();\n        boolean first = true;\n        for (String element : strings) {\n            if (first) {\n                first = false;\n            } else {\n                builder.append(\"\\n   \");\n            }\n            builder.append(element);\n        }\n\n        return builder.toString();\n    }", "signature": "private static String join(List<String> strings)"}, {"syntax_pass": true, "original_string": "    public Pattern getRegexp() {\n        return regexp;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pattern", "classes": []}, "name": "getRegexp", "params": [], "body": "                               {\n        return regexp;\n    }", "signature": "public Pattern getRegexp()"}, {"syntax_pass": true, "original_string": "    public String getParameterTypeRegexp() {\n        return parameterTypeRegexp;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getParameterTypeRegexp", "params": [], "body": "                                           {\n        return parameterTypeRegexp;\n    }", "signature": "public String getParameterTypeRegexp()"}, {"syntax_pass": true, "original_string": "    public SortedSet<ParameterType<?>> getParameterTypes() {\n        return parameterTypes;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedSet<ParameterType<?>>", "classes": []}, "name": "getParameterTypes", "params": [], "body": "                                                           {\n        return parameterTypes;\n    }", "signature": "public SortedSet<ParameterType<?>> getParameterTypes()"}, {"syntax_pass": true, "original_string": "    public List<GeneratedExpression> getGeneratedExpressions() {\n        return generatedExpressions;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<GeneratedExpression>", "classes": []}, "name": "getGeneratedExpressions", "params": [], "body": "                                                               {\n        return generatedExpressions;\n    }", "signature": "public List<GeneratedExpression> getGeneratedExpressions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/Transformer.java", "original_string": "package io.cucumber.cucumberexpressions;\n\n/**\n * Transformer for a @{@link ParameterType} with zero or one capture groups.\n *\n * @param <T> the type to transform to.\n */\n@FunctionalInterface\npublic interface Transformer<T> {\n    /**\n     * Transforms a string into to an object. The string is either taken\n     * from the sole capture group or matches the whole expression. Nested\n     * capture groups are ignored.\n     * <p>\n     * If the capture group is optional <code>arg</code> may be null.\n     *\n     * @param arg the value of the single capture group\n     * @return the transformed object\n     * @throws Throwable if transformation failed\n     */\n    T transform(String arg) throws Throwable;\n}\n", "file_hash": "40f44173b6bf9fd4203ef4ad5caa848668b0210ffe3543ab587708853491400e", "file_docstring": "\nTransformer for a @{@link ParameterType} with zero or one capture groups.\n\n@param <T> the type to transform to.\n", "contexts": ["package io.cucumber.cucumberexpressions;"], "methods": [], "classes": [], "interfaces": [{"original_string": "@FunctionalInterface\npublic interface Transformer<T> {\n    /**\n     * Transforms a string into to an object. The string is either taken\n     * from the sole capture group or matches the whole expression. Nested\n     * capture groups are ignored.\n     * <p>\n     * If the capture group is optional <code>arg</code> may be null.\n     *\n     * @param arg the value of the single capture group\n     * @return the transformed object\n     * @throws Throwable if transformation failed\n     */\n    T transform(String arg) throws Throwable;\n}", "definition": "@FunctionalInterface\npublic interface Transformer<T>", "interface_docstring": "\nTransformer for a @{@link ParameterType} with zero or one capture groups.\n\n@param <T> the type to transform to.\n", "name": "Transformer", "extends_interfaces": [], "attributes": {"modifiers": "@FunctionalInterface\npublic", "marker_annotations": ["@FunctionalInterface"], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    T transform(String arg) throws Throwable;", "docstring": "\nTransforms a string into to an object. The string is either taken\nfrom the sole capture group or matches the whole expression. Nested\ncapture groups are ignored.\n<p>\nIf the capture group is optional <code>arg</code> may be null.\n\n@param arg the value of the single capture group\n@return the transformed object\n@throws Throwable if transformation failed\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "name": "transform", "params": [{"name": "arg", "type": "String"}], "body": "", "signature": "T transform(String arg)"}]}], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/TypeReference.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\n\npublic abstract class TypeReference<T> {\n\n    private final Type type;\n\n    protected TypeReference() {\n        Type superclass = getClass().getGenericSuperclass();\n        if (superclass instanceof Class) {\n            throw new CucumberExpressionException(\"Missing type parameter: \" + superclass);\n        }\n        this.type = ((ParameterizedType) superclass).getActualTypeArguments()[0];\n    }\n\n    public Type getType() {\n        return this.type;\n    }\n}", "file_hash": "5b513ad65f4ba7e015cdc6cb375baef3c845a11d60d81518da3e8c8e2be9b44f", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import java.lang.reflect.ParameterizedType;", "import java.lang.reflect.Type;"], "methods": [], "classes": [{"original_string": "public abstract class TypeReference<T> {\n\n    private final Type type;\n\n    protected TypeReference() {\n        Type superclass = getClass().getGenericSuperclass();\n        if (superclass instanceof Class) {\n            throw new CucumberExpressionException(\"Missing type parameter: \" + superclass);\n        }\n        this.type = ((ParameterizedType) superclass).getActualTypeArguments()[0];\n    }\n\n    public Type getType() {\n        return this.type;\n    }\n}", "definition": "public abstract class TypeReference<T>", "class_docstring": "", "name": "TypeReference", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "fields": [{"attribute_expression": "private final Type type;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected TypeReference() {\n        Type superclass = getClass().getGenericSuperclass();\n        if (superclass instanceof Class) {\n            throw new CucumberExpressionException(\"Missing type parameter: \" + superclass);\n        }\n        this.type = ((ParameterizedType) superclass).getActualTypeArguments()[0];\n    }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "TypeReference", "params": [], "body": "                              {\n        Type superclass = getClass().getGenericSuperclass();\n        if (superclass instanceof Class) {\n            throw new CucumberExpressionException(\"Missing type parameter: \" + superclass);\n        }\n        this.type = ((ParameterizedType) superclass).getActualTypeArguments()[0];\n    }", "signature": "protected TypeReference()"}, {"syntax_pass": true, "original_string": "    public Type getType() {\n        return this.type;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "getType", "params": [], "body": "                          {\n        return this.type;\n    }", "signature": "public Type getType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport io.cucumber.cucumberexpressions.Ast.Token;\nimport io.cucumber.cucumberexpressions.Ast.Token.Type;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PrimitiveIterator.OfInt;\n\nimport static io.cucumber.cucumberexpressions.CucumberExpressionException.createCantEscape;\nimport static io.cucumber.cucumberexpressions.CucumberExpressionException.createTheEndOfLineCanNotBeEscaped;\n\nfinal class CucumberExpressionTokenizer {\n\n    List<Token> tokenize(String expression) {\n        List<Token> tokens = new ArrayList<>();\n        tokenizeImpl(expression).forEach(tokens::add);\n        return tokens;\n    }\n\n    private Iterable<Token> tokenizeImpl(String expression) {\n        return () -> new TokenIterator(expression);\n    }\n\n    private static class TokenIterator implements Iterator<Token> {\n\n        private final String expression;\n        private final OfInt codePoints;\n\n        private StringBuilder buffer = new StringBuilder();\n        private Type previousTokenType = null;\n        private Type currentTokenType = Type.START_OF_LINE;\n        private boolean treatAsText;\n        private int bufferStartIndex;\n        private int escaped;\n\n        TokenIterator(String expression) {\n            this.expression = expression;\n            this.codePoints = expression.codePoints().iterator();\n        }\n\n        private Token convertBufferToToken(Type tokenType) {\n            int escapeTokens = 0;\n            if (tokenType == Type.TEXT) {\n                escapeTokens = escaped;\n                escaped = 0;\n            }\n            int consumedIndex = bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escapeTokens;\n            Token t = new Token(buffer.toString(), tokenType, bufferStartIndex, consumedIndex);\n            buffer = new StringBuilder();\n            this.bufferStartIndex = consumedIndex;\n            return t;\n        }\n\n        private void advanceTokenTypes() {\n            previousTokenType = currentTokenType;\n            currentTokenType = null;\n        }\n\n        private Type tokenTypeOf(Integer token, boolean treatAsText) {\n            if (!treatAsText) {\n                return Token.typeOf(token);\n            }\n            if (Token.canEscape(token)) {\n                return Type.TEXT;\n            }\n            throw createCantEscape(expression, bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escaped);\n        }\n\n        private boolean shouldContinueTokenType(Type previousTokenType,\n                Type currentTokenType) {\n            return currentTokenType == previousTokenType\n                    && (currentTokenType == Type.WHITE_SPACE || currentTokenType == Type.TEXT);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return previousTokenType != Type.END_OF_LINE;\n        }\n\n        @Override\n        public Token next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            if (currentTokenType == Type.START_OF_LINE) {\n                Token token = convertBufferToToken(currentTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            while (codePoints.hasNext()) {\n                int codePoint = codePoints.nextInt();\n                if (!treatAsText && Token.isEscapeCharacter(codePoint)) {\n                    escaped++;\n                    treatAsText = true;\n                    continue;\n                }\n                currentTokenType = tokenTypeOf(codePoint, treatAsText);\n                treatAsText = false;\n\n                if (previousTokenType == Type.START_OF_LINE ||\n                        shouldContinueTokenType(previousTokenType, currentTokenType)) {\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                } else {\n                    Token t = convertBufferToToken(previousTokenType);\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                    return t;\n                }\n            }\n\n            if (buffer.length() > 0) {\n                Token token = convertBufferToToken(previousTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            currentTokenType = Type.END_OF_LINE;\n            if (treatAsText) {\n                throw createTheEndOfLineCanNotBeEscaped(expression);\n            }\n            Token token = convertBufferToToken(currentTokenType);\n            advanceTokenTypes();\n            return token;\n        }\n\n    }\n\n}\n", "file_hash": "baa0317e9e9d020e1b6073ba4cc506d574c94183be9e2ff66e243ccab4ab6e41", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import io.cucumber.cucumberexpressions.Ast.Token;", "import io.cucumber.cucumberexpressions.Ast.Token.Type;", "import java.util.ArrayList;", "import java.util.Iterator;", "import java.util.List;", "import java.util.NoSuchElementException;", "import java.util.PrimitiveIterator.OfInt;", "import static io.cucumber.cucumberexpressions.CucumberExpressionException.createCantEscape;", "import static io.cucumber.cucumberexpressions.CucumberExpressionException.createTheEndOfLineCanNotBeEscaped;"], "methods": [], "classes": [{"original_string": "final class CucumberExpressionTokenizer {\n\n    List<Token> tokenize(String expression) {\n        List<Token> tokens = new ArrayList<>();\n        tokenizeImpl(expression).forEach(tokens::add);\n        return tokens;\n    }\n\n    private Iterable<Token> tokenizeImpl(String expression) {\n        return () -> new TokenIterator(expression);\n    }\n\n    private static class TokenIterator implements Iterator<Token> {\n\n        private final String expression;\n        private final OfInt codePoints;\n\n        private StringBuilder buffer = new StringBuilder();\n        private Type previousTokenType = null;\n        private Type currentTokenType = Type.START_OF_LINE;\n        private boolean treatAsText;\n        private int bufferStartIndex;\n        private int escaped;\n\n        TokenIterator(String expression) {\n            this.expression = expression;\n            this.codePoints = expression.codePoints().iterator();\n        }\n\n        private Token convertBufferToToken(Type tokenType) {\n            int escapeTokens = 0;\n            if (tokenType == Type.TEXT) {\n                escapeTokens = escaped;\n                escaped = 0;\n            }\n            int consumedIndex = bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escapeTokens;\n            Token t = new Token(buffer.toString(), tokenType, bufferStartIndex, consumedIndex);\n            buffer = new StringBuilder();\n            this.bufferStartIndex = consumedIndex;\n            return t;\n        }\n\n        private void advanceTokenTypes() {\n            previousTokenType = currentTokenType;\n            currentTokenType = null;\n        }\n\n        private Type tokenTypeOf(Integer token, boolean treatAsText) {\n            if (!treatAsText) {\n                return Token.typeOf(token);\n            }\n            if (Token.canEscape(token)) {\n                return Type.TEXT;\n            }\n            throw createCantEscape(expression, bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escaped);\n        }\n\n        private boolean shouldContinueTokenType(Type previousTokenType,\n                Type currentTokenType) {\n            return currentTokenType == previousTokenType\n                    && (currentTokenType == Type.WHITE_SPACE || currentTokenType == Type.TEXT);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return previousTokenType != Type.END_OF_LINE;\n        }\n\n        @Override\n        public Token next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            if (currentTokenType == Type.START_OF_LINE) {\n                Token token = convertBufferToToken(currentTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            while (codePoints.hasNext()) {\n                int codePoint = codePoints.nextInt();\n                if (!treatAsText && Token.isEscapeCharacter(codePoint)) {\n                    escaped++;\n                    treatAsText = true;\n                    continue;\n                }\n                currentTokenType = tokenTypeOf(codePoint, treatAsText);\n                treatAsText = false;\n\n                if (previousTokenType == Type.START_OF_LINE ||\n                        shouldContinueTokenType(previousTokenType, currentTokenType)) {\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                } else {\n                    Token t = convertBufferToToken(previousTokenType);\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                    return t;\n                }\n            }\n\n            if (buffer.length() > 0) {\n                Token token = convertBufferToToken(previousTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            currentTokenType = Type.END_OF_LINE;\n            if (treatAsText) {\n                throw createTheEndOfLineCanNotBeEscaped(expression);\n            }\n            Token token = convertBufferToToken(currentTokenType);\n            advanceTokenTypes();\n            return token;\n        }\n\n    }\n\n}", "definition": "final class CucumberExpressionTokenizer", "class_docstring": "", "name": "CucumberExpressionTokenizer", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": [{"original_string": "    private static class TokenIterator implements Iterator<Token> {\n\n        private final String expression;\n        private final OfInt codePoints;\n\n        private StringBuilder buffer = new StringBuilder();\n        private Type previousTokenType = null;\n        private Type currentTokenType = Type.START_OF_LINE;\n        private boolean treatAsText;\n        private int bufferStartIndex;\n        private int escaped;\n\n        TokenIterator(String expression) {\n            this.expression = expression;\n            this.codePoints = expression.codePoints().iterator();\n        }\n\n        private Token convertBufferToToken(Type tokenType) {\n            int escapeTokens = 0;\n            if (tokenType == Type.TEXT) {\n                escapeTokens = escaped;\n                escaped = 0;\n            }\n            int consumedIndex = bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escapeTokens;\n            Token t = new Token(buffer.toString(), tokenType, bufferStartIndex, consumedIndex);\n            buffer = new StringBuilder();\n            this.bufferStartIndex = consumedIndex;\n            return t;\n        }\n\n        private void advanceTokenTypes() {\n            previousTokenType = currentTokenType;\n            currentTokenType = null;\n        }\n\n        private Type tokenTypeOf(Integer token, boolean treatAsText) {\n            if (!treatAsText) {\n                return Token.typeOf(token);\n            }\n            if (Token.canEscape(token)) {\n                return Type.TEXT;\n            }\n            throw createCantEscape(expression, bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escaped);\n        }\n\n        private boolean shouldContinueTokenType(Type previousTokenType,\n                Type currentTokenType) {\n            return currentTokenType == previousTokenType\n                    && (currentTokenType == Type.WHITE_SPACE || currentTokenType == Type.TEXT);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return previousTokenType != Type.END_OF_LINE;\n        }\n\n        @Override\n        public Token next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            if (currentTokenType == Type.START_OF_LINE) {\n                Token token = convertBufferToToken(currentTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            while (codePoints.hasNext()) {\n                int codePoint = codePoints.nextInt();\n                if (!treatAsText && Token.isEscapeCharacter(codePoint)) {\n                    escaped++;\n                    treatAsText = true;\n                    continue;\n                }\n                currentTokenType = tokenTypeOf(codePoint, treatAsText);\n                treatAsText = false;\n\n                if (previousTokenType == Type.START_OF_LINE ||\n                        shouldContinueTokenType(previousTokenType, currentTokenType)) {\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                } else {\n                    Token t = convertBufferToToken(previousTokenType);\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                    return t;\n                }\n            }\n\n            if (buffer.length() > 0) {\n                Token token = convertBufferToToken(previousTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            currentTokenType = Type.END_OF_LINE;\n            if (treatAsText) {\n                throw createTheEndOfLineCanNotBeEscaped(expression);\n            }\n            Token token = convertBufferToToken(currentTokenType);\n            advanceTokenTypes();\n            return token;\n        }\n\n    }", "definition": "    private static class TokenIterator implements Iterator<Token>", "class_docstring": "", "name": "TokenIterator", "super_interfaces": ["Iterator<Token>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final String expression;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "private final OfInt codePoints;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OfInt", "name": "codePoints", "syntax_pass": true}, {"attribute_expression": "private StringBuilder buffer = new StringBuilder();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StringBuilder", "name": "buffer = new StringBuilder()", "syntax_pass": true}, {"attribute_expression": "private Type previousTokenType = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Type", "name": "previousTokenType = null", "syntax_pass": true}, {"attribute_expression": "private Type currentTokenType = Type.START_OF_LINE;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Type", "name": "currentTokenType = Type.START_OF_LINE", "syntax_pass": true}, {"attribute_expression": "private boolean treatAsText;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "treatAsText", "syntax_pass": true}, {"attribute_expression": "private int bufferStartIndex;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "bufferStartIndex", "syntax_pass": true}, {"attribute_expression": "private int escaped;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "escaped", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TokenIterator(String expression) {\n            this.expression = expression;\n            this.codePoints = expression.codePoints().iterator();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TokenIterator", "params": [{"name": "expression", "type": "String"}], "body": "                                         {\n            this.expression = expression;\n            this.codePoints = expression.codePoints().iterator();\n        }", "signature": "TokenIterator(String expression)"}, {"syntax_pass": true, "original_string": "        private Token convertBufferToToken(Type tokenType) {\n            int escapeTokens = 0;\n            if (tokenType == Type.TEXT) {\n                escapeTokens = escaped;\n                escaped = 0;\n            }\n            int consumedIndex = bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escapeTokens;\n            Token t = new Token(buffer.toString(), tokenType, bufferStartIndex, consumedIndex);\n            buffer = new StringBuilder();\n            this.bufferStartIndex = consumedIndex;\n            return t;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Token", "classes": []}, "name": "convertBufferToToken", "params": [{"name": "tokenType", "type": "Type"}], "body": "                                                           {\n            int escapeTokens = 0;\n            if (tokenType == Type.TEXT) {\n                escapeTokens = escaped;\n                escaped = 0;\n            }\n            int consumedIndex = bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escapeTokens;\n            Token t = new Token(buffer.toString(), tokenType, bufferStartIndex, consumedIndex);\n            buffer = new StringBuilder();\n            this.bufferStartIndex = consumedIndex;\n            return t;\n        }", "signature": "private Token convertBufferToToken(Type tokenType)"}, {"syntax_pass": true, "original_string": "        private void advanceTokenTypes() {\n            previousTokenType = currentTokenType;\n            currentTokenType = null;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "advanceTokenTypes", "params": [], "body": "                                         {\n            previousTokenType = currentTokenType;\n            currentTokenType = null;\n        }", "signature": "private void advanceTokenTypes()"}, {"syntax_pass": true, "original_string": "        private Type tokenTypeOf(Integer token, boolean treatAsText) {\n            if (!treatAsText) {\n                return Token.typeOf(token);\n            }\n            if (Token.canEscape(token)) {\n                return Type.TEXT;\n            }\n            throw createCantEscape(expression, bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escaped);\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Type", "classes": []}, "name": "tokenTypeOf", "params": [{"name": "token", "type": "Integer"}, {"name": "treatAsText", "type": "boolean"}], "body": "                                                                     {\n            if (!treatAsText) {\n                return Token.typeOf(token);\n            }\n            if (Token.canEscape(token)) {\n                return Type.TEXT;\n            }\n            throw createCantEscape(expression, bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escaped);\n        }", "signature": "private Type tokenTypeOf(Integer token, boolean treatAsText)"}, {"syntax_pass": true, "original_string": "        private boolean shouldContinueTokenType(Type previousTokenType,\n                Type currentTokenType) {\n            return currentTokenType == previousTokenType\n                    && (currentTokenType == Type.WHITE_SPACE || currentTokenType == Type.TEXT);\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "shouldContinueTokenType", "params": [{"name": "previousTokenType", "type": "Type"}, {"name": "currentTokenType", "type": "Type"}], "body": "                                       {\n            return currentTokenType == previousTokenType\n                    && (currentTokenType == Type.WHITE_SPACE || currentTokenType == Type.TEXT);\n        }", "signature": "private boolean shouldContinueTokenType(Type previousTokenType,\n                Type currentTokenType)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return previousTokenType != Type.END_OF_LINE;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return previousTokenType != Type.END_OF_LINE;\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Token next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            if (currentTokenType == Type.START_OF_LINE) {\n                Token token = convertBufferToToken(currentTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            while (codePoints.hasNext()) {\n                int codePoint = codePoints.nextInt();\n                if (!treatAsText && Token.isEscapeCharacter(codePoint)) {\n                    escaped++;\n                    treatAsText = true;\n                    continue;\n                }\n                currentTokenType = tokenTypeOf(codePoint, treatAsText);\n                treatAsText = false;\n\n                if (previousTokenType == Type.START_OF_LINE ||\n                        shouldContinueTokenType(previousTokenType, currentTokenType)) {\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                } else {\n                    Token t = convertBufferToToken(previousTokenType);\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                    return t;\n                }\n            }\n\n            if (buffer.length() > 0) {\n                Token token = convertBufferToToken(previousTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            currentTokenType = Type.END_OF_LINE;\n            if (treatAsText) {\n                throw createTheEndOfLineCanNotBeEscaped(expression);\n            }\n            Token token = convertBufferToToken(currentTokenType);\n            advanceTokenTypes();\n            return token;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Token", "classes": []}, "name": "next", "params": [], "body": "                            {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            if (currentTokenType == Type.START_OF_LINE) {\n                Token token = convertBufferToToken(currentTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            while (codePoints.hasNext()) {\n                int codePoint = codePoints.nextInt();\n                if (!treatAsText && Token.isEscapeCharacter(codePoint)) {\n                    escaped++;\n                    treatAsText = true;\n                    continue;\n                }\n                currentTokenType = tokenTypeOf(codePoint, treatAsText);\n                treatAsText = false;\n\n                if (previousTokenType == Type.START_OF_LINE ||\n                        shouldContinueTokenType(previousTokenType, currentTokenType)) {\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                } else {\n                    Token t = convertBufferToToken(previousTokenType);\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                    return t;\n                }\n            }\n\n            if (buffer.length() > 0) {\n                Token token = convertBufferToToken(previousTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            currentTokenType = Type.END_OF_LINE;\n            if (treatAsText) {\n                throw createTheEndOfLineCanNotBeEscaped(expression);\n            }\n            Token token = convertBufferToToken(currentTokenType);\n            advanceTokenTypes();\n            return token;\n        }", "signature": "@Override\n        public Token next()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    List<Token> tokenize(String expression) {\n        List<Token> tokens = new ArrayList<>();\n        tokenizeImpl(expression).forEach(tokens::add);\n        return tokens;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Token>", "classes": []}, "name": "tokenize", "params": [{"name": "expression", "type": "String"}], "body": "                                            {\n        List<Token> tokens = new ArrayList<>();\n        tokenizeImpl(expression).forEach(tokens::add);\n        return tokens;\n    }", "signature": "List<Token> tokenize(String expression)"}, {"syntax_pass": true, "original_string": "    private Iterable<Token> tokenizeImpl(String expression) {\n        return () -> new TokenIterator(expression);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Iterable<Token>", "classes": []}, "name": "tokenizeImpl", "params": [{"name": "expression", "type": "String"}], "body": "                                                            {\n        return () -> new TokenIterator(expression);\n    }", "signature": "private Iterable<Token> tokenizeImpl(String expression)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\nimport static io.cucumber.cucumberexpressions.ParameterType.createAnonymousParameterType;\n\n@API(status = API.Status.STABLE)\npublic final class RegularExpression implements Expression {\n    private final Pattern expressionRegexp;\n    private final ParameterTypeRegistry parameterTypeRegistry;\n    private final TreeRegexp treeRegexp;\n\n    /**\n     * Creates a new instance. Use this when the transform types are not known in advance,\n     * and should be determined by the regular expression's capture groups. Use this with\n     * dynamically typed languages.\n     *\n     * @param expressionRegexp      the regular expression to use\n     * @param parameterTypeRegistry used to look up parameter types\n     */\n    RegularExpression(Pattern expressionRegexp, ParameterTypeRegistry parameterTypeRegistry) {\n        this.expressionRegexp = expressionRegexp;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n        this.treeRegexp = new TreeRegexp(expressionRegexp);\n    }\n\n    @Override\n    public List<Argument<?>> match(String text, Type... typeHints) {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        final ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n        final List<ParameterType<?>> parameterTypes = new ArrayList<>();\n        int typeHintIndex = 0;\n        for (GroupBuilder groupBuilder : treeRegexp.getGroupBuilder().getChildren()) {\n            final String parameterTypeRegexp = groupBuilder.getSource();\n            boolean hasTypeHint = typeHintIndex < typeHints.length;\n            final Type typeHint = hasTypeHint ? typeHints[typeHintIndex++] : String.class;\n\n            ParameterType<?> parameterType = parameterTypeRegistry.lookupByRegexp(parameterTypeRegexp, expressionRegexp, text);\n\n            // When there is a conflict between the type hint from the regular expression and the method\n            // prefer the parameter type associated with the regular expression. This ensures we will\n            // use the internal/user registered parameter transformer rather then the default.\n            //\n            // Unless the parameter type indicates it is the stronger type hint.\n            if (parameterType != null && hasTypeHint && !parameterType.useRegexpMatchAsStrongTypeHint()) {\n                if (!parameterType.getType().equals(typeHint)) {\n                    parameterType = null;\n                }\n            }\n\n            if (parameterType == null) {\n                parameterType = createAnonymousParameterType(parameterTypeRegexp);\n            }\n\n            // Either from createAnonymousParameterType or lookupByRegexp\n            if (parameterType.isAnonymous()) {\n                parameterType = parameterType.deAnonymize(typeHint, arg -> defaultTransformer.transform(arg, typeHint));\n            }\n\n            parameterTypes.add(parameterType);\n        }\n\n        return Argument.build(group, parameterTypes);\n    }\n\n    @Override\n    public Pattern getRegexp() {\n        return expressionRegexp;\n    }\n\n    @Override\n    public String getSource() {\n        return expressionRegexp.pattern();\n    }\n}\n", "file_hash": "16b6808a0410f642afde61d329c5503095fdaf17d9f19b2529c8394f4fddfeaf", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.lang.reflect.Type;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.regex.Pattern;", "import static io.cucumber.cucumberexpressions.ParameterType.createAnonymousParameterType;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic final class RegularExpression implements Expression {\n    private final Pattern expressionRegexp;\n    private final ParameterTypeRegistry parameterTypeRegistry;\n    private final TreeRegexp treeRegexp;\n\n    /**\n     * Creates a new instance. Use this when the transform types are not known in advance,\n     * and should be determined by the regular expression's capture groups. Use this with\n     * dynamically typed languages.\n     *\n     * @param expressionRegexp      the regular expression to use\n     * @param parameterTypeRegistry used to look up parameter types\n     */\n    RegularExpression(Pattern expressionRegexp, ParameterTypeRegistry parameterTypeRegistry) {\n        this.expressionRegexp = expressionRegexp;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n        this.treeRegexp = new TreeRegexp(expressionRegexp);\n    }\n\n    @Override\n    public List<Argument<?>> match(String text, Type... typeHints) {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        final ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n        final List<ParameterType<?>> parameterTypes = new ArrayList<>();\n        int typeHintIndex = 0;\n        for (GroupBuilder groupBuilder : treeRegexp.getGroupBuilder().getChildren()) {\n            final String parameterTypeRegexp = groupBuilder.getSource();\n            boolean hasTypeHint = typeHintIndex < typeHints.length;\n            final Type typeHint = hasTypeHint ? typeHints[typeHintIndex++] : String.class;\n\n            ParameterType<?> parameterType = parameterTypeRegistry.lookupByRegexp(parameterTypeRegexp, expressionRegexp, text);\n\n            // When there is a conflict between the type hint from the regular expression and the method\n            // prefer the parameter type associated with the regular expression. This ensures we will\n            // use the internal/user registered parameter transformer rather then the default.\n            //\n            // Unless the parameter type indicates it is the stronger type hint.\n            if (parameterType != null && hasTypeHint && !parameterType.useRegexpMatchAsStrongTypeHint()) {\n                if (!parameterType.getType().equals(typeHint)) {\n                    parameterType = null;\n                }\n            }\n\n            if (parameterType == null) {\n                parameterType = createAnonymousParameterType(parameterTypeRegexp);\n            }\n\n            // Either from createAnonymousParameterType or lookupByRegexp\n            if (parameterType.isAnonymous()) {\n                parameterType = parameterType.deAnonymize(typeHint, arg -> defaultTransformer.transform(arg, typeHint));\n            }\n\n            parameterTypes.add(parameterType);\n        }\n\n        return Argument.build(group, parameterTypes);\n    }\n\n    @Override\n    public Pattern getRegexp() {\n        return expressionRegexp;\n    }\n\n    @Override\n    public String getSource() {\n        return expressionRegexp.pattern();\n    }\n}", "definition": "@API(status = API.Status.STABLE)\npublic final class RegularExpression implements Expression", "class_docstring": "", "name": "RegularExpression", "super_interfaces": ["Expression"], "superclasses": "", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic final", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public", "final"], "comments": [], "fields": [{"attribute_expression": "private final Pattern expressionRegexp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pattern", "name": "expressionRegexp", "syntax_pass": true}, {"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}, {"attribute_expression": "private final TreeRegexp treeRegexp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TreeRegexp", "name": "treeRegexp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    RegularExpression(Pattern expressionRegexp, ParameterTypeRegistry parameterTypeRegistry) {\n        this.expressionRegexp = expressionRegexp;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n        this.treeRegexp = new TreeRegexp(expressionRegexp);\n    }", "docstring": "\nCreates a new instance. Use this when the transform types are not known in advance,\nand should be determined by the regular expression's capture groups. Use this with\ndynamically typed languages.\n\n@param expressionRegexp      the regular expression to use\n@param parameterTypeRegistry used to look up parameter types\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RegularExpression", "params": [{"name": "expressionRegexp", "type": "Pattern"}, {"name": "parameterTypeRegistry", "type": "ParameterTypeRegistry"}], "body": "                                                                                             {\n        this.expressionRegexp = expressionRegexp;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n        this.treeRegexp = new TreeRegexp(expressionRegexp);\n    }", "signature": "RegularExpression(Pattern expressionRegexp, ParameterTypeRegistry parameterTypeRegistry)"}, {"syntax_pass": true, "original_string": "    @Override\n    public List<Argument<?>> match(String text, Type... typeHints) {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        final ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n        final List<ParameterType<?>> parameterTypes = new ArrayList<>();\n        int typeHintIndex = 0;\n        for (GroupBuilder groupBuilder : treeRegexp.getGroupBuilder().getChildren()) {\n            final String parameterTypeRegexp = groupBuilder.getSource();\n            boolean hasTypeHint = typeHintIndex < typeHints.length;\n            final Type typeHint = hasTypeHint ? typeHints[typeHintIndex++] : String.class;\n\n            ParameterType<?> parameterType = parameterTypeRegistry.lookupByRegexp(parameterTypeRegexp, expressionRegexp, text);\n\n            // When there is a conflict between the type hint from the regular expression and the method\n            // prefer the parameter type associated with the regular expression. This ensures we will\n            // use the internal/user registered parameter transformer rather then the default.\n            //\n            // Unless the parameter type indicates it is the stronger type hint.\n            if (parameterType != null && hasTypeHint && !parameterType.useRegexpMatchAsStrongTypeHint()) {\n                if (!parameterType.getType().equals(typeHint)) {\n                    parameterType = null;\n                }\n            }\n\n            if (parameterType == null) {\n                parameterType = createAnonymousParameterType(parameterTypeRegexp);\n            }\n\n            // Either from createAnonymousParameterType or lookupByRegexp\n            if (parameterType.isAnonymous()) {\n                parameterType = parameterType.deAnonymize(typeHint, arg -> defaultTransformer.transform(arg, typeHint));\n            }\n\n            parameterTypes.add(parameterType);\n        }\n\n        return Argument.build(group, parameterTypes);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Argument<?>>", "classes": []}, "name": "match", "params": [{"name": "text", "type": "String"}], "body": "                                                                   {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        final ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n        final List<ParameterType<?>> parameterTypes = new ArrayList<>();\n        int typeHintIndex = 0;\n        for (GroupBuilder groupBuilder : treeRegexp.getGroupBuilder().getChildren()) {\n            final String parameterTypeRegexp = groupBuilder.getSource();\n            boolean hasTypeHint = typeHintIndex < typeHints.length;\n            final Type typeHint = hasTypeHint ? typeHints[typeHintIndex++] : String.class;\n\n            ParameterType<?> parameterType = parameterTypeRegistry.lookupByRegexp(parameterTypeRegexp, expressionRegexp, text);\n\n            // When there is a conflict between the type hint from the regular expression and the method\n            // prefer the parameter type associated with the regular expression. This ensures we will\n            // use the internal/user registered parameter transformer rather then the default.\n            //\n            // Unless the parameter type indicates it is the stronger type hint.\n            if (parameterType != null && hasTypeHint && !parameterType.useRegexpMatchAsStrongTypeHint()) {\n                if (!parameterType.getType().equals(typeHint)) {\n                    parameterType = null;\n                }\n            }\n\n            if (parameterType == null) {\n                parameterType = createAnonymousParameterType(parameterTypeRegexp);\n            }\n\n            // Either from createAnonymousParameterType or lookupByRegexp\n            if (parameterType.isAnonymous()) {\n                parameterType = parameterType.deAnonymize(typeHint, arg -> defaultTransformer.transform(arg, typeHint));\n            }\n\n            parameterTypes.add(parameterType);\n        }\n\n        return Argument.build(group, parameterTypes);\n    }", "signature": "@Override\n    public List<Argument<?>> match(String text, Type... typeHints)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Pattern getRegexp() {\n        return expressionRegexp;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pattern", "classes": []}, "name": "getRegexp", "params": [], "body": "                               {\n        return expressionRegexp;\n    }", "signature": "@Override\n    public Pattern getRegexp()"}, {"syntax_pass": true, "original_string": "    @Override\n    public String getSource() {\n        return expressionRegexp.pattern();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getSource", "params": [], "body": "                              {\n        return expressionRegexp.pattern();\n    }", "signature": "@Override\n    public String getSource()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbols.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport java.text.DecimalFormatSymbols;\nimport java.util.Locale;\n\n/**\n * A set of localized decimal symbols that can be written on a regular keyboard.\n * <p>\n * Note quite complete, feel free to make a suggestion.\n */\nclass KeyboardFriendlyDecimalFormatSymbols {\n\n    static DecimalFormatSymbols getInstance(Locale locale) {\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n\n        // Replace the minus sign with minus-hyphen as available on most keyboards.\n        if (symbols.getMinusSign() == '\\u2212') {\n            symbols.setMinusSign('-');\n        }\n\n        if (symbols.getDecimalSeparator() == '.') {\n            // For locales that use the period as the decimal separator\n            // always use the comma for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator(',');\n        } else if (symbols.getDecimalSeparator() == ',') {\n            // For locales that use the comma as the decimal separator\n            // always use the period for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator('.');\n        }\n        return symbols;\n    }\n}\n", "file_hash": "df511a59ad8a6ff2ab9a4ef1db3b6f266de54f3963ccdfe7cdfac151ff4fda8b", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import java.text.DecimalFormatSymbols;", "import java.util.Locale;"], "methods": [], "classes": [{"original_string": "class KeyboardFriendlyDecimalFormatSymbols {\n\n    static DecimalFormatSymbols getInstance(Locale locale) {\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n\n        // Replace the minus sign with minus-hyphen as available on most keyboards.\n        if (symbols.getMinusSign() == '\\u2212') {\n            symbols.setMinusSign('-');\n        }\n\n        if (symbols.getDecimalSeparator() == '.') {\n            // For locales that use the period as the decimal separator\n            // always use the comma for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator(',');\n        } else if (symbols.getDecimalSeparator() == ',') {\n            // For locales that use the comma as the decimal separator\n            // always use the period for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator('.');\n        }\n        return symbols;\n    }\n}", "definition": "class KeyboardFriendlyDecimalFormatSymbols", "class_docstring": "\nA set of localized decimal symbols that can be written on a regular keyboard.\n<p>\nNote quite complete, feel free to make a suggestion.\n", "name": "KeyboardFriendlyDecimalFormatSymbols", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    static DecimalFormatSymbols getInstance(Locale locale) {\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n\n        // Replace the minus sign with minus-hyphen as available on most keyboards.\n        if (symbols.getMinusSign() == '\\u2212') {\n            symbols.setMinusSign('-');\n        }\n\n        if (symbols.getDecimalSeparator() == '.') {\n            // For locales that use the period as the decimal separator\n            // always use the comma for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator(',');\n        } else if (symbols.getDecimalSeparator() == ',') {\n            // For locales that use the comma as the decimal separator\n            // always use the period for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator('.');\n        }\n        return symbols;\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "DecimalFormatSymbols", "classes": []}, "name": "getInstance", "params": [{"name": "locale", "type": "Locale"}], "body": "                                                           {\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n\n        // Replace the minus sign with minus-hyphen as available on most keyboards.\n        if (symbols.getMinusSign() == '\\u2212') {\n            symbols.setMinusSign('-');\n        }\n\n        if (symbols.getDecimalSeparator() == '.') {\n            // For locales that use the period as the decimal separator\n            // always use the comma for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator(',');\n        } else if (symbols.getDecimalSeparator() == ',') {\n            // For locales that use the comma as the decimal separator\n            // always use the period for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator('.');\n        }\n        return symbols;\n    }", "signature": "static DecimalFormatSymbols getInstance(Locale locale)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport io.cucumber.cucumberexpressions.Ast.Located;\nimport io.cucumber.cucumberexpressions.Ast.Node;\nimport io.cucumber.cucumberexpressions.Ast.Token;\nimport io.cucumber.cucumberexpressions.Ast.Token.Type;\nimport org.apiguardian.api.API;\n\n@API(status = API.Status.STABLE)\npublic class CucumberExpressionException extends RuntimeException {\n\n    CucumberExpressionException(String message) {\n        super(message);\n    }\n\n    CucumberExpressionException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    static CucumberExpressionException createMissingEndToken(String expression, Type beginToken, Type endToken,\n            Token current) {\n        return new CucumberExpressionException(message(\n                current.start(),\n                expression,\n                pointAt(current),\n                \"The '\" + beginToken.symbol() + \"' does not have a matching '\" + endToken.symbol() + \"'\",\n                \"If you did not intend to use \" + beginToken.purpose() + \" you can use '\\\\\" + beginToken\n                        .symbol() + \"' to escape the \" + beginToken.purpose()));\n    }\n\n    static CucumberExpressionException createAlternationNotAllowedInOptional(String expression, Token current) {\n        return new CucumberExpressionException(message(\n                current.start,\n                expression,\n                pointAt(current),\n                \"An alternation can not be used inside an optional\",\n                \"If you did not mean to use an alternation you can use '\\\\/' to escape the '/'. Otherwise rephrase your expression or consider using a regular expression instead.\"\n        ));\n    }\n\n    static CucumberExpressionException createTheEndOfLineCanNotBeEscaped(String expression) {\n        int index = expression.codePointCount(0, expression.length()) - 1;\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"The end of line can not be escaped\",\n                \"You can use '\\\\\\\\' to escape the '\\\\'\"\n        ));\n    }\n\n    static CucumberExpressionException createAlternativeMayNotBeEmpty(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Alternative may not be empty\",\n                \"If you did not mean to use an alternative you can use '\\\\/' to escape the '/'\"));\n    }\n\n    static CucumberExpressionException createParameterIsNotAllowedInOptional(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain a parameter type\",\n                \"If you did not mean to use an parameter type you can use '\\\\{' to escape the '{'\"));\n    }\n    static CucumberExpressionException createOptionalIsNotAllowedInOptional(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain an other optional\",\n                \"If you did not mean to use an optional type you can use '\\\\(' to escape the '('. For more complicated expressions consider using a regular expression instead.\"));\n    }\n\n    static CucumberExpressionException createOptionalMayNotBeEmpty(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional must contain some text\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }\n\n    static CucumberExpressionException createAlternativeMayNotExclusivelyContainOptionals(Node node,\n            String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An alternative may not exclusively contain optionals\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }\n\n    private static String thisCucumberExpressionHasAProblemAt(int index) {\n        return \"This Cucumber Expression has a problem at column \" + (index + 1) + \":\" + \"\\n\";\n    }\n\n    static CucumberExpressionException createCantEscape(String expression, int index) {\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"Only the characters '{', '}', '(', ')', '\\\\', '/' and whitespace can be escaped\",\n                \"If you did mean to use an '\\\\' you can use '\\\\\\\\' to escape it\"));\n    }\n\n    static CucumberExpressionException createInvalidParameterTypeName(String name) {\n        return new CucumberExpressionException(\n                \"Illegal character in parameter name {\" + name + \"}. Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\");\n    }\n\n    /**\n     * Not very clear, but this message has to be language independent\n     * Other languages have dedicated syntax for writing down regular expressions\n     * <p>\n     * In java a regular expression has to start with {@code ^} and end with\n     * {@code $} to be recognized as one by Cucumber.\n     *\n     * @see ExpressionFactory\n     */\n    static CucumberExpressionException createInvalidParameterTypeName(Token token, String expression) {\n        return new CucumberExpressionException(message(\n                token.start(),\n                expression,\n                pointAt(token),\n                \"Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\",\n                \"Did you mean to use a regular expression?\"));\n    }\n\n    static String message(int index, String expression, String pointer, String problem,\n            String solution) {\n        return thisCucumberExpressionHasAProblemAt(index) +\n                \"\\n\" +\n                expression + \"\\n\" +\n                pointer + \"\\n\" +\n                problem + \".\\n\" +\n                solution;\n    }\n\n    static String pointAt(Located node) {\n        StringBuilder pointer = new StringBuilder(pointAt(node.start()));\n        if (node.start() + 1 < node.end()) {\n            for (int i = node.start() + 1; i < node.end() - 1; i++) {\n                pointer.append(\"-\");\n            }\n            pointer.append(\"^\");\n        }\n        return pointer.toString();\n    }\n\n    private static String pointAt(int index) {\n        StringBuilder pointer = new StringBuilder();\n        for (int i = 0; i < index; i++) {\n            pointer.append(\" \");\n        }\n        pointer.append(\"^\");\n        return pointer.toString();\n    }\n\n}\n", "file_hash": "beccc238f5bac3d470af3afcc6024d402c6448df9ec1891d26cd50503d98b726", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import io.cucumber.cucumberexpressions.Ast.Located;", "import io.cucumber.cucumberexpressions.Ast.Node;", "import io.cucumber.cucumberexpressions.Ast.Token;", "import io.cucumber.cucumberexpressions.Ast.Token.Type;", "import org.apiguardian.api.API;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic class CucumberExpressionException extends RuntimeException {\n\n    CucumberExpressionException(String message) {\n        super(message);\n    }\n\n    CucumberExpressionException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    static CucumberExpressionException createMissingEndToken(String expression, Type beginToken, Type endToken,\n            Token current) {\n        return new CucumberExpressionException(message(\n                current.start(),\n                expression,\n                pointAt(current),\n                \"The '\" + beginToken.symbol() + \"' does not have a matching '\" + endToken.symbol() + \"'\",\n                \"If you did not intend to use \" + beginToken.purpose() + \" you can use '\\\\\" + beginToken\n                        .symbol() + \"' to escape the \" + beginToken.purpose()));\n    }\n\n    static CucumberExpressionException createAlternationNotAllowedInOptional(String expression, Token current) {\n        return new CucumberExpressionException(message(\n                current.start,\n                expression,\n                pointAt(current),\n                \"An alternation can not be used inside an optional\",\n                \"If you did not mean to use an alternation you can use '\\\\/' to escape the '/'. Otherwise rephrase your expression or consider using a regular expression instead.\"\n        ));\n    }\n\n    static CucumberExpressionException createTheEndOfLineCanNotBeEscaped(String expression) {\n        int index = expression.codePointCount(0, expression.length()) - 1;\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"The end of line can not be escaped\",\n                \"You can use '\\\\\\\\' to escape the '\\\\'\"\n        ));\n    }\n\n    static CucumberExpressionException createAlternativeMayNotBeEmpty(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Alternative may not be empty\",\n                \"If you did not mean to use an alternative you can use '\\\\/' to escape the '/'\"));\n    }\n\n    static CucumberExpressionException createParameterIsNotAllowedInOptional(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain a parameter type\",\n                \"If you did not mean to use an parameter type you can use '\\\\{' to escape the '{'\"));\n    }\n    static CucumberExpressionException createOptionalIsNotAllowedInOptional(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain an other optional\",\n                \"If you did not mean to use an optional type you can use '\\\\(' to escape the '('. For more complicated expressions consider using a regular expression instead.\"));\n    }\n\n    static CucumberExpressionException createOptionalMayNotBeEmpty(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional must contain some text\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }\n\n    static CucumberExpressionException createAlternativeMayNotExclusivelyContainOptionals(Node node,\n            String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An alternative may not exclusively contain optionals\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }\n\n    private static String thisCucumberExpressionHasAProblemAt(int index) {\n        return \"This Cucumber Expression has a problem at column \" + (index + 1) + \":\" + \"\\n\";\n    }\n\n    static CucumberExpressionException createCantEscape(String expression, int index) {\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"Only the characters '{', '}', '(', ')', '\\\\', '/' and whitespace can be escaped\",\n                \"If you did mean to use an '\\\\' you can use '\\\\\\\\' to escape it\"));\n    }\n\n    static CucumberExpressionException createInvalidParameterTypeName(String name) {\n        return new CucumberExpressionException(\n                \"Illegal character in parameter name {\" + name + \"}. Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\");\n    }\n\n    /**\n     * Not very clear, but this message has to be language independent\n     * Other languages have dedicated syntax for writing down regular expressions\n     * <p>\n     * In java a regular expression has to start with {@code ^} and end with\n     * {@code $} to be recognized as one by Cucumber.\n     *\n     * @see ExpressionFactory\n     */\n    static CucumberExpressionException createInvalidParameterTypeName(Token token, String expression) {\n        return new CucumberExpressionException(message(\n                token.start(),\n                expression,\n                pointAt(token),\n                \"Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\",\n                \"Did you mean to use a regular expression?\"));\n    }\n\n    static String message(int index, String expression, String pointer, String problem,\n            String solution) {\n        return thisCucumberExpressionHasAProblemAt(index) +\n                \"\\n\" +\n                expression + \"\\n\" +\n                pointer + \"\\n\" +\n                problem + \".\\n\" +\n                solution;\n    }\n\n    static String pointAt(Located node) {\n        StringBuilder pointer = new StringBuilder(pointAt(node.start()));\n        if (node.start() + 1 < node.end()) {\n            for (int i = node.start() + 1; i < node.end() - 1; i++) {\n                pointer.append(\"-\");\n            }\n            pointer.append(\"^\");\n        }\n        return pointer.toString();\n    }\n\n    private static String pointAt(int index) {\n        StringBuilder pointer = new StringBuilder();\n        for (int i = 0; i < index; i++) {\n            pointer.append(\" \");\n        }\n        pointer.append(\"^\");\n        return pointer.toString();\n    }\n\n}", "definition": "@API(status = API.Status.STABLE)\npublic class CucumberExpressionException extends RuntimeException", "class_docstring": "", "name": "CucumberExpressionException", "super_interfaces": [], "superclasses": "RuntimeException", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    CucumberExpressionException(String message) {\n        super(message);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CucumberExpressionException", "params": [{"name": "message", "type": "String"}], "body": "                                                {\n        super(message);\n    }", "signature": "CucumberExpressionException(String message)"}, {"syntax_pass": true, "original_string": "    CucumberExpressionException(String message, Throwable cause) {\n        super(message, cause);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CucumberExpressionException", "params": [{"name": "message", "type": "String"}, {"name": "cause", "type": "Throwable"}], "body": "                                                                 {\n        super(message, cause);\n    }", "signature": "CucumberExpressionException(String message, Throwable cause)"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createMissingEndToken(String expression, Type beginToken, Type endToken,\n            Token current) {\n        return new CucumberExpressionException(message(\n                current.start(),\n                expression,\n                pointAt(current),\n                \"The '\" + beginToken.symbol() + \"' does not have a matching '\" + endToken.symbol() + \"'\",\n                \"If you did not intend to use \" + beginToken.purpose() + \" you can use '\\\\\" + beginToken\n                        .symbol() + \"' to escape the \" + beginToken.purpose()));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createMissingEndToken", "params": [{"name": "expression", "type": "String"}, {"name": "beginToken", "type": "Type"}, {"name": "endToken", "type": "Type"}, {"name": "current", "type": "Token"}], "body": "                           {\n        return new CucumberExpressionException(message(\n                current.start(),\n                expression,\n                pointAt(current),\n                \"The '\" + beginToken.symbol() + \"' does not have a matching '\" + endToken.symbol() + \"'\",\n                \"If you did not intend to use \" + beginToken.purpose() + \" you can use '\\\\\" + beginToken\n                        .symbol() + \"' to escape the \" + beginToken.purpose()));\n    }", "signature": "static CucumberExpressionException createMissingEndToken(String expression, Type beginToken, Type endToken,\n            Token current)"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createAlternationNotAllowedInOptional(String expression, Token current) {\n        return new CucumberExpressionException(message(\n                current.start,\n                expression,\n                pointAt(current),\n                \"An alternation can not be used inside an optional\",\n                \"If you did not mean to use an alternation you can use '\\\\/' to escape the '/'. Otherwise rephrase your expression or consider using a regular expression instead.\"\n        ));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createAlternationNotAllowedInOptional", "params": [{"name": "expression", "type": "String"}, {"name": "current", "type": "Token"}], "body": "                                                                                                               {\n        return new CucumberExpressionException(message(\n                current.start,\n                expression,\n                pointAt(current),\n                \"An alternation can not be used inside an optional\",\n                \"If you did not mean to use an alternation you can use '\\\\/' to escape the '/'. Otherwise rephrase your expression or consider using a regular expression instead.\"\n        ));\n    }", "signature": "static CucumberExpressionException createAlternationNotAllowedInOptional(String expression, Token current)"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createTheEndOfLineCanNotBeEscaped(String expression) {\n        int index = expression.codePointCount(0, expression.length()) - 1;\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"The end of line can not be escaped\",\n                \"You can use '\\\\\\\\' to escape the '\\\\'\"\n        ));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createTheEndOfLineCanNotBeEscaped", "params": [{"name": "expression", "type": "String"}], "body": "                                                                                            {\n        int index = expression.codePointCount(0, expression.length()) - 1;\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"The end of line can not be escaped\",\n                \"You can use '\\\\\\\\' to escape the '\\\\'\"\n        ));\n    }", "signature": "static CucumberExpressionException createTheEndOfLineCanNotBeEscaped(String expression)"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createAlternativeMayNotBeEmpty(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Alternative may not be empty\",\n                \"If you did not mean to use an alternative you can use '\\\\/' to escape the '/'\"));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createAlternativeMayNotBeEmpty", "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}], "body": "                                                                                                    {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Alternative may not be empty\",\n                \"If you did not mean to use an alternative you can use '\\\\/' to escape the '/'\"));\n    }", "signature": "static CucumberExpressionException createAlternativeMayNotBeEmpty(Node node, String expression)"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createParameterIsNotAllowedInOptional(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain a parameter type\",\n                \"If you did not mean to use an parameter type you can use '\\\\{' to escape the '{'\"));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createParameterIsNotAllowedInOptional", "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}], "body": "                                                                                                           {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain a parameter type\",\n                \"If you did not mean to use an parameter type you can use '\\\\{' to escape the '{'\"));\n    }", "signature": "static CucumberExpressionException createParameterIsNotAllowedInOptional(Node node, String expression)"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createOptionalIsNotAllowedInOptional(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain an other optional\",\n                \"If you did not mean to use an optional type you can use '\\\\(' to escape the '('. For more complicated expressions consider using a regular expression instead.\"));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createOptionalIsNotAllowedInOptional", "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}], "body": "                                                                                                          {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain an other optional\",\n                \"If you did not mean to use an optional type you can use '\\\\(' to escape the '('. For more complicated expressions consider using a regular expression instead.\"));\n    }", "signature": "static CucumberExpressionException createOptionalIsNotAllowedInOptional(Node node, String expression)"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createOptionalMayNotBeEmpty(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional must contain some text\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createOptionalMayNotBeEmpty", "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}], "body": "                                                                                                 {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional must contain some text\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }", "signature": "static CucumberExpressionException createOptionalMayNotBeEmpty(Node node, String expression)"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createAlternativeMayNotExclusivelyContainOptionals(Node node,\n            String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An alternative may not exclusively contain optionals\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createAlternativeMayNotExclusivelyContainOptionals", "params": [{"name": "node", "type": "Node"}, {"name": "expression", "type": "String"}], "body": "                               {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An alternative may not exclusively contain optionals\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }", "signature": "static CucumberExpressionException createAlternativeMayNotExclusivelyContainOptionals(Node node,\n            String expression)"}, {"syntax_pass": true, "original_string": "    private static String thisCucumberExpressionHasAProblemAt(int index) {\n        return \"This Cucumber Expression has a problem at column \" + (index + 1) + \":\" + \"\\n\";\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "thisCucumberExpressionHasAProblemAt", "params": [{"name": "index", "type": "int"}], "body": "                                                                         {\n        return \"This Cucumber Expression has a problem at column \" + (index + 1) + \":\" + \"\\n\";\n    }", "signature": "private static String thisCucumberExpressionHasAProblemAt(int index)"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createCantEscape(String expression, int index) {\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"Only the characters '{', '}', '(', ')', '\\\\', '/' and whitespace can be escaped\",\n                \"If you did mean to use an '\\\\' you can use '\\\\\\\\' to escape it\"));\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createCantEscape", "params": [{"name": "expression", "type": "String"}, {"name": "index", "type": "int"}], "body": "                                                                                      {\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"Only the characters '{', '}', '(', ')', '\\\\', '/' and whitespace can be escaped\",\n                \"If you did mean to use an '\\\\' you can use '\\\\\\\\' to escape it\"));\n    }", "signature": "static CucumberExpressionException createCantEscape(String expression, int index)"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createInvalidParameterTypeName(String name) {\n        return new CucumberExpressionException(\n                \"Illegal character in parameter name {\" + name + \"}. Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\");\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createInvalidParameterTypeName", "params": [{"name": "name", "type": "String"}], "body": "                                                                                   {\n        return new CucumberExpressionException(\n                \"Illegal character in parameter name {\" + name + \"}. Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\");\n    }", "signature": "static CucumberExpressionException createInvalidParameterTypeName(String name)"}, {"syntax_pass": true, "original_string": "    static CucumberExpressionException createInvalidParameterTypeName(Token token, String expression) {\n        return new CucumberExpressionException(message(\n                token.start(),\n                expression,\n                pointAt(token),\n                \"Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\",\n                \"Did you mean to use a regular expression?\"));\n    }", "docstring": "\nNot very clear, but this message has to be language independent\nOther languages have dedicated syntax for writing down regular expressions\n<p>\nIn java a regular expression has to start with {@code ^} and end with\n{@code $} to be recognized as one by Cucumber.\n\n@see ExpressionFactory\n", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "CucumberExpressionException", "classes": []}, "name": "createInvalidParameterTypeName", "params": [{"name": "token", "type": "Token"}, {"name": "expression", "type": "String"}], "body": "                                                                                                      {\n        return new CucumberExpressionException(message(\n                token.start(),\n                expression,\n                pointAt(token),\n                \"Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\",\n                \"Did you mean to use a regular expression?\"));\n    }", "signature": "static CucumberExpressionException createInvalidParameterTypeName(Token token, String expression)"}, {"syntax_pass": true, "original_string": "    static String message(int index, String expression, String pointer, String problem,\n            String solution) {\n        return thisCucumberExpressionHasAProblemAt(index) +\n                \"\\n\" +\n                expression + \"\\n\" +\n                pointer + \"\\n\" +\n                problem + \".\\n\" +\n                solution;\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "name": "message", "params": [{"name": "index", "type": "int"}, {"name": "expression", "type": "String"}, {"name": "pointer", "type": "String"}, {"name": "problem", "type": "String"}, {"name": "solution", "type": "String"}], "body": "                             {\n        return thisCucumberExpressionHasAProblemAt(index) +\n                \"\\n\" +\n                expression + \"\\n\" +\n                pointer + \"\\n\" +\n                problem + \".\\n\" +\n                solution;\n    }", "signature": "static String message(int index, String expression, String pointer, String problem,\n            String solution)"}, {"syntax_pass": true, "original_string": "    static String pointAt(Located node) {\n        StringBuilder pointer = new StringBuilder(pointAt(node.start()));\n        if (node.start() + 1 < node.end()) {\n            for (int i = node.start() + 1; i < node.end() - 1; i++) {\n                pointer.append(\"-\");\n            }\n            pointer.append(\"^\");\n        }\n        return pointer.toString();\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "name": "pointAt", "params": [{"name": "node", "type": "Located"}], "body": "                                        {\n        StringBuilder pointer = new StringBuilder(pointAt(node.start()));\n        if (node.start() + 1 < node.end()) {\n            for (int i = node.start() + 1; i < node.end() - 1; i++) {\n                pointer.append(\"-\");\n            }\n            pointer.append(\"^\");\n        }\n        return pointer.toString();\n    }", "signature": "static String pointAt(Located node)"}, {"syntax_pass": true, "original_string": "    private static String pointAt(int index) {\n        StringBuilder pointer = new StringBuilder();\n        for (int i = 0; i < index; i++) {\n            pointer.append(\" \");\n        }\n        pointer.append(\"^\");\n        return pointer.toString();\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "pointAt", "params": [{"name": "index", "type": "int"}], "body": "                                             {\n        StringBuilder pointer = new StringBuilder();\n        for (int i = 0; i < index; i++) {\n            pointer.append(\" \");\n        }\n        pointer.append(\"^\");\n        return pointer.toString();\n    }", "signature": "private static String pointAt(int index)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/Ast.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Objects.requireNonNull;\nimport static java.util.stream.Collectors.joining;\n\nfinal class Ast {\n\n    private static final char escapeCharacter = '\\\\';\n    private static final char alternationCharacter = '/';\n    private static final char beginParameterCharacter = '{';\n    private static final char endParameterCharacter = '}';\n    private static final char beginOptionalCharacter = '(';\n    private static final char endOptionalCharacter = ')';\n\n    interface Located {\n        int start();\n\n        int end();\n\n    }\n\n    static final class Node implements Located {\n\n        private final Type type;\n        private final List<Node> nodes;\n        private final String token;\n        private final int start;\n        private final int end;\n\n        Node(Type type, int start, int end, String token) {\n            this(type, start, end, null, token);\n        }\n\n        Node(Type type, int start, int end, List<Node> nodes) {\n            this(type, start, end, nodes, null);\n        }\n\n        private Node(Type type, int start, int end, List<Node> nodes, String token) {\n            this.type = requireNonNull(type);\n            this.nodes = nodes;\n            this.token = token;\n            this.start = start;\n            this.end = end;\n        }\n\n        enum Type {\n            TEXT_NODE,\n            OPTIONAL_NODE,\n            ALTERNATION_NODE,\n            ALTERNATIVE_NODE,\n            PARAMETER_NODE,\n            EXPRESSION_NODE\n        }\n\n        public int start() {\n            return start;\n        }\n\n        public int end() {\n            return end;\n        }\n\n        List<Node> nodes() {\n            return nodes;\n        }\n\n        Type type() {\n            return type;\n        }\n\n        String text() {\n            if (nodes == null)\n                return token;\n\n            return nodes().stream()\n                    .map(Node::text)\n                    .collect(joining());\n        }\n\n        @Override\n        public String toString() {\n            return toString(0).toString();\n        }\n\n        private StringBuilder toString(int depth) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < depth; i++) {\n                sb.append(\"  \");\n            }\n            sb.append(\"{\")\n                    .append(\"\\\"type\\\": \\\"\").append(type)\n                    .append(\"\\\", \\\"start\\\": \")\n                    .append(start)\n                    .append(\", \\\"end\\\": \")\n                    .append(end);\n\n            if (token != null) {\n                sb.append(\", \\\"token\\\": \\\"\").append(token.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")).append(\"\\\"\");\n            }\n\n            if (nodes != null) {\n                sb.append(\", \\\"nodes\\\": \");\n                if (!nodes.isEmpty()) {\n                StringBuilder padding = new StringBuilder();\n                for (int i = 0; i < depth; i++) {\n                    padding.append(\"  \");\n                }\n                sb.append(nodes.stream()\n                        .map(node -> node.toString(depth + 1))\n                        .collect(joining(\",\\n\", \"[\\n\", \"\\n\" +padding + \"]\")));\n\n                } else {\n                    sb.append(\"[]\");\n                }\n            }\n            sb.append(\"}\");\n            return sb;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Node node = (Node) o;\n            return start == node.start &&\n                    end == node.end &&\n                    type == node.type &&\n                    Objects.equals(nodes, node.nodes) &&\n                    Objects.equals(token, node.token);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(type, nodes, token, start, end);\n        }\n\n    }\n\n    static final class Token implements Located {\n\n        final String text;\n        final Token.Type type;\n        final int start;\n        final int end;\n\n        Token(String text, Token.Type type, int start, int end) {\n            this.text = requireNonNull(text);\n            this.type = requireNonNull(type);\n            this.start = start;\n            this.end = end;\n        }\n\n        static boolean canEscape(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return true;\n            }\n            switch (token) {\n                case (int) escapeCharacter:\n                case (int) alternationCharacter:\n                case (int) beginParameterCharacter:\n                case (int) endParameterCharacter:\n                case (int) beginOptionalCharacter:\n                case (int) endOptionalCharacter:\n                    return true;\n            }\n            return false;\n        }\n\n        static Type typeOf(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return Type.WHITE_SPACE;\n            }\n            switch (token) {\n                case (int) alternationCharacter:\n                    return Type.ALTERNATION;\n                case (int) beginParameterCharacter:\n                    return Type.BEGIN_PARAMETER;\n                case (int) endParameterCharacter:\n                    return Type.END_PARAMETER;\n                case (int) beginOptionalCharacter:\n                    return Type.BEGIN_OPTIONAL;\n                case (int) endOptionalCharacter:\n                    return Type.END_OPTIONAL;\n            }\n            return Type.TEXT;\n        }\n\n        static boolean isEscapeCharacter(int token) {\n            return token == escapeCharacter;\n        }\n\n        public int start() {\n            return start;\n        }\n\n        public int end() {\n            return end;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Token token = (Token) o;\n            return start == token.start &&\n                    end == token.end &&\n                    text.equals(token.text) &&\n                    type == token.type;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(start, end, text, type);\n        }\n\n        @Override\n        public String toString() {\n            return new StringJoiner(\", \", \"\" + \"{\", \"}\")\n                    .add(\"\\\"type\\\": \\\"\" + type + \"\\\"\")\n                    .add(\"\\\"start\\\": \" + start + \"\")\n                    .add(\"\\\"end\\\": \" + end + \"\")\n                    .add(\"\\\"text\\\": \\\"\" + text + \"\\\"\")\n                    .toString();\n        }\n\n        enum Type {\n            START_OF_LINE,\n            END_OF_LINE,\n            WHITE_SPACE,\n            BEGIN_OPTIONAL(\"\" + beginOptionalCharacter, \"optional text\"),\n            END_OPTIONAL(\"\" + endOptionalCharacter, \"optional text\"),\n            BEGIN_PARAMETER(\"\" + beginParameterCharacter, \"a parameter\"),\n            END_PARAMETER(\"\" + endParameterCharacter, \"a parameter\"),\n            ALTERNATION(\"\" + alternationCharacter, \"alternation\"),\n            TEXT;\n\n            private final String symbol;\n            private final String purpose;\n\n            Type() {\n                this(null, null);\n            }\n\n            Type(String symbol, String purpose) {\n                this.symbol = symbol;\n                this.purpose = purpose;\n            }\n\n            String purpose() {\n                return requireNonNull(purpose, name() + \" does not have a purpose\");\n            }\n\n            String symbol() {\n                return requireNonNull(symbol, name() + \" does not have a symbol\");\n            }\n        }\n\n    }\n\n}\n", "file_hash": "40b511782301d9efd9558bf2dce38d67cf875086a4b8fa13b840dd12ed4eb90c", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import java.util.List;", "import java.util.Objects;", "import java.util.StringJoiner;", "import static java.util.Arrays.asList;", "import static java.util.Objects.requireNonNull;", "import static java.util.stream.Collectors.joining;"], "methods": [], "classes": [{"original_string": "final class Ast {\n\n    private static final char escapeCharacter = '\\\\';\n    private static final char alternationCharacter = '/';\n    private static final char beginParameterCharacter = '{';\n    private static final char endParameterCharacter = '}';\n    private static final char beginOptionalCharacter = '(';\n    private static final char endOptionalCharacter = ')';\n\n    interface Located {\n        int start();\n\n        int end();\n\n    }\n\n    static final class Node implements Located {\n\n        private final Type type;\n        private final List<Node> nodes;\n        private final String token;\n        private final int start;\n        private final int end;\n\n        Node(Type type, int start, int end, String token) {\n            this(type, start, end, null, token);\n        }\n\n        Node(Type type, int start, int end, List<Node> nodes) {\n            this(type, start, end, nodes, null);\n        }\n\n        private Node(Type type, int start, int end, List<Node> nodes, String token) {\n            this.type = requireNonNull(type);\n            this.nodes = nodes;\n            this.token = token;\n            this.start = start;\n            this.end = end;\n        }\n\n        enum Type {\n            TEXT_NODE,\n            OPTIONAL_NODE,\n            ALTERNATION_NODE,\n            ALTERNATIVE_NODE,\n            PARAMETER_NODE,\n            EXPRESSION_NODE\n        }\n\n        public int start() {\n            return start;\n        }\n\n        public int end() {\n            return end;\n        }\n\n        List<Node> nodes() {\n            return nodes;\n        }\n\n        Type type() {\n            return type;\n        }\n\n        String text() {\n            if (nodes == null)\n                return token;\n\n            return nodes().stream()\n                    .map(Node::text)\n                    .collect(joining());\n        }\n\n        @Override\n        public String toString() {\n            return toString(0).toString();\n        }\n\n        private StringBuilder toString(int depth) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < depth; i++) {\n                sb.append(\"  \");\n            }\n            sb.append(\"{\")\n                    .append(\"\\\"type\\\": \\\"\").append(type)\n                    .append(\"\\\", \\\"start\\\": \")\n                    .append(start)\n                    .append(\", \\\"end\\\": \")\n                    .append(end);\n\n            if (token != null) {\n                sb.append(\", \\\"token\\\": \\\"\").append(token.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")).append(\"\\\"\");\n            }\n\n            if (nodes != null) {\n                sb.append(\", \\\"nodes\\\": \");\n                if (!nodes.isEmpty()) {\n                StringBuilder padding = new StringBuilder();\n                for (int i = 0; i < depth; i++) {\n                    padding.append(\"  \");\n                }\n                sb.append(nodes.stream()\n                        .map(node -> node.toString(depth + 1))\n                        .collect(joining(\",\\n\", \"[\\n\", \"\\n\" +padding + \"]\")));\n\n                } else {\n                    sb.append(\"[]\");\n                }\n            }\n            sb.append(\"}\");\n            return sb;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Node node = (Node) o;\n            return start == node.start &&\n                    end == node.end &&\n                    type == node.type &&\n                    Objects.equals(nodes, node.nodes) &&\n                    Objects.equals(token, node.token);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(type, nodes, token, start, end);\n        }\n\n    }\n\n    static final class Token implements Located {\n\n        final String text;\n        final Token.Type type;\n        final int start;\n        final int end;\n\n        Token(String text, Token.Type type, int start, int end) {\n            this.text = requireNonNull(text);\n            this.type = requireNonNull(type);\n            this.start = start;\n            this.end = end;\n        }\n\n        static boolean canEscape(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return true;\n            }\n            switch (token) {\n                case (int) escapeCharacter:\n                case (int) alternationCharacter:\n                case (int) beginParameterCharacter:\n                case (int) endParameterCharacter:\n                case (int) beginOptionalCharacter:\n                case (int) endOptionalCharacter:\n                    return true;\n            }\n            return false;\n        }\n\n        static Type typeOf(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return Type.WHITE_SPACE;\n            }\n            switch (token) {\n                case (int) alternationCharacter:\n                    return Type.ALTERNATION;\n                case (int) beginParameterCharacter:\n                    return Type.BEGIN_PARAMETER;\n                case (int) endParameterCharacter:\n                    return Type.END_PARAMETER;\n                case (int) beginOptionalCharacter:\n                    return Type.BEGIN_OPTIONAL;\n                case (int) endOptionalCharacter:\n                    return Type.END_OPTIONAL;\n            }\n            return Type.TEXT;\n        }\n\n        static boolean isEscapeCharacter(int token) {\n            return token == escapeCharacter;\n        }\n\n        public int start() {\n            return start;\n        }\n\n        public int end() {\n            return end;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Token token = (Token) o;\n            return start == token.start &&\n                    end == token.end &&\n                    text.equals(token.text) &&\n                    type == token.type;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(start, end, text, type);\n        }\n\n        @Override\n        public String toString() {\n            return new StringJoiner(\", \", \"\" + \"{\", \"}\")\n                    .add(\"\\\"type\\\": \\\"\" + type + \"\\\"\")\n                    .add(\"\\\"start\\\": \" + start + \"\")\n                    .add(\"\\\"end\\\": \" + end + \"\")\n                    .add(\"\\\"text\\\": \\\"\" + text + \"\\\"\")\n                    .toString();\n        }\n\n        enum Type {\n            START_OF_LINE,\n            END_OF_LINE,\n            WHITE_SPACE,\n            BEGIN_OPTIONAL(\"\" + beginOptionalCharacter, \"optional text\"),\n            END_OPTIONAL(\"\" + endOptionalCharacter, \"optional text\"),\n            BEGIN_PARAMETER(\"\" + beginParameterCharacter, \"a parameter\"),\n            END_PARAMETER(\"\" + endParameterCharacter, \"a parameter\"),\n            ALTERNATION(\"\" + alternationCharacter, \"alternation\"),\n            TEXT;\n\n            private final String symbol;\n            private final String purpose;\n\n            Type() {\n                this(null, null);\n            }\n\n            Type(String symbol, String purpose) {\n                this.symbol = symbol;\n                this.purpose = purpose;\n            }\n\n            String purpose() {\n                return requireNonNull(purpose, name() + \" does not have a purpose\");\n            }\n\n            String symbol() {\n                return requireNonNull(symbol, name() + \" does not have a symbol\");\n            }\n        }\n\n    }\n\n}", "definition": "final class Ast", "class_docstring": "", "name": "Ast", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private static final char escapeCharacter = '\\\\';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "escapeCharacter = '\\\\'", "syntax_pass": true}, {"attribute_expression": "private static final char alternationCharacter = '/';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "alternationCharacter = '/'", "syntax_pass": true}, {"attribute_expression": "private static final char beginParameterCharacter = '{';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "beginParameterCharacter = '{'", "syntax_pass": true}, {"attribute_expression": "private static final char endParameterCharacter = '}';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "endParameterCharacter = '}'", "syntax_pass": true}, {"attribute_expression": "private static final char beginOptionalCharacter = '(';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "beginOptionalCharacter = '('", "syntax_pass": true}, {"attribute_expression": "private static final char endOptionalCharacter = ')';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "endOptionalCharacter = ')'", "syntax_pass": true}], "classes": [{"original_string": "    static final class Node implements Located {\n\n        private final Type type;\n        private final List<Node> nodes;\n        private final String token;\n        private final int start;\n        private final int end;\n\n        Node(Type type, int start, int end, String token) {\n            this(type, start, end, null, token);\n        }\n\n        Node(Type type, int start, int end, List<Node> nodes) {\n            this(type, start, end, nodes, null);\n        }\n\n        private Node(Type type, int start, int end, List<Node> nodes, String token) {\n            this.type = requireNonNull(type);\n            this.nodes = nodes;\n            this.token = token;\n            this.start = start;\n            this.end = end;\n        }\n\n        enum Type {\n            TEXT_NODE,\n            OPTIONAL_NODE,\n            ALTERNATION_NODE,\n            ALTERNATIVE_NODE,\n            PARAMETER_NODE,\n            EXPRESSION_NODE\n        }\n\n        public int start() {\n            return start;\n        }\n\n        public int end() {\n            return end;\n        }\n\n        List<Node> nodes() {\n            return nodes;\n        }\n\n        Type type() {\n            return type;\n        }\n\n        String text() {\n            if (nodes == null)\n                return token;\n\n            return nodes().stream()\n                    .map(Node::text)\n                    .collect(joining());\n        }\n\n        @Override\n        public String toString() {\n            return toString(0).toString();\n        }\n\n        private StringBuilder toString(int depth) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < depth; i++) {\n                sb.append(\"  \");\n            }\n            sb.append(\"{\")\n                    .append(\"\\\"type\\\": \\\"\").append(type)\n                    .append(\"\\\", \\\"start\\\": \")\n                    .append(start)\n                    .append(\", \\\"end\\\": \")\n                    .append(end);\n\n            if (token != null) {\n                sb.append(\", \\\"token\\\": \\\"\").append(token.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")).append(\"\\\"\");\n            }\n\n            if (nodes != null) {\n                sb.append(\", \\\"nodes\\\": \");\n                if (!nodes.isEmpty()) {\n                StringBuilder padding = new StringBuilder();\n                for (int i = 0; i < depth; i++) {\n                    padding.append(\"  \");\n                }\n                sb.append(nodes.stream()\n                        .map(node -> node.toString(depth + 1))\n                        .collect(joining(\",\\n\", \"[\\n\", \"\\n\" +padding + \"]\")));\n\n                } else {\n                    sb.append(\"[]\");\n                }\n            }\n            sb.append(\"}\");\n            return sb;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Node node = (Node) o;\n            return start == node.start &&\n                    end == node.end &&\n                    type == node.type &&\n                    Objects.equals(nodes, node.nodes) &&\n                    Objects.equals(token, node.token);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(type, nodes, token, start, end);\n        }\n\n    }", "definition": "    static final class Node implements Located", "class_docstring": "", "name": "Node", "super_interfaces": ["Located"], "superclasses": "", "attributes": {"modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Type type;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "private final List<Node> nodes;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Node>", "name": "nodes", "syntax_pass": true}, {"attribute_expression": "private final String token;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "token", "syntax_pass": true}, {"attribute_expression": "private final int start;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "private final int end;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Node(Type type, int start, int end, String token) {\n            this(type, start, end, null, token);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "type", "type": "Type"}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "token", "type": "String"}], "body": "                                                          {\n            this(type, start, end, null, token);\n        }", "signature": "Node(Type type, int start, int end, String token)"}, {"syntax_pass": true, "original_string": "        Node(Type type, int start, int end, List<Node> nodes) {\n            this(type, start, end, nodes, null);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "type", "type": "Type"}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "nodes", "type": "List<Node>"}], "body": "                                                              {\n            this(type, start, end, nodes, null);\n        }", "signature": "Node(Type type, int start, int end, List<Node> nodes)"}, {"syntax_pass": true, "original_string": "        private Node(Type type, int start, int end, List<Node> nodes, String token) {\n            this.type = requireNonNull(type);\n            this.nodes = nodes;\n            this.token = token;\n            this.start = start;\n            this.end = end;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "type", "type": "Type"}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "nodes", "type": "List<Node>"}, {"name": "token", "type": "String"}], "body": "                                                                                    {\n            this.type = requireNonNull(type);\n            this.nodes = nodes;\n            this.token = token;\n            this.start = start;\n            this.end = end;\n        }", "signature": "private Node(Type type, int start, int end, List<Node> nodes, String token)"}, {"syntax_pass": true, "original_string": "        public int start() {\n            return start;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "start", "params": [], "body": "                           {\n            return start;\n        }", "signature": "public int start()"}, {"syntax_pass": true, "original_string": "        public int end() {\n            return end;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "end", "params": [], "body": "                         {\n            return end;\n        }", "signature": "public int end()"}, {"syntax_pass": true, "original_string": "        List<Node> nodes() {\n            return nodes;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Node>", "classes": []}, "name": "nodes", "params": [], "body": "                           {\n            return nodes;\n        }", "signature": "List<Node> nodes()"}, {"syntax_pass": true, "original_string": "        Type type() {\n            return type;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Type", "classes": []}, "name": "type", "params": [], "body": "                    {\n            return type;\n        }", "signature": "Type type()"}, {"syntax_pass": true, "original_string": "        String text() {\n            if (nodes == null)\n                return token;\n\n            return nodes().stream()\n                    .map(Node::text)\n                    .collect(joining());\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "text", "params": [], "body": "                      {\n            if (nodes == null)\n                return token;\n\n            return nodes().stream()\n                    .map(Node::text)\n                    .collect(joining());\n        }", "signature": "String text()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return toString(0).toString();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return toString(0).toString();\n        }", "signature": "@Override\n        public String toString()"}, {"syntax_pass": true, "original_string": "        private StringBuilder toString(int depth) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < depth; i++) {\n                sb.append(\"  \");\n            }\n            sb.append(\"{\")\n                    .append(\"\\\"type\\\": \\\"\").append(type)\n                    .append(\"\\\", \\\"start\\\": \")\n                    .append(start)\n                    .append(\", \\\"end\\\": \")\n                    .append(end);\n\n            if (token != null) {\n                sb.append(\", \\\"token\\\": \\\"\").append(token.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")).append(\"\\\"\");\n            }\n\n            if (nodes != null) {\n                sb.append(\", \\\"nodes\\\": \");\n                if (!nodes.isEmpty()) {\n                StringBuilder padding = new StringBuilder();\n                for (int i = 0; i < depth; i++) {\n                    padding.append(\"  \");\n                }\n                sb.append(nodes.stream()\n                        .map(node -> node.toString(depth + 1))\n                        .collect(joining(\",\\n\", \"[\\n\", \"\\n\" +padding + \"]\")));\n\n                } else {\n                    sb.append(\"[]\");\n                }\n            }\n            sb.append(\"}\");\n            return sb;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "toString", "params": [{"name": "depth", "type": "int"}], "body": "                                                  {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < depth; i++) {\n                sb.append(\"  \");\n            }\n            sb.append(\"{\")\n                    .append(\"\\\"type\\\": \\\"\").append(type)\n                    .append(\"\\\", \\\"start\\\": \")\n                    .append(start)\n                    .append(\", \\\"end\\\": \")\n                    .append(end);\n\n            if (token != null) {\n                sb.append(\", \\\"token\\\": \\\"\").append(token.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")).append(\"\\\"\");\n            }\n\n            if (nodes != null) {\n                sb.append(\", \\\"nodes\\\": \");\n                if (!nodes.isEmpty()) {\n                StringBuilder padding = new StringBuilder();\n                for (int i = 0; i < depth; i++) {\n                    padding.append(\"  \");\n                }\n                sb.append(nodes.stream()\n                        .map(node -> node.toString(depth + 1))\n                        .collect(joining(\",\\n\", \"[\\n\", \"\\n\" +padding + \"]\")));\n\n                } else {\n                    sb.append(\"[]\");\n                }\n            }\n            sb.append(\"}\");\n            return sb;\n        }", "signature": "private StringBuilder toString(int depth)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Node node = (Node) o;\n            return start == node.start &&\n                    end == node.end &&\n                    type == node.type &&\n                    Objects.equals(nodes, node.nodes) &&\n                    Objects.equals(token, node.token);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                        {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Node node = (Node) o;\n            return start == node.start &&\n                    end == node.end &&\n                    type == node.type &&\n                    Objects.equals(nodes, node.nodes) &&\n                    Objects.equals(token, node.token);\n        }", "signature": "@Override\n        public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return Objects.hash(type, nodes, token, start, end);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return Objects.hash(type, nodes, token, start, end);\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    static final class Token implements Located {\n\n        final String text;\n        final Token.Type type;\n        final int start;\n        final int end;\n\n        Token(String text, Token.Type type, int start, int end) {\n            this.text = requireNonNull(text);\n            this.type = requireNonNull(type);\n            this.start = start;\n            this.end = end;\n        }\n\n        static boolean canEscape(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return true;\n            }\n            switch (token) {\n                case (int) escapeCharacter:\n                case (int) alternationCharacter:\n                case (int) beginParameterCharacter:\n                case (int) endParameterCharacter:\n                case (int) beginOptionalCharacter:\n                case (int) endOptionalCharacter:\n                    return true;\n            }\n            return false;\n        }\n\n        static Type typeOf(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return Type.WHITE_SPACE;\n            }\n            switch (token) {\n                case (int) alternationCharacter:\n                    return Type.ALTERNATION;\n                case (int) beginParameterCharacter:\n                    return Type.BEGIN_PARAMETER;\n                case (int) endParameterCharacter:\n                    return Type.END_PARAMETER;\n                case (int) beginOptionalCharacter:\n                    return Type.BEGIN_OPTIONAL;\n                case (int) endOptionalCharacter:\n                    return Type.END_OPTIONAL;\n            }\n            return Type.TEXT;\n        }\n\n        static boolean isEscapeCharacter(int token) {\n            return token == escapeCharacter;\n        }\n\n        public int start() {\n            return start;\n        }\n\n        public int end() {\n            return end;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Token token = (Token) o;\n            return start == token.start &&\n                    end == token.end &&\n                    text.equals(token.text) &&\n                    type == token.type;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(start, end, text, type);\n        }\n\n        @Override\n        public String toString() {\n            return new StringJoiner(\", \", \"\" + \"{\", \"}\")\n                    .add(\"\\\"type\\\": \\\"\" + type + \"\\\"\")\n                    .add(\"\\\"start\\\": \" + start + \"\")\n                    .add(\"\\\"end\\\": \" + end + \"\")\n                    .add(\"\\\"text\\\": \\\"\" + text + \"\\\"\")\n                    .toString();\n        }\n\n        enum Type {\n            START_OF_LINE,\n            END_OF_LINE,\n            WHITE_SPACE,\n            BEGIN_OPTIONAL(\"\" + beginOptionalCharacter, \"optional text\"),\n            END_OPTIONAL(\"\" + endOptionalCharacter, \"optional text\"),\n            BEGIN_PARAMETER(\"\" + beginParameterCharacter, \"a parameter\"),\n            END_PARAMETER(\"\" + endParameterCharacter, \"a parameter\"),\n            ALTERNATION(\"\" + alternationCharacter, \"alternation\"),\n            TEXT;\n\n            private final String symbol;\n            private final String purpose;\n\n            Type() {\n                this(null, null);\n            }\n\n            Type(String symbol, String purpose) {\n                this.symbol = symbol;\n                this.purpose = purpose;\n            }\n\n            String purpose() {\n                return requireNonNull(purpose, name() + \" does not have a purpose\");\n            }\n\n            String symbol() {\n                return requireNonNull(symbol, name() + \" does not have a symbol\");\n            }\n        }\n\n    }", "definition": "    static final class Token implements Located", "class_docstring": "", "name": "Token", "super_interfaces": ["Located"], "superclasses": "", "attributes": {"modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "fields": [{"attribute_expression": "final String text;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "text", "syntax_pass": true}, {"attribute_expression": "final Token.Type type;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Token.Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "final int start;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "final int end;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Token(String text, Token.Type type, int start, int end) {\n            this.text = requireNonNull(text);\n            this.type = requireNonNull(type);\n            this.start = start;\n            this.end = end;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Token", "params": [{"name": "text", "type": "String"}, {"name": "type", "type": "Token.Type"}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}], "body": "                                                                {\n            this.text = requireNonNull(text);\n            this.type = requireNonNull(type);\n            this.start = start;\n            this.end = end;\n        }", "signature": "Token(String text, Token.Type type, int start, int end)"}, {"syntax_pass": true, "original_string": "        static boolean canEscape(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return true;\n            }\n            switch (token) {\n                case (int) escapeCharacter:\n                case (int) alternationCharacter:\n                case (int) beginParameterCharacter:\n                case (int) endParameterCharacter:\n                case (int) beginOptionalCharacter:\n                case (int) endOptionalCharacter:\n                    return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "canEscape", "params": [{"name": "token", "type": "Integer"}], "body": "                                                {\n            if (Character.isWhitespace(token)) {\n                return true;\n            }\n            switch (token) {\n                case (int) escapeCharacter:\n                case (int) alternationCharacter:\n                case (int) beginParameterCharacter:\n                case (int) endParameterCharacter:\n                case (int) beginOptionalCharacter:\n                case (int) endOptionalCharacter:\n                    return true;\n            }\n            return false;\n        }", "signature": "static boolean canEscape(Integer token)"}, {"syntax_pass": true, "original_string": "        static Type typeOf(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return Type.WHITE_SPACE;\n            }\n            switch (token) {\n                case (int) alternationCharacter:\n                    return Type.ALTERNATION;\n                case (int) beginParameterCharacter:\n                    return Type.BEGIN_PARAMETER;\n                case (int) endParameterCharacter:\n                    return Type.END_PARAMETER;\n                case (int) beginOptionalCharacter:\n                    return Type.BEGIN_OPTIONAL;\n                case (int) endOptionalCharacter:\n                    return Type.END_OPTIONAL;\n            }\n            return Type.TEXT;\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Type", "classes": []}, "name": "typeOf", "params": [{"name": "token", "type": "Integer"}], "body": "                                          {\n            if (Character.isWhitespace(token)) {\n                return Type.WHITE_SPACE;\n            }\n            switch (token) {\n                case (int) alternationCharacter:\n                    return Type.ALTERNATION;\n                case (int) beginParameterCharacter:\n                    return Type.BEGIN_PARAMETER;\n                case (int) endParameterCharacter:\n                    return Type.END_PARAMETER;\n                case (int) beginOptionalCharacter:\n                    return Type.BEGIN_OPTIONAL;\n                case (int) endOptionalCharacter:\n                    return Type.END_OPTIONAL;\n            }\n            return Type.TEXT;\n        }", "signature": "static Type typeOf(Integer token)"}, {"syntax_pass": true, "original_string": "        static boolean isEscapeCharacter(int token) {\n            return token == escapeCharacter;\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEscapeCharacter", "params": [{"name": "token", "type": "int"}], "body": "                                                    {\n            return token == escapeCharacter;\n        }", "signature": "static boolean isEscapeCharacter(int token)"}, {"syntax_pass": true, "original_string": "        public int start() {\n            return start;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "start", "params": [], "body": "                           {\n            return start;\n        }", "signature": "public int start()"}, {"syntax_pass": true, "original_string": "        public int end() {\n            return end;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "end", "params": [], "body": "                         {\n            return end;\n        }", "signature": "public int end()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Token token = (Token) o;\n            return start == token.start &&\n                    end == token.end &&\n                    text.equals(token.text) &&\n                    type == token.type;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                        {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Token token = (Token) o;\n            return start == token.start &&\n                    end == token.end &&\n                    text.equals(token.text) &&\n                    type == token.type;\n        }", "signature": "@Override\n        public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return Objects.hash(start, end, text, type);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return Objects.hash(start, end, text, type);\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return new StringJoiner(\", \", \"\" + \"{\", \"}\")\n                    .add(\"\\\"type\\\": \\\"\" + type + \"\\\"\")\n                    .add(\"\\\"start\\\": \" + start + \"\")\n                    .add(\"\\\"end\\\": \" + end + \"\")\n                    .add(\"\\\"text\\\": \\\"\" + text + \"\\\"\")\n                    .toString();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return new StringJoiner(\", \", \"\" + \"{\", \"}\")\n                    .add(\"\\\"type\\\": \\\"\" + type + \"\\\"\")\n                    .add(\"\\\"start\\\": \" + start + \"\")\n                    .add(\"\\\"end\\\": \" + end + \"\")\n                    .add(\"\\\"text\\\": \\\"\" + text + \"\\\"\")\n                    .toString();\n        }", "signature": "@Override\n        public String toString()"}]}]}, "syntax_pass": true, "methods": []}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport io.cucumber.cucumberexpressions.Ast.Node;\nimport io.cucumber.cucumberexpressions.Ast.Token;\nimport io.cucumber.cucumberexpressions.Ast.Token.Type;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static io.cucumber.cucumberexpressions.Ast.Node.Type.ALTERNATION_NODE;\nimport static io.cucumber.cucumberexpressions.Ast.Node.Type.ALTERNATIVE_NODE;\nimport static io.cucumber.cucumberexpressions.Ast.Node.Type.EXPRESSION_NODE;\nimport static io.cucumber.cucumberexpressions.Ast.Node.Type.OPTIONAL_NODE;\nimport static io.cucumber.cucumberexpressions.Ast.Node.Type.PARAMETER_NODE;\nimport static io.cucumber.cucumberexpressions.Ast.Node.Type.TEXT_NODE;\nimport static io.cucumber.cucumberexpressions.Ast.Token.Type.ALTERNATION;\nimport static io.cucumber.cucumberexpressions.Ast.Token.Type.BEGIN_OPTIONAL;\nimport static io.cucumber.cucumberexpressions.Ast.Token.Type.BEGIN_PARAMETER;\nimport static io.cucumber.cucumberexpressions.Ast.Token.Type.END_OF_LINE;\nimport static io.cucumber.cucumberexpressions.Ast.Token.Type.END_OPTIONAL;\nimport static io.cucumber.cucumberexpressions.Ast.Token.Type.END_PARAMETER;\nimport static io.cucumber.cucumberexpressions.Ast.Token.Type.START_OF_LINE;\nimport static io.cucumber.cucumberexpressions.Ast.Token.Type.WHITE_SPACE;\nimport static io.cucumber.cucumberexpressions.CucumberExpressionException.createAlternationNotAllowedInOptional;\nimport static io.cucumber.cucumberexpressions.CucumberExpressionException.createInvalidParameterTypeName;\nimport static io.cucumber.cucumberexpressions.CucumberExpressionException.createMissingEndToken;\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.singletonList;\n\nfinal class CucumberExpressionParser {\n\n    /*\n     * text := whitespace | ')' | '}' | .\n     */\n    private static final Parser textParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n            case END_PARAMETER:\n            case END_OPTIONAL:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case ALTERNATION:\n                throw createAlternationNotAllowedInOptional(expression, token);\n            case BEGIN_PARAMETER:\n            case START_OF_LINE:\n            case END_OF_LINE:\n            case BEGIN_OPTIONAL:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    };\n\n    /*\n     * name := whitespace | .\n     */\n    private static final Parser nameParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case BEGIN_OPTIONAL:\n            case END_OPTIONAL:\n            case BEGIN_PARAMETER:\n            case END_PARAMETER:\n            case ALTERNATION:\n                throw createInvalidParameterTypeName(token, expression);\n            case START_OF_LINE:\n            case END_OF_LINE:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    };\n\n    /*\n     * parameter := '{' + name* + '}'\n     */\n    private static final Parser parameterParser = parseBetween(\n            PARAMETER_NODE,\n            BEGIN_PARAMETER,\n            END_PARAMETER,\n            singletonList(nameParser)\n    );\n\n    /*\n     * optional := '(' + option* + ')'\n     * option := optional | parameter | text\n     */\n    private static final Parser optionalParser;\n    static {\n        List<Parser> parsers = new ArrayList<>();\n        optionalParser = parseBetween(\n                OPTIONAL_NODE,\n                BEGIN_OPTIONAL,\n                END_OPTIONAL,\n                parsers\n        );\n        parsers.addAll(asList(optionalParser, parameterParser, textParser));\n    }\n\n    /*\n     * alternation := alternative* + ( '/' + alternative* )+\n     */\n    private static final Parser alternativeSeparator = (expression, tokens, current) -> {\n        if (!lookingAt(tokens, current, ALTERNATION)) {\n            return new Result(0);\n        }\n        Token token = tokens.get(current);\n        return new Result(1, new Node(ALTERNATIVE_NODE, token.start(), token.end(), token.text));\n    };\n\n    private static final List<Parser> alternativeParsers = asList(\n            alternativeSeparator,\n            optionalParser,\n            parameterParser,\n            textParser\n    );\n\n    /*\n     * alternation := (?<=left-boundary) + alternative* + ( '/' + alternative* )+ + (?=right-boundary)\n     * left-boundary := whitespace | } | ^\n     * right-boundary := whitespace | { | $\n     * alternative: = optional | parameter | text\n     */\n    private static final Parser alternationParser = (expression, tokens, current) -> {\n        int previous = current - 1;\n        if (!lookingAtAny(tokens, previous, START_OF_LINE, WHITE_SPACE, END_PARAMETER)) {\n            return new Result(0);\n        }\n\n        Result result = parseTokensUntil(expression, alternativeParsers, tokens, current, WHITE_SPACE, END_OF_LINE, BEGIN_PARAMETER);\n        int subCurrent = current + result.consumed;\n        if (result.ast.stream().noneMatch(astNode -> astNode.type() == ALTERNATIVE_NODE)) {\n            return new Result(0);\n        }\n\n        int start = tokens.get(current).start();\n        int end = tokens.get(subCurrent).start();\n        // Does not consume right hand boundary token\n        return new Result(result.consumed,\n                new Node(ALTERNATION_NODE, start, end, splitAlternatives(start, end, result.ast)));\n    };\n\n    /*\n     * cucumber-expression :=  ( alternation | optional | parameter | text )*\n     */\n    private static final Parser cucumberExpressionParser = parseBetween(\n            EXPRESSION_NODE,\n            START_OF_LINE,\n            END_OF_LINE,\n            asList(\n                    alternationParser,\n                    optionalParser,\n                    parameterParser,\n                    textParser\n            )\n    );\n\n    Node parse(String expression) {\n        CucumberExpressionTokenizer tokenizer = new CucumberExpressionTokenizer();\n        List<Token> tokens = tokenizer.tokenize(expression);\n        Result result = cucumberExpressionParser.parse(expression, tokens, 0);\n        return result.ast.get(0);\n    }\n\n    private interface Parser {\n        Result parse(String expression, List<Token> tokens, int current);\n\n    }\n\n    private static final class Result {\n        final int consumed;\n        final List<Node> ast;\n\n        private Result(int consumed, Node... ast) {\n            this(consumed, Arrays.asList(ast));\n        }\n\n        private Result(int consumed, List<Node> ast) {\n            this.consumed = consumed;\n            this.ast = ast;\n        }\n\n    }\n\n    private static Parser parseBetween(\n            Node.Type type,\n            Type beginToken,\n            Type endToken,\n            List<Parser> parsers) {\n        return (expression, tokens, current) -> {\n            if (!lookingAt(tokens, current, beginToken)) {\n                return new Result(0);\n            }\n            int subCurrent = current + 1;\n            Result result = parseTokensUntil(expression, parsers, tokens, subCurrent, endToken, END_OF_LINE);\n            subCurrent += result.consumed;\n\n            // endToken not found\n            if (!lookingAt(tokens, subCurrent, endToken)) {\n                throw createMissingEndToken(expression, beginToken, endToken, tokens.get(current));\n            }\n            // consumes endToken\n            int start = tokens.get(current).start();\n            int end = tokens.get(subCurrent).end();\n            return new Result(subCurrent + 1 - current, new Node(type, start, end, result.ast));\n        };\n    }\n\n    private static Result parseTokensUntil(\n            String expression,\n            List<Parser> parsers,\n            List<Token> tokens,\n            int startAt,\n            Type... endTokens) {\n        int current = startAt;\n        int size = tokens.size();\n        List<Node> ast = new ArrayList<>();\n        while (current < size) {\n            if (lookingAtAny(tokens, current, endTokens)) {\n                break;\n            }\n\n            Result result = parseToken(expression, parsers, tokens, current);\n            if (result.consumed == 0) {\n                // If configured correctly this will never happen\n                // Keep to avoid infinite loops\n                throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n            }\n            current += result.consumed;\n            ast.addAll(result.ast);\n        }\n        return new Result(current - startAt, ast);\n    }\n\n    private static Result parseToken(String expression, List<Parser> parsers,\n            List<Token> tokens,\n            int startAt) {\n        for (Parser parser : parsers) {\n            Result result = parser.parse(expression, tokens, startAt);\n            if (result.consumed != 0) {\n                return result;\n            }\n        }\n        // If configured correctly this will never happen\n        throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n    }\n\n    private static boolean lookingAtAny(List<Token> tokens, int at, Type... tokenTypes) {\n        for (Type tokeType : tokenTypes) {\n            if (lookingAt(tokens, at, tokeType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean lookingAt(List<Token> tokens, int at, Type token) {\n        if (at < 0) {\n            // If configured correctly this will never happen\n            // Keep for completeness\n            return token == START_OF_LINE;\n        }\n        if (at >= tokens.size()) {\n            return token == END_OF_LINE;\n        }\n        return tokens.get(at).type == token;\n    }\n\n    private static List<Node> splitAlternatives(int start, int end, List<Node> alternation) {\n        List<Node> separators = new ArrayList<>();\n        List<List<Node>> alternatives = new ArrayList<>();\n        List<Node> alternative = new ArrayList<>();\n        for (Node n : alternation) {\n            if (ALTERNATIVE_NODE.equals(n.type())) {\n                separators.add(n);\n                alternatives.add(alternative);\n                alternative = new ArrayList<>();\n            } else {\n                alternative.add(n);\n            }\n        }\n        alternatives.add(alternative);\n\n        return createAlternativeNodes(start, end, separators, alternatives);\n    }\n\n    private static List<Node> createAlternativeNodes(int start, int end, List<Node> separators, List<List<Node>> alternatives) {\n        List<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < alternatives.size(); i++) {\n            List<Node> n = alternatives.get(i);\n            if (i == 0) {\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, start, rightSeparator.start(), n));\n            } else if (i == alternatives.size() - 1) {\n                Node leftSeparator = separators.get(i - 1);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), end, n));\n            } else {\n                Node leftSeparator = separators.get(i - 1);\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), rightSeparator.start(), n));\n            }\n        }\n        return nodes;\n    }\n\n}\n", "file_hash": "a2c3a866d5ad57b8ebc9a88429cc408ca2962d43fa613c433d7d6cfbbb5c025d", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import io.cucumber.cucumberexpressions.Ast.Node;", "import io.cucumber.cucumberexpressions.Ast.Token;", "import io.cucumber.cucumberexpressions.Ast.Token.Type;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.List;", "import static io.cucumber.cucumberexpressions.Ast.Node.Type.ALTERNATION_NODE;", "import static io.cucumber.cucumberexpressions.Ast.Node.Type.ALTERNATIVE_NODE;", "import static io.cucumber.cucumberexpressions.Ast.Node.Type.EXPRESSION_NODE;", "import static io.cucumber.cucumberexpressions.Ast.Node.Type.OPTIONAL_NODE;", "import static io.cucumber.cucumberexpressions.Ast.Node.Type.PARAMETER_NODE;", "import static io.cucumber.cucumberexpressions.Ast.Node.Type.TEXT_NODE;", "import static io.cucumber.cucumberexpressions.Ast.Token.Type.ALTERNATION;", "import static io.cucumber.cucumberexpressions.Ast.Token.Type.BEGIN_OPTIONAL;", "import static io.cucumber.cucumberexpressions.Ast.Token.Type.BEGIN_PARAMETER;", "import static io.cucumber.cucumberexpressions.Ast.Token.Type.END_OF_LINE;", "import static io.cucumber.cucumberexpressions.Ast.Token.Type.END_OPTIONAL;", "import static io.cucumber.cucumberexpressions.Ast.Token.Type.END_PARAMETER;", "import static io.cucumber.cucumberexpressions.Ast.Token.Type.START_OF_LINE;", "import static io.cucumber.cucumberexpressions.Ast.Token.Type.WHITE_SPACE;", "import static io.cucumber.cucumberexpressions.CucumberExpressionException.createAlternationNotAllowedInOptional;", "import static io.cucumber.cucumberexpressions.CucumberExpressionException.createInvalidParameterTypeName;", "import static io.cucumber.cucumberexpressions.CucumberExpressionException.createMissingEndToken;", "import static java.util.Arrays.asList;", "import static java.util.Collections.singletonList;"], "methods": [], "classes": [{"original_string": "final class CucumberExpressionParser {\n\n    /*\n     * text := whitespace | ')' | '}' | .\n     */\n    private static final Parser textParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n            case END_PARAMETER:\n            case END_OPTIONAL:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case ALTERNATION:\n                throw createAlternationNotAllowedInOptional(expression, token);\n            case BEGIN_PARAMETER:\n            case START_OF_LINE:\n            case END_OF_LINE:\n            case BEGIN_OPTIONAL:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    };\n\n    /*\n     * name := whitespace | .\n     */\n    private static final Parser nameParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case BEGIN_OPTIONAL:\n            case END_OPTIONAL:\n            case BEGIN_PARAMETER:\n            case END_PARAMETER:\n            case ALTERNATION:\n                throw createInvalidParameterTypeName(token, expression);\n            case START_OF_LINE:\n            case END_OF_LINE:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    };\n\n    /*\n     * parameter := '{' + name* + '}'\n     */\n    private static final Parser parameterParser = parseBetween(\n            PARAMETER_NODE,\n            BEGIN_PARAMETER,\n            END_PARAMETER,\n            singletonList(nameParser)\n    );\n\n    /*\n     * optional := '(' + option* + ')'\n     * option := optional | parameter | text\n     */\n    private static final Parser optionalParser;\n    static {\n        List<Parser> parsers = new ArrayList<>();\n        optionalParser = parseBetween(\n                OPTIONAL_NODE,\n                BEGIN_OPTIONAL,\n                END_OPTIONAL,\n                parsers\n        );\n        parsers.addAll(asList(optionalParser, parameterParser, textParser));\n    }\n\n    /*\n     * alternation := alternative* + ( '/' + alternative* )+\n     */\n    private static final Parser alternativeSeparator = (expression, tokens, current) -> {\n        if (!lookingAt(tokens, current, ALTERNATION)) {\n            return new Result(0);\n        }\n        Token token = tokens.get(current);\n        return new Result(1, new Node(ALTERNATIVE_NODE, token.start(), token.end(), token.text));\n    };\n\n    private static final List<Parser> alternativeParsers = asList(\n            alternativeSeparator,\n            optionalParser,\n            parameterParser,\n            textParser\n    );\n\n    /*\n     * alternation := (?<=left-boundary) + alternative* + ( '/' + alternative* )+ + (?=right-boundary)\n     * left-boundary := whitespace | } | ^\n     * right-boundary := whitespace | { | $\n     * alternative: = optional | parameter | text\n     */\n    private static final Parser alternationParser = (expression, tokens, current) -> {\n        int previous = current - 1;\n        if (!lookingAtAny(tokens, previous, START_OF_LINE, WHITE_SPACE, END_PARAMETER)) {\n            return new Result(0);\n        }\n\n        Result result = parseTokensUntil(expression, alternativeParsers, tokens, current, WHITE_SPACE, END_OF_LINE, BEGIN_PARAMETER);\n        int subCurrent = current + result.consumed;\n        if (result.ast.stream().noneMatch(astNode -> astNode.type() == ALTERNATIVE_NODE)) {\n            return new Result(0);\n        }\n\n        int start = tokens.get(current).start();\n        int end = tokens.get(subCurrent).start();\n        // Does not consume right hand boundary token\n        return new Result(result.consumed,\n                new Node(ALTERNATION_NODE, start, end, splitAlternatives(start, end, result.ast)));\n    };\n\n    /*\n     * cucumber-expression :=  ( alternation | optional | parameter | text )*\n     */\n    private static final Parser cucumberExpressionParser = parseBetween(\n            EXPRESSION_NODE,\n            START_OF_LINE,\n            END_OF_LINE,\n            asList(\n                    alternationParser,\n                    optionalParser,\n                    parameterParser,\n                    textParser\n            )\n    );\n\n    Node parse(String expression) {\n        CucumberExpressionTokenizer tokenizer = new CucumberExpressionTokenizer();\n        List<Token> tokens = tokenizer.tokenize(expression);\n        Result result = cucumberExpressionParser.parse(expression, tokens, 0);\n        return result.ast.get(0);\n    }\n\n    private interface Parser {\n        Result parse(String expression, List<Token> tokens, int current);\n\n    }\n\n    private static final class Result {\n        final int consumed;\n        final List<Node> ast;\n\n        private Result(int consumed, Node... ast) {\n            this(consumed, Arrays.asList(ast));\n        }\n\n        private Result(int consumed, List<Node> ast) {\n            this.consumed = consumed;\n            this.ast = ast;\n        }\n\n    }\n\n    private static Parser parseBetween(\n            Node.Type type,\n            Type beginToken,\n            Type endToken,\n            List<Parser> parsers) {\n        return (expression, tokens, current) -> {\n            if (!lookingAt(tokens, current, beginToken)) {\n                return new Result(0);\n            }\n            int subCurrent = current + 1;\n            Result result = parseTokensUntil(expression, parsers, tokens, subCurrent, endToken, END_OF_LINE);\n            subCurrent += result.consumed;\n\n            // endToken not found\n            if (!lookingAt(tokens, subCurrent, endToken)) {\n                throw createMissingEndToken(expression, beginToken, endToken, tokens.get(current));\n            }\n            // consumes endToken\n            int start = tokens.get(current).start();\n            int end = tokens.get(subCurrent).end();\n            return new Result(subCurrent + 1 - current, new Node(type, start, end, result.ast));\n        };\n    }\n\n    private static Result parseTokensUntil(\n            String expression,\n            List<Parser> parsers,\n            List<Token> tokens,\n            int startAt,\n            Type... endTokens) {\n        int current = startAt;\n        int size = tokens.size();\n        List<Node> ast = new ArrayList<>();\n        while (current < size) {\n            if (lookingAtAny(tokens, current, endTokens)) {\n                break;\n            }\n\n            Result result = parseToken(expression, parsers, tokens, current);\n            if (result.consumed == 0) {\n                // If configured correctly this will never happen\n                // Keep to avoid infinite loops\n                throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n            }\n            current += result.consumed;\n            ast.addAll(result.ast);\n        }\n        return new Result(current - startAt, ast);\n    }\n\n    private static Result parseToken(String expression, List<Parser> parsers,\n            List<Token> tokens,\n            int startAt) {\n        for (Parser parser : parsers) {\n            Result result = parser.parse(expression, tokens, startAt);\n            if (result.consumed != 0) {\n                return result;\n            }\n        }\n        // If configured correctly this will never happen\n        throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n    }\n\n    private static boolean lookingAtAny(List<Token> tokens, int at, Type... tokenTypes) {\n        for (Type tokeType : tokenTypes) {\n            if (lookingAt(tokens, at, tokeType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean lookingAt(List<Token> tokens, int at, Type token) {\n        if (at < 0) {\n            // If configured correctly this will never happen\n            // Keep for completeness\n            return token == START_OF_LINE;\n        }\n        if (at >= tokens.size()) {\n            return token == END_OF_LINE;\n        }\n        return tokens.get(at).type == token;\n    }\n\n    private static List<Node> splitAlternatives(int start, int end, List<Node> alternation) {\n        List<Node> separators = new ArrayList<>();\n        List<List<Node>> alternatives = new ArrayList<>();\n        List<Node> alternative = new ArrayList<>();\n        for (Node n : alternation) {\n            if (ALTERNATIVE_NODE.equals(n.type())) {\n                separators.add(n);\n                alternatives.add(alternative);\n                alternative = new ArrayList<>();\n            } else {\n                alternative.add(n);\n            }\n        }\n        alternatives.add(alternative);\n\n        return createAlternativeNodes(start, end, separators, alternatives);\n    }\n\n    private static List<Node> createAlternativeNodes(int start, int end, List<Node> separators, List<List<Node>> alternatives) {\n        List<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < alternatives.size(); i++) {\n            List<Node> n = alternatives.get(i);\n            if (i == 0) {\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, start, rightSeparator.start(), n));\n            } else if (i == alternatives.size() - 1) {\n                Node leftSeparator = separators.get(i - 1);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), end, n));\n            } else {\n                Node leftSeparator = separators.get(i - 1);\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), rightSeparator.start(), n));\n            }\n        }\n        return nodes;\n    }\n\n}", "definition": "final class CucumberExpressionParser", "class_docstring": "", "name": "CucumberExpressionParser", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private static final Parser textParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n            case END_PARAMETER:\n            case END_OPTIONAL:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case ALTERNATION:\n                throw createAlternationNotAllowedInOptional(expression, token);\n            case BEGIN_PARAMETER:\n            case START_OF_LINE:\n            case END_OF_LINE:\n            case BEGIN_OPTIONAL:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    };", "docstring": "\ntext := whitespace | ')' | '}' | .\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "textParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n            case END_PARAMETER:\n            case END_OPTIONAL:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case ALTERNATION:\n                throw createAlternationNotAllowedInOptional(expression, token);\n            case BEGIN_PARAMETER:\n            case START_OF_LINE:\n            case END_OF_LINE:\n            case BEGIN_OPTIONAL:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Parser nameParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case BEGIN_OPTIONAL:\n            case END_OPTIONAL:\n            case BEGIN_PARAMETER:\n            case END_PARAMETER:\n            case ALTERNATION:\n                throw createInvalidParameterTypeName(token, expression);\n            case START_OF_LINE:\n            case END_OF_LINE:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    };", "docstring": "\nname := whitespace | .\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "nameParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case BEGIN_OPTIONAL:\n            case END_OPTIONAL:\n            case BEGIN_PARAMETER:\n            case END_PARAMETER:\n            case ALTERNATION:\n                throw createInvalidParameterTypeName(token, expression);\n            case START_OF_LINE:\n            case END_OF_LINE:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Parser parameterParser = parseBetween(\n            PARAMETER_NODE,\n            BEGIN_PARAMETER,\n            END_PARAMETER,\n            singletonList(nameParser)\n    );", "docstring": "\nparameter := '{' + name* + '}'\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "parameterParser = parseBetween(\n            PARAMETER_NODE,\n            BEGIN_PARAMETER,\n            END_PARAMETER,\n            singletonList(nameParser)\n    )", "syntax_pass": true}, {"attribute_expression": "private static final Parser optionalParser;", "docstring": "\noptional := '(' + option* + ')'\noption := optional | parameter | text\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "optionalParser", "syntax_pass": true}, {"attribute_expression": "private static final Parser alternativeSeparator = (expression, tokens, current) -> {\n        if (!lookingAt(tokens, current, ALTERNATION)) {\n            return new Result(0);\n        }\n        Token token = tokens.get(current);\n        return new Result(1, new Node(ALTERNATIVE_NODE, token.start(), token.end(), token.text));\n    };", "docstring": "\nalternation := alternative* + ( '/' + alternative* )+\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "alternativeSeparator = (expression, tokens, current) -> {\n        if (!lookingAt(tokens, current, ALTERNATION)) {\n            return new Result(0);\n        }\n        Token token = tokens.get(current);\n        return new Result(1, new Node(ALTERNATIVE_NODE, token.start(), token.end(), token.text));\n    }", "syntax_pass": true}, {"attribute_expression": "private static final List<Parser> alternativeParsers = asList(\n            alternativeSeparator,\n            optionalParser,\n            parameterParser,\n            textParser\n    );", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<Parser>", "name": "alternativeParsers = asList(\n            alternativeSeparator,\n            optionalParser,\n            parameterParser,\n            textParser\n    )", "syntax_pass": true}, {"attribute_expression": "private static final Parser alternationParser = (expression, tokens, current) -> {\n        int previous = current - 1;\n        if (!lookingAtAny(tokens, previous, START_OF_LINE, WHITE_SPACE, END_PARAMETER)) {\n            return new Result(0);\n        }\n\n        Result result = parseTokensUntil(expression, alternativeParsers, tokens, current, WHITE_SPACE, END_OF_LINE, BEGIN_PARAMETER);\n        int subCurrent = current + result.consumed;\n        if (result.ast.stream().noneMatch(astNode -> astNode.type() == ALTERNATIVE_NODE)) {\n            return new Result(0);\n        }\n\n        int start = tokens.get(current).start();\n        int end = tokens.get(subCurrent).start();\n        // Does not consume right hand boundary token\n        return new Result(result.consumed,\n                new Node(ALTERNATION_NODE, start, end, splitAlternatives(start, end, result.ast)));\n    };", "docstring": "\nalternation := (?<=left-boundary) + alternative* + ( '/' + alternative* )+ + (?=right-boundary)\nleft-boundary := whitespace | } | ^\nright-boundary := whitespace | { | $\nalternative: = optional | parameter | text\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "alternationParser = (expression, tokens, current) -> {\n        int previous = current - 1;\n        if (!lookingAtAny(tokens, previous, START_OF_LINE, WHITE_SPACE, END_PARAMETER)) {\n            return new Result(0);\n        }\n\n        Result result = parseTokensUntil(expression, alternativeParsers, tokens, current, WHITE_SPACE, END_OF_LINE, BEGIN_PARAMETER);\n        int subCurrent = current + result.consumed;\n        if (result.ast.stream().noneMatch(astNode -> astNode.type() == ALTERNATIVE_NODE)) {\n            return new Result(0);\n        }\n\n        int start = tokens.get(current).start();\n        int end = tokens.get(subCurrent).start();\n        // Does not consume right hand boundary token\n        return new Result(result.consumed,\n                new Node(ALTERNATION_NODE, start, end, splitAlternatives(start, end, result.ast)));\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Parser cucumberExpressionParser = parseBetween(\n            EXPRESSION_NODE,\n            START_OF_LINE,\n            END_OF_LINE,\n            asList(\n                    alternationParser,\n                    optionalParser,\n                    parameterParser,\n                    textParser\n            )\n    );", "docstring": "\ncucumber-expression :=  ( alternation | optional | parameter | text )*\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "cucumberExpressionParser = parseBetween(\n            EXPRESSION_NODE,\n            START_OF_LINE,\n            END_OF_LINE,\n            asList(\n                    alternationParser,\n                    optionalParser,\n                    parameterParser,\n                    textParser\n            )\n    )", "syntax_pass": true}], "classes": [{"original_string": "    private static final class Result {\n        final int consumed;\n        final List<Node> ast;\n\n        private Result(int consumed, Node... ast) {\n            this(consumed, Arrays.asList(ast));\n        }\n\n        private Result(int consumed, List<Node> ast) {\n            this.consumed = consumed;\n            this.ast = ast;\n        }\n\n    }", "definition": "    private static final class Result", "class_docstring": "", "name": "Result", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "final int consumed;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "consumed", "syntax_pass": true}, {"attribute_expression": "final List<Node> ast;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<Node>", "name": "ast", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private Result(int consumed, Node... ast) {\n            this(consumed, Arrays.asList(ast));\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Result", "params": [{"name": "consumed", "type": "int"}], "body": "                                                  {\n            this(consumed, Arrays.asList(ast));\n        }", "signature": "private Result(int consumed, Node... ast)"}, {"syntax_pass": true, "original_string": "        private Result(int consumed, List<Node> ast) {\n            this.consumed = consumed;\n            this.ast = ast;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Result", "params": [{"name": "consumed", "type": "int"}, {"name": "ast", "type": "List<Node>"}], "body": "                                                     {\n            this.consumed = consumed;\n            this.ast = ast;\n        }", "signature": "private Result(int consumed, List<Node> ast)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Node parse(String expression) {\n        CucumberExpressionTokenizer tokenizer = new CucumberExpressionTokenizer();\n        List<Token> tokens = tokenizer.tokenize(expression);\n        Result result = cucumberExpressionParser.parse(expression, tokens, 0);\n        return result.ast.get(0);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Node", "classes": []}, "name": "parse", "params": [{"name": "expression", "type": "String"}], "body": "                                  {\n        CucumberExpressionTokenizer tokenizer = new CucumberExpressionTokenizer();\n        List<Token> tokens = tokenizer.tokenize(expression);\n        Result result = cucumberExpressionParser.parse(expression, tokens, 0);\n        return result.ast.get(0);\n    }", "signature": "Node parse(String expression)"}, {"syntax_pass": true, "original_string": "    private static Parser parseBetween(\n            Node.Type type,\n            Type beginToken,\n            Type endToken,\n            List<Parser> parsers) {\n        return (expression, tokens, current) -> {\n            if (!lookingAt(tokens, current, beginToken)) {\n                return new Result(0);\n            }\n            int subCurrent = current + 1;\n            Result result = parseTokensUntil(expression, parsers, tokens, subCurrent, endToken, END_OF_LINE);\n            subCurrent += result.consumed;\n\n            // endToken not found\n            if (!lookingAt(tokens, subCurrent, endToken)) {\n                throw createMissingEndToken(expression, beginToken, endToken, tokens.get(current));\n            }\n            // consumes endToken\n            int start = tokens.get(current).start();\n            int end = tokens.get(subCurrent).end();\n            return new Result(subCurrent + 1 - current, new Node(type, start, end, result.ast));\n        };\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Parser", "classes": []}, "name": "parseBetween", "params": [{"name": "type", "type": "Node.Type"}, {"name": "beginToken", "type": "Type"}, {"name": "endToken", "type": "Type"}, {"name": "parsers", "type": "List<Parser>"}], "body": "                                  {\n        return (expression, tokens, current) -> {\n            if (!lookingAt(tokens, current, beginToken)) {\n                return new Result(0);\n            }\n            int subCurrent = current + 1;\n            Result result = parseTokensUntil(expression, parsers, tokens, subCurrent, endToken, END_OF_LINE);\n            subCurrent += result.consumed;\n\n            // endToken not found\n            if (!lookingAt(tokens, subCurrent, endToken)) {\n                throw createMissingEndToken(expression, beginToken, endToken, tokens.get(current));\n            }\n            // consumes endToken\n            int start = tokens.get(current).start();\n            int end = tokens.get(subCurrent).end();\n            return new Result(subCurrent + 1 - current, new Node(type, start, end, result.ast));\n        };\n    }", "signature": "private static Parser parseBetween(\n            Node.Type type,\n            Type beginToken,\n            Type endToken,\n            List<Parser> parsers)"}, {"syntax_pass": true, "original_string": "    private static Result parseTokensUntil(\n            String expression,\n            List<Parser> parsers,\n            List<Token> tokens,\n            int startAt,\n            Type... endTokens) {\n        int current = startAt;\n        int size = tokens.size();\n        List<Node> ast = new ArrayList<>();\n        while (current < size) {\n            if (lookingAtAny(tokens, current, endTokens)) {\n                break;\n            }\n\n            Result result = parseToken(expression, parsers, tokens, current);\n            if (result.consumed == 0) {\n                // If configured correctly this will never happen\n                // Keep to avoid infinite loops\n                throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n            }\n            current += result.consumed;\n            ast.addAll(result.ast);\n        }\n        return new Result(current - startAt, ast);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Result", "classes": []}, "name": "parseTokensUntil", "params": [{"name": "expression", "type": "String"}, {"name": "parsers", "type": "List<Parser>"}, {"name": "tokens", "type": "List<Token>"}, {"name": "startAt", "type": "int"}], "body": "                               {\n        int current = startAt;\n        int size = tokens.size();\n        List<Node> ast = new ArrayList<>();\n        while (current < size) {\n            if (lookingAtAny(tokens, current, endTokens)) {\n                break;\n            }\n\n            Result result = parseToken(expression, parsers, tokens, current);\n            if (result.consumed == 0) {\n                // If configured correctly this will never happen\n                // Keep to avoid infinite loops\n                throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n            }\n            current += result.consumed;\n            ast.addAll(result.ast);\n        }\n        return new Result(current - startAt, ast);\n    }", "signature": "private static Result parseTokensUntil(\n            String expression,\n            List<Parser> parsers,\n            List<Token> tokens,\n            int startAt,\n            Type... endTokens)"}, {"syntax_pass": true, "original_string": "    private static Result parseToken(String expression, List<Parser> parsers,\n            List<Token> tokens,\n            int startAt) {\n        for (Parser parser : parsers) {\n            Result result = parser.parse(expression, tokens, startAt);\n            if (result.consumed != 0) {\n                return result;\n            }\n        }\n        // If configured correctly this will never happen\n        throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Result", "classes": []}, "name": "parseToken", "params": [{"name": "expression", "type": "String"}, {"name": "parsers", "type": "List<Parser>"}, {"name": "tokens", "type": "List<Token>"}, {"name": "startAt", "type": "int"}], "body": "                         {\n        for (Parser parser : parsers) {\n            Result result = parser.parse(expression, tokens, startAt);\n            if (result.consumed != 0) {\n                return result;\n            }\n        }\n        // If configured correctly this will never happen\n        throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n    }", "signature": "private static Result parseToken(String expression, List<Parser> parsers,\n            List<Token> tokens,\n            int startAt)"}, {"syntax_pass": true, "original_string": "    private static boolean lookingAtAny(List<Token> tokens, int at, Type... tokenTypes) {\n        for (Type tokeType : tokenTypes) {\n            if (lookingAt(tokens, at, tokeType)) {\n                return true;\n            }\n        }\n        return false;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "lookingAtAny", "params": [{"name": "tokens", "type": "List<Token>"}, {"name": "at", "type": "int"}], "body": "                                                                                        {\n        for (Type tokeType : tokenTypes) {\n            if (lookingAt(tokens, at, tokeType)) {\n                return true;\n            }\n        }\n        return false;\n    }", "signature": "private static boolean lookingAtAny(List<Token> tokens, int at, Type... tokenTypes)"}, {"syntax_pass": true, "original_string": "    private static boolean lookingAt(List<Token> tokens, int at, Type token) {\n        if (at < 0) {\n            // If configured correctly this will never happen\n            // Keep for completeness\n            return token == START_OF_LINE;\n        }\n        if (at >= tokens.size()) {\n            return token == END_OF_LINE;\n        }\n        return tokens.get(at).type == token;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "lookingAt", "params": [{"name": "tokens", "type": "List<Token>"}, {"name": "at", "type": "int"}, {"name": "token", "type": "Type"}], "body": "                                                                             {\n        if (at < 0) {\n            // If configured correctly this will never happen\n            // Keep for completeness\n            return token == START_OF_LINE;\n        }\n        if (at >= tokens.size()) {\n            return token == END_OF_LINE;\n        }\n        return tokens.get(at).type == token;\n    }", "signature": "private static boolean lookingAt(List<Token> tokens, int at, Type token)"}, {"syntax_pass": true, "original_string": "    private static List<Node> splitAlternatives(int start, int end, List<Node> alternation) {\n        List<Node> separators = new ArrayList<>();\n        List<List<Node>> alternatives = new ArrayList<>();\n        List<Node> alternative = new ArrayList<>();\n        for (Node n : alternation) {\n            if (ALTERNATIVE_NODE.equals(n.type())) {\n                separators.add(n);\n                alternatives.add(alternative);\n                alternative = new ArrayList<>();\n            } else {\n                alternative.add(n);\n            }\n        }\n        alternatives.add(alternative);\n\n        return createAlternativeNodes(start, end, separators, alternatives);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Node>", "classes": []}, "name": "splitAlternatives", "params": [{"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "alternation", "type": "List<Node>"}], "body": "                                                                                            {\n        List<Node> separators = new ArrayList<>();\n        List<List<Node>> alternatives = new ArrayList<>();\n        List<Node> alternative = new ArrayList<>();\n        for (Node n : alternation) {\n            if (ALTERNATIVE_NODE.equals(n.type())) {\n                separators.add(n);\n                alternatives.add(alternative);\n                alternative = new ArrayList<>();\n            } else {\n                alternative.add(n);\n            }\n        }\n        alternatives.add(alternative);\n\n        return createAlternativeNodes(start, end, separators, alternatives);\n    }", "signature": "private static List<Node> splitAlternatives(int start, int end, List<Node> alternation)"}, {"syntax_pass": true, "original_string": "    private static List<Node> createAlternativeNodes(int start, int end, List<Node> separators, List<List<Node>> alternatives) {\n        List<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < alternatives.size(); i++) {\n            List<Node> n = alternatives.get(i);\n            if (i == 0) {\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, start, rightSeparator.start(), n));\n            } else if (i == alternatives.size() - 1) {\n                Node leftSeparator = separators.get(i - 1);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), end, n));\n            } else {\n                Node leftSeparator = separators.get(i - 1);\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), rightSeparator.start(), n));\n            }\n        }\n        return nodes;\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Node>", "classes": []}, "name": "createAlternativeNodes", "params": [{"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "separators", "type": "List<Node>"}, {"name": "alternatives", "type": "List<List<Node>>"}], "body": "                                                                                                                               {\n        List<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < alternatives.size(); i++) {\n            List<Node> n = alternatives.get(i);\n            if (i == 0) {\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, start, rightSeparator.start(), n));\n            } else if (i == alternatives.size() - 1) {\n                Node leftSeparator = separators.get(i - 1);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), end, n));\n            } else {\n                Node leftSeparator = separators.get(i - 1);\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), rightSeparator.start(), n));\n            }\n        }\n        return nodes;\n    }", "signature": "private static List<Node> createAlternativeNodes(int start, int end, List<Node> separators, List<List<Node>> alternatives)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Locale;\nimport java.util.Optional;\n\nimport static java.util.Objects.requireNonNull;\n\nfinal class BuiltInParameterTransformer implements ParameterByTypeTransformer {\n\n    private final NumberParser numberParser;\n\n    BuiltInParameterTransformer(Locale locale) {\n        this.numberParser = new NumberParser(locale);\n    }\n\n    @Override\n    public Object transform(String fromValue, Type toValueType) {\n        return doTransform(fromValue, toValueType, toValueType);\n    }\n\n    private Object doTransform(String fromValue, Type toValueType, Type originalToValueType) {\n        Type optionalValueType;\n        if ((optionalValueType = getOptionalGenericType(toValueType)) != null) {\n            Object wrappedValue = doTransform(fromValue, optionalValueType, originalToValueType);\n            return Optional.ofNullable(wrappedValue);\n        }\n\n        if (!(toValueType instanceof Class)) {\n            throw createIllegalArgumentException(fromValue, originalToValueType);\n        }\n\n        Class<?> toValueClass = (Class<?>) requireNonNull(toValueType);\n        if (fromValue == null) {\n            return null;\n        }\n\n        if (String.class.equals(toValueClass) || Object.class.equals(toValueClass)) {\n            return fromValue;\n        }\n\n        if (Character.class.equals(toValueClass) || char.class.equals(toValueClass)) {\n            if(fromValue.length() == 1) {\n                return fromValue.charAt(0);\n            }\n        }\n\n        if (BigInteger.class.equals(toValueClass)) {\n            return new BigInteger(fromValue);\n        }\n\n        if (BigDecimal.class.equals(toValueClass) || Number.class.equals(toValueClass)) {\n            return numberParser.parseBigDecimal(fromValue);\n        }\n\n        if (Byte.class.equals(toValueClass) || byte.class.equals(toValueClass)) {\n            return Byte.decode(fromValue);\n        }\n\n        if (Short.class.equals(toValueClass) || short.class.equals(toValueClass)) {\n            return Short.decode(fromValue);\n        }\n\n        if (Integer.class.equals(toValueClass) || int.class.equals(toValueClass)) {\n            return Integer.decode(fromValue);\n        }\n\n        if (Long.class.equals(toValueClass) || long.class.equals(toValueClass)) {\n            return Long.decode(fromValue);\n        }\n\n        if (Float.class.equals(toValueClass) || float.class.equals(toValueClass)) {\n            return numberParser.parseFloat(fromValue);\n        }\n\n        if (Double.class.equals(toValueClass) || double.class.equals(toValueClass)) {\n            return numberParser.parseDouble(fromValue);\n        }\n\n        if (Boolean.class.equals(toValueClass) || boolean.class.equals(toValueClass)) {\n            return Boolean.parseBoolean(fromValue);\n        }\n\n        if (toValueClass.isEnum()) {\n            @SuppressWarnings(\"unchecked\")\n            Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) toValueClass;\n            for (Enum<?> enumConstant : enumClass.getEnumConstants()) {\n                if (enumConstant.name().equals(fromValue)) {\n                    return enumConstant;\n                }\n            }\n            throw new CucumberExpressionException(\"Can't transform '\" + fromValue + \"' to \" + originalToValueType + \". \" +\n                    \"Not an enum constant\");\n        }\n\n        throw createIllegalArgumentException(fromValue, originalToValueType);\n    }\n\n    private Type getOptionalGenericType(Type type) {\n        if (Optional.class.equals(type)) {\n            return Object.class;\n        }\n\n        if (!(type instanceof ParameterizedType)) {\n            return null;\n        }\n\n        ParameterizedType parameterizedType = (ParameterizedType) type;\n        if (Optional.class.equals(parameterizedType.getRawType())) {\n            return parameterizedType.getActualTypeArguments()[0];\n        }\n\n        return null;\n    }\n\n    private IllegalArgumentException createIllegalArgumentException(String fromValue, Type toValueType) {\n        return new IllegalArgumentException(\n                \"Can't transform '\" + fromValue + \"' to \" + toValueType + \"\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for \" + toValueType\n        );\n    }\n\n}\n", "file_hash": "c59c921d76ef934b89c81b5e7dfb61253aeff23f620e0dd365ca1107571af791", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import java.lang.reflect.ParameterizedType;", "import java.lang.reflect.Type;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import java.util.Locale;", "import java.util.Optional;", "import static java.util.Objects.requireNonNull;"], "methods": [], "classes": [{"original_string": "final class BuiltInParameterTransformer implements ParameterByTypeTransformer {\n\n    private final NumberParser numberParser;\n\n    BuiltInParameterTransformer(Locale locale) {\n        this.numberParser = new NumberParser(locale);\n    }\n\n    @Override\n    public Object transform(String fromValue, Type toValueType) {\n        return doTransform(fromValue, toValueType, toValueType);\n    }\n\n    private Object doTransform(String fromValue, Type toValueType, Type originalToValueType) {\n        Type optionalValueType;\n        if ((optionalValueType = getOptionalGenericType(toValueType)) != null) {\n            Object wrappedValue = doTransform(fromValue, optionalValueType, originalToValueType);\n            return Optional.ofNullable(wrappedValue);\n        }\n\n        if (!(toValueType instanceof Class)) {\n            throw createIllegalArgumentException(fromValue, originalToValueType);\n        }\n\n        Class<?> toValueClass = (Class<?>) requireNonNull(toValueType);\n        if (fromValue == null) {\n            return null;\n        }\n\n        if (String.class.equals(toValueClass) || Object.class.equals(toValueClass)) {\n            return fromValue;\n        }\n\n        if (Character.class.equals(toValueClass) || char.class.equals(toValueClass)) {\n            if(fromValue.length() == 1) {\n                return fromValue.charAt(0);\n            }\n        }\n\n        if (BigInteger.class.equals(toValueClass)) {\n            return new BigInteger(fromValue);\n        }\n\n        if (BigDecimal.class.equals(toValueClass) || Number.class.equals(toValueClass)) {\n            return numberParser.parseBigDecimal(fromValue);\n        }\n\n        if (Byte.class.equals(toValueClass) || byte.class.equals(toValueClass)) {\n            return Byte.decode(fromValue);\n        }\n\n        if (Short.class.equals(toValueClass) || short.class.equals(toValueClass)) {\n            return Short.decode(fromValue);\n        }\n\n        if (Integer.class.equals(toValueClass) || int.class.equals(toValueClass)) {\n            return Integer.decode(fromValue);\n        }\n\n        if (Long.class.equals(toValueClass) || long.class.equals(toValueClass)) {\n            return Long.decode(fromValue);\n        }\n\n        if (Float.class.equals(toValueClass) || float.class.equals(toValueClass)) {\n            return numberParser.parseFloat(fromValue);\n        }\n\n        if (Double.class.equals(toValueClass) || double.class.equals(toValueClass)) {\n            return numberParser.parseDouble(fromValue);\n        }\n\n        if (Boolean.class.equals(toValueClass) || boolean.class.equals(toValueClass)) {\n            return Boolean.parseBoolean(fromValue);\n        }\n\n        if (toValueClass.isEnum()) {\n            @SuppressWarnings(\"unchecked\")\n            Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) toValueClass;\n            for (Enum<?> enumConstant : enumClass.getEnumConstants()) {\n                if (enumConstant.name().equals(fromValue)) {\n                    return enumConstant;\n                }\n            }\n            throw new CucumberExpressionException(\"Can't transform '\" + fromValue + \"' to \" + originalToValueType + \". \" +\n                    \"Not an enum constant\");\n        }\n\n        throw createIllegalArgumentException(fromValue, originalToValueType);\n    }\n\n    private Type getOptionalGenericType(Type type) {\n        if (Optional.class.equals(type)) {\n            return Object.class;\n        }\n\n        if (!(type instanceof ParameterizedType)) {\n            return null;\n        }\n\n        ParameterizedType parameterizedType = (ParameterizedType) type;\n        if (Optional.class.equals(parameterizedType.getRawType())) {\n            return parameterizedType.getActualTypeArguments()[0];\n        }\n\n        return null;\n    }\n\n    private IllegalArgumentException createIllegalArgumentException(String fromValue, Type toValueType) {\n        return new IllegalArgumentException(\n                \"Can't transform '\" + fromValue + \"' to \" + toValueType + \"\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for \" + toValueType\n        );\n    }\n\n}", "definition": "final class BuiltInParameterTransformer implements ParameterByTypeTransformer", "class_docstring": "", "name": "BuiltInParameterTransformer", "super_interfaces": ["ParameterByTypeTransformer"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private final NumberParser numberParser;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "numberParser", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    BuiltInParameterTransformer(Locale locale) {\n        this.numberParser = new NumberParser(locale);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "BuiltInParameterTransformer", "params": [{"name": "locale", "type": "Locale"}], "body": "                                               {\n        this.numberParser = new NumberParser(locale);\n    }", "signature": "BuiltInParameterTransformer(Locale locale)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Object transform(String fromValue, Type toValueType) {\n        return doTransform(fromValue, toValueType, toValueType);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "transform", "params": [{"name": "fromValue", "type": "String"}, {"name": "toValueType", "type": "Type"}], "body": "                                                                {\n        return doTransform(fromValue, toValueType, toValueType);\n    }", "signature": "@Override\n    public Object transform(String fromValue, Type toValueType)"}, {"syntax_pass": true, "original_string": "    private Object doTransform(String fromValue, Type toValueType, Type originalToValueType) {\n        Type optionalValueType;\n        if ((optionalValueType = getOptionalGenericType(toValueType)) != null) {\n            Object wrappedValue = doTransform(fromValue, optionalValueType, originalToValueType);\n            return Optional.ofNullable(wrappedValue);\n        }\n\n        if (!(toValueType instanceof Class)) {\n            throw createIllegalArgumentException(fromValue, originalToValueType);\n        }\n\n        Class<?> toValueClass = (Class<?>) requireNonNull(toValueType);\n        if (fromValue == null) {\n            return null;\n        }\n\n        if (String.class.equals(toValueClass) || Object.class.equals(toValueClass)) {\n            return fromValue;\n        }\n\n        if (Character.class.equals(toValueClass) || char.class.equals(toValueClass)) {\n            if(fromValue.length() == 1) {\n                return fromValue.charAt(0);\n            }\n        }\n\n        if (BigInteger.class.equals(toValueClass)) {\n            return new BigInteger(fromValue);\n        }\n\n        if (BigDecimal.class.equals(toValueClass) || Number.class.equals(toValueClass)) {\n            return numberParser.parseBigDecimal(fromValue);\n        }\n\n        if (Byte.class.equals(toValueClass) || byte.class.equals(toValueClass)) {\n            return Byte.decode(fromValue);\n        }\n\n        if (Short.class.equals(toValueClass) || short.class.equals(toValueClass)) {\n            return Short.decode(fromValue);\n        }\n\n        if (Integer.class.equals(toValueClass) || int.class.equals(toValueClass)) {\n            return Integer.decode(fromValue);\n        }\n\n        if (Long.class.equals(toValueClass) || long.class.equals(toValueClass)) {\n            return Long.decode(fromValue);\n        }\n\n        if (Float.class.equals(toValueClass) || float.class.equals(toValueClass)) {\n            return numberParser.parseFloat(fromValue);\n        }\n\n        if (Double.class.equals(toValueClass) || double.class.equals(toValueClass)) {\n            return numberParser.parseDouble(fromValue);\n        }\n\n        if (Boolean.class.equals(toValueClass) || boolean.class.equals(toValueClass)) {\n            return Boolean.parseBoolean(fromValue);\n        }\n\n        if (toValueClass.isEnum()) {\n            @SuppressWarnings(\"unchecked\")\n            Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) toValueClass;\n            for (Enum<?> enumConstant : enumClass.getEnumConstants()) {\n                if (enumConstant.name().equals(fromValue)) {\n                    return enumConstant;\n                }\n            }\n            throw new CucumberExpressionException(\"Can't transform '\" + fromValue + \"' to \" + originalToValueType + \". \" +\n                    \"Not an enum constant\");\n        }\n\n        throw createIllegalArgumentException(fromValue, originalToValueType);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Object", "classes": []}, "name": "doTransform", "params": [{"name": "fromValue", "type": "String"}, {"name": "toValueType", "type": "Type"}, {"name": "originalToValueType", "type": "Type"}], "body": "                                                                                             {\n        Type optionalValueType;\n        if ((optionalValueType = getOptionalGenericType(toValueType)) != null) {\n            Object wrappedValue = doTransform(fromValue, optionalValueType, originalToValueType);\n            return Optional.ofNullable(wrappedValue);\n        }\n\n        if (!(toValueType instanceof Class)) {\n            throw createIllegalArgumentException(fromValue, originalToValueType);\n        }\n\n        Class<?> toValueClass = (Class<?>) requireNonNull(toValueType);\n        if (fromValue == null) {\n            return null;\n        }\n\n        if (String.class.equals(toValueClass) || Object.class.equals(toValueClass)) {\n            return fromValue;\n        }\n\n        if (Character.class.equals(toValueClass) || char.class.equals(toValueClass)) {\n            if(fromValue.length() == 1) {\n                return fromValue.charAt(0);\n            }\n        }\n\n        if (BigInteger.class.equals(toValueClass)) {\n            return new BigInteger(fromValue);\n        }\n\n        if (BigDecimal.class.equals(toValueClass) || Number.class.equals(toValueClass)) {\n            return numberParser.parseBigDecimal(fromValue);\n        }\n\n        if (Byte.class.equals(toValueClass) || byte.class.equals(toValueClass)) {\n            return Byte.decode(fromValue);\n        }\n\n        if (Short.class.equals(toValueClass) || short.class.equals(toValueClass)) {\n            return Short.decode(fromValue);\n        }\n\n        if (Integer.class.equals(toValueClass) || int.class.equals(toValueClass)) {\n            return Integer.decode(fromValue);\n        }\n\n        if (Long.class.equals(toValueClass) || long.class.equals(toValueClass)) {\n            return Long.decode(fromValue);\n        }\n\n        if (Float.class.equals(toValueClass) || float.class.equals(toValueClass)) {\n            return numberParser.parseFloat(fromValue);\n        }\n\n        if (Double.class.equals(toValueClass) || double.class.equals(toValueClass)) {\n            return numberParser.parseDouble(fromValue);\n        }\n\n        if (Boolean.class.equals(toValueClass) || boolean.class.equals(toValueClass)) {\n            return Boolean.parseBoolean(fromValue);\n        }\n\n        if (toValueClass.isEnum()) {\n            @SuppressWarnings(\"unchecked\")\n            Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) toValueClass;\n            for (Enum<?> enumConstant : enumClass.getEnumConstants()) {\n                if (enumConstant.name().equals(fromValue)) {\n                    return enumConstant;\n                }\n            }\n            throw new CucumberExpressionException(\"Can't transform '\" + fromValue + \"' to \" + originalToValueType + \". \" +\n                    \"Not an enum constant\");\n        }\n\n        throw createIllegalArgumentException(fromValue, originalToValueType);\n    }", "signature": "private Object doTransform(String fromValue, Type toValueType, Type originalToValueType)"}, {"syntax_pass": true, "original_string": "    private Type getOptionalGenericType(Type type) {\n        if (Optional.class.equals(type)) {\n            return Object.class;\n        }\n\n        if (!(type instanceof ParameterizedType)) {\n            return null;\n        }\n\n        ParameterizedType parameterizedType = (ParameterizedType) type;\n        if (Optional.class.equals(parameterizedType.getRawType())) {\n            return parameterizedType.getActualTypeArguments()[0];\n        }\n\n        return null;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Type", "classes": []}, "name": "getOptionalGenericType", "params": [{"name": "type", "type": "Type"}], "body": "                                                   {\n        if (Optional.class.equals(type)) {\n            return Object.class;\n        }\n\n        if (!(type instanceof ParameterizedType)) {\n            return null;\n        }\n\n        ParameterizedType parameterizedType = (ParameterizedType) type;\n        if (Optional.class.equals(parameterizedType.getRawType())) {\n            return parameterizedType.getActualTypeArguments()[0];\n        }\n\n        return null;\n    }", "signature": "private Type getOptionalGenericType(Type type)"}, {"syntax_pass": true, "original_string": "    private IllegalArgumentException createIllegalArgumentException(String fromValue, Type toValueType) {\n        return new IllegalArgumentException(\n                \"Can't transform '\" + fromValue + \"' to \" + toValueType + \"\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for \" + toValueType\n        );\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "IllegalArgumentException", "classes": []}, "name": "createIllegalArgumentException", "params": [{"name": "fromValue", "type": "String"}, {"name": "toValueType", "type": "Type"}], "body": "                                                                                                        {\n        return new IllegalArgumentException(\n                \"Can't transform '\" + fromValue + \"' to \" + toValueType + \"\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for \" + toValueType\n        );\n    }", "signature": "private IllegalArgumentException createIllegalArgumentException(String fromValue, Type toValueType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport java.math.BigDecimal;\nimport java.text.DecimalFormat;\nimport java.text.DecimalFormatSymbols;\nimport java.text.NumberFormat;\nimport java.text.ParseException;\nimport java.util.Locale;\n\nfinal class NumberParser {\n    private final NumberFormat numberFormat;\n\n    NumberParser(Locale locale) {\n        numberFormat = DecimalFormat.getNumberInstance(locale);\n        if (numberFormat instanceof DecimalFormat) {\n            DecimalFormat decimalFormat = (DecimalFormat) numberFormat;\n            decimalFormat.setParseBigDecimal(true);\n            DecimalFormatSymbols symbols = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n            decimalFormat.setDecimalFormatSymbols(symbols);\n        }\n    }\n\n    double parseDouble(String s) {\n        return parse(s).doubleValue();\n    }\n\n    float parseFloat(String s) {\n        return parse(s).floatValue();\n    }\n\n    BigDecimal parseBigDecimal(String s) {\n        if (numberFormat instanceof DecimalFormat) {\n            return (BigDecimal) parse(s);\n        }\n        // Fall back to default big decimal format\n        // if the locale does not have a DecimalFormat\n        return new BigDecimal(s);\n    }\n\n    private Number parse(String s) {\n        try {\n            return numberFormat.parse(s);\n        } catch (ParseException e) {\n            throw new CucumberExpressionException(\"Failed to parse number\", e);\n        }\n    }\n}\n", "file_hash": "a8ecc9f44c1461a258f1b2e853ce6467fb46e14bd8a0cd7f9542214107d454eb", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import java.math.BigDecimal;", "import java.text.DecimalFormat;", "import java.text.DecimalFormatSymbols;", "import java.text.NumberFormat;", "import java.text.ParseException;", "import java.util.Locale;"], "methods": [], "classes": [{"original_string": "final class NumberParser {\n    private final NumberFormat numberFormat;\n\n    NumberParser(Locale locale) {\n        numberFormat = DecimalFormat.getNumberInstance(locale);\n        if (numberFormat instanceof DecimalFormat) {\n            DecimalFormat decimalFormat = (DecimalFormat) numberFormat;\n            decimalFormat.setParseBigDecimal(true);\n            DecimalFormatSymbols symbols = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n            decimalFormat.setDecimalFormatSymbols(symbols);\n        }\n    }\n\n    double parseDouble(String s) {\n        return parse(s).doubleValue();\n    }\n\n    float parseFloat(String s) {\n        return parse(s).floatValue();\n    }\n\n    BigDecimal parseBigDecimal(String s) {\n        if (numberFormat instanceof DecimalFormat) {\n            return (BigDecimal) parse(s);\n        }\n        // Fall back to default big decimal format\n        // if the locale does not have a DecimalFormat\n        return new BigDecimal(s);\n    }\n\n    private Number parse(String s) {\n        try {\n            return numberFormat.parse(s);\n        } catch (ParseException e) {\n            throw new CucumberExpressionException(\"Failed to parse number\", e);\n        }\n    }\n}", "definition": "final class NumberParser", "class_docstring": "", "name": "NumberParser", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private final NumberFormat numberFormat;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberFormat", "name": "numberFormat", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    NumberParser(Locale locale) {\n        numberFormat = DecimalFormat.getNumberInstance(locale);\n        if (numberFormat instanceof DecimalFormat) {\n            DecimalFormat decimalFormat = (DecimalFormat) numberFormat;\n            decimalFormat.setParseBigDecimal(true);\n            DecimalFormatSymbols symbols = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n            decimalFormat.setDecimalFormatSymbols(symbols);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "NumberParser", "params": [{"name": "locale", "type": "Locale"}], "body": "                                {\n        numberFormat = DecimalFormat.getNumberInstance(locale);\n        if (numberFormat instanceof DecimalFormat) {\n            DecimalFormat decimalFormat = (DecimalFormat) numberFormat;\n            decimalFormat.setParseBigDecimal(true);\n            DecimalFormatSymbols symbols = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n            decimalFormat.setDecimalFormatSymbols(symbols);\n        }\n    }", "signature": "NumberParser(Locale locale)"}, {"syntax_pass": true, "original_string": "    double parseDouble(String s) {\n        return parse(s).doubleValue();\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "double", "classes": []}, "name": "parseDouble", "params": [{"name": "s", "type": "String"}], "body": "                                 {\n        return parse(s).doubleValue();\n    }", "signature": "double parseDouble(String s)"}, {"syntax_pass": true, "original_string": "    float parseFloat(String s) {\n        return parse(s).floatValue();\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "float", "classes": []}, "name": "parseFloat", "params": [{"name": "s", "type": "String"}], "body": "                               {\n        return parse(s).floatValue();\n    }", "signature": "float parseFloat(String s)"}, {"syntax_pass": true, "original_string": "    BigDecimal parseBigDecimal(String s) {\n        if (numberFormat instanceof DecimalFormat) {\n            return (BigDecimal) parse(s);\n        }\n        // Fall back to default big decimal format\n        // if the locale does not have a DecimalFormat\n        return new BigDecimal(s);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "BigDecimal", "classes": []}, "name": "parseBigDecimal", "params": [{"name": "s", "type": "String"}], "body": "                                         {\n        if (numberFormat instanceof DecimalFormat) {\n            return (BigDecimal) parse(s);\n        }\n        // Fall back to default big decimal format\n        // if the locale does not have a DecimalFormat\n        return new BigDecimal(s);\n    }", "signature": "BigDecimal parseBigDecimal(String s)"}, {"syntax_pass": true, "original_string": "    private Number parse(String s) {\n        try {\n            return numberFormat.parse(s);\n        } catch (ParseException e) {\n            throw new CucumberExpressionException(\"Failed to parse number\", e);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Number", "classes": []}, "name": "parse", "params": [{"name": "s", "type": "String"}], "body": "                                   {\n        try {\n            return numberFormat.parse(s);\n        } catch (ParseException e) {\n            throw new CucumberExpressionException(\"Failed to parse number\", e);\n        }\n    }", "signature": "private Number parse(String s)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.DecimalFormatSymbols;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.regex.Pattern;\n\nimport static io.cucumber.cucumberexpressions.ParameterType.createAnonymousParameterType;\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.singletonList;\n\n@API(status = API.Status.STABLE)\npublic final class ParameterTypeRegistry {\n    // Pattern.compile(...).pattern() is not necessary, but it helps us take advantage of the IntelliJ's regexp validation,\n    // which detects unneeded escapes.\n    private static final List<String> INTEGER_REGEXPS = asList(\n            Pattern.compile(\"-?\\\\d+\").pattern(),\n            Pattern.compile(\"\\\\d+\").pattern()\n    );\n    private static final String SIGN = \"[-+]?\";\n    private static final String MUST_CONTAIN_NUMBER = \"(?=.*\\\\d.*)\";\n    private static final String SCIENTIFIC_NUMBER = \"(?:\\\\d+[{expnt}]-?\\\\d+)?\";\n    private static final String DECIMAL_FRACTION = \"(?:[{decimal}](?=\\\\d.*))?\\\\d*\";\n    private static final String INTEGER = \"(?:\\\\d+(?:[{group}]?\\\\d+)*)*\";\n    private static final String FLOAT_REGEXPS =\n            Pattern.compile(MUST_CONTAIN_NUMBER + SIGN + INTEGER + DECIMAL_FRACTION + SCIENTIFIC_NUMBER).pattern();\n    private static final List<String> WORD_REGEXPS = singletonList(\n            Pattern.compile(\"[^\\\\s]+\").pattern()\n    );\n    private static final List<String> STRING_REGEXPS = asList(\n            Pattern.compile(\"\\\"([^\\\"\\\\\\\\]*(\\\\\\\\.[^\\\"\\\\\\\\]*)*)\\\"\").pattern(),\n            Pattern.compile(\"'([^'\\\\\\\\]*(\\\\\\\\.[^'\\\\\\\\]*)*)'\").pattern()\n    );\n    private static final String ANONYMOUS_REGEX = Pattern.compile(\".*\").pattern();\n    private final Map<String, ParameterType<?>> parameterTypeByName = new HashMap<>();\n    private final Map<String, SortedSet<ParameterType<?>>> parameterTypesByRegexp = new HashMap<>();\n    /**\n     * To maintain consistency with `datatable` we don't use the mutable default\n     * transformer to handle build in in conversions yet.\n     */\n    private final ParameterByTypeTransformer internalParameterTransformer;\n    private ParameterByTypeTransformer defaultParameterTransformer;\n\n    public ParameterTypeRegistry(Locale locale) {\n        this(new BuiltInParameterTransformer(locale), locale);\n    }\n\n    private ParameterTypeRegistry(ParameterByTypeTransformer defaultParameterTransformer, Locale locale) {\n        this.internalParameterTransformer = defaultParameterTransformer;\n        this.defaultParameterTransformer = defaultParameterTransformer;\n\n        DecimalFormatSymbols numberFormat = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n\n        List<String> localizedFloatRegexp = singletonList(FLOAT_REGEXPS\n                .replace(\"{decimal}\", \"\" + numberFormat.getDecimalSeparator())\n                .replace(\"{group}\", \"\" + numberFormat.getGroupingSeparator())\n                .replace(\"{expnt}\", \"\" + numberFormat.getExponentSeparator())\n        );\n\n        defineParameterType(new ParameterType<>(\"biginteger\", INTEGER_REGEXPS, BigInteger.class, new Transformer<BigInteger>() {\n            @Override\n            public BigInteger transform(String arg) throws Throwable {\n                return (BigInteger) internalParameterTransformer.transform(arg, BigInteger.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"bigdecimal\", localizedFloatRegexp, BigDecimal.class, new Transformer<BigDecimal>() {\n            @Override\n            public BigDecimal transform(String arg) throws Throwable {\n                return (BigDecimal) internalParameterTransformer.transform(arg, BigDecimal.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"byte\", INTEGER_REGEXPS, Byte.class, new Transformer<Byte>() {\n            @Override\n            public Byte transform(String arg) throws Throwable {\n                return (Byte) internalParameterTransformer.transform(arg, Byte.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"short\", INTEGER_REGEXPS, Short.class, new Transformer<Short>() {\n            @Override\n            public Short transform(String arg) throws Throwable {\n                return (Short) internalParameterTransformer.transform(arg, Short.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"int\", INTEGER_REGEXPS, Integer.class, new Transformer<Integer>() {\n            @Override\n            public Integer transform(String arg) throws Throwable {\n                return (Integer) internalParameterTransformer.transform(arg, Integer.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"long\", INTEGER_REGEXPS, Long.class, new Transformer<Long>() {\n            @Override\n            public Long transform(String arg) throws Throwable {\n                return (Long) internalParameterTransformer.transform(arg, Long.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"float\", localizedFloatRegexp, Float.class, new Transformer<Float>() {\n            @Override\n            public Float transform(String arg) throws Throwable {\n                return (Float) internalParameterTransformer.transform(arg, Float.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"double\", localizedFloatRegexp, Double.class, new Transformer<Double>() {\n            @Override\n            public Double transform(String arg) throws Throwable {\n                return (Double) internalParameterTransformer.transform(arg, Double.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"word\", WORD_REGEXPS, String.class, new Transformer<String>() {\n            @Override\n            public String transform(String arg) throws Throwable {\n                return (String) internalParameterTransformer.transform(arg, String.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"string\", STRING_REGEXPS, String.class, new CaptureGroupTransformer<String>() {\n            @Override\n            public String transform(String... args) throws Throwable {\n                String arg = args[0] != null ? args[0] : args[1];\n                return (String) internalParameterTransformer.transform(arg\n                                .replaceAll(\"\\\\\\\\\\\"\", \"\\\"\")\n                                .replaceAll(\"\\\\\\\\'\", \"'\"),\n                        String.class);\n            }\n        }, true, false, false));\n\n        defineParameterType(createAnonymousParameterType(ANONYMOUS_REGEX));\n    }\n\n    public void defineParameterType(ParameterType<?> parameterType) {\n        if (parameterType.getName() != null) {\n            if (parameterTypeByName.containsKey(parameterType.getName())) {\n                if (parameterType.getName().isEmpty()) {\n                    throw new DuplicateTypeNameException(\"The anonymous parameter type has already been defined\");\n                }\n                throw new DuplicateTypeNameException(String.format(\"There is already a parameter type with name %s\", parameterType.getName()));\n            }\n            parameterTypeByName.put(parameterType.getName(), parameterType);\n        }\n\n        for (String parameterTypeRegexp : parameterType.getRegexps()) {\n            if (!parameterTypesByRegexp.containsKey(parameterTypeRegexp)) {\n                parameterTypesByRegexp.put(parameterTypeRegexp, new TreeSet<ParameterType<?>>());\n            }\n            SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n            if (!parameterTypes.isEmpty() && parameterTypes.first().preferForRegexpMatch() && parameterType.preferForRegexpMatch()) {\n                throw new CucumberExpressionException(String.format(\n                        \"There can only be one preferential parameter type per regexp. \" +\n                                \"The regexp /%s/ is used for two preferential parameter types, {%s} and {%s}\",\n                        parameterTypeRegexp, parameterTypes.first().getName(), parameterType.getName()\n                ));\n            }\n            parameterTypes.add(parameterType);\n        }\n    }\n\n    ParameterByTypeTransformer getDefaultParameterTransformer() {\n        return defaultParameterTransformer;\n    }\n\n    public void setDefaultParameterTransformer(ParameterByTypeTransformer defaultParameterTransformer) {\n        this.defaultParameterTransformer = defaultParameterTransformer;\n    }\n\n    <T> ParameterType<T> lookupByTypeName(String typeName) {\n        return (ParameterType<T>) parameterTypeByName.get(typeName);\n    }\n\n    <T> ParameterType<T> lookupByRegexp(String parameterTypeRegexp, Pattern expressionRegexp, String text) {\n        SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n        if (parameterTypes == null) return null;\n        if (parameterTypes.size() > 1 && !parameterTypes.first().preferForRegexpMatch()) {\n            // We don't do this check on insertion because we only want to restrict\n            // ambiguity when we look up by Regexp. Users of CucumberExpression should\n            // not be restricted.\n            List<GeneratedExpression> generatedExpressions = new CucumberExpressionGenerator(this).generateExpressions(text);\n            throw new AmbiguousParameterTypeException(parameterTypeRegexp, expressionRegexp, parameterTypes, generatedExpressions);\n        }\n        return (ParameterType<T>) parameterTypes.first();\n    }\n\n    Collection<ParameterType<?>> getParameterTypes() {\n        return parameterTypeByName.values();\n    }\n\n}\n", "file_hash": "ccb705a14ba887e4a6e0532bc35be2ee4256108944f7354c765c3706712c3454", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import java.text.DecimalFormatSymbols;", "import java.util.Collection;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Locale;", "import java.util.Map;", "import java.util.SortedSet;", "import java.util.TreeSet;", "import java.util.regex.Pattern;", "import static io.cucumber.cucumberexpressions.ParameterType.createAnonymousParameterType;", "import static java.util.Arrays.asList;", "import static java.util.Collections.singletonList;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic final class ParameterTypeRegistry {\n    // Pattern.compile(...).pattern() is not necessary, but it helps us take advantage of the IntelliJ's regexp validation,\n    // which detects unneeded escapes.\n    private static final List<String> INTEGER_REGEXPS = asList(\n            Pattern.compile(\"-?\\\\d+\").pattern(),\n            Pattern.compile(\"\\\\d+\").pattern()\n    );\n    private static final String SIGN = \"[-+]?\";\n    private static final String MUST_CONTAIN_NUMBER = \"(?=.*\\\\d.*)\";\n    private static final String SCIENTIFIC_NUMBER = \"(?:\\\\d+[{expnt}]-?\\\\d+)?\";\n    private static final String DECIMAL_FRACTION = \"(?:[{decimal}](?=\\\\d.*))?\\\\d*\";\n    private static final String INTEGER = \"(?:\\\\d+(?:[{group}]?\\\\d+)*)*\";\n    private static final String FLOAT_REGEXPS =\n            Pattern.compile(MUST_CONTAIN_NUMBER + SIGN + INTEGER + DECIMAL_FRACTION + SCIENTIFIC_NUMBER).pattern();\n    private static final List<String> WORD_REGEXPS = singletonList(\n            Pattern.compile(\"[^\\\\s]+\").pattern()\n    );\n    private static final List<String> STRING_REGEXPS = asList(\n            Pattern.compile(\"\\\"([^\\\"\\\\\\\\]*(\\\\\\\\.[^\\\"\\\\\\\\]*)*)\\\"\").pattern(),\n            Pattern.compile(\"'([^'\\\\\\\\]*(\\\\\\\\.[^'\\\\\\\\]*)*)'\").pattern()\n    );\n    private static final String ANONYMOUS_REGEX = Pattern.compile(\".*\").pattern();\n    private final Map<String, ParameterType<?>> parameterTypeByName = new HashMap<>();\n    private final Map<String, SortedSet<ParameterType<?>>> parameterTypesByRegexp = new HashMap<>();\n    /**\n     * To maintain consistency with `datatable` we don't use the mutable default\n     * transformer to handle build in in conversions yet.\n     */\n    private final ParameterByTypeTransformer internalParameterTransformer;\n    private ParameterByTypeTransformer defaultParameterTransformer;\n\n    public ParameterTypeRegistry(Locale locale) {\n        this(new BuiltInParameterTransformer(locale), locale);\n    }\n\n    private ParameterTypeRegistry(ParameterByTypeTransformer defaultParameterTransformer, Locale locale) {\n        this.internalParameterTransformer = defaultParameterTransformer;\n        this.defaultParameterTransformer = defaultParameterTransformer;\n\n        DecimalFormatSymbols numberFormat = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n\n        List<String> localizedFloatRegexp = singletonList(FLOAT_REGEXPS\n                .replace(\"{decimal}\", \"\" + numberFormat.getDecimalSeparator())\n                .replace(\"{group}\", \"\" + numberFormat.getGroupingSeparator())\n                .replace(\"{expnt}\", \"\" + numberFormat.getExponentSeparator())\n        );\n\n        defineParameterType(new ParameterType<>(\"biginteger\", INTEGER_REGEXPS, BigInteger.class, new Transformer<BigInteger>() {\n            @Override\n            public BigInteger transform(String arg) throws Throwable {\n                return (BigInteger) internalParameterTransformer.transform(arg, BigInteger.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"bigdecimal\", localizedFloatRegexp, BigDecimal.class, new Transformer<BigDecimal>() {\n            @Override\n            public BigDecimal transform(String arg) throws Throwable {\n                return (BigDecimal) internalParameterTransformer.transform(arg, BigDecimal.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"byte\", INTEGER_REGEXPS, Byte.class, new Transformer<Byte>() {\n            @Override\n            public Byte transform(String arg) throws Throwable {\n                return (Byte) internalParameterTransformer.transform(arg, Byte.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"short\", INTEGER_REGEXPS, Short.class, new Transformer<Short>() {\n            @Override\n            public Short transform(String arg) throws Throwable {\n                return (Short) internalParameterTransformer.transform(arg, Short.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"int\", INTEGER_REGEXPS, Integer.class, new Transformer<Integer>() {\n            @Override\n            public Integer transform(String arg) throws Throwable {\n                return (Integer) internalParameterTransformer.transform(arg, Integer.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"long\", INTEGER_REGEXPS, Long.class, new Transformer<Long>() {\n            @Override\n            public Long transform(String arg) throws Throwable {\n                return (Long) internalParameterTransformer.transform(arg, Long.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"float\", localizedFloatRegexp, Float.class, new Transformer<Float>() {\n            @Override\n            public Float transform(String arg) throws Throwable {\n                return (Float) internalParameterTransformer.transform(arg, Float.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"double\", localizedFloatRegexp, Double.class, new Transformer<Double>() {\n            @Override\n            public Double transform(String arg) throws Throwable {\n                return (Double) internalParameterTransformer.transform(arg, Double.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"word\", WORD_REGEXPS, String.class, new Transformer<String>() {\n            @Override\n            public String transform(String arg) throws Throwable {\n                return (String) internalParameterTransformer.transform(arg, String.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"string\", STRING_REGEXPS, String.class, new CaptureGroupTransformer<String>() {\n            @Override\n            public String transform(String... args) throws Throwable {\n                String arg = args[0] != null ? args[0] : args[1];\n                return (String) internalParameterTransformer.transform(arg\n                                .replaceAll(\"\\\\\\\\\\\"\", \"\\\"\")\n                                .replaceAll(\"\\\\\\\\'\", \"'\"),\n                        String.class);\n            }\n        }, true, false, false));\n\n        defineParameterType(createAnonymousParameterType(ANONYMOUS_REGEX));\n    }\n\n    public void defineParameterType(ParameterType<?> parameterType) {\n        if (parameterType.getName() != null) {\n            if (parameterTypeByName.containsKey(parameterType.getName())) {\n                if (parameterType.getName().isEmpty()) {\n                    throw new DuplicateTypeNameException(\"The anonymous parameter type has already been defined\");\n                }\n                throw new DuplicateTypeNameException(String.format(\"There is already a parameter type with name %s\", parameterType.getName()));\n            }\n            parameterTypeByName.put(parameterType.getName(), parameterType);\n        }\n\n        for (String parameterTypeRegexp : parameterType.getRegexps()) {\n            if (!parameterTypesByRegexp.containsKey(parameterTypeRegexp)) {\n                parameterTypesByRegexp.put(parameterTypeRegexp, new TreeSet<ParameterType<?>>());\n            }\n            SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n            if (!parameterTypes.isEmpty() && parameterTypes.first().preferForRegexpMatch() && parameterType.preferForRegexpMatch()) {\n                throw new CucumberExpressionException(String.format(\n                        \"There can only be one preferential parameter type per regexp. \" +\n                                \"The regexp /%s/ is used for two preferential parameter types, {%s} and {%s}\",\n                        parameterTypeRegexp, parameterTypes.first().getName(), parameterType.getName()\n                ));\n            }\n            parameterTypes.add(parameterType);\n        }\n    }\n\n    ParameterByTypeTransformer getDefaultParameterTransformer() {\n        return defaultParameterTransformer;\n    }\n\n    public void setDefaultParameterTransformer(ParameterByTypeTransformer defaultParameterTransformer) {\n        this.defaultParameterTransformer = defaultParameterTransformer;\n    }\n\n    <T> ParameterType<T> lookupByTypeName(String typeName) {\n        return (ParameterType<T>) parameterTypeByName.get(typeName);\n    }\n\n    <T> ParameterType<T> lookupByRegexp(String parameterTypeRegexp, Pattern expressionRegexp, String text) {\n        SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n        if (parameterTypes == null) return null;\n        if (parameterTypes.size() > 1 && !parameterTypes.first().preferForRegexpMatch()) {\n            // We don't do this check on insertion because we only want to restrict\n            // ambiguity when we look up by Regexp. Users of CucumberExpression should\n            // not be restricted.\n            List<GeneratedExpression> generatedExpressions = new CucumberExpressionGenerator(this).generateExpressions(text);\n            throw new AmbiguousParameterTypeException(parameterTypeRegexp, expressionRegexp, parameterTypes, generatedExpressions);\n        }\n        return (ParameterType<T>) parameterTypes.first();\n    }\n\n    Collection<ParameterType<?>> getParameterTypes() {\n        return parameterTypeByName.values();\n    }\n\n}", "definition": "@API(status = API.Status.STABLE)\npublic final class ParameterTypeRegistry", "class_docstring": "", "name": "ParameterTypeRegistry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic final", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public", "final"], "comments": [], "fields": [{"attribute_expression": "private static final List<String> INTEGER_REGEXPS = asList(\n            Pattern.compile(\"-?\\\\d+\").pattern(),\n            Pattern.compile(\"\\\\d+\").pattern()\n    );", "docstring": " which detects unneeded escapes.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<String>", "name": "INTEGER_REGEXPS = asList(\n            Pattern.compile(\"-?\\\\d+\").pattern(),\n            Pattern.compile(\"\\\\d+\").pattern()\n    )", "syntax_pass": true}, {"attribute_expression": "private static final String SIGN = \"[-+]?\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "SIGN = \"[-+]?\"", "syntax_pass": true}, {"attribute_expression": "private static final String MUST_CONTAIN_NUMBER = \"(?=.*\\\\d.*)\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "MUST_CONTAIN_NUMBER = \"(?=.*\\\\d.*)\"", "syntax_pass": true}, {"attribute_expression": "private static final String SCIENTIFIC_NUMBER = \"(?:\\\\d+[{expnt}]-?\\\\d+)?\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "SCIENTIFIC_NUMBER = \"(?:\\\\d+[{expnt}]-?\\\\d+)?\"", "syntax_pass": true}, {"attribute_expression": "private static final String DECIMAL_FRACTION = \"(?:[{decimal}](?=\\\\d.*))?\\\\d*\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "DECIMAL_FRACTION = \"(?:[{decimal}](?=\\\\d.*))?\\\\d*\"", "syntax_pass": true}, {"attribute_expression": "private static final String INTEGER = \"(?:\\\\d+(?:[{group}]?\\\\d+)*)*\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "INTEGER = \"(?:\\\\d+(?:[{group}]?\\\\d+)*)*\"", "syntax_pass": true}, {"attribute_expression": "private static final String FLOAT_REGEXPS =\n            Pattern.compile(MUST_CONTAIN_NUMBER + SIGN + INTEGER + DECIMAL_FRACTION + SCIENTIFIC_NUMBER).pattern();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "FLOAT_REGEXPS =\n            Pattern.compile(MUST_CONTAIN_NUMBER + SIGN + INTEGER + DECIMAL_FRACTION + SCIENTIFIC_NUMBER).pattern()", "syntax_pass": true}, {"attribute_expression": "private static final List<String> WORD_REGEXPS = singletonList(\n            Pattern.compile(\"[^\\\\s]+\").pattern()\n    );", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<String>", "name": "WORD_REGEXPS = singletonList(\n            Pattern.compile(\"[^\\\\s]+\").pattern()\n    )", "syntax_pass": true}, {"attribute_expression": "private static final List<String> STRING_REGEXPS = asList(\n            Pattern.compile(\"\\\"([^\\\"\\\\\\\\]*(\\\\\\\\.[^\\\"\\\\\\\\]*)*)\\\"\").pattern(),\n            Pattern.compile(\"'([^'\\\\\\\\]*(\\\\\\\\.[^'\\\\\\\\]*)*)'\").pattern()\n    );", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<String>", "name": "STRING_REGEXPS = asList(\n            Pattern.compile(\"\\\"([^\\\"\\\\\\\\]*(\\\\\\\\.[^\\\"\\\\\\\\]*)*)\\\"\").pattern(),\n            Pattern.compile(\"'([^'\\\\\\\\]*(\\\\\\\\.[^'\\\\\\\\]*)*)'\").pattern()\n    )", "syntax_pass": true}, {"attribute_expression": "private static final String ANONYMOUS_REGEX = Pattern.compile(\".*\").pattern();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "ANONYMOUS_REGEX = Pattern.compile(\".*\").pattern()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, ParameterType<?>> parameterTypeByName = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, ParameterType<?>>", "name": "parameterTypeByName = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, SortedSet<ParameterType<?>>> parameterTypesByRegexp = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, SortedSet<ParameterType<?>>>", "name": "parameterTypesByRegexp = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final ParameterByTypeTransformer internalParameterTransformer;", "docstring": "\nTo maintain consistency with `datatable` we don't use the mutable default\ntransformer to handle build in in conversions yet.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterByTypeTransformer", "name": "internalParameterTransformer", "syntax_pass": true}, {"attribute_expression": "private ParameterByTypeTransformer defaultParameterTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterByTypeTransformer", "name": "defaultParameterTransformer", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public ParameterTypeRegistry(Locale locale) {\n        this(new BuiltInParameterTransformer(locale), locale);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterTypeRegistry", "params": [{"name": "locale", "type": "Locale"}], "body": "                                                {\n        this(new BuiltInParameterTransformer(locale), locale);\n    }", "signature": "public ParameterTypeRegistry(Locale locale)"}, {"syntax_pass": true, "original_string": "    private ParameterTypeRegistry(ParameterByTypeTransformer defaultParameterTransformer, Locale locale) {\n        this.internalParameterTransformer = defaultParameterTransformer;\n        this.defaultParameterTransformer = defaultParameterTransformer;\n\n        DecimalFormatSymbols numberFormat = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n\n        List<String> localizedFloatRegexp = singletonList(FLOAT_REGEXPS\n                .replace(\"{decimal}\", \"\" + numberFormat.getDecimalSeparator())\n                .replace(\"{group}\", \"\" + numberFormat.getGroupingSeparator())\n                .replace(\"{expnt}\", \"\" + numberFormat.getExponentSeparator())\n        );\n\n        defineParameterType(new ParameterType<>(\"biginteger\", INTEGER_REGEXPS, BigInteger.class, new Transformer<BigInteger>() {\n            @Override\n            public BigInteger transform(String arg) throws Throwable {\n                return (BigInteger) internalParameterTransformer.transform(arg, BigInteger.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"bigdecimal\", localizedFloatRegexp, BigDecimal.class, new Transformer<BigDecimal>() {\n            @Override\n            public BigDecimal transform(String arg) throws Throwable {\n                return (BigDecimal) internalParameterTransformer.transform(arg, BigDecimal.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"byte\", INTEGER_REGEXPS, Byte.class, new Transformer<Byte>() {\n            @Override\n            public Byte transform(String arg) throws Throwable {\n                return (Byte) internalParameterTransformer.transform(arg, Byte.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"short\", INTEGER_REGEXPS, Short.class, new Transformer<Short>() {\n            @Override\n            public Short transform(String arg) throws Throwable {\n                return (Short) internalParameterTransformer.transform(arg, Short.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"int\", INTEGER_REGEXPS, Integer.class, new Transformer<Integer>() {\n            @Override\n            public Integer transform(String arg) throws Throwable {\n                return (Integer) internalParameterTransformer.transform(arg, Integer.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"long\", INTEGER_REGEXPS, Long.class, new Transformer<Long>() {\n            @Override\n            public Long transform(String arg) throws Throwable {\n                return (Long) internalParameterTransformer.transform(arg, Long.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"float\", localizedFloatRegexp, Float.class, new Transformer<Float>() {\n            @Override\n            public Float transform(String arg) throws Throwable {\n                return (Float) internalParameterTransformer.transform(arg, Float.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"double\", localizedFloatRegexp, Double.class, new Transformer<Double>() {\n            @Override\n            public Double transform(String arg) throws Throwable {\n                return (Double) internalParameterTransformer.transform(arg, Double.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"word\", WORD_REGEXPS, String.class, new Transformer<String>() {\n            @Override\n            public String transform(String arg) throws Throwable {\n                return (String) internalParameterTransformer.transform(arg, String.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"string\", STRING_REGEXPS, String.class, new CaptureGroupTransformer<String>() {\n            @Override\n            public String transform(String... args) throws Throwable {\n                String arg = args[0] != null ? args[0] : args[1];\n                return (String) internalParameterTransformer.transform(arg\n                                .replaceAll(\"\\\\\\\\\\\"\", \"\\\"\")\n                                .replaceAll(\"\\\\\\\\'\", \"'\"),\n                        String.class);\n            }\n        }, true, false, false));\n\n        defineParameterType(createAnonymousParameterType(ANONYMOUS_REGEX));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterTypeRegistry", "params": [{"name": "defaultParameterTransformer", "type": "ParameterByTypeTransformer"}, {"name": "locale", "type": "Locale"}], "body": "                                                                                                         {\n        this.internalParameterTransformer = defaultParameterTransformer;\n        this.defaultParameterTransformer = defaultParameterTransformer;\n\n        DecimalFormatSymbols numberFormat = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n\n        List<String> localizedFloatRegexp = singletonList(FLOAT_REGEXPS\n                .replace(\"{decimal}\", \"\" + numberFormat.getDecimalSeparator())\n                .replace(\"{group}\", \"\" + numberFormat.getGroupingSeparator())\n                .replace(\"{expnt}\", \"\" + numberFormat.getExponentSeparator())\n        );\n\n        defineParameterType(new ParameterType<>(\"biginteger\", INTEGER_REGEXPS, BigInteger.class, new Transformer<BigInteger>() {\n            @Override\n            public BigInteger transform(String arg) throws Throwable {\n                return (BigInteger) internalParameterTransformer.transform(arg, BigInteger.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"bigdecimal\", localizedFloatRegexp, BigDecimal.class, new Transformer<BigDecimal>() {\n            @Override\n            public BigDecimal transform(String arg) throws Throwable {\n                return (BigDecimal) internalParameterTransformer.transform(arg, BigDecimal.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"byte\", INTEGER_REGEXPS, Byte.class, new Transformer<Byte>() {\n            @Override\n            public Byte transform(String arg) throws Throwable {\n                return (Byte) internalParameterTransformer.transform(arg, Byte.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"short\", INTEGER_REGEXPS, Short.class, new Transformer<Short>() {\n            @Override\n            public Short transform(String arg) throws Throwable {\n                return (Short) internalParameterTransformer.transform(arg, Short.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"int\", INTEGER_REGEXPS, Integer.class, new Transformer<Integer>() {\n            @Override\n            public Integer transform(String arg) throws Throwable {\n                return (Integer) internalParameterTransformer.transform(arg, Integer.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"long\", INTEGER_REGEXPS, Long.class, new Transformer<Long>() {\n            @Override\n            public Long transform(String arg) throws Throwable {\n                return (Long) internalParameterTransformer.transform(arg, Long.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"float\", localizedFloatRegexp, Float.class, new Transformer<Float>() {\n            @Override\n            public Float transform(String arg) throws Throwable {\n                return (Float) internalParameterTransformer.transform(arg, Float.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"double\", localizedFloatRegexp, Double.class, new Transformer<Double>() {\n            @Override\n            public Double transform(String arg) throws Throwable {\n                return (Double) internalParameterTransformer.transform(arg, Double.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"word\", WORD_REGEXPS, String.class, new Transformer<String>() {\n            @Override\n            public String transform(String arg) throws Throwable {\n                return (String) internalParameterTransformer.transform(arg, String.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"string\", STRING_REGEXPS, String.class, new CaptureGroupTransformer<String>() {\n            @Override\n            public String transform(String... args) throws Throwable {\n                String arg = args[0] != null ? args[0] : args[1];\n                return (String) internalParameterTransformer.transform(arg\n                                .replaceAll(\"\\\\\\\\\\\"\", \"\\\"\")\n                                .replaceAll(\"\\\\\\\\'\", \"'\"),\n                        String.class);\n            }\n        }, true, false, false));\n\n        defineParameterType(createAnonymousParameterType(ANONYMOUS_REGEX));\n    }", "signature": "private ParameterTypeRegistry(ParameterByTypeTransformer defaultParameterTransformer, Locale locale)"}, {"syntax_pass": true, "original_string": "    public void defineParameterType(ParameterType<?> parameterType) {\n        if (parameterType.getName() != null) {\n            if (parameterTypeByName.containsKey(parameterType.getName())) {\n                if (parameterType.getName().isEmpty()) {\n                    throw new DuplicateTypeNameException(\"The anonymous parameter type has already been defined\");\n                }\n                throw new DuplicateTypeNameException(String.format(\"There is already a parameter type with name %s\", parameterType.getName()));\n            }\n            parameterTypeByName.put(parameterType.getName(), parameterType);\n        }\n\n        for (String parameterTypeRegexp : parameterType.getRegexps()) {\n            if (!parameterTypesByRegexp.containsKey(parameterTypeRegexp)) {\n                parameterTypesByRegexp.put(parameterTypeRegexp, new TreeSet<ParameterType<?>>());\n            }\n            SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n            if (!parameterTypes.isEmpty() && parameterTypes.first().preferForRegexpMatch() && parameterType.preferForRegexpMatch()) {\n                throw new CucumberExpressionException(String.format(\n                        \"There can only be one preferential parameter type per regexp. \" +\n                                \"The regexp /%s/ is used for two preferential parameter types, {%s} and {%s}\",\n                        parameterTypeRegexp, parameterTypes.first().getName(), parameterType.getName()\n                ));\n            }\n            parameterTypes.add(parameterType);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "defineParameterType", "params": [{"name": "parameterType", "type": "ParameterType<?>"}], "body": "                                                                    {\n        if (parameterType.getName() != null) {\n            if (parameterTypeByName.containsKey(parameterType.getName())) {\n                if (parameterType.getName().isEmpty()) {\n                    throw new DuplicateTypeNameException(\"The anonymous parameter type has already been defined\");\n                }\n                throw new DuplicateTypeNameException(String.format(\"There is already a parameter type with name %s\", parameterType.getName()));\n            }\n            parameterTypeByName.put(parameterType.getName(), parameterType);\n        }\n\n        for (String parameterTypeRegexp : parameterType.getRegexps()) {\n            if (!parameterTypesByRegexp.containsKey(parameterTypeRegexp)) {\n                parameterTypesByRegexp.put(parameterTypeRegexp, new TreeSet<ParameterType<?>>());\n            }\n            SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n            if (!parameterTypes.isEmpty() && parameterTypes.first().preferForRegexpMatch() && parameterType.preferForRegexpMatch()) {\n                throw new CucumberExpressionException(String.format(\n                        \"There can only be one preferential parameter type per regexp. \" +\n                                \"The regexp /%s/ is used for two preferential parameter types, {%s} and {%s}\",\n                        parameterTypeRegexp, parameterTypes.first().getName(), parameterType.getName()\n                ));\n            }\n            parameterTypes.add(parameterType);\n        }\n    }", "signature": "public void defineParameterType(ParameterType<?> parameterType)"}, {"syntax_pass": true, "original_string": "    ParameterByTypeTransformer getDefaultParameterTransformer() {\n        return defaultParameterTransformer;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ParameterByTypeTransformer", "classes": []}, "name": "getDefaultParameterTransformer", "params": [], "body": "                                                                {\n        return defaultParameterTransformer;\n    }", "signature": "ParameterByTypeTransformer getDefaultParameterTransformer()"}, {"syntax_pass": true, "original_string": "    public void setDefaultParameterTransformer(ParameterByTypeTransformer defaultParameterTransformer) {\n        this.defaultParameterTransformer = defaultParameterTransformer;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setDefaultParameterTransformer", "params": [{"name": "defaultParameterTransformer", "type": "ParameterByTypeTransformer"}], "body": "                                                                                                       {\n        this.defaultParameterTransformer = defaultParameterTransformer;\n    }", "signature": "public void setDefaultParameterTransformer(ParameterByTypeTransformer defaultParameterTransformer)"}, {"syntax_pass": true, "original_string": "    <T> ParameterType<T> lookupByTypeName(String typeName) {\n        return (ParameterType<T>) parameterTypeByName.get(typeName);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ParameterType<T>", "classes": []}, "name": "lookupByTypeName", "params": [{"name": "typeName", "type": "String"}], "body": "                                                           {\n        return (ParameterType<T>) parameterTypeByName.get(typeName);\n    }", "signature": "<T> ParameterType<T> lookupByTypeName(String typeName)"}, {"syntax_pass": true, "original_string": "    <T> ParameterType<T> lookupByRegexp(String parameterTypeRegexp, Pattern expressionRegexp, String text) {\n        SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n        if (parameterTypes == null) return null;\n        if (parameterTypes.size() > 1 && !parameterTypes.first().preferForRegexpMatch()) {\n            // We don't do this check on insertion because we only want to restrict\n            // ambiguity when we look up by Regexp. Users of CucumberExpression should\n            // not be restricted.\n            List<GeneratedExpression> generatedExpressions = new CucumberExpressionGenerator(this).generateExpressions(text);\n            throw new AmbiguousParameterTypeException(parameterTypeRegexp, expressionRegexp, parameterTypes, generatedExpressions);\n        }\n        return (ParameterType<T>) parameterTypes.first();\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ParameterType<T>", "classes": []}, "name": "lookupByRegexp", "params": [{"name": "parameterTypeRegexp", "type": "String"}, {"name": "expressionRegexp", "type": "Pattern"}, {"name": "text", "type": "String"}], "body": "                                                                                                           {\n        SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n        if (parameterTypes == null) return null;\n        if (parameterTypes.size() > 1 && !parameterTypes.first().preferForRegexpMatch()) {\n            // We don't do this check on insertion because we only want to restrict\n            // ambiguity when we look up by Regexp. Users of CucumberExpression should\n            // not be restricted.\n            List<GeneratedExpression> generatedExpressions = new CucumberExpressionGenerator(this).generateExpressions(text);\n            throw new AmbiguousParameterTypeException(parameterTypeRegexp, expressionRegexp, parameterTypes, generatedExpressions);\n        }\n        return (ParameterType<T>) parameterTypes.first();\n    }", "signature": "<T> ParameterType<T> lookupByRegexp(String parameterTypeRegexp, Pattern expressionRegexp, String text)"}, {"syntax_pass": true, "original_string": "    Collection<ParameterType<?>> getParameterTypes() {\n        return parameterTypeByName.values();\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Collection<ParameterType<?>>", "classes": []}, "name": "getParameterTypes", "params": [], "body": "                                                     {\n        return parameterTypeByName.values();\n    }", "signature": "Collection<ParameterType<?>> getParameterTypes()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\n/**\n * Creates a {@link CucumberExpression} or {@link RegularExpression} from a {@link String}\n * using heuristics. This is particularly useful for languages that don't have a\n * literal syntax for regular expressions. In Java, a regular expression has to be represented as a String.\n *\n *  A string that starts with `^` and/or ends with `$` (or written in script style, i.e. starting with `/` \n *  and ending with `/`) is considered a regular expression.\n *  Everything else is considered a Cucumber expression.\n */\n@API(status = API.Status.STABLE)\npublic final class ExpressionFactory {\n\n    private static final Pattern PARAMETER_PATTERN = Pattern.compile(\"((?:\\\\\\\\){0,2})\\\\{([^}]*)\\\\}\");\n\n    private final ParameterTypeRegistry parameterTypeRegistry;\n\n    public ExpressionFactory(ParameterTypeRegistry parameterTypeRegistry) {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }\n\n    public Expression createExpression(String expressionString) {\n        /* This method is called often (typically about number_of_steps x\n         * nbr_test_scenarios), thus performance is more important than\n         * readability here.\n         * Consequently, we check the first and last expressionString\n         * characters to determine whether we need to create a\n         * RegularExpression or a CucumberExpression (because character\n         * matching is faster than startsWith/endsWith and regexp matching).\n         */\n        int length = expressionString.length();\n        if (length == 0) {\n            return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n        }\n\n        int lastCharIndex = length - 1;\n        char firstChar = expressionString.charAt(0);\n        char lastChar = expressionString.charAt(lastCharIndex);\n\n        if (firstChar == '^' || lastChar == '$') {\n            return this.createRegularExpressionWithAnchors(expressionString);\n        } else if (firstChar == '/' && lastChar == '/') {\n            return new RegularExpression(Pattern.compile(expressionString.substring(1, lastCharIndex)), this.parameterTypeRegistry);\n        }\n\n        return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n    }\n\n    private RegularExpression createRegularExpressionWithAnchors(String expressionString) {\n        try {\n            return new RegularExpression(Pattern.compile(expressionString), parameterTypeRegistry);\n        } catch (PatternSyntaxException e) {\n            if (PARAMETER_PATTERN.matcher(expressionString).find()) {\n                throw new CucumberExpressionException(\"You cannot use anchors (^ or $) in Cucumber Expressions. Please remove them from \" + expressionString, e);\n            }\n            throw e;\n        }\n    }\n}\n", "file_hash": "1352763673d1eb26bf017cd3b86d9df08d8cd8e9028358f84a6565e49fb8b855", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.util.regex.Matcher;", "import java.util.regex.Pattern;", "import java.util.regex.PatternSyntaxException;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic final class ExpressionFactory {\n\n    private static final Pattern PARAMETER_PATTERN = Pattern.compile(\"((?:\\\\\\\\){0,2})\\\\{([^}]*)\\\\}\");\n\n    private final ParameterTypeRegistry parameterTypeRegistry;\n\n    public ExpressionFactory(ParameterTypeRegistry parameterTypeRegistry) {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }\n\n    public Expression createExpression(String expressionString) {\n        /* This method is called often (typically about number_of_steps x\n         * nbr_test_scenarios), thus performance is more important than\n         * readability here.\n         * Consequently, we check the first and last expressionString\n         * characters to determine whether we need to create a\n         * RegularExpression or a CucumberExpression (because character\n         * matching is faster than startsWith/endsWith and regexp matching).\n         */\n        int length = expressionString.length();\n        if (length == 0) {\n            return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n        }\n\n        int lastCharIndex = length - 1;\n        char firstChar = expressionString.charAt(0);\n        char lastChar = expressionString.charAt(lastCharIndex);\n\n        if (firstChar == '^' || lastChar == '$') {\n            return this.createRegularExpressionWithAnchors(expressionString);\n        } else if (firstChar == '/' && lastChar == '/') {\n            return new RegularExpression(Pattern.compile(expressionString.substring(1, lastCharIndex)), this.parameterTypeRegistry);\n        }\n\n        return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n    }\n\n    private RegularExpression createRegularExpressionWithAnchors(String expressionString) {\n        try {\n            return new RegularExpression(Pattern.compile(expressionString), parameterTypeRegistry);\n        } catch (PatternSyntaxException e) {\n            if (PARAMETER_PATTERN.matcher(expressionString).find()) {\n                throw new CucumberExpressionException(\"You cannot use anchors (^ or $) in Cucumber Expressions. Please remove them from \" + expressionString, e);\n            }\n            throw e;\n        }\n    }\n}", "definition": "@API(status = API.Status.STABLE)\npublic final class ExpressionFactory", "class_docstring": "\nCreates a {@link CucumberExpression} or {@link RegularExpression} from a {@link String}\nusing heuristics. This is particularly useful for languages that don't have a\nliteral syntax for regular expressions. In Java, a regular expression has to be represented as a String.\n\n A string that starts with `^` and/or ends with `$` (or written in script style, i.e. starting with `/` \n and ending with `/`) is considered a regular expression.\n Everything else is considered a Cucumber expression.\n", "name": "ExpressionFactory", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic final", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public", "final"], "comments": [], "fields": [{"attribute_expression": "private static final Pattern PARAMETER_PATTERN = Pattern.compile(\"((?:\\\\\\\\){0,2})\\\\{([^}]*)\\\\}\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "PARAMETER_PATTERN = Pattern.compile(\"((?:\\\\\\\\){0,2})\\\\{([^}]*)\\\\}\")", "syntax_pass": true}, {"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public ExpressionFactory(ParameterTypeRegistry parameterTypeRegistry) {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ExpressionFactory", "params": [{"name": "parameterTypeRegistry", "type": "ParameterTypeRegistry"}], "body": "                                                                          {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }", "signature": "public ExpressionFactory(ParameterTypeRegistry parameterTypeRegistry)"}, {"syntax_pass": true, "original_string": "    public Expression createExpression(String expressionString) {\n        /* This method is called often (typically about number_of_steps x\n         * nbr_test_scenarios), thus performance is more important than\n         * readability here.\n         * Consequently, we check the first and last expressionString\n         * characters to determine whether we need to create a\n         * RegularExpression or a CucumberExpression (because character\n         * matching is faster than startsWith/endsWith and regexp matching).\n         */\n        int length = expressionString.length();\n        if (length == 0) {\n            return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n        }\n\n        int lastCharIndex = length - 1;\n        char firstChar = expressionString.charAt(0);\n        char lastChar = expressionString.charAt(lastCharIndex);\n\n        if (firstChar == '^' || lastChar == '$') {\n            return this.createRegularExpressionWithAnchors(expressionString);\n        } else if (firstChar == '/' && lastChar == '/') {\n            return new RegularExpression(Pattern.compile(expressionString.substring(1, lastCharIndex)), this.parameterTypeRegistry);\n        }\n\n        return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expression", "classes": []}, "name": "createExpression", "params": [{"name": "expressionString", "type": "String"}], "body": "                                                                {\n        /* This method is called often (typically about number_of_steps x\n         * nbr_test_scenarios), thus performance is more important than\n         * readability here.\n         * Consequently, we check the first and last expressionString\n         * characters to determine whether we need to create a\n         * RegularExpression or a CucumberExpression (because character\n         * matching is faster than startsWith/endsWith and regexp matching).\n         */\n        int length = expressionString.length();\n        if (length == 0) {\n            return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n        }\n\n        int lastCharIndex = length - 1;\n        char firstChar = expressionString.charAt(0);\n        char lastChar = expressionString.charAt(lastCharIndex);\n\n        if (firstChar == '^' || lastChar == '$') {\n            return this.createRegularExpressionWithAnchors(expressionString);\n        } else if (firstChar == '/' && lastChar == '/') {\n            return new RegularExpression(Pattern.compile(expressionString.substring(1, lastCharIndex)), this.parameterTypeRegistry);\n        }\n\n        return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n    }", "signature": "public Expression createExpression(String expressionString)"}, {"syntax_pass": true, "original_string": "    private RegularExpression createRegularExpressionWithAnchors(String expressionString) {\n        try {\n            return new RegularExpression(Pattern.compile(expressionString), parameterTypeRegistry);\n        } catch (PatternSyntaxException e) {\n            if (PARAMETER_PATTERN.matcher(expressionString).find()) {\n                throw new CucumberExpressionException(\"You cannot use anchors (^ or $) in Cucumber Expressions. Please remove them from \" + expressionString, e);\n            }\n            throw e;\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RegularExpression", "classes": []}, "name": "createRegularExpressionWithAnchors", "params": [{"name": "expressionString", "type": "String"}], "body": "                                                                                          {\n        try {\n            return new RegularExpression(Pattern.compile(expressionString), parameterTypeRegistry);\n        } catch (PatternSyntaxException e) {\n            if (PARAMETER_PATTERN.matcher(expressionString).find()) {\n                throw new CucumberExpressionException(\"You cannot use anchors (^ or $) in Cucumber Expressions. Please remove them from \" + expressionString, e);\n            }\n            throw e;\n        }\n    }", "signature": "private RegularExpression createRegularExpressionWithAnchors(String expressionString)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/DefaultPatternCompiler.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport java.util.regex.Pattern;\n\n/**\n * Default {@link PatternCompiler}\n */\nfinal class DefaultPatternCompiler implements PatternCompiler {\n\n    @Override\n    public Pattern compile(String regexp, int flags) {\n        return Pattern.compile(regexp, flags);\n    }\n}\n", "file_hash": "3226433ca14497771b931ebbc922e5fe628425a8490368711c719e17aa41ba4b", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import java.util.regex.Pattern;"], "methods": [], "classes": [{"original_string": "final class DefaultPatternCompiler implements PatternCompiler {\n\n    @Override\n    public Pattern compile(String regexp, int flags) {\n        return Pattern.compile(regexp, flags);\n    }\n}", "definition": "final class DefaultPatternCompiler implements PatternCompiler", "class_docstring": "\nDefault {@link PatternCompiler}\n", "name": "DefaultPatternCompiler", "super_interfaces": ["PatternCompiler"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Pattern compile(String regexp, int flags) {\n        return Pattern.compile(regexp, flags);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pattern", "classes": []}, "name": "compile", "params": [{"name": "regexp", "type": "String"}, {"name": "flags", "type": "int"}], "body": "                                                     {\n        return Pattern.compile(regexp, flags);\n    }", "signature": "@Override\n    public Pattern compile(String regexp, int flags)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport io.cucumber.cucumberexpressions.Ast.Node;\nimport org.apiguardian.api.API;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\n\nimport static io.cucumber.cucumberexpressions.Ast.Node.Type.OPTIONAL_NODE;\nimport static io.cucumber.cucumberexpressions.Ast.Node.Type.PARAMETER_NODE;\nimport static io.cucumber.cucumberexpressions.Ast.Node.Type.TEXT_NODE;\nimport static io.cucumber.cucumberexpressions.CucumberExpressionException.createAlternativeMayNotBeEmpty;\nimport static io.cucumber.cucumberexpressions.CucumberExpressionException.createAlternativeMayNotExclusivelyContainOptionals;\nimport static io.cucumber.cucumberexpressions.CucumberExpressionException.createInvalidParameterTypeName;\nimport static io.cucumber.cucumberexpressions.CucumberExpressionException.createOptionalIsNotAllowedInOptional;\nimport static io.cucumber.cucumberexpressions.CucumberExpressionException.createOptionalMayNotBeEmpty;\nimport static io.cucumber.cucumberexpressions.CucumberExpressionException.createParameterIsNotAllowedInOptional;\nimport static io.cucumber.cucumberexpressions.ParameterType.isValidParameterTypeName;\nimport static io.cucumber.cucumberexpressions.RegexpUtils.escapeRegex;\nimport static io.cucumber.cucumberexpressions.UndefinedParameterTypeException.createUndefinedParameterType;\nimport static java.util.stream.Collectors.joining;\n\n@API(status = API.Status.STABLE)\npublic final class CucumberExpression implements Expression {\n    private final List<ParameterType<?>> parameterTypes = new ArrayList<>();\n    private final String source;\n    private final TreeRegexp treeRegexp;\n    private final ParameterTypeRegistry parameterTypeRegistry;\n\n    CucumberExpression(String expression, ParameterTypeRegistry parameterTypeRegistry) {\n        this.source = expression;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n\n        CucumberExpressionParser parser = new CucumberExpressionParser();\n        Node ast = parser.parse(expression);\n        String pattern = rewriteToRegex(ast);\n        treeRegexp = new TreeRegexp(pattern);\n    }\n\n    private String rewriteToRegex(Node node) {\n        switch (node.type()) {\n            case TEXT_NODE:\n                return escapeRegex(node.text());\n            case OPTIONAL_NODE:\n                return rewriteOptional(node);\n            case ALTERNATION_NODE:\n                return rewriteAlternation(node);\n            case ALTERNATIVE_NODE:\n                return rewriteAlternative(node);\n            case PARAMETER_NODE:\n                return rewriteParameter(node);\n            case EXPRESSION_NODE:\n                return rewriteExpression(node);\n            default:\n                // Can't happen as long as the switch case is exhaustive\n                throw new IllegalArgumentException(node.type().name());\n        }\n    }\n\n    private String rewriteOptional(Node node) {\n        assertNoParameters(node, astNode -> createParameterIsNotAllowedInOptional(astNode, source));\n        assertNoOptionals(node, astNode -> createOptionalIsNotAllowedInOptional(astNode, source));\n        assertNotEmpty(node, astNode -> createOptionalMayNotBeEmpty(astNode, source));\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"(?:\", \")?\"));\n    }\n\n    private String rewriteAlternation(Node node) {\n        // Make sure the alternative parts aren't empty and don't contain parameter types\n        for (Node alternative : node.nodes()) {\n            if (alternative.nodes().isEmpty()) {\n                throw createAlternativeMayNotBeEmpty(alternative, source);\n            }\n            assertNotEmpty(alternative, astNode -> createAlternativeMayNotExclusivelyContainOptionals(astNode, source));\n        }\n        return node.nodes()\n                .stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"|\", \"(?:\", \")\"));\n    }\n\n    private String rewriteAlternative(Node node) {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining());\n    }\n\n    private String rewriteParameter(Node node) {\n        String name = node.text();\n        ParameterType<?> parameterType = parameterTypeRegistry.lookupByTypeName(name);\n        if (parameterType == null) {\n            throw createUndefinedParameterType(node, source, name);\n        }\n        parameterTypes.add(parameterType);\n        List<String> regexps = parameterType.getRegexps();\n        if (regexps.size() == 1) {\n            return \"(\" + regexps.get(0) + \")\";\n        }\n        return regexps.stream()\n                .collect(joining(\")|(?:\", \"((?:\", \"))\"));\n    }\n\n\n    private String rewriteExpression(Node node) {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"^\", \"$\"));\n    }\n\n    private void assertNotEmpty(Node node,\n            Function<Node, CucumberExpressionException> createNodeWasNotEmptyException) {\n        node.nodes()\n                .stream()\n                .filter(astNode -> TEXT_NODE.equals(astNode.type()))\n                .findFirst()\n                .orElseThrow(() -> createNodeWasNotEmptyException.apply(node));\n    }\n\n    private void assertNoParameters(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAParameterException) {\n        assertNoNodeOfType(PARAMETER_NODE, node, createNodeContainedAParameterException);\n    }\n\n    private void assertNoOptionals(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAnOptionalException) {\n        assertNoNodeOfType(OPTIONAL_NODE, node, createNodeContainedAnOptionalException);\n    }\n\n    private void assertNoNodeOfType(Node.Type nodeType, Node node,\n            Function<Node, CucumberExpressionException> createException) {\n        node.nodes()\n                .stream()\n                .filter(astNode -> nodeType.equals(astNode.type()))\n                .map(createException)\n                .findFirst()\n                .ifPresent(exception -> {\n                    throw exception;\n                });\n    }\n\n\n    @Override\n    public List<Argument<?>> match(String text, Type... typeHints) {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        List<ParameterType<?>> parameterTypes = new ArrayList<>(this.parameterTypes);\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            Type type = i < typeHints.length ? typeHints[i] : String.class;\n            if (parameterType.isAnonymous()) {\n                ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n                parameterTypes.set(i, parameterType.deAnonymize(type, arg -> defaultTransformer.transform(arg, type)));\n            }\n        }\n\n        return Argument.build(group, parameterTypes);\n    }\n\n    @Override\n    public String getSource() {\n        return source;\n    }\n\n    @Override\n    public Pattern getRegexp() {\n        return treeRegexp.pattern();\n    }\n\n}\n", "file_hash": "b471829af51fd269b227a21c92115e0264786fe3dab3ab5943b304e9c9def93a", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import io.cucumber.cucumberexpressions.Ast.Node;", "import org.apiguardian.api.API;", "import java.lang.reflect.Type;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.function.Function;", "import java.util.regex.Pattern;", "import static io.cucumber.cucumberexpressions.Ast.Node.Type.OPTIONAL_NODE;", "import static io.cucumber.cucumberexpressions.Ast.Node.Type.PARAMETER_NODE;", "import static io.cucumber.cucumberexpressions.Ast.Node.Type.TEXT_NODE;", "import static io.cucumber.cucumberexpressions.CucumberExpressionException.createAlternativeMayNotBeEmpty;", "import static io.cucumber.cucumberexpressions.CucumberExpressionException.createAlternativeMayNotExclusivelyContainOptionals;", "import static io.cucumber.cucumberexpressions.CucumberExpressionException.createInvalidParameterTypeName;", "import static io.cucumber.cucumberexpressions.CucumberExpressionException.createOptionalIsNotAllowedInOptional;", "import static io.cucumber.cucumberexpressions.CucumberExpressionException.createOptionalMayNotBeEmpty;", "import static io.cucumber.cucumberexpressions.CucumberExpressionException.createParameterIsNotAllowedInOptional;", "import static io.cucumber.cucumberexpressions.ParameterType.isValidParameterTypeName;", "import static io.cucumber.cucumberexpressions.RegexpUtils.escapeRegex;", "import static io.cucumber.cucumberexpressions.UndefinedParameterTypeException.createUndefinedParameterType;", "import static java.util.stream.Collectors.joining;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic final class CucumberExpression implements Expression {\n    private final List<ParameterType<?>> parameterTypes = new ArrayList<>();\n    private final String source;\n    private final TreeRegexp treeRegexp;\n    private final ParameterTypeRegistry parameterTypeRegistry;\n\n    CucumberExpression(String expression, ParameterTypeRegistry parameterTypeRegistry) {\n        this.source = expression;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n\n        CucumberExpressionParser parser = new CucumberExpressionParser();\n        Node ast = parser.parse(expression);\n        String pattern = rewriteToRegex(ast);\n        treeRegexp = new TreeRegexp(pattern);\n    }\n\n    private String rewriteToRegex(Node node) {\n        switch (node.type()) {\n            case TEXT_NODE:\n                return escapeRegex(node.text());\n            case OPTIONAL_NODE:\n                return rewriteOptional(node);\n            case ALTERNATION_NODE:\n                return rewriteAlternation(node);\n            case ALTERNATIVE_NODE:\n                return rewriteAlternative(node);\n            case PARAMETER_NODE:\n                return rewriteParameter(node);\n            case EXPRESSION_NODE:\n                return rewriteExpression(node);\n            default:\n                // Can't happen as long as the switch case is exhaustive\n                throw new IllegalArgumentException(node.type().name());\n        }\n    }\n\n    private String rewriteOptional(Node node) {\n        assertNoParameters(node, astNode -> createParameterIsNotAllowedInOptional(astNode, source));\n        assertNoOptionals(node, astNode -> createOptionalIsNotAllowedInOptional(astNode, source));\n        assertNotEmpty(node, astNode -> createOptionalMayNotBeEmpty(astNode, source));\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"(?:\", \")?\"));\n    }\n\n    private String rewriteAlternation(Node node) {\n        // Make sure the alternative parts aren't empty and don't contain parameter types\n        for (Node alternative : node.nodes()) {\n            if (alternative.nodes().isEmpty()) {\n                throw createAlternativeMayNotBeEmpty(alternative, source);\n            }\n            assertNotEmpty(alternative, astNode -> createAlternativeMayNotExclusivelyContainOptionals(astNode, source));\n        }\n        return node.nodes()\n                .stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"|\", \"(?:\", \")\"));\n    }\n\n    private String rewriteAlternative(Node node) {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining());\n    }\n\n    private String rewriteParameter(Node node) {\n        String name = node.text();\n        ParameterType<?> parameterType = parameterTypeRegistry.lookupByTypeName(name);\n        if (parameterType == null) {\n            throw createUndefinedParameterType(node, source, name);\n        }\n        parameterTypes.add(parameterType);\n        List<String> regexps = parameterType.getRegexps();\n        if (regexps.size() == 1) {\n            return \"(\" + regexps.get(0) + \")\";\n        }\n        return regexps.stream()\n                .collect(joining(\")|(?:\", \"((?:\", \"))\"));\n    }\n\n\n    private String rewriteExpression(Node node) {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"^\", \"$\"));\n    }\n\n    private void assertNotEmpty(Node node,\n            Function<Node, CucumberExpressionException> createNodeWasNotEmptyException) {\n        node.nodes()\n                .stream()\n                .filter(astNode -> TEXT_NODE.equals(astNode.type()))\n                .findFirst()\n                .orElseThrow(() -> createNodeWasNotEmptyException.apply(node));\n    }\n\n    private void assertNoParameters(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAParameterException) {\n        assertNoNodeOfType(PARAMETER_NODE, node, createNodeContainedAParameterException);\n    }\n\n    private void assertNoOptionals(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAnOptionalException) {\n        assertNoNodeOfType(OPTIONAL_NODE, node, createNodeContainedAnOptionalException);\n    }\n\n    private void assertNoNodeOfType(Node.Type nodeType, Node node,\n            Function<Node, CucumberExpressionException> createException) {\n        node.nodes()\n                .stream()\n                .filter(astNode -> nodeType.equals(astNode.type()))\n                .map(createException)\n                .findFirst()\n                .ifPresent(exception -> {\n                    throw exception;\n                });\n    }\n\n\n    @Override\n    public List<Argument<?>> match(String text, Type... typeHints) {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        List<ParameterType<?>> parameterTypes = new ArrayList<>(this.parameterTypes);\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            Type type = i < typeHints.length ? typeHints[i] : String.class;\n            if (parameterType.isAnonymous()) {\n                ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n                parameterTypes.set(i, parameterType.deAnonymize(type, arg -> defaultTransformer.transform(arg, type)));\n            }\n        }\n\n        return Argument.build(group, parameterTypes);\n    }\n\n    @Override\n    public String getSource() {\n        return source;\n    }\n\n    @Override\n    public Pattern getRegexp() {\n        return treeRegexp.pattern();\n    }\n\n}", "definition": "@API(status = API.Status.STABLE)\npublic final class CucumberExpression implements Expression", "class_docstring": "", "name": "CucumberExpression", "super_interfaces": ["Expression"], "superclasses": "", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic final", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public", "final"], "comments": [], "fields": [{"attribute_expression": "private final List<ParameterType<?>> parameterTypes = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<ParameterType<?>>", "name": "parameterTypes = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final String source;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "source", "syntax_pass": true}, {"attribute_expression": "private final TreeRegexp treeRegexp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TreeRegexp", "name": "treeRegexp", "syntax_pass": true}, {"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    CucumberExpression(String expression, ParameterTypeRegistry parameterTypeRegistry) {\n        this.source = expression;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n\n        CucumberExpressionParser parser = new CucumberExpressionParser();\n        Node ast = parser.parse(expression);\n        String pattern = rewriteToRegex(ast);\n        treeRegexp = new TreeRegexp(pattern);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CucumberExpression", "params": [{"name": "expression", "type": "String"}, {"name": "parameterTypeRegistry", "type": "ParameterTypeRegistry"}], "body": "                                                                                       {\n        this.source = expression;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n\n        CucumberExpressionParser parser = new CucumberExpressionParser();\n        Node ast = parser.parse(expression);\n        String pattern = rewriteToRegex(ast);\n        treeRegexp = new TreeRegexp(pattern);\n    }", "signature": "CucumberExpression(String expression, ParameterTypeRegistry parameterTypeRegistry)"}, {"syntax_pass": true, "original_string": "    private String rewriteToRegex(Node node) {\n        switch (node.type()) {\n            case TEXT_NODE:\n                return escapeRegex(node.text());\n            case OPTIONAL_NODE:\n                return rewriteOptional(node);\n            case ALTERNATION_NODE:\n                return rewriteAlternation(node);\n            case ALTERNATIVE_NODE:\n                return rewriteAlternative(node);\n            case PARAMETER_NODE:\n                return rewriteParameter(node);\n            case EXPRESSION_NODE:\n                return rewriteExpression(node);\n            default:\n                // Can't happen as long as the switch case is exhaustive\n                throw new IllegalArgumentException(node.type().name());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "rewriteToRegex", "params": [{"name": "node", "type": "Node"}], "body": "                                             {\n        switch (node.type()) {\n            case TEXT_NODE:\n                return escapeRegex(node.text());\n            case OPTIONAL_NODE:\n                return rewriteOptional(node);\n            case ALTERNATION_NODE:\n                return rewriteAlternation(node);\n            case ALTERNATIVE_NODE:\n                return rewriteAlternative(node);\n            case PARAMETER_NODE:\n                return rewriteParameter(node);\n            case EXPRESSION_NODE:\n                return rewriteExpression(node);\n            default:\n                // Can't happen as long as the switch case is exhaustive\n                throw new IllegalArgumentException(node.type().name());\n        }\n    }", "signature": "private String rewriteToRegex(Node node)"}, {"syntax_pass": true, "original_string": "    private String rewriteOptional(Node node) {\n        assertNoParameters(node, astNode -> createParameterIsNotAllowedInOptional(astNode, source));\n        assertNoOptionals(node, astNode -> createOptionalIsNotAllowedInOptional(astNode, source));\n        assertNotEmpty(node, astNode -> createOptionalMayNotBeEmpty(astNode, source));\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"(?:\", \")?\"));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "rewriteOptional", "params": [{"name": "node", "type": "Node"}], "body": "                                              {\n        assertNoParameters(node, astNode -> createParameterIsNotAllowedInOptional(astNode, source));\n        assertNoOptionals(node, astNode -> createOptionalIsNotAllowedInOptional(astNode, source));\n        assertNotEmpty(node, astNode -> createOptionalMayNotBeEmpty(astNode, source));\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"(?:\", \")?\"));\n    }", "signature": "private String rewriteOptional(Node node)"}, {"syntax_pass": true, "original_string": "    private String rewriteAlternation(Node node) {\n        // Make sure the alternative parts aren't empty and don't contain parameter types\n        for (Node alternative : node.nodes()) {\n            if (alternative.nodes().isEmpty()) {\n                throw createAlternativeMayNotBeEmpty(alternative, source);\n            }\n            assertNotEmpty(alternative, astNode -> createAlternativeMayNotExclusivelyContainOptionals(astNode, source));\n        }\n        return node.nodes()\n                .stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"|\", \"(?:\", \")\"));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "rewriteAlternation", "params": [{"name": "node", "type": "Node"}], "body": "                                                 {\n        // Make sure the alternative parts aren't empty and don't contain parameter types\n        for (Node alternative : node.nodes()) {\n            if (alternative.nodes().isEmpty()) {\n                throw createAlternativeMayNotBeEmpty(alternative, source);\n            }\n            assertNotEmpty(alternative, astNode -> createAlternativeMayNotExclusivelyContainOptionals(astNode, source));\n        }\n        return node.nodes()\n                .stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"|\", \"(?:\", \")\"));\n    }", "signature": "private String rewriteAlternation(Node node)"}, {"syntax_pass": true, "original_string": "    private String rewriteAlternative(Node node) {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining());\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "rewriteAlternative", "params": [{"name": "node", "type": "Node"}], "body": "                                                 {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining());\n    }", "signature": "private String rewriteAlternative(Node node)"}, {"syntax_pass": true, "original_string": "    private String rewriteParameter(Node node) {\n        String name = node.text();\n        ParameterType<?> parameterType = parameterTypeRegistry.lookupByTypeName(name);\n        if (parameterType == null) {\n            throw createUndefinedParameterType(node, source, name);\n        }\n        parameterTypes.add(parameterType);\n        List<String> regexps = parameterType.getRegexps();\n        if (regexps.size() == 1) {\n            return \"(\" + regexps.get(0) + \")\";\n        }\n        return regexps.stream()\n                .collect(joining(\")|(?:\", \"((?:\", \"))\"));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "rewriteParameter", "params": [{"name": "node", "type": "Node"}], "body": "                                               {\n        String name = node.text();\n        ParameterType<?> parameterType = parameterTypeRegistry.lookupByTypeName(name);\n        if (parameterType == null) {\n            throw createUndefinedParameterType(node, source, name);\n        }\n        parameterTypes.add(parameterType);\n        List<String> regexps = parameterType.getRegexps();\n        if (regexps.size() == 1) {\n            return \"(\" + regexps.get(0) + \")\";\n        }\n        return regexps.stream()\n                .collect(joining(\")|(?:\", \"((?:\", \"))\"));\n    }", "signature": "private String rewriteParameter(Node node)"}, {"syntax_pass": true, "original_string": "    private String rewriteExpression(Node node) {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"^\", \"$\"));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "rewriteExpression", "params": [{"name": "node", "type": "Node"}], "body": "                                                {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"^\", \"$\"));\n    }", "signature": "private String rewriteExpression(Node node)"}, {"syntax_pass": true, "original_string": "    private void assertNotEmpty(Node node,\n            Function<Node, CucumberExpressionException> createNodeWasNotEmptyException) {\n        node.nodes()\n                .stream()\n                .filter(astNode -> TEXT_NODE.equals(astNode.type()))\n                .findFirst()\n                .orElseThrow(() -> createNodeWasNotEmptyException.apply(node));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertNotEmpty", "params": [{"name": "node", "type": "Node"}, {"name": "createNodeWasNotEmptyException", "type": "Function<Node, CucumberExpressionException>"}], "body": "                                                                                        {\n        node.nodes()\n                .stream()\n                .filter(astNode -> TEXT_NODE.equals(astNode.type()))\n                .findFirst()\n                .orElseThrow(() -> createNodeWasNotEmptyException.apply(node));\n    }", "signature": "private void assertNotEmpty(Node node,\n            Function<Node, CucumberExpressionException> createNodeWasNotEmptyException)"}, {"syntax_pass": true, "original_string": "    private void assertNoParameters(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAParameterException) {\n        assertNoNodeOfType(PARAMETER_NODE, node, createNodeContainedAParameterException);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertNoParameters", "params": [{"name": "node", "type": "Node"}, {"name": "createNodeContainedAParameterException", "type": "Function<Node, CucumberExpressionException>"}], "body": "                                                                                                {\n        assertNoNodeOfType(PARAMETER_NODE, node, createNodeContainedAParameterException);\n    }", "signature": "private void assertNoParameters(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAParameterException)"}, {"syntax_pass": true, "original_string": "    private void assertNoOptionals(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAnOptionalException) {\n        assertNoNodeOfType(OPTIONAL_NODE, node, createNodeContainedAnOptionalException);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertNoOptionals", "params": [{"name": "node", "type": "Node"}, {"name": "createNodeContainedAnOptionalException", "type": "Function<Node, CucumberExpressionException>"}], "body": "                                                                                                {\n        assertNoNodeOfType(OPTIONAL_NODE, node, createNodeContainedAnOptionalException);\n    }", "signature": "private void assertNoOptionals(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAnOptionalException)"}, {"syntax_pass": true, "original_string": "    private void assertNoNodeOfType(Node.Type nodeType, Node node,\n            Function<Node, CucumberExpressionException> createException) {\n        node.nodes()\n                .stream()\n                .filter(astNode -> nodeType.equals(astNode.type()))\n                .map(createException)\n                .findFirst()\n                .ifPresent(exception -> {\n                    throw exception;\n                });\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertNoNodeOfType", "params": [{"name": "nodeType", "type": "Node.Type"}, {"name": "node", "type": "Node"}, {"name": "createException", "type": "Function<Node, CucumberExpressionException>"}], "body": "                                                                         {\n        node.nodes()\n                .stream()\n                .filter(astNode -> nodeType.equals(astNode.type()))\n                .map(createException)\n                .findFirst()\n                .ifPresent(exception -> {\n                    throw exception;\n                });\n    }", "signature": "private void assertNoNodeOfType(Node.Type nodeType, Node node,\n            Function<Node, CucumberExpressionException> createException)"}, {"syntax_pass": true, "original_string": "    @Override\n    public List<Argument<?>> match(String text, Type... typeHints) {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        List<ParameterType<?>> parameterTypes = new ArrayList<>(this.parameterTypes);\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            Type type = i < typeHints.length ? typeHints[i] : String.class;\n            if (parameterType.isAnonymous()) {\n                ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n                parameterTypes.set(i, parameterType.deAnonymize(type, arg -> defaultTransformer.transform(arg, type)));\n            }\n        }\n\n        return Argument.build(group, parameterTypes);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Argument<?>>", "classes": []}, "name": "match", "params": [{"name": "text", "type": "String"}], "body": "                                                                   {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        List<ParameterType<?>> parameterTypes = new ArrayList<>(this.parameterTypes);\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            Type type = i < typeHints.length ? typeHints[i] : String.class;\n            if (parameterType.isAnonymous()) {\n                ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n                parameterTypes.set(i, parameterType.deAnonymize(type, arg -> defaultTransformer.transform(arg, type)));\n            }\n        }\n\n        return Argument.build(group, parameterTypes);\n    }", "signature": "@Override\n    public List<Argument<?>> match(String text, Type... typeHints)"}, {"syntax_pass": true, "original_string": "    @Override\n    public String getSource() {\n        return source;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getSource", "params": [], "body": "                              {\n        return source;\n    }", "signature": "@Override\n    public String getSource()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Pattern getRegexp() {\n        return treeRegexp.pattern();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pattern", "classes": []}, "name": "getRegexp", "params": [], "body": "                               {\n        return treeRegexp.pattern();\n    }", "signature": "@Override\n    public Pattern getRegexp()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.regex.Matcher;\n\nfinal class GroupBuilder {\n    private final List<GroupBuilder> groupBuilders = new ArrayList<>();\n    private boolean capturing = true;\n    private String source;\n    private int startIndex;\n    private int endIndex;\n\n    GroupBuilder(int startIndex) {\n        this.startIndex = startIndex;\n    }\n\n    void add(GroupBuilder groupBuilder) {\n        groupBuilders.add(groupBuilder);\n    }\n\n    Group build(Matcher matcher, Iterator<Integer> groupIndices) {\n        int groupIndex = groupIndices.next();\n        List<Group> children = new ArrayList<>(groupBuilders.size());\n        for (GroupBuilder childGroupBuilder : groupBuilders) {\n            children.add(childGroupBuilder.build(matcher, groupIndices));\n        }\n        return new Group(matcher.group(groupIndex), matcher.start(groupIndex), matcher.end(groupIndex), children);\n    }\n\n    void setNonCapturing() {\n        this.capturing = false;\n    }\n\n    boolean isCapturing() {\n        return capturing;\n    }\n\n    void moveChildrenTo(GroupBuilder groupBuilder) {\n        for (GroupBuilder child : groupBuilders) {\n            groupBuilder.add(child);\n        }\n    }\n\n    List<GroupBuilder> getChildren() {\n        return groupBuilders;\n    }\n\n    String getSource() {\n        return source;\n    }\n\n    void setSource(String source) {\n        this.source = source;\n    }\n\n    int getStartIndex() {\n        return startIndex;\n    }\n\n    int getEndIndex() {\n        return endIndex;\n    }\n\n    void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }\n}\n", "file_hash": "f739b4f0f33ce07e4308d425de7b1931f234f461301143ab20bf307c8583b0ca", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import java.util.ArrayList;", "import java.util.Iterator;", "import java.util.List;", "import java.util.regex.Matcher;"], "methods": [], "classes": [{"original_string": "final class GroupBuilder {\n    private final List<GroupBuilder> groupBuilders = new ArrayList<>();\n    private boolean capturing = true;\n    private String source;\n    private int startIndex;\n    private int endIndex;\n\n    GroupBuilder(int startIndex) {\n        this.startIndex = startIndex;\n    }\n\n    void add(GroupBuilder groupBuilder) {\n        groupBuilders.add(groupBuilder);\n    }\n\n    Group build(Matcher matcher, Iterator<Integer> groupIndices) {\n        int groupIndex = groupIndices.next();\n        List<Group> children = new ArrayList<>(groupBuilders.size());\n        for (GroupBuilder childGroupBuilder : groupBuilders) {\n            children.add(childGroupBuilder.build(matcher, groupIndices));\n        }\n        return new Group(matcher.group(groupIndex), matcher.start(groupIndex), matcher.end(groupIndex), children);\n    }\n\n    void setNonCapturing() {\n        this.capturing = false;\n    }\n\n    boolean isCapturing() {\n        return capturing;\n    }\n\n    void moveChildrenTo(GroupBuilder groupBuilder) {\n        for (GroupBuilder child : groupBuilders) {\n            groupBuilder.add(child);\n        }\n    }\n\n    List<GroupBuilder> getChildren() {\n        return groupBuilders;\n    }\n\n    String getSource() {\n        return source;\n    }\n\n    void setSource(String source) {\n        this.source = source;\n    }\n\n    int getStartIndex() {\n        return startIndex;\n    }\n\n    int getEndIndex() {\n        return endIndex;\n    }\n\n    void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }\n}", "definition": "final class GroupBuilder", "class_docstring": "", "name": "GroupBuilder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private final List<GroupBuilder> groupBuilders = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<GroupBuilder>", "name": "groupBuilders = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private boolean capturing = true;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "capturing = true", "syntax_pass": true}, {"attribute_expression": "private String source;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "source", "syntax_pass": true}, {"attribute_expression": "private int startIndex;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "startIndex", "syntax_pass": true}, {"attribute_expression": "private int endIndex;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "endIndex", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    GroupBuilder(int startIndex) {\n        this.startIndex = startIndex;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "GroupBuilder", "params": [{"name": "startIndex", "type": "int"}], "body": "                                 {\n        this.startIndex = startIndex;\n    }", "signature": "GroupBuilder(int startIndex)"}, {"syntax_pass": true, "original_string": "    void add(GroupBuilder groupBuilder) {\n        groupBuilders.add(groupBuilder);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "groupBuilder", "type": "GroupBuilder"}], "body": "                                        {\n        groupBuilders.add(groupBuilder);\n    }", "signature": "void add(GroupBuilder groupBuilder)"}, {"syntax_pass": true, "original_string": "    Group build(Matcher matcher, Iterator<Integer> groupIndices) {\n        int groupIndex = groupIndices.next();\n        List<Group> children = new ArrayList<>(groupBuilders.size());\n        for (GroupBuilder childGroupBuilder : groupBuilders) {\n            children.add(childGroupBuilder.build(matcher, groupIndices));\n        }\n        return new Group(matcher.group(groupIndex), matcher.start(groupIndex), matcher.end(groupIndex), children);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Group", "classes": []}, "name": "build", "params": [{"name": "matcher", "type": "Matcher"}, {"name": "groupIndices", "type": "Iterator<Integer>"}], "body": "                                                                 {\n        int groupIndex = groupIndices.next();\n        List<Group> children = new ArrayList<>(groupBuilders.size());\n        for (GroupBuilder childGroupBuilder : groupBuilders) {\n            children.add(childGroupBuilder.build(matcher, groupIndices));\n        }\n        return new Group(matcher.group(groupIndex), matcher.start(groupIndex), matcher.end(groupIndex), children);\n    }", "signature": "Group build(Matcher matcher, Iterator<Integer> groupIndices)"}, {"syntax_pass": true, "original_string": "    void setNonCapturing() {\n        this.capturing = false;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "setNonCapturing", "params": [], "body": "                           {\n        this.capturing = false;\n    }", "signature": "void setNonCapturing()"}, {"syntax_pass": true, "original_string": "    boolean isCapturing() {\n        return capturing;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "isCapturing", "params": [], "body": "                          {\n        return capturing;\n    }", "signature": "boolean isCapturing()"}, {"syntax_pass": true, "original_string": "    void moveChildrenTo(GroupBuilder groupBuilder) {\n        for (GroupBuilder child : groupBuilders) {\n            groupBuilder.add(child);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "moveChildrenTo", "params": [{"name": "groupBuilder", "type": "GroupBuilder"}], "body": "                                                   {\n        for (GroupBuilder child : groupBuilders) {\n            groupBuilder.add(child);\n        }\n    }", "signature": "void moveChildrenTo(GroupBuilder groupBuilder)"}, {"syntax_pass": true, "original_string": "    List<GroupBuilder> getChildren() {\n        return groupBuilders;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<GroupBuilder>", "classes": []}, "name": "getChildren", "params": [], "body": "                                     {\n        return groupBuilders;\n    }", "signature": "List<GroupBuilder> getChildren()"}, {"syntax_pass": true, "original_string": "    String getSource() {\n        return source;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "getSource", "params": [], "body": "                       {\n        return source;\n    }", "signature": "String getSource()"}, {"syntax_pass": true, "original_string": "    void setSource(String source) {\n        this.source = source;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "setSource", "params": [{"name": "source", "type": "String"}], "body": "                                  {\n        this.source = source;\n    }", "signature": "void setSource(String source)"}, {"syntax_pass": true, "original_string": "    int getStartIndex() {\n        return startIndex;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "name": "getStartIndex", "params": [], "body": "                        {\n        return startIndex;\n    }", "signature": "int getStartIndex()"}, {"syntax_pass": true, "original_string": "    int getEndIndex() {\n        return endIndex;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "name": "getEndIndex", "params": [], "body": "                      {\n        return endIndex;\n    }", "signature": "int getEndIndex()"}, {"syntax_pass": true, "original_string": "    void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "setEndIndex", "params": [{"name": "endIndex", "type": "int"}], "body": "                                   {\n        this.endIndex = endIndex;\n    }", "signature": "void setEndIndex(int endIndex)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ServiceLoader;\n\nfinal class PatternCompilerProvider {\n    // visible from tests\n    static PatternCompiler service;\n\n    private PatternCompilerProvider() {\n    }\n\n    static synchronized PatternCompiler getCompiler() {\n        if (service == null) {\n            ServiceLoader<PatternCompiler> loader = ServiceLoader.load(PatternCompiler.class);\n            Iterator<PatternCompiler> iterator = loader.iterator();\n            findPatternCompiler(iterator);\n        }\n        return service;\n    }\n\n    static void findPatternCompiler(Iterator<PatternCompiler> iterator) {\n        if (iterator.hasNext()) {\n            service = iterator.next();\n            if (iterator.hasNext()) {\n                throwMoreThanOneCompilerException(iterator);\n            }\n        } else {\n            service = new DefaultPatternCompiler();\n        }\n    }\n\n    private static void throwMoreThanOneCompilerException(Iterator<PatternCompiler> iterator) {\n        List<Class<? extends PatternCompiler>> allCompilers = new ArrayList<>();\n        allCompilers.add(service.getClass());\n        while (iterator.hasNext()) {\n            allCompilers.add(iterator.next().getClass());\n        }\n        throw new IllegalStateException(\"More than one PatternCompiler: \" + allCompilers);\n    }\n}\n", "file_hash": "77f63eb9863e7cf4271fa63d3eaff76c9036f89e2e15e1dfef833baa25d30b89", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import java.util.ArrayList;", "import java.util.Iterator;", "import java.util.List;", "import java.util.ServiceLoader;"], "methods": [], "classes": [{"original_string": "final class PatternCompilerProvider {\n    // visible from tests\n    static PatternCompiler service;\n\n    private PatternCompilerProvider() {\n    }\n\n    static synchronized PatternCompiler getCompiler() {\n        if (service == null) {\n            ServiceLoader<PatternCompiler> loader = ServiceLoader.load(PatternCompiler.class);\n            Iterator<PatternCompiler> iterator = loader.iterator();\n            findPatternCompiler(iterator);\n        }\n        return service;\n    }\n\n    static void findPatternCompiler(Iterator<PatternCompiler> iterator) {\n        if (iterator.hasNext()) {\n            service = iterator.next();\n            if (iterator.hasNext()) {\n                throwMoreThanOneCompilerException(iterator);\n            }\n        } else {\n            service = new DefaultPatternCompiler();\n        }\n    }\n\n    private static void throwMoreThanOneCompilerException(Iterator<PatternCompiler> iterator) {\n        List<Class<? extends PatternCompiler>> allCompilers = new ArrayList<>();\n        allCompilers.add(service.getClass());\n        while (iterator.hasNext()) {\n            allCompilers.add(iterator.next().getClass());\n        }\n        throw new IllegalStateException(\"More than one PatternCompiler: \" + allCompilers);\n    }\n}", "definition": "final class PatternCompilerProvider", "class_docstring": "", "name": "PatternCompilerProvider", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "static PatternCompiler service;", "docstring": " visible from tests", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "PatternCompiler", "name": "service", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private PatternCompilerProvider() {\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "PatternCompilerProvider", "params": [], "body": "                                      {\n    }", "signature": "private PatternCompilerProvider()"}, {"syntax_pass": true, "original_string": "    static synchronized PatternCompiler getCompiler() {\n        if (service == null) {\n            ServiceLoader<PatternCompiler> loader = ServiceLoader.load(PatternCompiler.class);\n            Iterator<PatternCompiler> iterator = loader.iterator();\n            findPatternCompiler(iterator);\n        }\n        return service;\n    }", "docstring": "", "attributes": {"modifiers": "static synchronized", "marker_annotations": [], "non_marker_annotations": ["static", "synchronized"], "comments": [], "return_type": "PatternCompiler", "classes": []}, "name": "getCompiler", "params": [], "body": "                                                      {\n        if (service == null) {\n            ServiceLoader<PatternCompiler> loader = ServiceLoader.load(PatternCompiler.class);\n            Iterator<PatternCompiler> iterator = loader.iterator();\n            findPatternCompiler(iterator);\n        }\n        return service;\n    }", "signature": "static synchronized PatternCompiler getCompiler()"}, {"syntax_pass": true, "original_string": "    static void findPatternCompiler(Iterator<PatternCompiler> iterator) {\n        if (iterator.hasNext()) {\n            service = iterator.next();\n            if (iterator.hasNext()) {\n                throwMoreThanOneCompilerException(iterator);\n            }\n        } else {\n            service = new DefaultPatternCompiler();\n        }\n    }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "name": "findPatternCompiler", "params": [{"name": "iterator", "type": "Iterator<PatternCompiler>"}], "body": "                                                                        {\n        if (iterator.hasNext()) {\n            service = iterator.next();\n            if (iterator.hasNext()) {\n                throwMoreThanOneCompilerException(iterator);\n            }\n        } else {\n            service = new DefaultPatternCompiler();\n        }\n    }", "signature": "static void findPatternCompiler(Iterator<PatternCompiler> iterator)"}, {"syntax_pass": true, "original_string": "    private static void throwMoreThanOneCompilerException(Iterator<PatternCompiler> iterator) {\n        List<Class<? extends PatternCompiler>> allCompilers = new ArrayList<>();\n        allCompilers.add(service.getClass());\n        while (iterator.hasNext()) {\n            allCompilers.add(iterator.next().getClass());\n        }\n        throw new IllegalStateException(\"More than one PatternCompiler: \" + allCompilers);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "throwMoreThanOneCompilerException", "params": [{"name": "iterator", "type": "Iterator<PatternCompiler>"}], "body": "                                                                                              {\n        List<Class<? extends PatternCompiler>> allCompilers = new ArrayList<>();\n        allCompilers.add(service.getClass());\n        while (iterator.hasNext()) {\n            allCompilers.add(iterator.next().getClass());\n        }\n        throw new IllegalStateException(\"More than one PatternCompiler: \" + allCompilers);\n    }", "signature": "private static void throwMoreThanOneCompilerException(Iterator<PatternCompiler> iterator)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/CaptureGroupTransformer.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\n/**\n * Transformer for a @{@link ParameterType} with (multiple) capture groups.\n *\n * @param <T> the type to transform to.\n */\n@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic interface CaptureGroupTransformer<T> {\n    /**\n     * Transforms multiple strings into to an object. The strings are taken from\n     * the capture groups in the regular expressions in order. Nested capture\n     * groups are ignored. If a capture group is optional the corresponding element\n     * in the array may be null.\n     *\n     * @param args the values of the top level capture groups\n     * @return the transformed object\n     * @throws Throwable if transformation failed\n     */\n    T transform(String[] args) throws Throwable;\n}\n", "file_hash": "7ed0d640eab98b00776a15e9cde876ed9c36da2576b1e15c9589827efe543163", "file_docstring": "\nTransformer for a @{@link ParameterType} with (multiple) capture groups.\n\n@param <T> the type to transform to.\n", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;"], "methods": [], "classes": [], "interfaces": [{"original_string": "@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic interface CaptureGroupTransformer<T> {\n    /**\n     * Transforms multiple strings into to an object. The strings are taken from\n     * the capture groups in the regular expressions in order. Nested capture\n     * groups are ignored. If a capture group is optional the corresponding element\n     * in the array may be null.\n     *\n     * @param args the values of the top level capture groups\n     * @return the transformed object\n     * @throws Throwable if transformation failed\n     */\n    T transform(String[] args) throws Throwable;\n}", "definition": "@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic interface CaptureGroupTransformer<T>", "interface_docstring": "\nTransformer for a @{@link ParameterType} with (multiple) capture groups.\n\n@param <T> the type to transform to.\n", "name": "CaptureGroupTransformer", "extends_interfaces": [], "attributes": {"modifiers": "@API(status = API.Status.STABLE)\n@FunctionalInterface\npublic", "marker_annotations": ["@FunctionalInterface"], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    T transform(String[] args) throws Throwable;", "docstring": "\nTransforms multiple strings into to an object. The strings are taken from\nthe capture groups in the regular expressions in order. Nested capture\ngroups are ignored. If a capture group is optional the corresponding element\nin the array may be null.\n\n@param args the values of the top level capture groups\n@return the transformed object\n@throws Throwable if transformation failed\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "name": "transform", "params": [{"name": "args", "type": "String[]"}], "body": "", "signature": "T transform(String[] args)"}]}], "records": []}, {"relative_path": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java", "original_string": "package io.cucumber.cucumberexpressions;\n\nimport org.apiguardian.api.API;\n\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\n\n@API(status = API.Status.STABLE)\npublic class GeneratedExpression {\n    private static final Collator ENGLISH_COLLATOR = Collator.getInstance(Locale.ENGLISH);\n    private static final String[] JAVA_KEYWORDS = {\n            \"abstract\", \"assert\", \"boolean\", \"break\", \"byte\", \"case\",\n            \"catch\", \"char\", \"class\", \"const\", \"continue\",\n            \"default\", \"do\", \"double\", \"else\", \"extends\",\n            \"false\", \"final\", \"finally\", \"float\", \"for\",\n            \"goto\", \"if\", \"implements\", \"import\", \"instanceof\",\n            \"int\", \"interface\", \"long\", \"native\", \"new\",\n            \"null\", \"package\", \"private\", \"protected\", \"public\",\n            \"return\", \"short\", \"static\", \"strictfp\", \"super\",\n            \"switch\", \"synchronized\", \"this\", \"throw\", \"throws\",\n            \"transient\", \"true\", \"try\", \"void\", \"volatile\",\n            \"while\"\n    };\n    private final String expressionTemplate;\n    private final List<ParameterType<?>> parameterTypes;\n\n    GeneratedExpression(String expressionTemplate, List<ParameterType<?>> parameterTypes) {\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypes = parameterTypes;\n    }\n\n    private static boolean isJavaKeyword(String keyword) {\n        return (Arrays.binarySearch(JAVA_KEYWORDS, keyword, ENGLISH_COLLATOR) >= 0);\n    }\n\n    public String getSource() {\n        List<String> parameterTypeNames = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String name = parameterType.getName();\n            parameterTypeNames.add(name);\n        }\n        return String.format(expressionTemplate, parameterTypeNames.toArray());\n    }\n\n    private String getParameterName(String typeName, Map<String, Integer> usageByTypeName) {\n        Integer count = usageByTypeName.get(typeName);\n        count = count != null ? count + 1 : 1;\n        usageByTypeName.put(typeName, count);\n\n        return count == 1 && !isJavaKeyword(typeName) ? typeName : typeName + count;\n    }\n\n    public List<String> getParameterNames() {\n        HashMap<String, Integer> usageByTypeName = new HashMap<>();\n        List<String> list = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String parameterName = getParameterName(parameterType.getName(), usageByTypeName);\n            list.add(parameterName);\n        }\n        return list;\n    }\n\n    public List<ParameterType<?>> getParameterTypes() {\n        return parameterTypes;\n    }\n}\n", "file_hash": "60aa9fe9ff0bf5ef8dd239485fe53845234d64352db27739565c431fba905786", "file_docstring": "", "contexts": ["package io.cucumber.cucumberexpressions;", "import org.apiguardian.api.API;", "import java.text.Collator;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Locale;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "@API(status = API.Status.STABLE)\npublic class GeneratedExpression {\n    private static final Collator ENGLISH_COLLATOR = Collator.getInstance(Locale.ENGLISH);\n    private static final String[] JAVA_KEYWORDS = {\n            \"abstract\", \"assert\", \"boolean\", \"break\", \"byte\", \"case\",\n            \"catch\", \"char\", \"class\", \"const\", \"continue\",\n            \"default\", \"do\", \"double\", \"else\", \"extends\",\n            \"false\", \"final\", \"finally\", \"float\", \"for\",\n            \"goto\", \"if\", \"implements\", \"import\", \"instanceof\",\n            \"int\", \"interface\", \"long\", \"native\", \"new\",\n            \"null\", \"package\", \"private\", \"protected\", \"public\",\n            \"return\", \"short\", \"static\", \"strictfp\", \"super\",\n            \"switch\", \"synchronized\", \"this\", \"throw\", \"throws\",\n            \"transient\", \"true\", \"try\", \"void\", \"volatile\",\n            \"while\"\n    };\n    private final String expressionTemplate;\n    private final List<ParameterType<?>> parameterTypes;\n\n    GeneratedExpression(String expressionTemplate, List<ParameterType<?>> parameterTypes) {\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypes = parameterTypes;\n    }\n\n    private static boolean isJavaKeyword(String keyword) {\n        return (Arrays.binarySearch(JAVA_KEYWORDS, keyword, ENGLISH_COLLATOR) >= 0);\n    }\n\n    public String getSource() {\n        List<String> parameterTypeNames = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String name = parameterType.getName();\n            parameterTypeNames.add(name);\n        }\n        return String.format(expressionTemplate, parameterTypeNames.toArray());\n    }\n\n    private String getParameterName(String typeName, Map<String, Integer> usageByTypeName) {\n        Integer count = usageByTypeName.get(typeName);\n        count = count != null ? count + 1 : 1;\n        usageByTypeName.put(typeName, count);\n\n        return count == 1 && !isJavaKeyword(typeName) ? typeName : typeName + count;\n    }\n\n    public List<String> getParameterNames() {\n        HashMap<String, Integer> usageByTypeName = new HashMap<>();\n        List<String> list = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String parameterName = getParameterName(parameterType.getName(), usageByTypeName);\n            list.add(parameterName);\n        }\n        return list;\n    }\n\n    public List<ParameterType<?>> getParameterTypes() {\n        return parameterTypes;\n    }\n}", "definition": "@API(status = API.Status.STABLE)\npublic class GeneratedExpression", "class_docstring": "", "name": "GeneratedExpression", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@API(status = API.Status.STABLE)\npublic", "marker_annotations": [], "non_marker_annotations": ["@API(status = API.Status.STABLE)", "public"], "comments": [], "fields": [{"attribute_expression": "private static final Collator ENGLISH_COLLATOR = Collator.getInstance(Locale.ENGLISH);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Collator", "name": "ENGLISH_COLLATOR = Collator.getInstance(Locale.ENGLISH)", "syntax_pass": true}, {"attribute_expression": "private static final String[] JAVA_KEYWORDS = {\n            \"abstract\", \"assert\", \"boolean\", \"break\", \"byte\", \"case\",\n            \"catch\", \"char\", \"class\", \"const\", \"continue\",\n            \"default\", \"do\", \"double\", \"else\", \"extends\",\n            \"false\", \"final\", \"finally\", \"float\", \"for\",\n            \"goto\", \"if\", \"implements\", \"import\", \"instanceof\",\n            \"int\", \"interface\", \"long\", \"native\", \"new\",\n            \"null\", \"package\", \"private\", \"protected\", \"public\",\n            \"return\", \"short\", \"static\", \"strictfp\", \"super\",\n            \"switch\", \"synchronized\", \"this\", \"throw\", \"throws\",\n            \"transient\", \"true\", \"try\", \"void\", \"volatile\",\n            \"while\"\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "JAVA_KEYWORDS = {\n            \"abstract\", \"assert\", \"boolean\", \"break\", \"byte\", \"case\",\n            \"catch\", \"char\", \"class\", \"const\", \"continue\",\n            \"default\", \"do\", \"double\", \"else\", \"extends\",\n            \"false\", \"final\", \"finally\", \"float\", \"for\",\n            \"goto\", \"if\", \"implements\", \"import\", \"instanceof\",\n            \"int\", \"interface\", \"long\", \"native\", \"new\",\n            \"null\", \"package\", \"private\", \"protected\", \"public\",\n            \"return\", \"short\", \"static\", \"strictfp\", \"super\",\n            \"switch\", \"synchronized\", \"this\", \"throw\", \"throws\",\n            \"transient\", \"true\", \"try\", \"void\", \"volatile\",\n            \"while\"\n    }", "syntax_pass": true}, {"attribute_expression": "private final String expressionTemplate;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "expressionTemplate", "syntax_pass": true}, {"attribute_expression": "private final List<ParameterType<?>> parameterTypes;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<ParameterType<?>>", "name": "parameterTypes", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    GeneratedExpression(String expressionTemplate, List<ParameterType<?>> parameterTypes) {\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypes = parameterTypes;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "GeneratedExpression", "params": [{"name": "expressionTemplate", "type": "String"}, {"name": "parameterTypes", "type": "List<ParameterType<?>>"}], "body": "                                                                                          {\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypes = parameterTypes;\n    }", "signature": "GeneratedExpression(String expressionTemplate, List<ParameterType<?>> parameterTypes)"}, {"syntax_pass": true, "original_string": "    private static boolean isJavaKeyword(String keyword) {\n        return (Arrays.binarySearch(JAVA_KEYWORDS, keyword, ENGLISH_COLLATOR) >= 0);\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isJavaKeyword", "params": [{"name": "keyword", "type": "String"}], "body": "                                                         {\n        return (Arrays.binarySearch(JAVA_KEYWORDS, keyword, ENGLISH_COLLATOR) >= 0);\n    }", "signature": "private static boolean isJavaKeyword(String keyword)"}, {"syntax_pass": true, "original_string": "    public String getSource() {\n        List<String> parameterTypeNames = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String name = parameterType.getName();\n            parameterTypeNames.add(name);\n        }\n        return String.format(expressionTemplate, parameterTypeNames.toArray());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getSource", "params": [], "body": "                              {\n        List<String> parameterTypeNames = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String name = parameterType.getName();\n            parameterTypeNames.add(name);\n        }\n        return String.format(expressionTemplate, parameterTypeNames.toArray());\n    }", "signature": "public String getSource()"}, {"syntax_pass": true, "original_string": "    private String getParameterName(String typeName, Map<String, Integer> usageByTypeName) {\n        Integer count = usageByTypeName.get(typeName);\n        count = count != null ? count + 1 : 1;\n        usageByTypeName.put(typeName, count);\n\n        return count == 1 && !isJavaKeyword(typeName) ? typeName : typeName + count;\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "getParameterName", "params": [{"name": "typeName", "type": "String"}, {"name": "usageByTypeName", "type": "Map<String, Integer>"}], "body": "                                                                                           {\n        Integer count = usageByTypeName.get(typeName);\n        count = count != null ? count + 1 : 1;\n        usageByTypeName.put(typeName, count);\n\n        return count == 1 && !isJavaKeyword(typeName) ? typeName : typeName + count;\n    }", "signature": "private String getParameterName(String typeName, Map<String, Integer> usageByTypeName)"}, {"syntax_pass": true, "original_string": "    public List<String> getParameterNames() {\n        HashMap<String, Integer> usageByTypeName = new HashMap<>();\n        List<String> list = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String parameterName = getParameterName(parameterType.getName(), usageByTypeName);\n            list.add(parameterName);\n        }\n        return list;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getParameterNames", "params": [], "body": "                                            {\n        HashMap<String, Integer> usageByTypeName = new HashMap<>();\n        List<String> list = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String parameterName = getParameterName(parameterType.getName(), usageByTypeName);\n            list.add(parameterName);\n        }\n        return list;\n    }", "signature": "public List<String> getParameterNames()"}, {"syntax_pass": true, "original_string": "    public List<ParameterType<?>> getParameterTypes() {\n        return parameterTypes;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<ParameterType<?>>", "classes": []}, "name": "getParameterTypes", "params": [], "body": "                                                      {\n        return parameterTypes;\n    }", "signature": "public List<ParameterType<?>> getParameterTypes()"}]}], "interfaces": [], "records": []}]