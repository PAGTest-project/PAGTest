[{"strategy": "retry", "code": "\npackage org.ice4j.pseudotcp;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class PseudoTcpSocket_acceptTest {\n    private PseudoTcpSocket server;\n    private PseudoTcpSocket client;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        server = new PseudoTcpSocketFactory().createSocket();\n        client = new PseudoTcpSocketFactory().createSocket();\n    }\n\n    @Test\n    @Timeout(10)\n    public void testAcceptWithTimeout() throws IOException, InterruptedException {\n        server.setDebugName(\"Server\");\n        server.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n        final InetSocketAddress serverAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), server.getLocalPort());\n\n        AtomicBoolean serverThreadEnded = new AtomicBoolean();\n        Thread serverThread = new Thread(() -> {\n            try {\n                server.accept(5000);\n                serverThreadEnded.set(true);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        AtomicBoolean clientThreadEnded = new AtomicBoolean();\n        Thread clientThread = new Thread(() -> {\n            try {\n                client.setDebugName(\"Client\");\n                client.connect(serverAddress, 5000);\n                clientThreadEnded.set(true);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        });\n\n        serverThread.start();\n        clientThread.start();\n\n        try {\n            boolean success = assert_wait_until(() -> client.isConnected(), 5000);\n            if (success) {\n                clientThread.join(10_000);\n                if (!clientThreadEnded.get()) {\n                    fail(\"client thread did not end\");\n                }\n                serverThread.join(10_000);\n                if (!serverThreadEnded.get()) {\n                    fail(\"server thread did not end\");\n                }\n                server.close();\n                client.close();\n            } else {\n                fail(\"Connection timeout\");\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Test\n    @Timeout(10)\n    public void testAcceptTimeoutExpired() throws IOException, InterruptedException {\n        server.setDebugName(\"Server\");\n        server.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n\n        AtomicBoolean serverThreadEnded = new AtomicBoolean();\n        Thread serverThread = new Thread(() -> {\n            try {\n                server.accept(1000);\n                serverThreadEnded.set(true);\n            } catch (IOException e) {\n                if (!e.getMessage().contains(\"timeout\")) {\n                    throw new RuntimeException(e);\n                }\n            }\n        });\n\n        serverThread.start();\n\n        try {\n            boolean success = assert_wait_until(() -> serverThreadEnded.get(), 2000);\n            if (success) {\n                serverThread.join(10_000);\n                if (!serverThreadEnded.get()) {\n                    fail(\"server thread did not end\");\n                }\n                server.close();\n            } else {\n                fail(\"Server thread did not end as expected\");\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private boolean assert_wait_until(java.util.function.BooleanSupplier condition, long timeout) throws InterruptedException {\n        long startTime = System.currentTimeMillis();\n        while (!condition.getAsBoolean()) {\n            if (System.currentTimeMillis() - startTime > timeout) {\n                return false;\n            }\n            Thread.sleep(100);\n        }\n        return true;\n    }\n}\n"}]